import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
import { dirname as ESM_COMPAT_dirname } from 'node:path';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const __dirname = ESM_COMPAT_dirname(__filename);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var zN = Object.create;
var zc = Object.defineProperty;
var GN = Object.getOwnPropertyDescriptor;
var QN = Object.getOwnPropertyNames;
var ZN = Object.getPrototypeOf, e2 = Object.prototype.hasOwnProperty;
var n = (t, e) => zc(t, "name", { value: e, configurable: !0 }), ds = /* @__PURE__ */ ((t) => typeof require < "u" ? require : typeof Proxy <
"u" ? new Proxy(t, {
  get: (e, r) => (typeof require < "u" ? require : e)[r]
}) : t)(function(t) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + t + '" is not supported');
});
var w = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var t2 = (t, e, r, s) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of QN(e))
      !e2.call(t, i) && i !== r && zc(t, i, { get: () => e[i], enumerable: !(s = GN(e, i)) || s.enumerable });
  return t;
};
var tr = (t, e, r) => (r = t != null ? zN(ZN(t)) : {}, t2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !t || !t.__esModule ? zc(r, "default", { value: t, enumerable: !0 }) : r,
  t
));

// ../node_modules/ts-dedent/dist/index.js
var ol = w((la) => {
  "use strict";
  Object.defineProperty(la, "__esModule", { value: !0 });
  la.dedent = void 0;
  function zb(t) {
    for (var e = [], r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
    var s = Array.from(typeof t == "string" ? [t] : t);
    s[s.length - 1] = s[s.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var i = s.reduce(function(l, u) {
      var c = u.match(/\n([\t ]+|(?!\s).)/g);
      return c ? l.concat(c.map(function(p) {
        var f, m;
        return (m = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && m !== void 0 ? m : 0;
      })) : l;
    }, []);
    if (i.length) {
      var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
      s = s.map(function(l) {
        return l.replace(a, `
`);
      });
    }
    s[0] = s[0].replace(/^\r?\n/, "");
    var o = s[0];
    return e.forEach(function(l, u) {
      var c = o.match(/(?:^|\n)( *)$/), p = c ? c[1] : "", f = l;
      typeof l == "string" && l.includes(`
`) && (f = String(l).split(`
`).map(function(m, y) {
        return y === 0 ? m : "" + p + m;
      }).join(`
`)), o += f + s[u + 1];
    }), o;
  }
  n(zb, "dedent");
  la.dedent = zb;
  la.default = zb;
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var ll = w((Gc) => {
  "use strict";
  Object.defineProperty(Gc, "__esModule", {
    value: !0
  });
  Gc.default = r2;
  function r2(t, e) {
    let r = Object.keys(e);
    for (let s of r)
      if (t[s] !== e[s])
        return !1;
    return !0;
  }
  n(r2, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var ua = w((Qc) => {
  "use strict";
  Object.defineProperty(Qc, "__esModule", {
    value: !0
  });
  Qc.default = s2;
  var Gb = /* @__PURE__ */ new Set();
  function s2(t, e, r = "") {
    if (Gb.has(t)) return;
    Gb.add(t);
    let {
      internal: s,
      trace: i
    } = i2(1, 2);
    s || console.warn(`${r}\`${t}\` has been deprecated, please migrate to \`${e}\`
${i}`);
  }
  n(s2, "deprecationWarning");
  function i2(t, e) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: s
    } = Error, i;
    if (Error.stackTraceLimit = 1 + t + e, Error.prepareStackTrace = function(o, l) {
      i = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = s, !i) return {
      internal: !1,
      trace: ""
    };
    let a = i.slice(1 + t, 1 + t + e);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  n(i2, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var jt = w((S) => {
  "use strict";
  Object.defineProperty(S, "__esModule", {
    value: !0
  });
  S.isAccessor = bL;
  S.isAnyTypeAnnotation = RO;
  S.isArgumentPlaceholder = dD;
  S.isArrayExpression = n2;
  S.isArrayPattern = sO;
  S.isArrayTypeAnnotation = UO;
  S.isArrowFunctionExpression = iO;
  S.isAssignmentExpression = a2;
  S.isAssignmentPattern = rO;
  S.isAwaitExpression = IO;
  S.isBigIntLiteral = NO;
  S.isBinary = q_;
  S.isBinaryExpression = o2;
  S.isBindExpression = mD;
  S.isBlock = W_;
  S.isBlockParent = K_;
  S.isBlockStatement = p2;
  S.isBooleanLiteral = D2;
  S.isBooleanLiteralTypeAnnotation = VO;
  S.isBooleanTypeAnnotation = qO;
  S.isBreakStatement = f2;
  S.isCallExpression = h2;
  S.isCatchClause = d2;
  S.isClass = mL;
  S.isClassAccessorProperty = LO;
  S.isClassBody = nO;
  S.isClassDeclaration = oO;
  S.isClassExpression = aO;
  S.isClassImplements = WO;
  S.isClassMethod = xO;
  S.isClassPrivateMethod = BO;
  S.isClassPrivateProperty = MO;
  S.isClassProperty = _O;
  S.isCompletionStatement = X_;
  S.isConditional = $_;
  S.isConditionalExpression = m2;
  S.isContinueStatement = y2;
  S.isDebuggerStatement = T2;
  S.isDecimalLiteral = PD;
  S.isDeclaration = sL;
  S.isDeclareClass = YO;
  S.isDeclareExportAllDeclaration = ek;
  S.isDeclareExportDeclaration = ZO;
  S.isDeclareFunction = JO;
  S.isDeclareInterface = XO;
  S.isDeclareModule = $O;
  S.isDeclareModuleExports = HO;
  S.isDeclareOpaqueType = GO;
  S.isDeclareTypeAlias = zO;
  S.isDeclareVariable = QO;
  S.isDeclaredPredicate = tk;
  S.isDecorator = TD;
  S.isDirective = u2;
  S.isDirectiveLiteral = c2;
  S.isDoExpression = bD;
  S.isDoWhileStatement = b2;
  S.isEmptyStatement = x2;
  S.isEmptyTypeAnnotation = fk;
  S.isEnumBody = vL;
  S.isEnumBooleanBody = Uk;
  S.isEnumBooleanMember = Wk;
  S.isEnumDeclaration = Rk;
  S.isEnumDefaultedMember = Xk;
  S.isEnumMember = CL;
  S.isEnumNumberBody = qk;
  S.isEnumNumberMember = Yk;
  S.isEnumStringBody = Vk;
  S.isEnumStringMember = Jk;
  S.isEnumSymbolBody = Kk;
  S.isExistsTypeAnnotation = rk;
  S.isExportAllDeclaration = lO;
  S.isExportDeclaration = yL;
  S.isExportDefaultDeclaration = uO;
  S.isExportDefaultSpecifier = xD;
  S.isExportNamedDeclaration = cO;
  S.isExportNamespaceSpecifier = OO;
  S.isExportSpecifier = pO;
  S.isExpression = U_;
  S.isExpressionStatement = S2;
  S.isExpressionWrapper = G_;
  S.isFile = g2;
  S.isFlow = SL;
  S.isFlowBaseAnnotation = PL;
  S.isFlowDeclaration = EL;
  S.isFlowPredicate = AL;
  S.isFlowType = gL;
  S.isFor = Q_;
  S.isForInStatement = P2;
  S.isForOfStatement = fO;
  S.isForStatement = E2;
  S.isForXStatement = Z_;
  S.isFunction = eL;
  S.isFunctionDeclaration = A2;
  S.isFunctionExpression = v2;
  S.isFunctionParent = tL;
  S.isFunctionTypeAnnotation = sk;
  S.isFunctionTypeParam = ik;
  S.isGenericTypeAnnotation = nk;
  S.isIdentifier = C2;
  S.isIfStatement = I2;
  S.isImmutable = lL;
  S.isImport = wO;
  S.isImportAttribute = yD;
  S.isImportDeclaration = hO;
  S.isImportDefaultSpecifier = dO;
  S.isImportExpression = TO;
  S.isImportNamespaceSpecifier = mO;
  S.isImportOrExportDeclaration = Qb;
  S.isImportSpecifier = yO;
  S.isIndexedAccessType = $k;
  S.isInferredPredicate = ak;
  S.isInterfaceDeclaration = lk;
  S.isInterfaceExtends = ok;
  S.isInterfaceTypeAnnotation = uk;
  S.isInterpreterDirective = l2;
  S.isIntersectionTypeAnnotation = ck;
  S.isJSX = IL;
  S.isJSXAttribute = zk;
  S.isJSXClosingElement = Gk;
  S.isJSXClosingFragment = cD;
  S.isJSXElement = Qk;
  S.isJSXEmptyExpression = Zk;
  S.isJSXExpressionContainer = eD;
  S.isJSXFragment = lD;
  S.isJSXIdentifier = rD;
  S.isJSXMemberExpression = sD;
  S.isJSXNamespacedName = iD;
  S.isJSXOpeningElement = nD;
  S.isJSXOpeningFragment = uD;
  S.isJSXSpreadAttribute = aD;
  S.isJSXSpreadChild = tD;
  S.isJSXText = oD;
  S.isLVal = nL;
  S.isLabeledStatement = w2;
  S.isLiteral = oL;
  S.isLogicalExpression = L2;
  S.isLoop = H_;
  S.isMemberExpression = M2;
  S.isMetaProperty = bO;
  S.isMethod = cL;
  S.isMiscellaneous = wL;
  S.isMixedTypeAnnotation = pk;
  S.isModuleDeclaration = FL;
  S.isModuleExpression = ED;
  S.isModuleSpecifier = TL;
  S.isNewExpression = B2;
  S.isNoop = pD;
  S.isNullLiteral = k2;
  S.isNullLiteralTypeAnnotation = KO;
  S.isNullableTypeAnnotation = hk;
  S.isNumberLiteral = _L;
  S.isNumberLiteralTypeAnnotation = dk;
  S.isNumberTypeAnnotation = mk;
  S.isNumericLiteral = O2;
  S.isObjectExpression = j2;
  S.isObjectMember = pL;
  S.isObjectMethod = R2;
  S.isObjectPattern = SO;
  S.isObjectProperty = U2;
  S.isObjectTypeAnnotation = yk;
  S.isObjectTypeCallProperty = bk;
  S.isObjectTypeIndexer = xk;
  S.isObjectTypeInternalSlot = Tk;
  S.isObjectTypeProperty = Sk;
  S.isObjectTypeSpreadProperty = gk;
  S.isOpaqueType = Pk;
  S.isOptionalCallExpression = DO;
  S.isOptionalIndexedAccessType = Hk;
  S.isOptionalMemberExpression = kO;
  S.isParenthesizedExpression = W2;
  S.isPattern = dL;
  S.isPatternLike = iL;
  S.isPipelineBareFunction = CD;
  S.isPipelinePrimaryTopicReference = ID;
  S.isPipelineTopicExpression = vD;
  S.isPlaceholder = fD;
  S.isPrivate = xL;
  S.isPrivateName = FO;
  S.isProgram = F2;
  S.isProperty = fL;
  S.isPureish = rL;
  S.isQualifiedTypeIdentifier = Ek;
  S.isRecordExpression = SD;
  S.isRegExpLiteral = _2;
  S.isRegexLiteral = LL;
  S.isRestElement = q2;
  S.isRestProperty = ML;
  S.isReturnStatement = V2;
  S.isScopable = V_;
  S.isSequenceExpression = K2;
  S.isSpreadElement = gO;
  S.isSpreadProperty = BL;
  S.isStandardized = R_;
  S.isStatement = Y_;
  S.isStaticBlock = jO;
  S.isStringLiteral = N2;
  S.isStringLiteralTypeAnnotation = Ak;
  S.isStringTypeAnnotation = vk;
  S.isSuper = PO;
  S.isSwitchCase = Y2;
  S.isSwitchStatement = J2;
  S.isSymbolTypeAnnotation = Ck;
  S.isTSAnyKeyword = FD;
  S.isTSArrayType = s_;
  S.isTSAsExpression = P_;
  S.isTSBaseType = DL;
  S.isTSBigIntKeyword = RD;
  S.isTSBooleanKeyword = jD;
  S.isTSCallSignatureDeclaration = DD;
  S.isTSConditionalType = c_;
  S.isTSConstructSignatureDeclaration = _D;
  S.isTSConstructorType = QD;
  S.isTSDeclareFunction = ND;
  S.isTSDeclareMethod = OD;
  S.isTSEntityName = aL;
  S.isTSEnumDeclaration = v_;
  S.isTSEnumMember = C_;
  S.isTSExportAssignment = __;
  S.isTSExpressionWithTypeArguments = T_;
  S.isTSExternalModuleReference = k_;
  S.isTSFunctionType = GD;
  S.isTSImportEqualsDeclaration = O_;
  S.isTSImportType = N_;
  S.isTSIndexSignature = BD;
  S.isTSIndexedAccessType = d_;
  S.isTSInferType = p_;
  S.isTSInstantiationExpression = g_;
  S.isTSInterfaceBody = x_;
  S.isTSInterfaceDeclaration = b_;
  S.isTSIntersectionType = u_;
  S.isTSIntrinsicKeyword = UD;
  S.isTSLiteralType = y_;
  S.isTSMappedType = m_;
  S.isTSMethodSignature = MD;
  S.isTSModuleBlock = w_;
  S.isTSModuleDeclaration = I_;
  S.isTSNamedTupleMember = o_;
  S.isTSNamespaceExportDeclaration = L_;
  S.isTSNeverKeyword = qD;
  S.isTSNonNullExpression = D_;
  S.isTSNullKeyword = VD;
  S.isTSNumberKeyword = KD;
  S.isTSObjectKeyword = WD;
  S.isTSOptionalType = n_;
  S.isTSParameterProperty = wD;
  S.isTSParenthesizedType = f_;
  S.isTSPropertySignature = LD;
  S.isTSQualifiedName = kD;
  S.isTSRestType = a_;
  S.isTSSatisfiesExpression = E_;
  S.isTSStringKeyword = YD;
  S.isTSSymbolKeyword = JD;
  S.isTSThisType = zD;
  S.isTSTupleType = i_;
  S.isTSType = kL;
  S.isTSTypeAliasDeclaration = S_;
  S.isTSTypeAnnotation = M_;
  S.isTSTypeAssertion = A_;
  S.isTSTypeElement = OL;
  S.isTSTypeLiteral = r_;
  S.isTSTypeOperator = h_;
  S.isTSTypeParameter = j_;
  S.isTSTypeParameterDeclaration = F_;
  S.isTSTypeParameterInstantiation = B_;
  S.isTSTypePredicate = e_;
  S.isTSTypeQuery = t_;
  S.isTSTypeReference = ZD;
  S.isTSUndefinedKeyword = XD;
  S.isTSUnionType = l_;
  S.isTSUnknownKeyword = $D;
  S.isTSVoidKeyword = HD;
  S.isTaggedTemplateExpression = EO;
  S.isTemplateElement = AO;
  S.isTemplateLiteral = vO;
  S.isTerminatorless = J_;
  S.isThisExpression = X2;
  S.isThisTypeAnnotation = Ik;
  S.isThrowStatement = $2;
  S.isTopicReference = AD;
  S.isTryStatement = H2;
  S.isTupleExpression = gD;
  S.isTupleTypeAnnotation = wk;
  S.isTypeAlias = Ok;
  S.isTypeAnnotation = kk;
  S.isTypeCastExpression = Dk;
  S.isTypeParameter = _k;
  S.isTypeParameterDeclaration = Lk;
  S.isTypeParameterInstantiation = Mk;
  S.isTypeScript = NL;
  S.isTypeofTypeAnnotation = Nk;
  S.isUnaryExpression = z2;
  S.isUnaryLike = hL;
  S.isUnionTypeAnnotation = Bk;
  S.isUpdateExpression = G2;
  S.isUserWhitespacable = uL;
  S.isV8IntrinsicIdentifier = hD;
  S.isVariableDeclaration = Q2;
  S.isVariableDeclarator = Z2;
  S.isVariance = Fk;
  S.isVoidTypeAnnotation = jk;
  S.isWhile = z_;
  S.isWhileStatement = eO;
  S.isWithStatement = tO;
  S.isYieldExpression = CO;
  var C = ll(), ca = ua();
  function n2(t, e) {
    return !t || t.type !== "ArrayExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(n2, "isArrayExpression");
  function a2(t, e) {
    return !t || t.type !== "AssignmentExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(a2, "isAssignmentExpression");
  function o2(t, e) {
    return !t || t.type !== "BinaryExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(o2, "isBinaryExpression");
  function l2(t, e) {
    return !t || t.type !== "InterpreterDirective" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(l2, "isInterpreterDirective");
  function u2(t, e) {
    return !t || t.type !== "Directive" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(u2, "isDirective");
  function c2(t, e) {
    return !t || t.type !== "DirectiveLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(c2, "isDirectiveLiteral");
  function p2(t, e) {
    return !t || t.type !== "BlockStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(p2, "isBlockStatement");
  function f2(t, e) {
    return !t || t.type !== "BreakStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(f2, "isBreakStatement");
  function h2(t, e) {
    return !t || t.type !== "CallExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(h2, "isCallExpression");
  function d2(t, e) {
    return !t || t.type !== "CatchClause" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(d2, "isCatchClause");
  function m2(t, e) {
    return !t || t.type !== "ConditionalExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(m2, "isConditionalExpression");
  function y2(t, e) {
    return !t || t.type !== "ContinueStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(y2, "isContinueStatement");
  function T2(t, e) {
    return !t || t.type !== "DebuggerStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(T2, "isDebuggerStatement");
  function b2(t, e) {
    return !t || t.type !== "DoWhileStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(b2, "isDoWhileStatement");
  function x2(t, e) {
    return !t || t.type !== "EmptyStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(x2, "isEmptyStatement");
  function S2(t, e) {
    return !t || t.type !== "ExpressionStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(S2, "isExpressionStatement");
  function g2(t, e) {
    return !t || t.type !== "File" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(g2, "isFile");
  function P2(t, e) {
    return !t || t.type !== "ForInStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(P2, "isForInStatement");
  function E2(t, e) {
    return !t || t.type !== "ForStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(E2, "isForStatement");
  function A2(t, e) {
    return !t || t.type !== "FunctionDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(A2, "isFunctionDeclaration");
  function v2(t, e) {
    return !t || t.type !== "FunctionExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(v2, "isFunctionExpression");
  function C2(t, e) {
    return !t || t.type !== "Identifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(C2, "isIdentifier");
  function I2(t, e) {
    return !t || t.type !== "IfStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(I2, "isIfStatement");
  function w2(t, e) {
    return !t || t.type !== "LabeledStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(w2, "isLabeledStatement");
  function N2(t, e) {
    return !t || t.type !== "StringLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(N2, "isStringLiteral");
  function O2(t, e) {
    return !t || t.type !== "NumericLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(O2, "isNumericLiteral");
  function k2(t, e) {
    return !t || t.type !== "NullLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(k2, "isNullLiteral");
  function D2(t, e) {
    return !t || t.type !== "BooleanLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(D2, "isBooleanLiteral");
  function _2(t, e) {
    return !t || t.type !== "RegExpLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_2, "isRegExpLiteral");
  function L2(t, e) {
    return !t || t.type !== "LogicalExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(L2, "isLogicalExpression");
  function M2(t, e) {
    return !t || t.type !== "MemberExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(M2, "isMemberExpression");
  function B2(t, e) {
    return !t || t.type !== "NewExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(B2, "isNewExpression");
  function F2(t, e) {
    return !t || t.type !== "Program" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(F2, "isProgram");
  function j2(t, e) {
    return !t || t.type !== "ObjectExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(j2, "isObjectExpression");
  function R2(t, e) {
    return !t || t.type !== "ObjectMethod" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(R2, "isObjectMethod");
  function U2(t, e) {
    return !t || t.type !== "ObjectProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(U2, "isObjectProperty");
  function q2(t, e) {
    return !t || t.type !== "RestElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(q2, "isRestElement");
  function V2(t, e) {
    return !t || t.type !== "ReturnStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(V2, "isReturnStatement");
  function K2(t, e) {
    return !t || t.type !== "SequenceExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(K2, "isSequenceExpression");
  function W2(t, e) {
    return !t || t.type !== "ParenthesizedExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(W2, "isParenthesizedExpression");
  function Y2(t, e) {
    return !t || t.type !== "SwitchCase" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Y2, "isSwitchCase");
  function J2(t, e) {
    return !t || t.type !== "SwitchStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(J2, "isSwitchStatement");
  function X2(t, e) {
    return !t || t.type !== "ThisExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(X2, "isThisExpression");
  function $2(t, e) {
    return !t || t.type !== "ThrowStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($2, "isThrowStatement");
  function H2(t, e) {
    return !t || t.type !== "TryStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(H2, "isTryStatement");
  function z2(t, e) {
    return !t || t.type !== "UnaryExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(z2, "isUnaryExpression");
  function G2(t, e) {
    return !t || t.type !== "UpdateExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(G2, "isUpdateExpression");
  function Q2(t, e) {
    return !t || t.type !== "VariableDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Q2, "isVariableDeclaration");
  function Z2(t, e) {
    return !t || t.type !== "VariableDeclarator" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Z2, "isVariableDeclarator");
  function eO(t, e) {
    return !t || t.type !== "WhileStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(eO, "isWhileStatement");
  function tO(t, e) {
    return !t || t.type !== "WithStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(tO, "isWithStatement");
  function rO(t, e) {
    return !t || t.type !== "AssignmentPattern" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(rO, "isAssignmentPattern");
  function sO(t, e) {
    return !t || t.type !== "ArrayPattern" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(sO, "isArrayPattern");
  function iO(t, e) {
    return !t || t.type !== "ArrowFunctionExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(iO, "isArrowFunctionExpression");
  function nO(t, e) {
    return !t || t.type !== "ClassBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(nO, "isClassBody");
  function aO(t, e) {
    return !t || t.type !== "ClassExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(aO, "isClassExpression");
  function oO(t, e) {
    return !t || t.type !== "ClassDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(oO, "isClassDeclaration");
  function lO(t, e) {
    return !t || t.type !== "ExportAllDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(lO, "isExportAllDeclaration");
  function uO(t, e) {
    return !t || t.type !== "ExportDefaultDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(uO, "isExportDefaultDeclaration");
  function cO(t, e) {
    return !t || t.type !== "ExportNamedDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(cO, "isExportNamedDeclaration");
  function pO(t, e) {
    return !t || t.type !== "ExportSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(pO, "isExportSpecifier");
  function fO(t, e) {
    return !t || t.type !== "ForOfStatement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(fO, "isForOfStatement");
  function hO(t, e) {
    return !t || t.type !== "ImportDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(hO, "isImportDeclaration");
  function dO(t, e) {
    return !t || t.type !== "ImportDefaultSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(dO, "isImportDefaultSpecifier");
  function mO(t, e) {
    return !t || t.type !== "ImportNamespaceSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(mO, "isImportNamespaceSpecifier");
  function yO(t, e) {
    return !t || t.type !== "ImportSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(yO, "isImportSpecifier");
  function TO(t, e) {
    return !t || t.type !== "ImportExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(TO, "isImportExpression");
  function bO(t, e) {
    return !t || t.type !== "MetaProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(bO, "isMetaProperty");
  function xO(t, e) {
    return !t || t.type !== "ClassMethod" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(xO, "isClassMethod");
  function SO(t, e) {
    return !t || t.type !== "ObjectPattern" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(SO, "isObjectPattern");
  function gO(t, e) {
    return !t || t.type !== "SpreadElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(gO, "isSpreadElement");
  function PO(t, e) {
    return !t || t.type !== "Super" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(PO, "isSuper");
  function EO(t, e) {
    return !t || t.type !== "TaggedTemplateExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(EO, "isTaggedTemplateExpression");
  function AO(t, e) {
    return !t || t.type !== "TemplateElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(AO, "isTemplateElement");
  function vO(t, e) {
    return !t || t.type !== "TemplateLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(vO, "isTemplateLiteral");
  function CO(t, e) {
    return !t || t.type !== "YieldExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(CO, "isYieldExpression");
  function IO(t, e) {
    return !t || t.type !== "AwaitExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(IO, "isAwaitExpression");
  function wO(t, e) {
    return !t || t.type !== "Import" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(wO, "isImport");
  function NO(t, e) {
    return !t || t.type !== "BigIntLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(NO, "isBigIntLiteral");
  function OO(t, e) {
    return !t || t.type !== "ExportNamespaceSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(OO, "isExportNamespaceSpecifier");
  function kO(t, e) {
    return !t || t.type !== "OptionalMemberExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(kO, "isOptionalMemberExpression");
  function DO(t, e) {
    return !t || t.type !== "OptionalCallExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(DO, "isOptionalCallExpression");
  function _O(t, e) {
    return !t || t.type !== "ClassProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_O, "isClassProperty");
  function LO(t, e) {
    return !t || t.type !== "ClassAccessorProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(LO, "isClassAccessorProperty");
  function MO(t, e) {
    return !t || t.type !== "ClassPrivateProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(MO, "isClassPrivateProperty");
  function BO(t, e) {
    return !t || t.type !== "ClassPrivateMethod" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(BO, "isClassPrivateMethod");
  function FO(t, e) {
    return !t || t.type !== "PrivateName" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(FO, "isPrivateName");
  function jO(t, e) {
    return !t || t.type !== "StaticBlock" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(jO, "isStaticBlock");
  function RO(t, e) {
    return !t || t.type !== "AnyTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(RO, "isAnyTypeAnnotation");
  function UO(t, e) {
    return !t || t.type !== "ArrayTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(UO, "isArrayTypeAnnotation");
  function qO(t, e) {
    return !t || t.type !== "BooleanTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(qO, "isBooleanTypeAnnotation");
  function VO(t, e) {
    return !t || t.type !== "BooleanLiteralTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(VO, "isBooleanLiteralTypeAnnotation");
  function KO(t, e) {
    return !t || t.type !== "NullLiteralTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(KO, "isNullLiteralTypeAnnotation");
  function WO(t, e) {
    return !t || t.type !== "ClassImplements" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(WO, "isClassImplements");
  function YO(t, e) {
    return !t || t.type !== "DeclareClass" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(YO, "isDeclareClass");
  function JO(t, e) {
    return !t || t.type !== "DeclareFunction" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(JO, "isDeclareFunction");
  function XO(t, e) {
    return !t || t.type !== "DeclareInterface" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(XO, "isDeclareInterface");
  function $O(t, e) {
    return !t || t.type !== "DeclareModule" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($O, "isDeclareModule");
  function HO(t, e) {
    return !t || t.type !== "DeclareModuleExports" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(HO, "isDeclareModuleExports");
  function zO(t, e) {
    return !t || t.type !== "DeclareTypeAlias" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(zO, "isDeclareTypeAlias");
  function GO(t, e) {
    return !t || t.type !== "DeclareOpaqueType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(GO, "isDeclareOpaqueType");
  function QO(t, e) {
    return !t || t.type !== "DeclareVariable" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(QO, "isDeclareVariable");
  function ZO(t, e) {
    return !t || t.type !== "DeclareExportDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ZO, "isDeclareExportDeclaration");
  function ek(t, e) {
    return !t || t.type !== "DeclareExportAllDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ek, "isDeclareExportAllDeclaration");
  function tk(t, e) {
    return !t || t.type !== "DeclaredPredicate" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(tk, "isDeclaredPredicate");
  function rk(t, e) {
    return !t || t.type !== "ExistsTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(rk, "isExistsTypeAnnotation");
  function sk(t, e) {
    return !t || t.type !== "FunctionTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(sk, "isFunctionTypeAnnotation");
  function ik(t, e) {
    return !t || t.type !== "FunctionTypeParam" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ik, "isFunctionTypeParam");
  function nk(t, e) {
    return !t || t.type !== "GenericTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(nk, "isGenericTypeAnnotation");
  function ak(t, e) {
    return !t || t.type !== "InferredPredicate" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ak, "isInferredPredicate");
  function ok(t, e) {
    return !t || t.type !== "InterfaceExtends" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ok, "isInterfaceExtends");
  function lk(t, e) {
    return !t || t.type !== "InterfaceDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(lk, "isInterfaceDeclaration");
  function uk(t, e) {
    return !t || t.type !== "InterfaceTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(uk, "isInterfaceTypeAnnotation");
  function ck(t, e) {
    return !t || t.type !== "IntersectionTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ck, "isIntersectionTypeAnnotation");
  function pk(t, e) {
    return !t || t.type !== "MixedTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(pk, "isMixedTypeAnnotation");
  function fk(t, e) {
    return !t || t.type !== "EmptyTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(fk, "isEmptyTypeAnnotation");
  function hk(t, e) {
    return !t || t.type !== "NullableTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(hk, "isNullableTypeAnnotation");
  function dk(t, e) {
    return !t || t.type !== "NumberLiteralTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(dk, "isNumberLiteralTypeAnnotation");
  function mk(t, e) {
    return !t || t.type !== "NumberTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(mk, "isNumberTypeAnnotation");
  function yk(t, e) {
    return !t || t.type !== "ObjectTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(yk, "isObjectTypeAnnotation");
  function Tk(t, e) {
    return !t || t.type !== "ObjectTypeInternalSlot" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Tk, "isObjectTypeInternalSlot");
  function bk(t, e) {
    return !t || t.type !== "ObjectTypeCallProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(bk, "isObjectTypeCallProperty");
  function xk(t, e) {
    return !t || t.type !== "ObjectTypeIndexer" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(xk, "isObjectTypeIndexer");
  function Sk(t, e) {
    return !t || t.type !== "ObjectTypeProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Sk, "isObjectTypeProperty");
  function gk(t, e) {
    return !t || t.type !== "ObjectTypeSpreadProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(gk, "isObjectTypeSpreadProperty");
  function Pk(t, e) {
    return !t || t.type !== "OpaqueType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Pk, "isOpaqueType");
  function Ek(t, e) {
    return !t || t.type !== "QualifiedTypeIdentifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ek, "isQualifiedTypeIdentifier");
  function Ak(t, e) {
    return !t || t.type !== "StringLiteralTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ak, "isStringLiteralTypeAnnotation");
  function vk(t, e) {
    return !t || t.type !== "StringTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(vk, "isStringTypeAnnotation");
  function Ck(t, e) {
    return !t || t.type !== "SymbolTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ck, "isSymbolTypeAnnotation");
  function Ik(t, e) {
    return !t || t.type !== "ThisTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ik, "isThisTypeAnnotation");
  function wk(t, e) {
    return !t || t.type !== "TupleTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(wk, "isTupleTypeAnnotation");
  function Nk(t, e) {
    return !t || t.type !== "TypeofTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Nk, "isTypeofTypeAnnotation");
  function Ok(t, e) {
    return !t || t.type !== "TypeAlias" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Ok, "isTypeAlias");
  function kk(t, e) {
    return !t || t.type !== "TypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(kk, "isTypeAnnotation");
  function Dk(t, e) {
    return !t || t.type !== "TypeCastExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Dk, "isTypeCastExpression");
  function _k(t, e) {
    return !t || t.type !== "TypeParameter" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_k, "isTypeParameter");
  function Lk(t, e) {
    return !t || t.type !== "TypeParameterDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Lk, "isTypeParameterDeclaration");
  function Mk(t, e) {
    return !t || t.type !== "TypeParameterInstantiation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Mk, "isTypeParameterInstantiation");
  function Bk(t, e) {
    return !t || t.type !== "UnionTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Bk, "isUnionTypeAnnotation");
  function Fk(t, e) {
    return !t || t.type !== "Variance" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Fk, "isVariance");
  function jk(t, e) {
    return !t || t.type !== "VoidTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(jk, "isVoidTypeAnnotation");
  function Rk(t, e) {
    return !t || t.type !== "EnumDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Rk, "isEnumDeclaration");
  function Uk(t, e) {
    return !t || t.type !== "EnumBooleanBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Uk, "isEnumBooleanBody");
  function qk(t, e) {
    return !t || t.type !== "EnumNumberBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(qk, "isEnumNumberBody");
  function Vk(t, e) {
    return !t || t.type !== "EnumStringBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Vk, "isEnumStringBody");
  function Kk(t, e) {
    return !t || t.type !== "EnumSymbolBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Kk, "isEnumSymbolBody");
  function Wk(t, e) {
    return !t || t.type !== "EnumBooleanMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Wk, "isEnumBooleanMember");
  function Yk(t, e) {
    return !t || t.type !== "EnumNumberMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Yk, "isEnumNumberMember");
  function Jk(t, e) {
    return !t || t.type !== "EnumStringMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Jk, "isEnumStringMember");
  function Xk(t, e) {
    return !t || t.type !== "EnumDefaultedMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Xk, "isEnumDefaultedMember");
  function $k(t, e) {
    return !t || t.type !== "IndexedAccessType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($k, "isIndexedAccessType");
  function Hk(t, e) {
    return !t || t.type !== "OptionalIndexedAccessType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Hk, "isOptionalIndexedAccessType");
  function zk(t, e) {
    return !t || t.type !== "JSXAttribute" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(zk, "isJSXAttribute");
  function Gk(t, e) {
    return !t || t.type !== "JSXClosingElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Gk, "isJSXClosingElement");
  function Qk(t, e) {
    return !t || t.type !== "JSXElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Qk, "isJSXElement");
  function Zk(t, e) {
    return !t || t.type !== "JSXEmptyExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(Zk, "isJSXEmptyExpression");
  function eD(t, e) {
    return !t || t.type !== "JSXExpressionContainer" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(eD, "isJSXExpressionContainer");
  function tD(t, e) {
    return !t || t.type !== "JSXSpreadChild" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(tD, "isJSXSpreadChild");
  function rD(t, e) {
    return !t || t.type !== "JSXIdentifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(rD, "isJSXIdentifier");
  function sD(t, e) {
    return !t || t.type !== "JSXMemberExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(sD, "isJSXMemberExpression");
  function iD(t, e) {
    return !t || t.type !== "JSXNamespacedName" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(iD, "isJSXNamespacedName");
  function nD(t, e) {
    return !t || t.type !== "JSXOpeningElement" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(nD, "isJSXOpeningElement");
  function aD(t, e) {
    return !t || t.type !== "JSXSpreadAttribute" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(aD, "isJSXSpreadAttribute");
  function oD(t, e) {
    return !t || t.type !== "JSXText" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(oD, "isJSXText");
  function lD(t, e) {
    return !t || t.type !== "JSXFragment" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(lD, "isJSXFragment");
  function uD(t, e) {
    return !t || t.type !== "JSXOpeningFragment" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(uD, "isJSXOpeningFragment");
  function cD(t, e) {
    return !t || t.type !== "JSXClosingFragment" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(cD, "isJSXClosingFragment");
  function pD(t, e) {
    return !t || t.type !== "Noop" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(pD, "isNoop");
  function fD(t, e) {
    return !t || t.type !== "Placeholder" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(fD, "isPlaceholder");
  function hD(t, e) {
    return !t || t.type !== "V8IntrinsicIdentifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(hD, "isV8IntrinsicIdentifier");
  function dD(t, e) {
    return !t || t.type !== "ArgumentPlaceholder" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(dD, "isArgumentPlaceholder");
  function mD(t, e) {
    return !t || t.type !== "BindExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(mD, "isBindExpression");
  function yD(t, e) {
    return !t || t.type !== "ImportAttribute" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(yD, "isImportAttribute");
  function TD(t, e) {
    return !t || t.type !== "Decorator" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(TD, "isDecorator");
  function bD(t, e) {
    return !t || t.type !== "DoExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(bD, "isDoExpression");
  function xD(t, e) {
    return !t || t.type !== "ExportDefaultSpecifier" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(xD, "isExportDefaultSpecifier");
  function SD(t, e) {
    return !t || t.type !== "RecordExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(SD, "isRecordExpression");
  function gD(t, e) {
    return !t || t.type !== "TupleExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(gD, "isTupleExpression");
  function PD(t, e) {
    return !t || t.type !== "DecimalLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(PD, "isDecimalLiteral");
  function ED(t, e) {
    return !t || t.type !== "ModuleExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ED, "isModuleExpression");
  function AD(t, e) {
    return !t || t.type !== "TopicReference" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(AD, "isTopicReference");
  function vD(t, e) {
    return !t || t.type !== "PipelineTopicExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(vD, "isPipelineTopicExpression");
  function CD(t, e) {
    return !t || t.type !== "PipelineBareFunction" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(CD, "isPipelineBareFunction");
  function ID(t, e) {
    return !t || t.type !== "PipelinePrimaryTopicReference" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ID, "isPipelinePrimaryTopicReference");
  function wD(t, e) {
    return !t || t.type !== "TSParameterProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(wD, "isTSParameterProperty");
  function ND(t, e) {
    return !t || t.type !== "TSDeclareFunction" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ND, "isTSDeclareFunction");
  function OD(t, e) {
    return !t || t.type !== "TSDeclareMethod" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(OD, "isTSDeclareMethod");
  function kD(t, e) {
    return !t || t.type !== "TSQualifiedName" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(kD, "isTSQualifiedName");
  function DD(t, e) {
    return !t || t.type !== "TSCallSignatureDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(DD, "isTSCallSignatureDeclaration");
  function _D(t, e) {
    return !t || t.type !== "TSConstructSignatureDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_D, "isTSConstructSignatureDeclaration");
  function LD(t, e) {
    return !t || t.type !== "TSPropertySignature" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(LD, "isTSPropertySignature");
  function MD(t, e) {
    return !t || t.type !== "TSMethodSignature" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(MD, "isTSMethodSignature");
  function BD(t, e) {
    return !t || t.type !== "TSIndexSignature" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(BD, "isTSIndexSignature");
  function FD(t, e) {
    return !t || t.type !== "TSAnyKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(FD, "isTSAnyKeyword");
  function jD(t, e) {
    return !t || t.type !== "TSBooleanKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(jD, "isTSBooleanKeyword");
  function RD(t, e) {
    return !t || t.type !== "TSBigIntKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(RD, "isTSBigIntKeyword");
  function UD(t, e) {
    return !t || t.type !== "TSIntrinsicKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(UD, "isTSIntrinsicKeyword");
  function qD(t, e) {
    return !t || t.type !== "TSNeverKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(qD, "isTSNeverKeyword");
  function VD(t, e) {
    return !t || t.type !== "TSNullKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(VD, "isTSNullKeyword");
  function KD(t, e) {
    return !t || t.type !== "TSNumberKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(KD, "isTSNumberKeyword");
  function WD(t, e) {
    return !t || t.type !== "TSObjectKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(WD, "isTSObjectKeyword");
  function YD(t, e) {
    return !t || t.type !== "TSStringKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(YD, "isTSStringKeyword");
  function JD(t, e) {
    return !t || t.type !== "TSSymbolKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(JD, "isTSSymbolKeyword");
  function XD(t, e) {
    return !t || t.type !== "TSUndefinedKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(XD, "isTSUndefinedKeyword");
  function $D(t, e) {
    return !t || t.type !== "TSUnknownKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n($D, "isTSUnknownKeyword");
  function HD(t, e) {
    return !t || t.type !== "TSVoidKeyword" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(HD, "isTSVoidKeyword");
  function zD(t, e) {
    return !t || t.type !== "TSThisType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(zD, "isTSThisType");
  function GD(t, e) {
    return !t || t.type !== "TSFunctionType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(GD, "isTSFunctionType");
  function QD(t, e) {
    return !t || t.type !== "TSConstructorType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(QD, "isTSConstructorType");
  function ZD(t, e) {
    return !t || t.type !== "TSTypeReference" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ZD, "isTSTypeReference");
  function e_(t, e) {
    return !t || t.type !== "TSTypePredicate" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(e_, "isTSTypePredicate");
  function t_(t, e) {
    return !t || t.type !== "TSTypeQuery" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(t_, "isTSTypeQuery");
  function r_(t, e) {
    return !t || t.type !== "TSTypeLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(r_, "isTSTypeLiteral");
  function s_(t, e) {
    return !t || t.type !== "TSArrayType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(s_, "isTSArrayType");
  function i_(t, e) {
    return !t || t.type !== "TSTupleType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(i_, "isTSTupleType");
  function n_(t, e) {
    return !t || t.type !== "TSOptionalType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(n_, "isTSOptionalType");
  function a_(t, e) {
    return !t || t.type !== "TSRestType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(a_, "isTSRestType");
  function o_(t, e) {
    return !t || t.type !== "TSNamedTupleMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(o_, "isTSNamedTupleMember");
  function l_(t, e) {
    return !t || t.type !== "TSUnionType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(l_, "isTSUnionType");
  function u_(t, e) {
    return !t || t.type !== "TSIntersectionType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(u_, "isTSIntersectionType");
  function c_(t, e) {
    return !t || t.type !== "TSConditionalType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(c_, "isTSConditionalType");
  function p_(t, e) {
    return !t || t.type !== "TSInferType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(p_, "isTSInferType");
  function f_(t, e) {
    return !t || t.type !== "TSParenthesizedType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(f_, "isTSParenthesizedType");
  function h_(t, e) {
    return !t || t.type !== "TSTypeOperator" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(h_, "isTSTypeOperator");
  function d_(t, e) {
    return !t || t.type !== "TSIndexedAccessType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(d_, "isTSIndexedAccessType");
  function m_(t, e) {
    return !t || t.type !== "TSMappedType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(m_, "isTSMappedType");
  function y_(t, e) {
    return !t || t.type !== "TSLiteralType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(y_, "isTSLiteralType");
  function T_(t, e) {
    return !t || t.type !== "TSExpressionWithTypeArguments" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(T_, "isTSExpressionWithTypeArguments");
  function b_(t, e) {
    return !t || t.type !== "TSInterfaceDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(b_, "isTSInterfaceDeclaration");
  function x_(t, e) {
    return !t || t.type !== "TSInterfaceBody" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(x_, "isTSInterfaceBody");
  function S_(t, e) {
    return !t || t.type !== "TSTypeAliasDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(S_, "isTSTypeAliasDeclaration");
  function g_(t, e) {
    return !t || t.type !== "TSInstantiationExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(g_, "isTSInstantiationExpression");
  function P_(t, e) {
    return !t || t.type !== "TSAsExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(P_, "isTSAsExpression");
  function E_(t, e) {
    return !t || t.type !== "TSSatisfiesExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(E_, "isTSSatisfiesExpression");
  function A_(t, e) {
    return !t || t.type !== "TSTypeAssertion" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(A_, "isTSTypeAssertion");
  function v_(t, e) {
    return !t || t.type !== "TSEnumDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(v_, "isTSEnumDeclaration");
  function C_(t, e) {
    return !t || t.type !== "TSEnumMember" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(C_, "isTSEnumMember");
  function I_(t, e) {
    return !t || t.type !== "TSModuleDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(I_, "isTSModuleDeclaration");
  function w_(t, e) {
    return !t || t.type !== "TSModuleBlock" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(w_, "isTSModuleBlock");
  function N_(t, e) {
    return !t || t.type !== "TSImportType" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(N_, "isTSImportType");
  function O_(t, e) {
    return !t || t.type !== "TSImportEqualsDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(O_, "isTSImportEqualsDeclaration");
  function k_(t, e) {
    return !t || t.type !== "TSExternalModuleReference" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(k_, "isTSExternalModuleReference");
  function D_(t, e) {
    return !t || t.type !== "TSNonNullExpression" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(D_, "isTSNonNullExpression");
  function __(t, e) {
    return !t || t.type !== "TSExportAssignment" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(__, "isTSExportAssignment");
  function L_(t, e) {
    return !t || t.type !== "TSNamespaceExportDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(L_, "isTSNamespaceExportDeclaration");
  function M_(t, e) {
    return !t || t.type !== "TSTypeAnnotation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(M_, "isTSTypeAnnotation");
  function B_(t, e) {
    return !t || t.type !== "TSTypeParameterInstantiation" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(B_, "isTSTypeParameterInstantiation");
  function F_(t, e) {
    return !t || t.type !== "TSTypeParameterDeclaration" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(F_, "isTSTypeParameterDeclaration");
  function j_(t, e) {
    return !t || t.type !== "TSTypeParameter" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(j_, "isTSTypeParameter");
  function R_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(R_, "isStandardized");
  function U_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(U_, "isExpression");
  function q_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(q_, "isBinary");
  function V_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(V_, "isScopable");
  function K_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(K_, "isBlockParent");
  function W_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(W_, "isBlock");
  function Y_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(Y_, "isStatement");
  function J_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(J_, "isTerminatorless");
  function X_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(X_, "isCompletionStatement");
  function $_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n($_, "isConditional");
  function H_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(H_, "isLoop");
  function z_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(z_, "isWhile");
  function G_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(G_, "isExpressionWrapper");
  function Q_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(Q_, "isFor");
  function Z_(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(Z_, "isForXStatement");
  function eL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(eL, "isFunction");
  function tL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(tL, "isFunctionParent");
  function rL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(rL, "isPureish");
  function sL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (t.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(sL, "isDeclaration");
  function iL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(iL, "isPatternLike");
  function nL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(nL, "isLVal");
  function aL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (t.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(aL, "isTSEntityName");
  function oL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(oL, "isLiteral");
  function lL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(lL, "isImmutable");
  function uL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(uL, "isUserWhitespacable");
  function cL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(cL, "isMethod");
  function pL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(pL, "isObjectMember");
  function fL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(fL, "isProperty");
  function hL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(hL, "isUnaryLike");
  function dL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (t.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(dL, "isPattern");
  function mL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(mL, "isClass");
  function Qb(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(Qb, "isImportOrExportDeclaration");
  function yL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(yL, "isExportDeclaration");
  function TL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(TL, "isModuleSpecifier");
  function bL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(bL, "isAccessor");
  function xL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(xL, "isPrivate");
  function SL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(SL, "isFlow");
  function gL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(gL, "isFlowType");
  function PL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(PL, "isFlowBaseAnnotation");
  function EL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(EL, "isFlowDeclaration");
  function AL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(AL, "isFlowPredicate");
  function vL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(vL, "isEnumBody");
  function CL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(CL, "isEnumMember");
  function IL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(IL, "isJSX");
  function wL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(wL, "isMiscellaneous");
  function NL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(NL, "isTypeScript");
  function OL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(OL, "isTSTypeElement");
  function kL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(kL, "isTSType");
  function DL(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return e == null || (0, C.default)(t, e);
  }
  n(DL, "isTSBaseType");
  function _L(t, e) {
    return (0, ca.default)("isNumberLiteral", "isNumericLiteral"), !t || t.type !== "NumberLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(_L, "isNumberLiteral");
  function LL(t, e) {
    return (0, ca.default)("isRegexLiteral", "isRegExpLiteral"), !t || t.type !== "RegexLiteral" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(LL, "isRegexLiteral");
  function ML(t, e) {
    return (0, ca.default)("isRestProperty", "isRestElement"), !t || t.type !== "RestProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(ML, "isRestProperty");
  function BL(t, e) {
    return (0, ca.default)("isSpreadProperty", "isSpreadElement"), !t || t.type !== "SpreadProperty" ? !1 : e == null || (0, C.default)(t, e);
  }
  n(BL, "isSpreadProperty");
  function FL(t, e) {
    return (0, ca.default)("isModuleDeclaration", "isImportOrExportDeclaration"), Qb(t, e);
  }
  n(FL, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var ep = w((Zc) => {
  "use strict";
  Object.defineProperty(Zc, "__esModule", {
    value: !0
  });
  Zc.default = jL;
  var pa = jt();
  function jL(t, e, r) {
    if (!(0, pa.isMemberExpression)(t)) return !1;
    let s = Array.isArray(e) ? e : e.split("."), i = [], a;
    for (a = t; (0, pa.isMemberExpression)(a); a = a.object)
      i.push(a.property);
    if (i.push(a), i.length < s.length || !r && i.length > s.length) return !1;
    for (let o = 0, l = i.length - 1; o < s.length; o++, l--) {
      let u = i[l], c;
      if ((0, pa.isIdentifier)(u))
        c = u.name;
      else if ((0, pa.isStringLiteral)(u))
        c = u.value;
      else if ((0, pa.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (s[o] !== c) return !1;
    }
    return !0;
  }
  n(jL, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var rp = w((tp) => {
  "use strict";
  Object.defineProperty(tp, "__esModule", {
    value: !0
  });
  tp.default = UL;
  var RL = ep();
  function UL(t, e) {
    let r = t.split(".");
    return (s) => (0, RL.default)(s, r, e);
  }
  n(UL, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var Zb = w((ul) => {
  "use strict";
  Object.defineProperty(ul, "__esModule", {
    value: !0
  });
  ul.default = void 0;
  var qL = rp(), VL = (0, qL.default)("React.Component"), oLe = ul.default = VL;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var ex = w((sp) => {
  "use strict";
  Object.defineProperty(sp, "__esModule", {
    value: !0
  });
  sp.default = KL;
  function KL(t) {
    return !!t && /^[a-z]/.test(t);
  }
  n(KL, "isCompatTag");
});

// ../node_modules/to-fast-properties/index.js
var ip = w((pLe, tx) => {
  "use strict";
  var fa = null;
  function ha(t) {
    if (fa !== null && typeof fa.property) {
      let e = fa;
      return fa = ha.prototype = null, e;
    }
    return fa = ha.prototype = t ?? /* @__PURE__ */ Object.create(null), new ha();
  }
  n(ha, "FastObject");
  ha();
  tx.exports = /* @__PURE__ */ n(function(e) {
    return ha(e);
  }, "toFastproperties");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var cl = w((np) => {
  "use strict";
  Object.defineProperty(np, "__esModule", {
    value: !0
  });
  np.default = WL;
  var rx = Br();
  function WL(t, e) {
    if (t === e) return !0;
    if (t == null || rx.ALIAS_KEYS[e]) return !1;
    let r = rx.FLIPPED_ALIAS_KEYS[e];
    if (r) {
      if (r[0] === t) return !0;
      for (let s of r)
        if (t === s) return !0;
    }
    return !1;
  }
  n(WL, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var op = w((ap) => {
  "use strict";
  Object.defineProperty(ap, "__esModule", {
    value: !0
  });
  ap.default = JL;
  var YL = Br();
  function JL(t, e) {
    if (t === e) return !0;
    let r = YL.PLACEHOLDERS_ALIAS[t];
    if (r) {
      for (let s of r)
        if (e === s) return !0;
    }
    return !1;
  }
  n(JL, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var cn = w((lp) => {
  "use strict";
  Object.defineProperty(lp, "__esModule", {
    value: !0
  });
  lp.default = GL;
  var XL = ll(), $L = cl(), HL = op(), zL = Br();
  function GL(t, e, r) {
    return e ? (0, $L.default)(e.type, t) ? typeof r > "u" ? !0 : (0, XL.default)(e, r) : !r && e.type === "Placeholder" && t in zL.FLIPPED_ALIAS_KEYS ?
    (0, HL.default)(e.expectedNode, t) : !1 : !1;
  }
  n(GL, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var ox = w((da) => {
  "use strict";
  Object.defineProperty(da, "__esModule", {
    value: !0
  });
  da.isIdentifierChar = ax;
  da.isIdentifierName = tM;
  da.isIdentifierStart = nx;
  var cp = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  sx = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", QL = new RegExp("[" + cp + "]"), ZL = new RegExp("[" + cp + sx + "]");
  cp = sx = null;
  var ix = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], eM = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2,
  5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6,
  1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function up(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(up, "isInAstralSet");
  function nx(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && QL.test(String.fromCharCode(t)) :
    up(t, ix);
  }
  n(nx, "isIdentifierStart");
  function ax(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && ZL.test(
    String.fromCharCode(t)) : up(t, ix) || up(t, eM);
  }
  n(ax, "isIdentifierChar");
  function tM(t) {
    let e = !0;
    for (let r = 0; r < t.length; r++) {
      let s = t.charCodeAt(r);
      if ((s & 64512) === 55296 && r + 1 < t.length) {
        let i = t.charCodeAt(++r);
        (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
      }
      if (e) {
        if (e = !1, !nx(s))
          return !1;
      } else if (!ax(s))
        return !1;
    }
    return !e;
  }
  n(tM, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var px = w((Ii) => {
  "use strict";
  Object.defineProperty(Ii, "__esModule", {
    value: !0
  });
  Ii.isKeyword = aM;
  Ii.isReservedWord = lx;
  Ii.isStrictBindOnlyReservedWord = cx;
  Ii.isStrictBindReservedWord = nM;
  Ii.isStrictReservedWord = ux;
  var pp = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, rM = new Set(pp.keyword), sM = new Set(pp.strict), iM = new Set(pp.strictBind);
  function lx(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(lx, "isReservedWord");
  function ux(t, e) {
    return lx(t, e) || sM.has(t);
  }
  n(ux, "isStrictReservedWord");
  function cx(t) {
    return iM.has(t);
  }
  n(cx, "isStrictBindOnlyReservedWord");
  function nM(t, e) {
    return ux(t, e) || cx(t);
  }
  n(nM, "isStrictBindReservedWord");
  function aM(t) {
    return rM.has(t);
  }
  n(aM, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var ya = w((is) => {
  "use strict";
  Object.defineProperty(is, "__esModule", {
    value: !0
  });
  Object.defineProperty(is, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fp.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(is, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fp.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(is, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fp.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(is, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ma.isKeyword;
    }, "get")
  });
  Object.defineProperty(is, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ma.isReservedWord;
    }, "get")
  });
  Object.defineProperty(is, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ma.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(is, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ma.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(is, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ma.isStrictReservedWord;
    }, "get")
  });
  var fp = ox(), ma = px();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var pn = w((dp) => {
  "use strict";
  Object.defineProperty(dp, "__esModule", {
    value: !0
  });
  dp.default = oM;
  var hp = ya();
  function oM(t, e = !0) {
    return typeof t != "string" || e && ((0, hp.isKeyword)(t) || (0, hp.isStrictReservedWord)(t, !0)) ? !1 : (0, hp.isIdentifierName)(t);
  }
  n(oM, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var mx = w((Ta) => {
  "use strict";
  Object.defineProperty(Ta, "__esModule", {
    value: !0
  });
  Ta.readCodePoint = dx;
  Ta.readInt = hx;
  Ta.readStringContents = uM;
  var lM = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), fx = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, pl = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function uM(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (cM(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = pM(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(uM, "readStringContents");
  function cM(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(cM, "isStringEnd");
  function pM(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = mp(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = dx(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(pM, "readEscapedChar");
  function mp(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = hx(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(mp, "readHexChar");
  function hx(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? fx.hex : fx.decBinOct, m = i === 16 ? pl.hex : i === 10 ? pl.dec : i === 8 ? pl.oct : pl.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : lM(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(hx, "readInt");
  function dx(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = mp(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = mp(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(dx, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var Js = w((qe) => {
  "use strict";
  Object.defineProperty(qe, "__esModule", {
    value: !0
  });
  qe.UPDATE_OPERATORS = qe.UNARY_OPERATORS = qe.STRING_UNARY_OPERATORS = qe.STATEMENT_OR_BLOCK_KEYS = qe.NUMBER_UNARY_OPERATORS = qe.NUMBER_BINARY_OPERATORS =
  qe.NOT_LOCAL_BINDING = qe.LOGICAL_OPERATORS = qe.INHERIT_KEYS = qe.FOR_INIT_KEYS = qe.FLATTENABLE_KEYS = qe.EQUALITY_BINARY_OPERATORS = qe.
  COMPARISON_BINARY_OPERATORS = qe.COMMENT_KEYS = qe.BOOLEAN_UNARY_OPERATORS = qe.BOOLEAN_NUMBER_BINARY_OPERATORS = qe.BOOLEAN_BINARY_OPERATORS =
  qe.BLOCK_SCOPED_SYMBOL = qe.BINARY_OPERATORS = qe.ASSIGNMENT_OPERATORS = void 0;
  var NLe = qe.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], OLe = qe.FLATTENABLE_KEYS = ["body", "expressions"], kLe = qe.
  FOR_INIT_KEYS = ["left", "init"], DLe = qe.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], fM = qe.LOGICAL_OPERATORS =
  ["||", "&&", "??"], _Le = qe.UPDATE_OPERATORS = ["++", "--"], hM = qe.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], dM = qe.EQUALITY_BINARY_OPERATORS =
  ["==", "===", "!=", "!=="], mM = qe.COMPARISON_BINARY_OPERATORS = [...dM, "in", "instanceof"], yM = qe.BOOLEAN_BINARY_OPERATORS = [...mM, ...hM],
  yx = qe.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], LLe = qe.BINARY_OPERATORS = ["+", ...yx, ...yM,
  "|>"], MLe = qe.ASSIGNMENT_OPERATORS = ["=", "+=", ...yx.map((t) => t + "="), ...fM.map((t) => t + "=")], TM = qe.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], bM = qe.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], xM = qe.STRING_UNARY_OPERATORS = ["typeof"], BLe = qe.UNARY_OPERATORS =
  ["void", "throw", ...TM, ...bM, ...xM], FLe = qe.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, jLe = qe.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), RLe = qe.NOT_LOCAL_BINDING = Symbol.for("should not be consid\
ered a local binding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var ms = w((rt) => {
  "use strict";
  Object.defineProperty(rt, "__esModule", {
    value: !0
  });
  rt.VISITOR_KEYS = rt.NODE_PARENT_VALIDATIONS = rt.NODE_FIELDS = rt.FLIPPED_ALIAS_KEYS = rt.DEPRECATED_KEYS = rt.BUILDER_KEYS = rt.ALIAS_KEYS =
  void 0;
  rt.arrayOf = bx;
  rt.arrayOfType = xx;
  rt.assertEach = Sx;
  rt.assertNodeOrValueType = kM;
  rt.assertNodeType = Tp;
  rt.assertOneOf = OM;
  rt.assertOptionalChainStart = _M;
  rt.assertShape = DM;
  rt.assertValueType = Sp;
  rt.chain = gx;
  rt.default = Px;
  rt.defineAliasedType = BM;
  rt.typeIs = dl;
  rt.validate = xp;
  rt.validateArrayOfType = NM;
  rt.validateOptional = IM;
  rt.validateOptionalType = wM;
  rt.validateType = CM;
  var Tx = cn(), hl = ml(), SM = rt.VISITOR_KEYS = {}, gM = rt.ALIAS_KEYS = {}, yp = rt.FLIPPED_ALIAS_KEYS = {}, PM = rt.NODE_FIELDS = {}, EM = rt.
  BUILDER_KEYS = {}, AM = rt.DEPRECATED_KEYS = {}, vM = rt.NODE_PARENT_VALIDATIONS = {};
  function fl(t) {
    return Array.isArray(t) ? "array" : t === null ? "null" : typeof t;
  }
  n(fl, "getType");
  function xp(t) {
    return {
      validate: t
    };
  }
  n(xp, "validate");
  function dl(t) {
    return typeof t == "string" ? Tp(t) : Tp(...t);
  }
  n(dl, "typeIs");
  function CM(t) {
    return xp(dl(t));
  }
  n(CM, "validateType");
  function IM(t) {
    return {
      validate: t,
      optional: !0
    };
  }
  n(IM, "validateOptional");
  function wM(t) {
    return {
      validate: dl(t),
      optional: !0
    };
  }
  n(wM, "validateOptionalType");
  function bx(t) {
    return gx(Sp("array"), Sx(t));
  }
  n(bx, "arrayOf");
  function xx(t) {
    return bx(dl(t));
  }
  n(xx, "arrayOfType");
  function NM(t) {
    return xp(xx(t));
  }
  n(NM, "validateArrayOfType");
  function Sx(t) {
    function e(r, s, i) {
      if (Array.isArray(i))
        for (let a = 0; a < i.length; a++) {
          let o = `${s}[${a}]`, l = i[a];
          t(r, o, l), process.env.BABEL_TYPES_8_BREAKING && (0, hl.validateChild)(r, o, l);
        }
    }
    return n(e, "validator"), e.each = t, e;
  }
  n(Sx, "assertEach");
  function OM(...t) {
    function e(r, s, i) {
      if (t.indexOf(i) < 0)
        throw new TypeError(`Property ${s} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(i)}`);
    }
    return n(e, "validate"), e.oneOf = t, e;
  }
  n(OM, "assertOneOf");
  function Tp(...t) {
    function e(r, s, i) {
      for (let a of t)
        if ((0, Tx.default)(a, i)) {
          (0, hl.validateChild)(r, s, i);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeTypes = t, e;
  }
  n(Tp, "assertNodeType");
  function kM(...t) {
    function e(r, s, i) {
      for (let a of t)
        if (fl(i) === a || (0, Tx.default)(a, i)) {
          (0, hl.validateChild)(r, s, i);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeOrValueTypes = t, e;
  }
  n(kM, "assertNodeOrValueType");
  function Sp(t) {
    function e(r, s, i) {
      if (!(fl(i) === t))
        throw new TypeError(`Property ${s} expected type of ${t} but got ${fl(i)}`);
    }
    return n(e, "validate"), e.type = t, e;
  }
  n(Sp, "assertValueType");
  function DM(t) {
    function e(r, s, i) {
      let a = [];
      for (let o of Object.keys(t))
        try {
          (0, hl.validateField)(r, o, i[o], t[o]);
        } catch (l) {
          if (l instanceof TypeError) {
            a.push(l.message);
            continue;
          }
          throw l;
        }
      if (a.length)
        throw new TypeError(`Property ${s} of ${r.type} expected to have the following:
${a.join(`
`)}`);
    }
    return n(e, "validate"), e.shapeOf = t, e;
  }
  n(DM, "assertShape");
  function _M() {
    function t(e) {
      var r;
      let s = e;
      for (; e; ) {
        let {
          type: i
        } = s;
        if (i === "OptionalCallExpression") {
          if (s.optional) return;
          s = s.callee;
          continue;
        }
        if (i === "OptionalMemberExpression") {
          if (s.optional) return;
          s = s.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = s) == null ? void 0 : r.type}`);
    }
    return n(t, "validate"), t;
  }
  n(_M, "assertOptionalChainStart");
  function gx(...t) {
    function e(...r) {
      for (let s of t)
        s(...r);
    }
    if (n(e, "validate"), e.chainOf = t, t.length >= 2 && "type" in t[0] && t[0].type === "array" && !("each" in t[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return e;
  }
  n(gx, "chain");
  var LM = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], MM = ["default", "optional", "deprecated",
  "validate"], bp = {};
  function BM(...t) {
    return (e, r = {}) => {
      let s = r.aliases;
      if (!s) {
        var i, a;
        r.inherits && (s = (i = bp[r.inherits].aliases) == null ? void 0 : i.slice()), (a = s) != null || (s = []), r.aliases = s;
      }
      let o = t.filter((l) => !s.includes(l));
      s.unshift(...o), Px(e, r);
    };
  }
  n(BM, "defineAliasedType");
  function Px(t, e = {}) {
    let r = e.inherits && bp[e.inherits] || {}, s = e.fields;
    if (!s && (s = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        s[u] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let i = e.visitor || r.visitor || [], a = e.aliases || r.aliases || [], o = e.builder || r.builder || e.visitor || [];
    for (let l of Object.keys(e))
      if (LM.indexOf(l) === -1)
        throw new Error(`Unknown type option "${l}" on ${t}`);
    e.deprecatedAlias && (AM[e.deprecatedAlias] = t);
    for (let l of i.concat(o))
      s[l] = s[l] || {};
    for (let l of Object.keys(s)) {
      let u = s[l];
      u.default !== void 0 && o.indexOf(l) === -1 && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default !=
      null && (u.validate = Sp(fl(u.default)));
      for (let c of Object.keys(u))
        if (MM.indexOf(c) === -1)
          throw new Error(`Unknown field key "${c}" on ${t}.${l}`);
    }
    SM[t] = e.visitor = i, EM[t] = e.builder = o, PM[t] = e.fields = s, gM[t] = e.aliases = a, a.forEach((l) => {
      yp[l] = yp[l] || [], yp[l].push(t);
    }), e.validate && (vM[t] = e.validate), bp[t] = e;
  }
  n(Px, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var Pp = w((wr) => {
  "use strict";
  Object.defineProperty(wr, "__esModule", {
    value: !0
  });
  wr.patternLikeCommon = wr.functionTypeAnnotationCommon = wr.functionDeclarationCommon = wr.functionCommon = wr.classMethodOrPropertyCommon =
  wr.classMethodOrDeclareMethodCommon = void 0;
  var lr = cn(), FM = pn(), Ex = ya(), jM = mx(), ba = Js(), h = ms(), ee = (0, h.defineAliasedType)("Standardized");
  ee("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeOrValueType)("null", "Expression", "Spread\
Element"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  ee("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, h.assertValueType)("string");
          let t = (0, h.assertOneOf)(...ba.ASSIGNMENT_OPERATORS), e = (0, h.assertOneOf)("=");
          return function(r, s, i) {
            ((0, lr.default)("Pattern", r.left) ? e : t)(r, s, i);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, h.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  ee("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, h.assertOneOf)(...ba.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let t = (0, h.assertNodeType)("Expression"), e = (0, h.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(s, i, a) {
            (s.operator === "in" ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  ee("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("string")
      }
    }
  });
  ee("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, h.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  ee("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("string")
      }
    }
  });
  ee("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  ee("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  ee("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, h.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Expression", "SpreadElement", "Argu\
mentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, h.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  ee("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, h.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  ee("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, h.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, h.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  ee("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  ee("DebuggerStatement", {
    aliases: ["Statement"]
  });
  ee("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  ee("EmptyStatement", {
    aliases: ["Statement"]
  });
  ee("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, h.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  ee("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, h.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertEach)((0, h.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, h.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  ee("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, h.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, h.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  var fn = /* @__PURE__ */ n(() => ({
    params: {
      validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  wr.functionCommon = fn;
  var wi = /* @__PURE__ */ n(() => ({
    returnType: {
      validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, h.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  wr.functionTypeAnnotationCommon = wi;
  var Ax = /* @__PURE__ */ n(() => Object.assign({}, fn(), {
    declare: {
      validate: (0, h.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, h.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  wr.functionDeclarationCommon = Ax;
  ee("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, Ax(), wi(), {
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, h.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      let t = (0, h.assertNodeType)("Identifier");
      return function(e, r, s) {
        (0, lr.default)("ExportDefaultDeclaration", e) || t(s, "id", s.id);
      };
    }()
  });
  ee("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, fn(), wi(), {
      id: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, h.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var hn = /* @__PURE__ */ n(() => ({
    typeAnnotation: {
      validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, h.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "patternLikeCommon");
  wr.patternLikeCommon = hn;
  ee("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, hn(), {
      name: {
        validate: (0, h.chain)((0, h.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, FM.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(t, e, r) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let s = /\.(\w+)$/.exec(e);
      if (!s) return;
      let [, i] = s, a = {
        computed: !1
      };
      if (i === "property") {
        if ((0, lr.default)("MemberExpression", t, a) || (0, lr.default)("OptionalMemberExpression", t, a)) return;
      } else if (i === "key") {
        if ((0, lr.default)("Property", t, a) || (0, lr.default)("Method", t, a)) return;
      } else if (i === "exported") {
        if ((0, lr.default)("ExportSpecifier", t)) return;
      } else if (i === "imported") {
        if ((0, lr.default)("ImportSpecifier", t, {
          imported: r
        })) return;
      } else if (i === "meta" && (0, lr.default)("MetaProperty", t, {
        meta: r
      }))
        return;
      if (((0, Ex.isKeyword)(r.name) || (0, Ex.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    }
  });
  ee("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, h.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, h.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, h.chain)((0, h.assertValueType)("number"), Object.assign(function(t, e, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let s = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, h.assertValueType)("string")
      },
      flags: {
        validate: (0, h.chain)((0, h.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s = /[^gimsuy]/.exec(r);
          if (s)
            throw new TypeError(`"${s[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  ee("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, h.assertOneOf)(...ba.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, h.assertNodeType)("Expression")
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, h.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let t = (0, h.assertNodeType)("Identifier", "PrivateName"), e = (0, h.assertNodeType)("Expression"), r = /* @__PURE__ */ n(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, h.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  });
  ee("NewExpression", {
    inherits: "CallExpression"
  });
  ee("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, h.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, h.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  ee("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ObjectMethod", "ObjectProperty", "S\
preadElement")))
      }
    }
  });
  ee("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, fn(), wi(), {
      kind: Object.assign({
        validate: (0, h.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, h.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ n(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  ee("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), e = (0, h.
          assertNodeType)("Expression");
          return Object.assign(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, h.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, h.chain)((0, h.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !(0, lr.default)("Identifier", t.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      let t = (0, h.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), e = (0, h.assertNodeType)("Expression");
      return function(r, s, i) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, lr.default)("ObjectPattern", r) ? t : e)(i, "value", i.value);
      };
    }()
  });
  ee("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, hn(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, h.assertNodeType)("LVal")
      }
    }),
    validate(t, e) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let r = /(\w+)\[(\d+)\]/.exec(e);
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, s, i] = r;
      if (t[s].length > +i + 1)
        throw new TypeError(`RestElement must be last element of ${s}`);
    }
  });
  ee("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  ee("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  ee("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Statement")))
      }
    }
  });
  ee("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, h.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("SwitchCase")))
      }
    }
  });
  ee("ThisExpression", {
    aliases: ["Expression"]
  });
  ee("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, h.chain)((0, h.assertNodeType)("BlockStatement"), Object.assign(function(t) {
          if (process.env.BABEL_TYPES_8_BREAKING && !t.handler && !t.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, h.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    }
  });
  ee("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, h.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, h.assertOneOf)(...ba.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  ee("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.assertNodeType)("Identifier", "MemberExpression") : (0, h.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, h.assertOneOf)(...ba.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  ee("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, h.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(t, e, r) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, lr.default)("ForXStatement", t, {
        left: r
      }) && r.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${t.type}`);
    }
  });
  ee("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, h.assertNodeType)("LVal");
          let t = (0, h.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), e = (0, h.assertNodeType)("Identifier");
          return function(r, s, i) {
            (r.init ? t : e)(r, s, i);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, h.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      }
    }
  });
  ee("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, hn(), {
      left: {
        validate: (0, h.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  });
  ee("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, hn(), {
      elements: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  ee("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, fn(), wi(), {
      expression: {
        validate: (0, h.assertValueType)("boolean")
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, h.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  ee("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ClassMethod", "ClassPrivateMethod",
        "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  ee("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, h.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, h.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  ee("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, h.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, h.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, h.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, h.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      let t = (0, h.assertNodeType)("Identifier");
      return function(e, r, s) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, lr.default)("ExportDefaultDeclaration", e) || t(s, "id", s.id));
      };
    }()
  });
  ee("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, h.assertNodeType)("StringLiteral")
      },
      exportKind: (0, h.validateOptional)((0, h.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      }
    }
  });
  ee("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, h.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, h.validateOptional)((0, h.assertOneOf)("value"))
    }
  });
  ee("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertNodeType)("Declaration"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)(function() {
          let t = (0, h.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), e = (0, h.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(r, s, i) {
            (r.source ? t : e)(r, s, i);
          } : t;
        }()))
      },
      source: {
        validate: (0, h.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, h.validateOptional)((0, h.assertOneOf)("type", "value"))
    }
  });
  ee("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, h.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, h.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, h.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  ee("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, h.assertNodeType)("VariableDeclaration", "LVal");
          let t = (0, h.assertNodeType)("VariableDeclaration"), e = (0, h.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(r, s, i) {
            (0, lr.default)("VariableDeclaration", i) ? t(r, s, i) : e(r, s, i);
          };
        }()
      },
      right: {
        validate: (0, h.assertNodeType)("Expression")
      },
      body: {
        validate: (0, h.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  ee("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, h.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, h.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("ImportSpecifier", "ImportDefaultSpe\
cifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, h.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, h.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  ee("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  ee("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  ee("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, h.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, h.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, h.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  ee("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, h.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, h.assertNodeType)("Expression")
      },
      options: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  ee("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, h.chain)((0, h.assertNodeType)("Identifier"), Object.assign(function(t, e, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s;
          switch (r.name) {
            case "function":
              s = "sent";
              break;
            case "new":
              s = "target";
              break;
            case "import":
              s = "meta";
              break;
          }
          if (!(0, lr.default)("Identifier", t.property, {
            name: s
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  var yl = /* @__PURE__ */ n(() => ({
    abstract: {
      validate: (0, h.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, h.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, h.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, h.chain)(function() {
        let t = (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, h.assertNodeType)("Expressi\
on");
        return function(r, s, i) {
          (r.computed ? e : t)(r, s, i);
        };
      }(), (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  wr.classMethodOrPropertyCommon = yl;
  var gp = /* @__PURE__ */ n(() => Object.assign({}, fn(), yl(), {
    params: {
      validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Identifier", "Pattern", "RestElement",
      "TSParameterProperty")))
    },
    kind: {
      validate: (0, h.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, h.chain)((0, h.assertValueType)("string"), (0, h.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  wr.classMethodOrDeclareMethodCommon = gp;
  ee("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, gp(), wi(), {
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    })
  });
  ee("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, hn(), {
      properties: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  ee("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("Super", {
    aliases: ["Expression"]
  });
  ee("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, h.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, h.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ee("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, h.chain)((0, h.assertShape)({
          raw: {
            validate: (0, h.assertValueType)("string")
          },
          cooked: {
            validate: (0, h.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ n(function(e) {
          let r = e.value.raw, s = !1, i = /* @__PURE__ */ n(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, jM.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              s = !0;
            },
            strictNumericEscape: i,
            invalidEscapeSequence: i,
            numericSeparatorInEscapeSequence: i,
            unexpectedNumericSeparator: i,
            invalidDigit: i,
            invalidCodePoint: i
          });
          if (!s) throw new Error("Invalid raw");
          e.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  ee("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Expression", "TSType")), function(t, e, r) {
          if (t.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  ee("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, h.chain)((0, h.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !t.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, h.assertNodeType)("Expression")
      }
    }
  });
  ee("Import", {
    aliases: ["Expression"]
  });
  ee("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, h.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ee("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  ee("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, h.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let t = (0, h.assertNodeType)("Identifier"), e = (0, h.assertNodeType)("Expression");
          return Object.assign(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.chain)((0, h.assertValueType)("boolean"), (0, h.assertOptionalChainStart)()) : (0, h.
        assertValueType)("boolean")
      }
    }
  });
  ee("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, h.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Expression", "SpreadElement", "Argu\
mentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, h.chain)((0, h.assertValueType)("boolean"), (0, h.assertOptionalChainStart)()) : (0, h.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, h.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, h.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ee("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, yl(), {
      value: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, h.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  ee("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, yl(), {
      key: {
        validate: (0, h.chain)(function() {
          let t = (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), e = (0, h.assertNodeType)(
          "Expression");
          return function(r, s, i) {
            (r.computed ? e : t)(r, s, i);
          };
        }(), (0, h.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, h.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  ee("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, h.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, h.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, h.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, h.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, h.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, h.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  ee("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, gp(), wi(), {
      kind: {
        validate: (0, h.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, h.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, h.assertNodeType)("BlockStatement")
      }
    })
  });
  ee("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, h.assertNodeType)("Identifier")
      }
    }
  });
  ee("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, h.chain)((0, h.assertValueType)("array"), (0, h.assertEach)((0, h.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var vx = w(() => {
  "use strict";
  var V = ms(), be = (0, V.defineAliasedType)("Flow"), Ep = /* @__PURE__ */ n((t) => {
    let e = t === "DeclareClass";
    be(t, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...e ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, V.validateType)("Identifier"),
        typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, V.validateOptional)((0, V.arrayOfType)("InterfaceExtends"))
      }, e ? {
        mixins: (0, V.validateOptional)((0, V.arrayOfType)("InterfaceExtends")),
        implements: (0, V.validateOptional)((0, V.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, V.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  be("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, V.validateType)("FlowType")
    }
  });
  be("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ep("DeclareClass");
  be("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      predicate: (0, V.validateOptionalType)("DeclaredPredicate")
    }
  });
  Ep("DeclareInterface");
  be("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)(["Identifier", "StringLiteral"]),
      body: (0, V.validateType)("BlockStatement"),
      kind: (0, V.validateOptional)((0, V.assertOneOf)("CommonJS", "ES"))
    }
  });
  be("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, V.validateType)("TypeAnnotation")
    }
  });
  be("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, V.validateType)("FlowType")
    }
  });
  be("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, V.validateOptionalType)("FlowType"),
      impltype: (0, V.validateOptionalType)("FlowType")
    }
  });
  be("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier")
    }
  });
  be("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, V.validateOptionalType)("Flow"),
      specifiers: (0, V.validateOptional)((0, V.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, V.validateOptionalType)("StringLiteral"),
      default: (0, V.validateOptional)((0, V.assertValueType)("boolean"))
    }
  });
  be("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, V.validateType)("StringLiteral"),
      exportKind: (0, V.validateOptional)((0, V.assertOneOf)("type", "value"))
    }
  });
  be("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, V.validateType)("Flow")
    }
  });
  be("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  be("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, V.validate)((0, V.arrayOfType)("FunctionTypeParam")),
      rest: (0, V.validateOptionalType)("FunctionTypeParam"),
      this: (0, V.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, V.validateType)("FlowType")
    }
  });
  be("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, V.validateOptionalType)("Identifier"),
      typeAnnotation: (0, V.validateType)("FlowType"),
      optional: (0, V.validateOptional)((0, V.assertValueType)("boolean"))
    }
  });
  be("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, V.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, V.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  be("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  be("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, V.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, V.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  Ep("InterfaceDeclaration");
  be("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, V.validateOptional)((0, V.arrayOfType)("InterfaceExtends")),
      body: (0, V.validateType)("ObjectTypeAnnotation")
    }
  });
  be("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, V.validate)((0, V.arrayOfType)("FlowType"))
    }
  });
  be("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, V.validateType)("FlowType")
    }
  });
  be("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, V.validate)((0, V.assertValueType)("number"))
    }
  });
  be("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, V.validate)((0, V.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, V.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, V.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, V.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, V.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, V.validateOptional)((0, V.assertValueType)("boolean"))
    }
  });
  be("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      value: (0, V.validateType)("FlowType"),
      optional: (0, V.validate)((0, V.assertValueType)("boolean")),
      static: (0, V.validate)((0, V.assertValueType)("boolean")),
      method: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, V.validateType)("FlowType"),
      static: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, V.validateOptionalType)("Identifier"),
      key: (0, V.validateType)("FlowType"),
      value: (0, V.validateType)("FlowType"),
      static: (0, V.validate)((0, V.assertValueType)("boolean")),
      variance: (0, V.validateOptionalType)("Variance")
    }
  });
  be("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, V.validateType)(["Identifier", "StringLiteral"]),
      value: (0, V.validateType)("FlowType"),
      kind: (0, V.validate)((0, V.assertOneOf)("init", "get", "set")),
      static: (0, V.validate)((0, V.assertValueType)("boolean")),
      proto: (0, V.validate)((0, V.assertValueType)("boolean")),
      optional: (0, V.validate)((0, V.assertValueType)("boolean")),
      variance: (0, V.validateOptionalType)("Variance"),
      method: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, V.validateType)("FlowType")
    }
  });
  be("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, V.validateOptionalType)("FlowType"),
      impltype: (0, V.validateType)("FlowType")
    }
  });
  be("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      qualification: (0, V.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  be("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, V.validate)((0, V.assertValueType)("string"))
    }
  });
  be("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, V.validate)((0, V.arrayOfType)("FlowType"))
    }
  });
  be("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, V.validateType)("FlowType")
    }
  });
  be("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      typeParameters: (0, V.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, V.validateType)("FlowType")
    }
  });
  be("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, V.validateType)("FlowType")
    }
  });
  be("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, V.validateType)("Expression"),
      typeAnnotation: (0, V.validateType)("TypeAnnotation")
    }
  });
  be("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, V.validate)((0, V.assertValueType)("string")),
      bound: (0, V.validateOptionalType)("TypeAnnotation"),
      default: (0, V.validateOptionalType)("FlowType"),
      variance: (0, V.validateOptionalType)("Variance")
    }
  });
  be("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, V.validate)((0, V.arrayOfType)("TypeParameter"))
    }
  });
  be("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, V.validate)((0, V.arrayOfType)("FlowType"))
    }
  });
  be("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, V.validate)((0, V.arrayOfType)("FlowType"))
    }
  });
  be("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, V.validate)((0, V.assertOneOf)("minus", "plus"))
    }
  });
  be("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  be("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      body: (0, V.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  be("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, V.validate)((0, V.assertValueType)("boolean")),
      members: (0, V.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, V.validate)((0, V.assertValueType)("boolean")),
      members: (0, V.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, V.validate)((0, V.assertValueType)("boolean")),
      members: (0, V.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, V.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
  be("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      init: (0, V.validateType)("BooleanLiteral")
    }
  });
  be("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      init: (0, V.validateType)("NumericLiteral")
    }
  });
  be("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, V.validateType)("Identifier"),
      init: (0, V.validateType)("StringLiteral")
    }
  });
  be("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, V.validateType)("Identifier")
    }
  });
  be("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, V.validateType)("FlowType"),
      indexType: (0, V.validateType)("FlowType")
    }
  });
  be("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, V.validateType)("FlowType"),
      indexType: (0, V.validateType)("FlowType"),
      optional: (0, V.validate)((0, V.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var Cx = w(() => {
  "use strict";
  var lt = ms(), ur = (0, lt.defineAliasedType)("JSX");
  ur("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, lt.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, lt.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  ur("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, lt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  ur("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, lt.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, lt.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, lt.chain)((0, lt.assertValueType)("array"), (0, lt.assertEach)((0, lt.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, lt.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  ur("JSXEmptyExpression", {});
  ur("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, lt.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  ur("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, lt.assertNodeType)("Expression")
      }
    }
  });
  ur("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, lt.assertValueType)("string")
      }
    }
  });
  ur("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, lt.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, lt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ur("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, lt.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, lt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ur("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, lt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, lt.chain)((0, lt.assertValueType)("array"), (0, lt.assertEach)((0, lt.assertNodeType)("JSXAttribute", "JSXSpreadAttrib\
ute")))
      },
      typeParameters: {
        validate: (0, lt.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ur("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, lt.assertNodeType)("Expression")
      }
    }
  });
  ur("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, lt.assertValueType)("string")
      }
    }
  });
  ur("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, lt.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, lt.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, lt.chain)((0, lt.assertValueType)("array"), (0, lt.assertEach)((0, lt.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  ur("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  ur("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Cp = w((Xs) => {
  "use strict";
  Object.defineProperty(Xs, "__esModule", {
    value: !0
  });
  Xs.PLACEHOLDERS_FLIPPED_ALIAS = Xs.PLACEHOLDERS_ALIAS = Xs.PLACEHOLDERS = void 0;
  var RM = ms(), UM = Xs.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBo\
dy", "Pattern"], vp = Xs.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let t of UM) {
    let e = RM.ALIAS_KEYS[t];
    e != null && e.length && (vp[t] = e);
  }
  var Ap = Xs.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(vp).forEach((t) => {
    vp[t].forEach((e) => {
      hasOwnProperty.call(Ap, e) || (Ap[e] = []), Ap[e].push(t);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var Ix = w(() => {
  "use strict";
  var Tl = ms(), qM = Cp(), Ip = (0, Tl.defineAliasedType)("Miscellaneous");
  Ip("Noop", {
    visitor: []
  });
  Ip("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, Tl.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, Tl.assertOneOf)(...qM.PLACEHOLDERS)
      }
    }
  });
  Ip("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Tl.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var wx = w(() => {
  "use strict";
  var st = ms();
  (0, st.default)("ArgumentPlaceholder", {});
  (0, st.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, st.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, st.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, st.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, st.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, st.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, st.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, st.assertNodeType)("Expression")
      }
    }
  });
  (0, st.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, st.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, st.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, st.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, st.assertNodeType)("Identifier")
      }
    }
  });
  (0, st.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, st.chain)((0, st.assertValueType)("array"), (0, st.assertEach)((0, st.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, st.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, st.chain)((0, st.assertValueType)("array"), (0, st.assertEach)((0, st.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, st.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, st.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, st.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, st.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, st.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, st.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, st.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, st.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, st.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, st.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var Bx = w(() => {
  "use strict";
  var X = ms(), Nx = Pp(), VM = cn(), _e = (0, X.defineAliasedType)("TypeScript"), Nr = (0, X.assertValueType)("boolean"), Ox = /* @__PURE__ */ n(
  () => ({
    returnType: {
      validate: (0, X.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, X.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  _e("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, X.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, X.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  });
  _e("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Nx.functionDeclarationCommon)(), Ox())
  });
  _e("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Nx.classMethodOrDeclareMethodCommon)(), Ox())
  });
  _e("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, X.validateType)("TSEntityName"),
      right: (0, X.validateType)("Identifier")
    }
  });
  var bl = /* @__PURE__ */ n(() => ({
    typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, X.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), kx = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: bl()
  };
  _e("TSCallSignatureDeclaration", kx);
  _e("TSConstructSignatureDeclaration", kx);
  var Dx = /* @__PURE__ */ n(() => ({
    key: (0, X.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, X.validateOptional)(Nr)
  }), "namedTypeElementCommon");
  _e("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, Dx(), {
      readonly: (0, X.validateOptional)(Nr),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, X.assertOneOf)("get", "set")
      }
    })
  });
  _e("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, bl(), Dx(), {
      kind: {
        validate: (0, X.assertOneOf)("method", "get", "set")
      }
    })
  });
  _e("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, X.validateOptional)(Nr),
      static: (0, X.validateOptional)(Nr),
      parameters: (0, X.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var KM = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword",
  "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let t of KM)
    _e(t, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  _e("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var _x = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  _e("TSFunctionType", Object.assign({}, _x, {
    fields: bl()
  }));
  _e("TSConstructorType", Object.assign({}, _x, {
    fields: Object.assign({}, bl(), {
      abstract: (0, X.validateOptional)(Nr)
    })
  }));
  _e("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, X.validateType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  _e("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, X.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, X.validateOptional)(Nr)
    }
  });
  _e("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, X.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  _e("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, X.validateArrayOfType)("TSTypeElement")
    }
  });
  _e("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, X.validateType)("TSType")
    }
  });
  _e("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, X.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  _e("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, X.validateType)("Identifier"),
      optional: {
        validate: Nr,
        default: !1
      },
      elementType: (0, X.validateType)("TSType")
    }
  });
  var Lx = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, X.validateArrayOfType)("TSType")
    }
  };
  _e("TSUnionType", Lx);
  _e("TSIntersectionType", Lx);
  _e("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, X.validateType)("TSType"),
      extendsType: (0, X.validateType)("TSType"),
      trueType: (0, X.validateType)("TSType"),
      falseType: (0, X.validateType)("TSType")
    }
  });
  _e("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, X.validateType)("TSTypeParameter")
    }
  });
  _e("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, X.validate)((0, X.assertValueType)("string")),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, X.validateType)("TSType"),
      indexType: (0, X.validateType)("TSType")
    }
  });
  _e("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, X.validateOptional)((0, X.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, X.validateType)("TSTypeParameter"),
      optional: (0, X.validateOptional)((0, X.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, X.validateOptionalType)("TSType"),
      nameType: (0, X.validateOptionalType)("TSType")
    }
  });
  _e("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let t = (0, X.assertNodeType)("NumericLiteral", "BigIntLiteral"), e = (0, X.assertOneOf)("-"), r = (0, X.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function s(i, a, o) {
            (0, VM.default)("UnaryExpression", o) ? (e(o, "operator", o.operator), t(o, "argument", o.argument)) : r(i, a, o);
          }
          return n(s, "validator"), s.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], s;
        }()
      }
    }
  });
  _e("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, X.validateType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  _e("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, X.validateOptional)(Nr),
      id: (0, X.validateType)("Identifier"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, X.validateOptional)((0, X.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, X.validateType)("TSInterfaceBody")
    }
  });
  _e("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, X.validateArrayOfType)("TSTypeElement")
    }
  });
  _e("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, X.validateOptional)(Nr),
      id: (0, X.validateType)("Identifier"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  _e("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, X.validateType)("Expression"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var Mx = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, X.validateType)("Expression"),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  };
  _e("TSAsExpression", Mx);
  _e("TSSatisfiesExpression", Mx);
  _e("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType"),
      expression: (0, X.validateType)("Expression")
    }
  });
  _e("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, X.validateOptional)(Nr),
      const: (0, X.validateOptional)(Nr),
      id: (0, X.validateType)("Identifier"),
      members: (0, X.validateArrayOfType)("TSEnumMember"),
      initializer: (0, X.validateOptionalType)("Expression")
    }
  });
  _e("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, X.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, X.validateOptionalType)("Expression")
    }
  });
  _e("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, X.validateOptional)(Nr),
      global: (0, X.validateOptional)(Nr),
      id: (0, X.validateType)(["Identifier", "StringLiteral"]),
      body: (0, X.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  _e("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, X.validateArrayOfType)("Statement")
    }
  });
  _e("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, X.validateType)("StringLiteral"),
      qualifier: (0, X.validateOptionalType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, X.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  _e("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, X.validate)(Nr),
      id: (0, X.validateType)("Identifier"),
      moduleReference: (0, X.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, X.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  _e("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("StringLiteral")
    }
  });
  _e("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("Expression")
    }
  });
  _e("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("Expression")
    }
  });
  _e("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, X.validateType)("Identifier")
    }
  });
  _e("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, X.assertNodeType)("TSType")
      }
    }
  });
  _e("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("TSType")))
      }
    }
  });
  _e("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  _e("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, X.assertValueType)("string")
      },
      in: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, X.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, X.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var Fx = w((xl) => {
  "use strict";
  Object.defineProperty(xl, "__esModule", {
    value: !0
  });
  xl.DEPRECATED_ALIASES = void 0;
  var iMe = xl.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Br = w((cr) => {
  "use strict";
  Object.defineProperty(cr, "__esModule", {
    value: !0
  });
  Object.defineProperty(cr, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $t.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(cr, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $t.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(cr, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wp.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(cr, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $t.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(cr, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $t.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(cr, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $t.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(cr, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $t.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(cr, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xa.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(cr, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xa.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(cr, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xa.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  cr.TYPES = void 0;
  Object.defineProperty(cr, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $t.VISITOR_KEYS;
    }, "get")
  });
  var $s = ip();
  Pp();
  vx();
  Cx();
  Ix();
  wx();
  Bx();
  var $t = ms(), xa = Cp(), wp = Fx();
  Object.keys(wp.DEPRECATED_ALIASES).forEach((t) => {
    $t.FLIPPED_ALIAS_KEYS[t] = $t.FLIPPED_ALIAS_KEYS[wp.DEPRECATED_ALIASES[t]];
  });
  $s($t.VISITOR_KEYS);
  $s($t.ALIAS_KEYS);
  $s($t.FLIPPED_ALIAS_KEYS);
  $s($t.NODE_FIELDS);
  $s($t.BUILDER_KEYS);
  $s($t.DEPRECATED_KEYS);
  $s(xa.PLACEHOLDERS_ALIAS);
  $s(xa.PLACEHOLDERS_FLIPPED_ALIAS);
  var aMe = cr.TYPES = [].concat(Object.keys($t.VISITOR_KEYS), Object.keys($t.FLIPPED_ALIAS_KEYS), Object.keys($t.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var ml = w((Sa) => {
  "use strict";
  Object.defineProperty(Sa, "__esModule", {
    value: !0
  });
  Sa.default = WM;
  Sa.validateChild = Ux;
  Sa.validateField = Rx;
  var jx = Br();
  function WM(t, e, r) {
    if (!t) return;
    let s = jx.NODE_FIELDS[t.type];
    if (!s) return;
    let i = s[e];
    Rx(t, e, r, i), Ux(t, e, r);
  }
  n(WM, "validate");
  function Rx(t, e, r, s) {
    s != null && s.validate && (s.optional && r == null || s.validate(t, e, r));
  }
  n(Rx, "validateField");
  function Ux(t, e, r) {
    if (r == null) return;
    let s = jx.NODE_PARENT_VALIDATIONS[r.type];
    s && s(t, e, r);
  }
  n(Ux, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/validateNode.js
var qx = w((Np) => {
  "use strict";
  Object.defineProperty(Np, "__esModule", {
    value: !0
  });
  Np.default = XM;
  var YM = ml(), JM = Ce();
  function XM(t) {
    let e = JM.BUILDER_KEYS[t.type];
    for (let r of e)
      (0, YM.default)(t, r, t[r]);
    return t;
  }
  n(XM, "validateNode");
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var pr = w((b) => {
  "use strict";
  Object.defineProperty(b, "__esModule", {
    value: !0
  });
  b.anyTypeAnnotation = AB;
  b.argumentPlaceholder = ZF;
  b.arrayExpression = $M;
  b.arrayPattern = K3;
  b.arrayTypeAnnotation = vB;
  b.arrowFunctionExpression = W3;
  b.assignmentExpression = HM;
  b.assignmentPattern = V3;
  b.awaitExpression = fB;
  b.bigIntLiteral = dB;
  b.binaryExpression = zM;
  b.bindExpression = e4;
  b.blockStatement = e3;
  b.booleanLiteral = S3;
  b.booleanLiteralTypeAnnotation = IB;
  b.booleanTypeAnnotation = CB;
  b.breakStatement = t3;
  b.callExpression = r3;
  b.catchClause = s3;
  b.classAccessorProperty = xB;
  b.classBody = Y3;
  b.classDeclaration = X3;
  b.classExpression = J3;
  b.classImplements = NB;
  b.classMethod = nB;
  b.classPrivateMethod = gB;
  b.classPrivateProperty = SB;
  b.classProperty = bB;
  b.conditionalExpression = i3;
  b.continueStatement = n3;
  b.debuggerStatement = a3;
  b.decimalLiteral = o4;
  b.declareClass = OB;
  b.declareExportAllDeclaration = RB;
  b.declareExportDeclaration = jB;
  b.declareFunction = kB;
  b.declareInterface = DB;
  b.declareModule = _B;
  b.declareModuleExports = LB;
  b.declareOpaqueType = BB;
  b.declareTypeAlias = MB;
  b.declareVariable = FB;
  b.declaredPredicate = UB;
  b.decorator = r4;
  b.directive = QM;
  b.directiveLiteral = ZM;
  b.doExpression = s4;
  b.doWhileStatement = o3;
  b.emptyStatement = l3;
  b.emptyTypeAnnotation = GB;
  b.enumBooleanBody = vF;
  b.enumBooleanMember = NF;
  b.enumDeclaration = AF;
  b.enumDefaultedMember = DF;
  b.enumNumberBody = CF;
  b.enumNumberMember = OF;
  b.enumStringBody = IF;
  b.enumStringMember = kF;
  b.enumSymbolBody = wF;
  b.existsTypeAnnotation = qB;
  b.exportAllDeclaration = $3;
  b.exportDefaultDeclaration = H3;
  b.exportDefaultSpecifier = i4;
  b.exportNamedDeclaration = z3;
  b.exportNamespaceSpecifier = mB;
  b.exportSpecifier = G3;
  b.expressionStatement = u3;
  b.file = c3;
  b.forInStatement = p3;
  b.forOfStatement = Q3;
  b.forStatement = f3;
  b.functionDeclaration = h3;
  b.functionExpression = d3;
  b.functionTypeAnnotation = VB;
  b.functionTypeParam = KB;
  b.genericTypeAnnotation = WB;
  b.identifier = m3;
  b.ifStatement = y3;
  b.import = hB;
  b.importAttribute = t4;
  b.importDeclaration = Z3;
  b.importDefaultSpecifier = eB;
  b.importExpression = sB;
  b.importNamespaceSpecifier = tB;
  b.importSpecifier = rB;
  b.indexedAccessType = _F;
  b.inferredPredicate = YB;
  b.interfaceDeclaration = XB;
  b.interfaceExtends = JB;
  b.interfaceTypeAnnotation = $B;
  b.interpreterDirective = GM;
  b.intersectionTypeAnnotation = HB;
  b.jSXAttribute = b.jsxAttribute = MF;
  b.jSXClosingElement = b.jsxClosingElement = BF;
  b.jSXClosingFragment = b.jsxClosingFragment = HF;
  b.jSXElement = b.jsxElement = FF;
  b.jSXEmptyExpression = b.jsxEmptyExpression = jF;
  b.jSXExpressionContainer = b.jsxExpressionContainer = RF;
  b.jSXFragment = b.jsxFragment = XF;
  b.jSXIdentifier = b.jsxIdentifier = qF;
  b.jSXMemberExpression = b.jsxMemberExpression = VF;
  b.jSXNamespacedName = b.jsxNamespacedName = KF;
  b.jSXOpeningElement = b.jsxOpeningElement = WF;
  b.jSXOpeningFragment = b.jsxOpeningFragment = $F;
  b.jSXSpreadAttribute = b.jsxSpreadAttribute = YF;
  b.jSXSpreadChild = b.jsxSpreadChild = UF;
  b.jSXText = b.jsxText = JF;
  b.labeledStatement = T3;
  b.logicalExpression = g3;
  b.memberExpression = P3;
  b.metaProperty = iB;
  b.mixedTypeAnnotation = zB;
  b.moduleExpression = l4;
  b.newExpression = E3;
  b.noop = zF;
  b.nullLiteral = x3;
  b.nullLiteralTypeAnnotation = wB;
  b.nullableTypeAnnotation = QB;
  b.numberLiteral = A5;
  b.numberLiteralTypeAnnotation = ZB;
  b.numberTypeAnnotation = eF;
  b.numericLiteral = Vx;
  b.objectExpression = v3;
  b.objectMethod = C3;
  b.objectPattern = aB;
  b.objectProperty = I3;
  b.objectTypeAnnotation = tF;
  b.objectTypeCallProperty = sF;
  b.objectTypeIndexer = iF;
  b.objectTypeInternalSlot = rF;
  b.objectTypeProperty = nF;
  b.objectTypeSpreadProperty = aF;
  b.opaqueType = oF;
  b.optionalCallExpression = TB;
  b.optionalIndexedAccessType = LF;
  b.optionalMemberExpression = yB;
  b.parenthesizedExpression = O3;
  b.pipelineBareFunction = p4;
  b.pipelinePrimaryTopicReference = f4;
  b.pipelineTopicExpression = c4;
  b.placeholder = GF;
  b.privateName = PB;
  b.program = A3;
  b.qualifiedTypeIdentifier = lF;
  b.recordExpression = n4;
  b.regExpLiteral = Kx;
  b.regexLiteral = v5;
  b.restElement = Wx;
  b.restProperty = C5;
  b.returnStatement = w3;
  b.sequenceExpression = N3;
  b.spreadElement = Yx;
  b.spreadProperty = I5;
  b.staticBlock = EB;
  b.stringLiteral = b3;
  b.stringLiteralTypeAnnotation = uF;
  b.stringTypeAnnotation = cF;
  b.super = oB;
  b.switchCase = k3;
  b.switchStatement = D3;
  b.symbolTypeAnnotation = pF;
  b.taggedTemplateExpression = lB;
  b.templateElement = uB;
  b.templateLiteral = cB;
  b.thisExpression = _3;
  b.thisTypeAnnotation = fF;
  b.throwStatement = L3;
  b.topicReference = u4;
  b.tryStatement = M3;
  b.tSAnyKeyword = b.tsAnyKeyword = P4;
  b.tSArrayType = b.tsArrayType = V4;
  b.tSAsExpression = b.tsAsExpression = o5;
  b.tSBigIntKeyword = b.tsBigIntKeyword = A4;
  b.tSBooleanKeyword = b.tsBooleanKeyword = E4;
  b.tSCallSignatureDeclaration = b.tsCallSignatureDeclaration = T4;
  b.tSConditionalType = b.tsConditionalType = H4;
  b.tSConstructSignatureDeclaration = b.tsConstructSignatureDeclaration = b4;
  b.tSConstructorType = b.tsConstructorType = F4;
  b.tSDeclareFunction = b.tsDeclareFunction = d4;
  b.tSDeclareMethod = b.tsDeclareMethod = m4;
  b.tSEnumDeclaration = b.tsEnumDeclaration = c5;
  b.tSEnumMember = b.tsEnumMember = p5;
  b.tSExportAssignment = b.tsExportAssignment = b5;
  b.tSExpressionWithTypeArguments = b.tsExpressionWithTypeArguments = r5;
  b.tSExternalModuleReference = b.tsExternalModuleReference = y5;
  b.tSFunctionType = b.tsFunctionType = B4;
  b.tSImportEqualsDeclaration = b.tsImportEqualsDeclaration = m5;
  b.tSImportType = b.tsImportType = d5;
  b.tSIndexSignature = b.tsIndexSignature = g4;
  b.tSIndexedAccessType = b.tsIndexedAccessType = Z4;
  b.tSInferType = b.tsInferType = z4;
  b.tSInstantiationExpression = b.tsInstantiationExpression = a5;
  b.tSInterfaceBody = b.tsInterfaceBody = i5;
  b.tSInterfaceDeclaration = b.tsInterfaceDeclaration = s5;
  b.tSIntersectionType = b.tsIntersectionType = $4;
  b.tSIntrinsicKeyword = b.tsIntrinsicKeyword = v4;
  b.tSLiteralType = b.tsLiteralType = t5;
  b.tSMappedType = b.tsMappedType = e5;
  b.tSMethodSignature = b.tsMethodSignature = S4;
  b.tSModuleBlock = b.tsModuleBlock = h5;
  b.tSModuleDeclaration = b.tsModuleDeclaration = f5;
  b.tSNamedTupleMember = b.tsNamedTupleMember = J4;
  b.tSNamespaceExportDeclaration = b.tsNamespaceExportDeclaration = x5;
  b.tSNeverKeyword = b.tsNeverKeyword = C4;
  b.tSNonNullExpression = b.tsNonNullExpression = T5;
  b.tSNullKeyword = b.tsNullKeyword = I4;
  b.tSNumberKeyword = b.tsNumberKeyword = w4;
  b.tSObjectKeyword = b.tsObjectKeyword = N4;
  b.tSOptionalType = b.tsOptionalType = W4;
  b.tSParameterProperty = b.tsParameterProperty = h4;
  b.tSParenthesizedType = b.tsParenthesizedType = G4;
  b.tSPropertySignature = b.tsPropertySignature = x4;
  b.tSQualifiedName = b.tsQualifiedName = y4;
  b.tSRestType = b.tsRestType = Y4;
  b.tSSatisfiesExpression = b.tsSatisfiesExpression = l5;
  b.tSStringKeyword = b.tsStringKeyword = O4;
  b.tSSymbolKeyword = b.tsSymbolKeyword = k4;
  b.tSThisType = b.tsThisType = M4;
  b.tSTupleType = b.tsTupleType = K4;
  b.tSTypeAliasDeclaration = b.tsTypeAliasDeclaration = n5;
  b.tSTypeAnnotation = b.tsTypeAnnotation = S5;
  b.tSTypeAssertion = b.tsTypeAssertion = u5;
  b.tSTypeLiteral = b.tsTypeLiteral = q4;
  b.tSTypeOperator = b.tsTypeOperator = Q4;
  b.tSTypeParameter = b.tsTypeParameter = E5;
  b.tSTypeParameterDeclaration = b.tsTypeParameterDeclaration = P5;
  b.tSTypeParameterInstantiation = b.tsTypeParameterInstantiation = g5;
  b.tSTypePredicate = b.tsTypePredicate = R4;
  b.tSTypeQuery = b.tsTypeQuery = U4;
  b.tSTypeReference = b.tsTypeReference = j4;
  b.tSUndefinedKeyword = b.tsUndefinedKeyword = D4;
  b.tSUnionType = b.tsUnionType = X4;
  b.tSUnknownKeyword = b.tsUnknownKeyword = _4;
  b.tSVoidKeyword = b.tsVoidKeyword = L4;
  b.tupleExpression = a4;
  b.tupleTypeAnnotation = hF;
  b.typeAlias = mF;
  b.typeAnnotation = yF;
  b.typeCastExpression = TF;
  b.typeParameter = bF;
  b.typeParameterDeclaration = xF;
  b.typeParameterInstantiation = SF;
  b.typeofTypeAnnotation = dF;
  b.unaryExpression = B3;
  b.unionTypeAnnotation = gF;
  b.updateExpression = F3;
  b.v8IntrinsicIdentifier = QF;
  b.variableDeclaration = j3;
  b.variableDeclarator = R3;
  b.variance = PF;
  b.voidTypeAnnotation = EF;
  b.whileStatement = U3;
  b.withStatement = q3;
  b.yieldExpression = pB;
  var j = qx(), Sl = ua();
  function $M(t = []) {
    return (0, j.default)({
      type: "ArrayExpression",
      elements: t
    });
  }
  n($M, "arrayExpression");
  function HM(t, e, r) {
    return (0, j.default)({
      type: "AssignmentExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(HM, "assignmentExpression");
  function zM(t, e, r) {
    return (0, j.default)({
      type: "BinaryExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(zM, "binaryExpression");
  function GM(t) {
    return (0, j.default)({
      type: "InterpreterDirective",
      value: t
    });
  }
  n(GM, "interpreterDirective");
  function QM(t) {
    return (0, j.default)({
      type: "Directive",
      value: t
    });
  }
  n(QM, "directive");
  function ZM(t) {
    return (0, j.default)({
      type: "DirectiveLiteral",
      value: t
    });
  }
  n(ZM, "directiveLiteral");
  function e3(t, e = []) {
    return (0, j.default)({
      type: "BlockStatement",
      body: t,
      directives: e
    });
  }
  n(e3, "blockStatement");
  function t3(t = null) {
    return (0, j.default)({
      type: "BreakStatement",
      label: t
    });
  }
  n(t3, "breakStatement");
  function r3(t, e) {
    return (0, j.default)({
      type: "CallExpression",
      callee: t,
      arguments: e
    });
  }
  n(r3, "callExpression");
  function s3(t = null, e) {
    return (0, j.default)({
      type: "CatchClause",
      param: t,
      body: e
    });
  }
  n(s3, "catchClause");
  function i3(t, e, r) {
    return (0, j.default)({
      type: "ConditionalExpression",
      test: t,
      consequent: e,
      alternate: r
    });
  }
  n(i3, "conditionalExpression");
  function n3(t = null) {
    return (0, j.default)({
      type: "ContinueStatement",
      label: t
    });
  }
  n(n3, "continueStatement");
  function a3() {
    return {
      type: "DebuggerStatement"
    };
  }
  n(a3, "debuggerStatement");
  function o3(t, e) {
    return (0, j.default)({
      type: "DoWhileStatement",
      test: t,
      body: e
    });
  }
  n(o3, "doWhileStatement");
  function l3() {
    return {
      type: "EmptyStatement"
    };
  }
  n(l3, "emptyStatement");
  function u3(t) {
    return (0, j.default)({
      type: "ExpressionStatement",
      expression: t
    });
  }
  n(u3, "expressionStatement");
  function c3(t, e = null, r = null) {
    return (0, j.default)({
      type: "File",
      program: t,
      comments: e,
      tokens: r
    });
  }
  n(c3, "file");
  function p3(t, e, r) {
    return (0, j.default)({
      type: "ForInStatement",
      left: t,
      right: e,
      body: r
    });
  }
  n(p3, "forInStatement");
  function f3(t = null, e = null, r = null, s) {
    return (0, j.default)({
      type: "ForStatement",
      init: t,
      test: e,
      update: r,
      body: s
    });
  }
  n(f3, "forStatement");
  function h3(t = null, e, r, s = !1, i = !1) {
    return (0, j.default)({
      type: "FunctionDeclaration",
      id: t,
      params: e,
      body: r,
      generator: s,
      async: i
    });
  }
  n(h3, "functionDeclaration");
  function d3(t = null, e, r, s = !1, i = !1) {
    return (0, j.default)({
      type: "FunctionExpression",
      id: t,
      params: e,
      body: r,
      generator: s,
      async: i
    });
  }
  n(d3, "functionExpression");
  function m3(t) {
    return (0, j.default)({
      type: "Identifier",
      name: t
    });
  }
  n(m3, "identifier");
  function y3(t, e, r = null) {
    return (0, j.default)({
      type: "IfStatement",
      test: t,
      consequent: e,
      alternate: r
    });
  }
  n(y3, "ifStatement");
  function T3(t, e) {
    return (0, j.default)({
      type: "LabeledStatement",
      label: t,
      body: e
    });
  }
  n(T3, "labeledStatement");
  function b3(t) {
    return (0, j.default)({
      type: "StringLiteral",
      value: t
    });
  }
  n(b3, "stringLiteral");
  function Vx(t) {
    return (0, j.default)({
      type: "NumericLiteral",
      value: t
    });
  }
  n(Vx, "numericLiteral");
  function x3() {
    return {
      type: "NullLiteral"
    };
  }
  n(x3, "nullLiteral");
  function S3(t) {
    return (0, j.default)({
      type: "BooleanLiteral",
      value: t
    });
  }
  n(S3, "booleanLiteral");
  function Kx(t, e = "") {
    return (0, j.default)({
      type: "RegExpLiteral",
      pattern: t,
      flags: e
    });
  }
  n(Kx, "regExpLiteral");
  function g3(t, e, r) {
    return (0, j.default)({
      type: "LogicalExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(g3, "logicalExpression");
  function P3(t, e, r = !1, s = null) {
    return (0, j.default)({
      type: "MemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: s
    });
  }
  n(P3, "memberExpression");
  function E3(t, e) {
    return (0, j.default)({
      type: "NewExpression",
      callee: t,
      arguments: e
    });
  }
  n(E3, "newExpression");
  function A3(t, e = [], r = "script", s = null) {
    return (0, j.default)({
      type: "Program",
      body: t,
      directives: e,
      sourceType: r,
      interpreter: s
    });
  }
  n(A3, "program");
  function v3(t) {
    return (0, j.default)({
      type: "ObjectExpression",
      properties: t
    });
  }
  n(v3, "objectExpression");
  function C3(t = "method", e, r, s, i = !1, a = !1, o = !1) {
    return (0, j.default)({
      type: "ObjectMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      computed: i,
      generator: a,
      async: o
    });
  }
  n(C3, "objectMethod");
  function I3(t, e, r = !1, s = !1, i = null) {
    return (0, j.default)({
      type: "ObjectProperty",
      key: t,
      value: e,
      computed: r,
      shorthand: s,
      decorators: i
    });
  }
  n(I3, "objectProperty");
  function Wx(t) {
    return (0, j.default)({
      type: "RestElement",
      argument: t
    });
  }
  n(Wx, "restElement");
  function w3(t = null) {
    return (0, j.default)({
      type: "ReturnStatement",
      argument: t
    });
  }
  n(w3, "returnStatement");
  function N3(t) {
    return (0, j.default)({
      type: "SequenceExpression",
      expressions: t
    });
  }
  n(N3, "sequenceExpression");
  function O3(t) {
    return (0, j.default)({
      type: "ParenthesizedExpression",
      expression: t
    });
  }
  n(O3, "parenthesizedExpression");
  function k3(t = null, e) {
    return (0, j.default)({
      type: "SwitchCase",
      test: t,
      consequent: e
    });
  }
  n(k3, "switchCase");
  function D3(t, e) {
    return (0, j.default)({
      type: "SwitchStatement",
      discriminant: t,
      cases: e
    });
  }
  n(D3, "switchStatement");
  function _3() {
    return {
      type: "ThisExpression"
    };
  }
  n(_3, "thisExpression");
  function L3(t) {
    return (0, j.default)({
      type: "ThrowStatement",
      argument: t
    });
  }
  n(L3, "throwStatement");
  function M3(t, e = null, r = null) {
    return (0, j.default)({
      type: "TryStatement",
      block: t,
      handler: e,
      finalizer: r
    });
  }
  n(M3, "tryStatement");
  function B3(t, e, r = !0) {
    return (0, j.default)({
      type: "UnaryExpression",
      operator: t,
      argument: e,
      prefix: r
    });
  }
  n(B3, "unaryExpression");
  function F3(t, e, r = !1) {
    return (0, j.default)({
      type: "UpdateExpression",
      operator: t,
      argument: e,
      prefix: r
    });
  }
  n(F3, "updateExpression");
  function j3(t, e) {
    return (0, j.default)({
      type: "VariableDeclaration",
      kind: t,
      declarations: e
    });
  }
  n(j3, "variableDeclaration");
  function R3(t, e = null) {
    return (0, j.default)({
      type: "VariableDeclarator",
      id: t,
      init: e
    });
  }
  n(R3, "variableDeclarator");
  function U3(t, e) {
    return (0, j.default)({
      type: "WhileStatement",
      test: t,
      body: e
    });
  }
  n(U3, "whileStatement");
  function q3(t, e) {
    return (0, j.default)({
      type: "WithStatement",
      object: t,
      body: e
    });
  }
  n(q3, "withStatement");
  function V3(t, e) {
    return (0, j.default)({
      type: "AssignmentPattern",
      left: t,
      right: e
    });
  }
  n(V3, "assignmentPattern");
  function K3(t) {
    return (0, j.default)({
      type: "ArrayPattern",
      elements: t
    });
  }
  n(K3, "arrayPattern");
  function W3(t, e, r = !1) {
    return (0, j.default)({
      type: "ArrowFunctionExpression",
      params: t,
      body: e,
      async: r,
      expression: null
    });
  }
  n(W3, "arrowFunctionExpression");
  function Y3(t) {
    return (0, j.default)({
      type: "ClassBody",
      body: t
    });
  }
  n(Y3, "classBody");
  function J3(t = null, e = null, r, s = null) {
    return (0, j.default)({
      type: "ClassExpression",
      id: t,
      superClass: e,
      body: r,
      decorators: s
    });
  }
  n(J3, "classExpression");
  function X3(t = null, e = null, r, s = null) {
    return (0, j.default)({
      type: "ClassDeclaration",
      id: t,
      superClass: e,
      body: r,
      decorators: s
    });
  }
  n(X3, "classDeclaration");
  function $3(t) {
    return (0, j.default)({
      type: "ExportAllDeclaration",
      source: t
    });
  }
  n($3, "exportAllDeclaration");
  function H3(t) {
    return (0, j.default)({
      type: "ExportDefaultDeclaration",
      declaration: t
    });
  }
  n(H3, "exportDefaultDeclaration");
  function z3(t = null, e = [], r = null) {
    return (0, j.default)({
      type: "ExportNamedDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    });
  }
  n(z3, "exportNamedDeclaration");
  function G3(t, e) {
    return (0, j.default)({
      type: "ExportSpecifier",
      local: t,
      exported: e
    });
  }
  n(G3, "exportSpecifier");
  function Q3(t, e, r, s = !1) {
    return (0, j.default)({
      type: "ForOfStatement",
      left: t,
      right: e,
      body: r,
      await: s
    });
  }
  n(Q3, "forOfStatement");
  function Z3(t, e) {
    return (0, j.default)({
      type: "ImportDeclaration",
      specifiers: t,
      source: e
    });
  }
  n(Z3, "importDeclaration");
  function eB(t) {
    return (0, j.default)({
      type: "ImportDefaultSpecifier",
      local: t
    });
  }
  n(eB, "importDefaultSpecifier");
  function tB(t) {
    return (0, j.default)({
      type: "ImportNamespaceSpecifier",
      local: t
    });
  }
  n(tB, "importNamespaceSpecifier");
  function rB(t, e) {
    return (0, j.default)({
      type: "ImportSpecifier",
      local: t,
      imported: e
    });
  }
  n(rB, "importSpecifier");
  function sB(t, e = null) {
    return (0, j.default)({
      type: "ImportExpression",
      source: t,
      options: e
    });
  }
  n(sB, "importExpression");
  function iB(t, e) {
    return (0, j.default)({
      type: "MetaProperty",
      meta: t,
      property: e
    });
  }
  n(iB, "metaProperty");
  function nB(t = "method", e, r, s, i = !1, a = !1, o = !1, l = !1) {
    return (0, j.default)({
      type: "ClassMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      computed: i,
      static: a,
      generator: o,
      async: l
    });
  }
  n(nB, "classMethod");
  function aB(t) {
    return (0, j.default)({
      type: "ObjectPattern",
      properties: t
    });
  }
  n(aB, "objectPattern");
  function Yx(t) {
    return (0, j.default)({
      type: "SpreadElement",
      argument: t
    });
  }
  n(Yx, "spreadElement");
  function oB() {
    return {
      type: "Super"
    };
  }
  n(oB, "_super");
  function lB(t, e) {
    return (0, j.default)({
      type: "TaggedTemplateExpression",
      tag: t,
      quasi: e
    });
  }
  n(lB, "taggedTemplateExpression");
  function uB(t, e = !1) {
    return (0, j.default)({
      type: "TemplateElement",
      value: t,
      tail: e
    });
  }
  n(uB, "templateElement");
  function cB(t, e) {
    return (0, j.default)({
      type: "TemplateLiteral",
      quasis: t,
      expressions: e
    });
  }
  n(cB, "templateLiteral");
  function pB(t = null, e = !1) {
    return (0, j.default)({
      type: "YieldExpression",
      argument: t,
      delegate: e
    });
  }
  n(pB, "yieldExpression");
  function fB(t) {
    return (0, j.default)({
      type: "AwaitExpression",
      argument: t
    });
  }
  n(fB, "awaitExpression");
  function hB() {
    return {
      type: "Import"
    };
  }
  n(hB, "_import");
  function dB(t) {
    return (0, j.default)({
      type: "BigIntLiteral",
      value: t
    });
  }
  n(dB, "bigIntLiteral");
  function mB(t) {
    return (0, j.default)({
      type: "ExportNamespaceSpecifier",
      exported: t
    });
  }
  n(mB, "exportNamespaceSpecifier");
  function yB(t, e, r = !1, s) {
    return (0, j.default)({
      type: "OptionalMemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: s
    });
  }
  n(yB, "optionalMemberExpression");
  function TB(t, e, r) {
    return (0, j.default)({
      type: "OptionalCallExpression",
      callee: t,
      arguments: e,
      optional: r
    });
  }
  n(TB, "optionalCallExpression");
  function bB(t, e = null, r = null, s = null, i = !1, a = !1) {
    return (0, j.default)({
      type: "ClassProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: s,
      computed: i,
      static: a
    });
  }
  n(bB, "classProperty");
  function xB(t, e = null, r = null, s = null, i = !1, a = !1) {
    return (0, j.default)({
      type: "ClassAccessorProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: s,
      computed: i,
      static: a
    });
  }
  n(xB, "classAccessorProperty");
  function SB(t, e = null, r = null, s = !1) {
    return (0, j.default)({
      type: "ClassPrivateProperty",
      key: t,
      value: e,
      decorators: r,
      static: s
    });
  }
  n(SB, "classPrivateProperty");
  function gB(t = "method", e, r, s, i = !1) {
    return (0, j.default)({
      type: "ClassPrivateMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      static: i
    });
  }
  n(gB, "classPrivateMethod");
  function PB(t) {
    return (0, j.default)({
      type: "PrivateName",
      id: t
    });
  }
  n(PB, "privateName");
  function EB(t) {
    return (0, j.default)({
      type: "StaticBlock",
      body: t
    });
  }
  n(EB, "staticBlock");
  function AB() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  n(AB, "anyTypeAnnotation");
  function vB(t) {
    return (0, j.default)({
      type: "ArrayTypeAnnotation",
      elementType: t
    });
  }
  n(vB, "arrayTypeAnnotation");
  function CB() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  n(CB, "booleanTypeAnnotation");
  function IB(t) {
    return (0, j.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: t
    });
  }
  n(IB, "booleanLiteralTypeAnnotation");
  function wB() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  n(wB, "nullLiteralTypeAnnotation");
  function NB(t, e = null) {
    return (0, j.default)({
      type: "ClassImplements",
      id: t,
      typeParameters: e
    });
  }
  n(NB, "classImplements");
  function OB(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "DeclareClass",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(OB, "declareClass");
  function kB(t) {
    return (0, j.default)({
      type: "DeclareFunction",
      id: t
    });
  }
  n(kB, "declareFunction");
  function DB(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "DeclareInterface",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(DB, "declareInterface");
  function _B(t, e, r = null) {
    return (0, j.default)({
      type: "DeclareModule",
      id: t,
      body: e,
      kind: r
    });
  }
  n(_B, "declareModule");
  function LB(t) {
    return (0, j.default)({
      type: "DeclareModuleExports",
      typeAnnotation: t
    });
  }
  n(LB, "declareModuleExports");
  function MB(t, e = null, r) {
    return (0, j.default)({
      type: "DeclareTypeAlias",
      id: t,
      typeParameters: e,
      right: r
    });
  }
  n(MB, "declareTypeAlias");
  function BB(t, e = null, r = null) {
    return (0, j.default)({
      type: "DeclareOpaqueType",
      id: t,
      typeParameters: e,
      supertype: r
    });
  }
  n(BB, "declareOpaqueType");
  function FB(t) {
    return (0, j.default)({
      type: "DeclareVariable",
      id: t
    });
  }
  n(FB, "declareVariable");
  function jB(t = null, e = null, r = null) {
    return (0, j.default)({
      type: "DeclareExportDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    });
  }
  n(jB, "declareExportDeclaration");
  function RB(t) {
    return (0, j.default)({
      type: "DeclareExportAllDeclaration",
      source: t
    });
  }
  n(RB, "declareExportAllDeclaration");
  function UB(t) {
    return (0, j.default)({
      type: "DeclaredPredicate",
      value: t
    });
  }
  n(UB, "declaredPredicate");
  function qB() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  n(qB, "existsTypeAnnotation");
  function VB(t = null, e, r = null, s) {
    return (0, j.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: t,
      params: e,
      rest: r,
      returnType: s
    });
  }
  n(VB, "functionTypeAnnotation");
  function KB(t = null, e) {
    return (0, j.default)({
      type: "FunctionTypeParam",
      name: t,
      typeAnnotation: e
    });
  }
  n(KB, "functionTypeParam");
  function WB(t, e = null) {
    return (0, j.default)({
      type: "GenericTypeAnnotation",
      id: t,
      typeParameters: e
    });
  }
  n(WB, "genericTypeAnnotation");
  function YB() {
    return {
      type: "InferredPredicate"
    };
  }
  n(YB, "inferredPredicate");
  function JB(t, e = null) {
    return (0, j.default)({
      type: "InterfaceExtends",
      id: t,
      typeParameters: e
    });
  }
  n(JB, "interfaceExtends");
  function XB(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "InterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(XB, "interfaceDeclaration");
  function $B(t = null, e) {
    return (0, j.default)({
      type: "InterfaceTypeAnnotation",
      extends: t,
      body: e
    });
  }
  n($B, "interfaceTypeAnnotation");
  function HB(t) {
    return (0, j.default)({
      type: "IntersectionTypeAnnotation",
      types: t
    });
  }
  n(HB, "intersectionTypeAnnotation");
  function zB() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  n(zB, "mixedTypeAnnotation");
  function GB() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  n(GB, "emptyTypeAnnotation");
  function QB(t) {
    return (0, j.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: t
    });
  }
  n(QB, "nullableTypeAnnotation");
  function ZB(t) {
    return (0, j.default)({
      type: "NumberLiteralTypeAnnotation",
      value: t
    });
  }
  n(ZB, "numberLiteralTypeAnnotation");
  function eF() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  n(eF, "numberTypeAnnotation");
  function tF(t, e = [], r = [], s = [], i = !1) {
    return (0, j.default)({
      type: "ObjectTypeAnnotation",
      properties: t,
      indexers: e,
      callProperties: r,
      internalSlots: s,
      exact: i
    });
  }
  n(tF, "objectTypeAnnotation");
  function rF(t, e, r, s, i) {
    return (0, j.default)({
      type: "ObjectTypeInternalSlot",
      id: t,
      value: e,
      optional: r,
      static: s,
      method: i
    });
  }
  n(rF, "objectTypeInternalSlot");
  function sF(t) {
    return (0, j.default)({
      type: "ObjectTypeCallProperty",
      value: t,
      static: null
    });
  }
  n(sF, "objectTypeCallProperty");
  function iF(t = null, e, r, s = null) {
    return (0, j.default)({
      type: "ObjectTypeIndexer",
      id: t,
      key: e,
      value: r,
      variance: s,
      static: null
    });
  }
  n(iF, "objectTypeIndexer");
  function nF(t, e, r = null) {
    return (0, j.default)({
      type: "ObjectTypeProperty",
      key: t,
      value: e,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  n(nF, "objectTypeProperty");
  function aF(t) {
    return (0, j.default)({
      type: "ObjectTypeSpreadProperty",
      argument: t
    });
  }
  n(aF, "objectTypeSpreadProperty");
  function oF(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "OpaqueType",
      id: t,
      typeParameters: e,
      supertype: r,
      impltype: s
    });
  }
  n(oF, "opaqueType");
  function lF(t, e) {
    return (0, j.default)({
      type: "QualifiedTypeIdentifier",
      id: t,
      qualification: e
    });
  }
  n(lF, "qualifiedTypeIdentifier");
  function uF(t) {
    return (0, j.default)({
      type: "StringLiteralTypeAnnotation",
      value: t
    });
  }
  n(uF, "stringLiteralTypeAnnotation");
  function cF() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  n(cF, "stringTypeAnnotation");
  function pF() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  n(pF, "symbolTypeAnnotation");
  function fF() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  n(fF, "thisTypeAnnotation");
  function hF(t) {
    return (0, j.default)({
      type: "TupleTypeAnnotation",
      types: t
    });
  }
  n(hF, "tupleTypeAnnotation");
  function dF(t) {
    return (0, j.default)({
      type: "TypeofTypeAnnotation",
      argument: t
    });
  }
  n(dF, "typeofTypeAnnotation");
  function mF(t, e = null, r) {
    return (0, j.default)({
      type: "TypeAlias",
      id: t,
      typeParameters: e,
      right: r
    });
  }
  n(mF, "typeAlias");
  function yF(t) {
    return (0, j.default)({
      type: "TypeAnnotation",
      typeAnnotation: t
    });
  }
  n(yF, "typeAnnotation");
  function TF(t, e) {
    return (0, j.default)({
      type: "TypeCastExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(TF, "typeCastExpression");
  function bF(t = null, e = null, r = null) {
    return (0, j.default)({
      type: "TypeParameter",
      bound: t,
      default: e,
      variance: r,
      name: null
    });
  }
  n(bF, "typeParameter");
  function xF(t) {
    return (0, j.default)({
      type: "TypeParameterDeclaration",
      params: t
    });
  }
  n(xF, "typeParameterDeclaration");
  function SF(t) {
    return (0, j.default)({
      type: "TypeParameterInstantiation",
      params: t
    });
  }
  n(SF, "typeParameterInstantiation");
  function gF(t) {
    return (0, j.default)({
      type: "UnionTypeAnnotation",
      types: t
    });
  }
  n(gF, "unionTypeAnnotation");
  function PF(t) {
    return (0, j.default)({
      type: "Variance",
      kind: t
    });
  }
  n(PF, "variance");
  function EF() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  n(EF, "voidTypeAnnotation");
  function AF(t, e) {
    return (0, j.default)({
      type: "EnumDeclaration",
      id: t,
      body: e
    });
  }
  n(AF, "enumDeclaration");
  function vF(t) {
    return (0, j.default)({
      type: "EnumBooleanBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(vF, "enumBooleanBody");
  function CF(t) {
    return (0, j.default)({
      type: "EnumNumberBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(CF, "enumNumberBody");
  function IF(t) {
    return (0, j.default)({
      type: "EnumStringBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(IF, "enumStringBody");
  function wF(t) {
    return (0, j.default)({
      type: "EnumSymbolBody",
      members: t,
      hasUnknownMembers: null
    });
  }
  n(wF, "enumSymbolBody");
  function NF(t) {
    return (0, j.default)({
      type: "EnumBooleanMember",
      id: t,
      init: null
    });
  }
  n(NF, "enumBooleanMember");
  function OF(t, e) {
    return (0, j.default)({
      type: "EnumNumberMember",
      id: t,
      init: e
    });
  }
  n(OF, "enumNumberMember");
  function kF(t, e) {
    return (0, j.default)({
      type: "EnumStringMember",
      id: t,
      init: e
    });
  }
  n(kF, "enumStringMember");
  function DF(t) {
    return (0, j.default)({
      type: "EnumDefaultedMember",
      id: t
    });
  }
  n(DF, "enumDefaultedMember");
  function _F(t, e) {
    return (0, j.default)({
      type: "IndexedAccessType",
      objectType: t,
      indexType: e
    });
  }
  n(_F, "indexedAccessType");
  function LF(t, e) {
    return (0, j.default)({
      type: "OptionalIndexedAccessType",
      objectType: t,
      indexType: e,
      optional: null
    });
  }
  n(LF, "optionalIndexedAccessType");
  function MF(t, e = null) {
    return (0, j.default)({
      type: "JSXAttribute",
      name: t,
      value: e
    });
  }
  n(MF, "jsxAttribute");
  function BF(t) {
    return (0, j.default)({
      type: "JSXClosingElement",
      name: t
    });
  }
  n(BF, "jsxClosingElement");
  function FF(t, e = null, r, s = null) {
    return (0, j.default)({
      type: "JSXElement",
      openingElement: t,
      closingElement: e,
      children: r,
      selfClosing: s
    });
  }
  n(FF, "jsxElement");
  function jF() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  n(jF, "jsxEmptyExpression");
  function RF(t) {
    return (0, j.default)({
      type: "JSXExpressionContainer",
      expression: t
    });
  }
  n(RF, "jsxExpressionContainer");
  function UF(t) {
    return (0, j.default)({
      type: "JSXSpreadChild",
      expression: t
    });
  }
  n(UF, "jsxSpreadChild");
  function qF(t) {
    return (0, j.default)({
      type: "JSXIdentifier",
      name: t
    });
  }
  n(qF, "jsxIdentifier");
  function VF(t, e) {
    return (0, j.default)({
      type: "JSXMemberExpression",
      object: t,
      property: e
    });
  }
  n(VF, "jsxMemberExpression");
  function KF(t, e) {
    return (0, j.default)({
      type: "JSXNamespacedName",
      namespace: t,
      name: e
    });
  }
  n(KF, "jsxNamespacedName");
  function WF(t, e, r = !1) {
    return (0, j.default)({
      type: "JSXOpeningElement",
      name: t,
      attributes: e,
      selfClosing: r
    });
  }
  n(WF, "jsxOpeningElement");
  function YF(t) {
    return (0, j.default)({
      type: "JSXSpreadAttribute",
      argument: t
    });
  }
  n(YF, "jsxSpreadAttribute");
  function JF(t) {
    return (0, j.default)({
      type: "JSXText",
      value: t
    });
  }
  n(JF, "jsxText");
  function XF(t, e, r) {
    return (0, j.default)({
      type: "JSXFragment",
      openingFragment: t,
      closingFragment: e,
      children: r
    });
  }
  n(XF, "jsxFragment");
  function $F() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  n($F, "jsxOpeningFragment");
  function HF() {
    return {
      type: "JSXClosingFragment"
    };
  }
  n(HF, "jsxClosingFragment");
  function zF() {
    return {
      type: "Noop"
    };
  }
  n(zF, "noop");
  function GF(t, e) {
    return (0, j.default)({
      type: "Placeholder",
      expectedNode: t,
      name: e
    });
  }
  n(GF, "placeholder");
  function QF(t) {
    return (0, j.default)({
      type: "V8IntrinsicIdentifier",
      name: t
    });
  }
  n(QF, "v8IntrinsicIdentifier");
  function ZF() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  n(ZF, "argumentPlaceholder");
  function e4(t, e) {
    return (0, j.default)({
      type: "BindExpression",
      object: t,
      callee: e
    });
  }
  n(e4, "bindExpression");
  function t4(t, e) {
    return (0, j.default)({
      type: "ImportAttribute",
      key: t,
      value: e
    });
  }
  n(t4, "importAttribute");
  function r4(t) {
    return (0, j.default)({
      type: "Decorator",
      expression: t
    });
  }
  n(r4, "decorator");
  function s4(t, e = !1) {
    return (0, j.default)({
      type: "DoExpression",
      body: t,
      async: e
    });
  }
  n(s4, "doExpression");
  function i4(t) {
    return (0, j.default)({
      type: "ExportDefaultSpecifier",
      exported: t
    });
  }
  n(i4, "exportDefaultSpecifier");
  function n4(t) {
    return (0, j.default)({
      type: "RecordExpression",
      properties: t
    });
  }
  n(n4, "recordExpression");
  function a4(t = []) {
    return (0, j.default)({
      type: "TupleExpression",
      elements: t
    });
  }
  n(a4, "tupleExpression");
  function o4(t) {
    return (0, j.default)({
      type: "DecimalLiteral",
      value: t
    });
  }
  n(o4, "decimalLiteral");
  function l4(t) {
    return (0, j.default)({
      type: "ModuleExpression",
      body: t
    });
  }
  n(l4, "moduleExpression");
  function u4() {
    return {
      type: "TopicReference"
    };
  }
  n(u4, "topicReference");
  function c4(t) {
    return (0, j.default)({
      type: "PipelineTopicExpression",
      expression: t
    });
  }
  n(c4, "pipelineTopicExpression");
  function p4(t) {
    return (0, j.default)({
      type: "PipelineBareFunction",
      callee: t
    });
  }
  n(p4, "pipelineBareFunction");
  function f4() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  n(f4, "pipelinePrimaryTopicReference");
  function h4(t) {
    return (0, j.default)({
      type: "TSParameterProperty",
      parameter: t
    });
  }
  n(h4, "tsParameterProperty");
  function d4(t = null, e = null, r, s = null) {
    return (0, j.default)({
      type: "TSDeclareFunction",
      id: t,
      typeParameters: e,
      params: r,
      returnType: s
    });
  }
  n(d4, "tsDeclareFunction");
  function m4(t = null, e, r = null, s, i = null) {
    return (0, j.default)({
      type: "TSDeclareMethod",
      decorators: t,
      key: e,
      typeParameters: r,
      params: s,
      returnType: i
    });
  }
  n(m4, "tsDeclareMethod");
  function y4(t, e) {
    return (0, j.default)({
      type: "TSQualifiedName",
      left: t,
      right: e
    });
  }
  n(y4, "tsQualifiedName");
  function T4(t = null, e, r = null) {
    return (0, j.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(T4, "tsCallSignatureDeclaration");
  function b4(t = null, e, r = null) {
    return (0, j.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(b4, "tsConstructSignatureDeclaration");
  function x4(t, e = null) {
    return (0, j.default)({
      type: "TSPropertySignature",
      key: t,
      typeAnnotation: e,
      kind: null
    });
  }
  n(x4, "tsPropertySignature");
  function S4(t, e = null, r, s = null) {
    return (0, j.default)({
      type: "TSMethodSignature",
      key: t,
      typeParameters: e,
      parameters: r,
      typeAnnotation: s,
      kind: null
    });
  }
  n(S4, "tsMethodSignature");
  function g4(t, e = null) {
    return (0, j.default)({
      type: "TSIndexSignature",
      parameters: t,
      typeAnnotation: e
    });
  }
  n(g4, "tsIndexSignature");
  function P4() {
    return {
      type: "TSAnyKeyword"
    };
  }
  n(P4, "tsAnyKeyword");
  function E4() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  n(E4, "tsBooleanKeyword");
  function A4() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  n(A4, "tsBigIntKeyword");
  function v4() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  n(v4, "tsIntrinsicKeyword");
  function C4() {
    return {
      type: "TSNeverKeyword"
    };
  }
  n(C4, "tsNeverKeyword");
  function I4() {
    return {
      type: "TSNullKeyword"
    };
  }
  n(I4, "tsNullKeyword");
  function w4() {
    return {
      type: "TSNumberKeyword"
    };
  }
  n(w4, "tsNumberKeyword");
  function N4() {
    return {
      type: "TSObjectKeyword"
    };
  }
  n(N4, "tsObjectKeyword");
  function O4() {
    return {
      type: "TSStringKeyword"
    };
  }
  n(O4, "tsStringKeyword");
  function k4() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  n(k4, "tsSymbolKeyword");
  function D4() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  n(D4, "tsUndefinedKeyword");
  function _4() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  n(_4, "tsUnknownKeyword");
  function L4() {
    return {
      type: "TSVoidKeyword"
    };
  }
  n(L4, "tsVoidKeyword");
  function M4() {
    return {
      type: "TSThisType"
    };
  }
  n(M4, "tsThisType");
  function B4(t = null, e, r = null) {
    return (0, j.default)({
      type: "TSFunctionType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(B4, "tsFunctionType");
  function F4(t = null, e, r = null) {
    return (0, j.default)({
      type: "TSConstructorType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(F4, "tsConstructorType");
  function j4(t, e = null) {
    return (0, j.default)({
      type: "TSTypeReference",
      typeName: t,
      typeParameters: e
    });
  }
  n(j4, "tsTypeReference");
  function R4(t, e = null, r = null) {
    return (0, j.default)({
      type: "TSTypePredicate",
      parameterName: t,
      typeAnnotation: e,
      asserts: r
    });
  }
  n(R4, "tsTypePredicate");
  function U4(t, e = null) {
    return (0, j.default)({
      type: "TSTypeQuery",
      exprName: t,
      typeParameters: e
    });
  }
  n(U4, "tsTypeQuery");
  function q4(t) {
    return (0, j.default)({
      type: "TSTypeLiteral",
      members: t
    });
  }
  n(q4, "tsTypeLiteral");
  function V4(t) {
    return (0, j.default)({
      type: "TSArrayType",
      elementType: t
    });
  }
  n(V4, "tsArrayType");
  function K4(t) {
    return (0, j.default)({
      type: "TSTupleType",
      elementTypes: t
    });
  }
  n(K4, "tsTupleType");
  function W4(t) {
    return (0, j.default)({
      type: "TSOptionalType",
      typeAnnotation: t
    });
  }
  n(W4, "tsOptionalType");
  function Y4(t) {
    return (0, j.default)({
      type: "TSRestType",
      typeAnnotation: t
    });
  }
  n(Y4, "tsRestType");
  function J4(t, e, r = !1) {
    return (0, j.default)({
      type: "TSNamedTupleMember",
      label: t,
      elementType: e,
      optional: r
    });
  }
  n(J4, "tsNamedTupleMember");
  function X4(t) {
    return (0, j.default)({
      type: "TSUnionType",
      types: t
    });
  }
  n(X4, "tsUnionType");
  function $4(t) {
    return (0, j.default)({
      type: "TSIntersectionType",
      types: t
    });
  }
  n($4, "tsIntersectionType");
  function H4(t, e, r, s) {
    return (0, j.default)({
      type: "TSConditionalType",
      checkType: t,
      extendsType: e,
      trueType: r,
      falseType: s
    });
  }
  n(H4, "tsConditionalType");
  function z4(t) {
    return (0, j.default)({
      type: "TSInferType",
      typeParameter: t
    });
  }
  n(z4, "tsInferType");
  function G4(t) {
    return (0, j.default)({
      type: "TSParenthesizedType",
      typeAnnotation: t
    });
  }
  n(G4, "tsParenthesizedType");
  function Q4(t) {
    return (0, j.default)({
      type: "TSTypeOperator",
      typeAnnotation: t,
      operator: null
    });
  }
  n(Q4, "tsTypeOperator");
  function Z4(t, e) {
    return (0, j.default)({
      type: "TSIndexedAccessType",
      objectType: t,
      indexType: e
    });
  }
  n(Z4, "tsIndexedAccessType");
  function e5(t, e = null, r = null) {
    return (0, j.default)({
      type: "TSMappedType",
      typeParameter: t,
      typeAnnotation: e,
      nameType: r
    });
  }
  n(e5, "tsMappedType");
  function t5(t) {
    return (0, j.default)({
      type: "TSLiteralType",
      literal: t
    });
  }
  n(t5, "tsLiteralType");
  function r5(t, e = null) {
    return (0, j.default)({
      type: "TSExpressionWithTypeArguments",
      expression: t,
      typeParameters: e
    });
  }
  n(r5, "tsExpressionWithTypeArguments");
  function s5(t, e = null, r = null, s) {
    return (0, j.default)({
      type: "TSInterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(s5, "tsInterfaceDeclaration");
  function i5(t) {
    return (0, j.default)({
      type: "TSInterfaceBody",
      body: t
    });
  }
  n(i5, "tsInterfaceBody");
  function n5(t, e = null, r) {
    return (0, j.default)({
      type: "TSTypeAliasDeclaration",
      id: t,
      typeParameters: e,
      typeAnnotation: r
    });
  }
  n(n5, "tsTypeAliasDeclaration");
  function a5(t, e = null) {
    return (0, j.default)({
      type: "TSInstantiationExpression",
      expression: t,
      typeParameters: e
    });
  }
  n(a5, "tsInstantiationExpression");
  function o5(t, e) {
    return (0, j.default)({
      type: "TSAsExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(o5, "tsAsExpression");
  function l5(t, e) {
    return (0, j.default)({
      type: "TSSatisfiesExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(l5, "tsSatisfiesExpression");
  function u5(t, e) {
    return (0, j.default)({
      type: "TSTypeAssertion",
      typeAnnotation: t,
      expression: e
    });
  }
  n(u5, "tsTypeAssertion");
  function c5(t, e) {
    return (0, j.default)({
      type: "TSEnumDeclaration",
      id: t,
      members: e
    });
  }
  n(c5, "tsEnumDeclaration");
  function p5(t, e = null) {
    return (0, j.default)({
      type: "TSEnumMember",
      id: t,
      initializer: e
    });
  }
  n(p5, "tsEnumMember");
  function f5(t, e) {
    return (0, j.default)({
      type: "TSModuleDeclaration",
      id: t,
      body: e
    });
  }
  n(f5, "tsModuleDeclaration");
  function h5(t) {
    return (0, j.default)({
      type: "TSModuleBlock",
      body: t
    });
  }
  n(h5, "tsModuleBlock");
  function d5(t, e = null, r = null) {
    return (0, j.default)({
      type: "TSImportType",
      argument: t,
      qualifier: e,
      typeParameters: r
    });
  }
  n(d5, "tsImportType");
  function m5(t, e) {
    return (0, j.default)({
      type: "TSImportEqualsDeclaration",
      id: t,
      moduleReference: e,
      isExport: null
    });
  }
  n(m5, "tsImportEqualsDeclaration");
  function y5(t) {
    return (0, j.default)({
      type: "TSExternalModuleReference",
      expression: t
    });
  }
  n(y5, "tsExternalModuleReference");
  function T5(t) {
    return (0, j.default)({
      type: "TSNonNullExpression",
      expression: t
    });
  }
  n(T5, "tsNonNullExpression");
  function b5(t) {
    return (0, j.default)({
      type: "TSExportAssignment",
      expression: t
    });
  }
  n(b5, "tsExportAssignment");
  function x5(t) {
    return (0, j.default)({
      type: "TSNamespaceExportDeclaration",
      id: t
    });
  }
  n(x5, "tsNamespaceExportDeclaration");
  function S5(t) {
    return (0, j.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: t
    });
  }
  n(S5, "tsTypeAnnotation");
  function g5(t) {
    return (0, j.default)({
      type: "TSTypeParameterInstantiation",
      params: t
    });
  }
  n(g5, "tsTypeParameterInstantiation");
  function P5(t) {
    return (0, j.default)({
      type: "TSTypeParameterDeclaration",
      params: t
    });
  }
  n(P5, "tsTypeParameterDeclaration");
  function E5(t = null, e = null, r) {
    return (0, j.default)({
      type: "TSTypeParameter",
      constraint: t,
      default: e,
      name: r
    });
  }
  n(E5, "tsTypeParameter");
  function A5(t) {
    return (0, Sl.default)("NumberLiteral", "NumericLiteral", "The node type "), Vx(t);
  }
  n(A5, "NumberLiteral");
  function v5(t, e = "") {
    return (0, Sl.default)("RegexLiteral", "RegExpLiteral", "The node type "), Kx(t, e);
  }
  n(v5, "RegexLiteral");
  function C5(t) {
    return (0, Sl.default)("RestProperty", "RestElement", "The node type "), Wx(t);
  }
  n(C5, "RestProperty");
  function I5(t) {
    return (0, Sl.default)("SpreadProperty", "SpreadElement", "The node type "), Yx(t);
  }
  n(I5, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var Jx = w((Op) => {
  "use strict";
  Object.defineProperty(Op, "__esModule", {
    value: !0
  });
  Op.default = O5;
  var w5 = pr(), N5 = Ce();
  function O5(t, e) {
    let r = t.value.split(/\r\n|\n|\r/), s = 0;
    for (let a = 0; a < r.length; a++)
      r[a].match(/[^ \t]/) && (s = a);
    let i = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === s, p = o.replace(/\t/g, " ");
      l || (p = p.replace(/^[ ]+/, "")), u || (p = p.replace(/[ ]+$/, "")), p && (c || (p += " "), i += p);
    }
    i && e.push((0, N5.inherits)((0, w5.stringLiteral)(i), t));
  }
  n(O5, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var Xx = w((Dp) => {
  "use strict";
  Object.defineProperty(Dp, "__esModule", {
    value: !0
  });
  Dp.default = D5;
  var kp = jt(), k5 = Jx();
  function D5(t) {
    let e = [];
    for (let r = 0; r < t.children.length; r++) {
      let s = t.children[r];
      if ((0, kp.isJSXText)(s)) {
        (0, k5.default)(s, e);
        continue;
      }
      (0, kp.isJSXExpressionContainer)(s) && (s = s.expression), !(0, kp.isJSXEmptyExpression)(s) && e.push(s);
    }
    return e;
  }
  n(D5, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var Lp = w((_p) => {
  "use strict";
  Object.defineProperty(_p, "__esModule", {
    value: !0
  });
  _p.default = L5;
  var _5 = Br();
  function L5(t) {
    return !!(t && _5.VISITOR_KEYS[t.type]);
  }
  n(L5, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var $x = w((Mp) => {
  "use strict";
  Object.defineProperty(Mp, "__esModule", {
    value: !0
  });
  Mp.default = B5;
  var M5 = Lp();
  function B5(t) {
    if (!(0, M5.default)(t)) {
      var e;
      let r = (e = t?.type) != null ? e : JSON.stringify(t);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  n(B5, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var Hx = w((g) => {
  "use strict";
  Object.defineProperty(g, "__esModule", {
    value: !0
  });
  g.assertAccessor = Q9;
  g.assertAnyTypeAnnotation = b8;
  g.assertArgumentPlaceholder = X6;
  g.assertArrayExpression = j5;
  g.assertArrayPattern = Bj;
  g.assertArrayTypeAnnotation = x8;
  g.assertArrowFunctionExpression = Fj;
  g.assertAssignmentExpression = R5;
  g.assertAssignmentPattern = Mj;
  g.assertAwaitExpression = a8;
  g.assertBigIntLiteral = l8;
  g.assertBinary = S9;
  g.assertBinaryExpression = U5;
  g.assertBindExpression = $6;
  g.assertBlock = E9;
  g.assertBlockParent = P9;
  g.assertBlockStatement = W5;
  g.assertBooleanLiteral = pj;
  g.assertBooleanLiteralTypeAnnotation = g8;
  g.assertBooleanTypeAnnotation = S8;
  g.assertBreakStatement = Y5;
  g.assertCallExpression = J5;
  g.assertCatchClause = X5;
  g.assertClass = $9;
  g.assertClassAccessorProperty = h8;
  g.assertClassBody = jj;
  g.assertClassDeclaration = Uj;
  g.assertClassExpression = Rj;
  g.assertClassImplements = E8;
  g.assertClassMethod = Qj;
  g.assertClassPrivateMethod = m8;
  g.assertClassPrivateProperty = d8;
  g.assertClassProperty = f8;
  g.assertCompletionStatement = C9;
  g.assertConditional = I9;
  g.assertConditionalExpression = $5;
  g.assertContinueStatement = H5;
  g.assertDebuggerStatement = z5;
  g.assertDecimalLiteral = tR;
  g.assertDeclaration = B9;
  g.assertDeclareClass = A8;
  g.assertDeclareExportAllDeclaration = _8;
  g.assertDeclareExportDeclaration = D8;
  g.assertDeclareFunction = v8;
  g.assertDeclareInterface = C8;
  g.assertDeclareModule = I8;
  g.assertDeclareModuleExports = w8;
  g.assertDeclareOpaqueType = O8;
  g.assertDeclareTypeAlias = N8;
  g.assertDeclareVariable = k8;
  g.assertDeclaredPredicate = L8;
  g.assertDecorator = z6;
  g.assertDirective = V5;
  g.assertDirectiveLiteral = K5;
  g.assertDoExpression = G6;
  g.assertDoWhileStatement = G5;
  g.assertEmptyStatement = Q5;
  g.assertEmptyTypeAnnotation = Y8;
  g.assertEnumBody = n7;
  g.assertEnumBooleanBody = x6;
  g.assertEnumBooleanMember = E6;
  g.assertEnumDeclaration = b6;
  g.assertEnumDefaultedMember = C6;
  g.assertEnumMember = a7;
  g.assertEnumNumberBody = S6;
  g.assertEnumNumberMember = A6;
  g.assertEnumStringBody = g6;
  g.assertEnumStringMember = v6;
  g.assertEnumSymbolBody = P6;
  g.assertExistsTypeAnnotation = M8;
  g.assertExportAllDeclaration = qj;
  g.assertExportDeclaration = z9;
  g.assertExportDefaultDeclaration = Vj;
  g.assertExportDefaultSpecifier = Q6;
  g.assertExportNamedDeclaration = Kj;
  g.assertExportNamespaceSpecifier = u8;
  g.assertExportSpecifier = Wj;
  g.assertExpression = x9;
  g.assertExpressionStatement = Z5;
  g.assertExpressionWrapper = O9;
  g.assertFile = ej;
  g.assertFlow = e7;
  g.assertFlowBaseAnnotation = r7;
  g.assertFlowDeclaration = s7;
  g.assertFlowPredicate = i7;
  g.assertFlowType = t7;
  g.assertFor = k9;
  g.assertForInStatement = tj;
  g.assertForOfStatement = Yj;
  g.assertForStatement = rj;
  g.assertForXStatement = D9;
  g.assertFunction = _9;
  g.assertFunctionDeclaration = sj;
  g.assertFunctionExpression = ij;
  g.assertFunctionParent = L9;
  g.assertFunctionTypeAnnotation = B8;
  g.assertFunctionTypeParam = F8;
  g.assertGenericTypeAnnotation = j8;
  g.assertIdentifier = nj;
  g.assertIfStatement = aj;
  g.assertImmutable = q9;
  g.assertImport = o8;
  g.assertImportAttribute = H6;
  g.assertImportDeclaration = Jj;
  g.assertImportDefaultSpecifier = Xj;
  g.assertImportExpression = zj;
  g.assertImportNamespaceSpecifier = $j;
  g.assertImportOrExportDeclaration = H9;
  g.assertImportSpecifier = Hj;
  g.assertIndexedAccessType = I6;
  g.assertInferredPredicate = R8;
  g.assertInterfaceDeclaration = q8;
  g.assertInterfaceExtends = U8;
  g.assertInterfaceTypeAnnotation = V8;
  g.assertInterpreterDirective = q5;
  g.assertIntersectionTypeAnnotation = K8;
  g.assertJSX = o7;
  g.assertJSXAttribute = N6;
  g.assertJSXClosingElement = O6;
  g.assertJSXClosingFragment = K6;
  g.assertJSXElement = k6;
  g.assertJSXEmptyExpression = D6;
  g.assertJSXExpressionContainer = _6;
  g.assertJSXFragment = q6;
  g.assertJSXIdentifier = M6;
  g.assertJSXMemberExpression = B6;
  g.assertJSXNamespacedName = F6;
  g.assertJSXOpeningElement = j6;
  g.assertJSXOpeningFragment = V6;
  g.assertJSXSpreadAttribute = R6;
  g.assertJSXSpreadChild = L6;
  g.assertJSXText = U6;
  g.assertLVal = j9;
  g.assertLabeledStatement = oj;
  g.assertLiteral = U9;
  g.assertLogicalExpression = hj;
  g.assertLoop = w9;
  g.assertMemberExpression = dj;
  g.assertMetaProperty = Gj;
  g.assertMethod = K9;
  g.assertMiscellaneous = l7;
  g.assertMixedTypeAnnotation = W8;
  g.assertModuleDeclaration = T7;
  g.assertModuleExpression = rR;
  g.assertModuleSpecifier = G9;
  g.assertNewExpression = mj;
  g.assertNoop = W6;
  g.assertNullLiteral = cj;
  g.assertNullLiteralTypeAnnotation = P8;
  g.assertNullableTypeAnnotation = J8;
  g.assertNumberLiteral = h7;
  g.assertNumberLiteralTypeAnnotation = X8;
  g.assertNumberTypeAnnotation = $8;
  g.assertNumericLiteral = uj;
  g.assertObjectExpression = Tj;
  g.assertObjectMember = W9;
  g.assertObjectMethod = bj;
  g.assertObjectPattern = Zj;
  g.assertObjectProperty = xj;
  g.assertObjectTypeAnnotation = H8;
  g.assertObjectTypeCallProperty = G8;
  g.assertObjectTypeIndexer = Q8;
  g.assertObjectTypeInternalSlot = z8;
  g.assertObjectTypeProperty = Z8;
  g.assertObjectTypeSpreadProperty = e6;
  g.assertOpaqueType = t6;
  g.assertOptionalCallExpression = p8;
  g.assertOptionalIndexedAccessType = w6;
  g.assertOptionalMemberExpression = c8;
  g.assertParenthesizedExpression = Ej;
  g.assertPattern = X9;
  g.assertPatternLike = F9;
  g.assertPipelineBareFunction = nR;
  g.assertPipelinePrimaryTopicReference = aR;
  g.assertPipelineTopicExpression = iR;
  g.assertPlaceholder = Y6;
  g.assertPrivate = Z9;
  g.assertPrivateName = y8;
  g.assertProgram = yj;
  g.assertProperty = Y9;
  g.assertPureish = M9;
  g.assertQualifiedTypeIdentifier = r6;
  g.assertRecordExpression = Z6;
  g.assertRegExpLiteral = fj;
  g.assertRegexLiteral = d7;
  g.assertRestElement = Sj;
  g.assertRestProperty = m7;
  g.assertReturnStatement = gj;
  g.assertScopable = g9;
  g.assertSequenceExpression = Pj;
  g.assertSpreadElement = e8;
  g.assertSpreadProperty = y7;
  g.assertStandardized = b9;
  g.assertStatement = A9;
  g.assertStaticBlock = T8;
  g.assertStringLiteral = lj;
  g.assertStringLiteralTypeAnnotation = s6;
  g.assertStringTypeAnnotation = i6;
  g.assertSuper = t8;
  g.assertSwitchCase = Aj;
  g.assertSwitchStatement = vj;
  g.assertSymbolTypeAnnotation = n6;
  g.assertTSAnyKeyword = yR;
  g.assertTSArrayType = BR;
  g.assertTSAsExpression = t9;
  g.assertTSBaseType = f7;
  g.assertTSBigIntKeyword = bR;
  g.assertTSBooleanKeyword = TR;
  g.assertTSCallSignatureDeclaration = pR;
  g.assertTSConditionalType = KR;
  g.assertTSConstructSignatureDeclaration = fR;
  g.assertTSConstructorType = kR;
  g.assertTSDeclareFunction = lR;
  g.assertTSDeclareMethod = uR;
  g.assertTSEntityName = R9;
  g.assertTSEnumDeclaration = i9;
  g.assertTSEnumMember = n9;
  g.assertTSExportAssignment = f9;
  g.assertTSExpressionWithTypeArguments = zR;
  g.assertTSExternalModuleReference = c9;
  g.assertTSFunctionType = OR;
  g.assertTSImportEqualsDeclaration = u9;
  g.assertTSImportType = l9;
  g.assertTSIndexSignature = mR;
  g.assertTSIndexedAccessType = XR;
  g.assertTSInferType = WR;
  g.assertTSInstantiationExpression = e9;
  g.assertTSInterfaceBody = QR;
  g.assertTSInterfaceDeclaration = GR;
  g.assertTSIntersectionType = VR;
  g.assertTSIntrinsicKeyword = xR;
  g.assertTSLiteralType = HR;
  g.assertTSMappedType = $R;
  g.assertTSMethodSignature = dR;
  g.assertTSModuleBlock = o9;
  g.assertTSModuleDeclaration = a9;
  g.assertTSNamedTupleMember = UR;
  g.assertTSNamespaceExportDeclaration = h9;
  g.assertTSNeverKeyword = SR;
  g.assertTSNonNullExpression = p9;
  g.assertTSNullKeyword = gR;
  g.assertTSNumberKeyword = PR;
  g.assertTSObjectKeyword = ER;
  g.assertTSOptionalType = jR;
  g.assertTSParameterProperty = oR;
  g.assertTSParenthesizedType = YR;
  g.assertTSPropertySignature = hR;
  g.assertTSQualifiedName = cR;
  g.assertTSRestType = RR;
  g.assertTSSatisfiesExpression = r9;
  g.assertTSStringKeyword = AR;
  g.assertTSSymbolKeyword = vR;
  g.assertTSThisType = NR;
  g.assertTSTupleType = FR;
  g.assertTSType = p7;
  g.assertTSTypeAliasDeclaration = ZR;
  g.assertTSTypeAnnotation = d9;
  g.assertTSTypeAssertion = s9;
  g.assertTSTypeElement = c7;
  g.assertTSTypeLiteral = MR;
  g.assertTSTypeOperator = JR;
  g.assertTSTypeParameter = T9;
  g.assertTSTypeParameterDeclaration = y9;
  g.assertTSTypeParameterInstantiation = m9;
  g.assertTSTypePredicate = _R;
  g.assertTSTypeQuery = LR;
  g.assertTSTypeReference = DR;
  g.assertTSUndefinedKeyword = CR;
  g.assertTSUnionType = qR;
  g.assertTSUnknownKeyword = IR;
  g.assertTSVoidKeyword = wR;
  g.assertTaggedTemplateExpression = r8;
  g.assertTemplateElement = s8;
  g.assertTemplateLiteral = i8;
  g.assertTerminatorless = v9;
  g.assertThisExpression = Cj;
  g.assertThisTypeAnnotation = a6;
  g.assertThrowStatement = Ij;
  g.assertTopicReference = sR;
  g.assertTryStatement = wj;
  g.assertTupleExpression = eR;
  g.assertTupleTypeAnnotation = o6;
  g.assertTypeAlias = u6;
  g.assertTypeAnnotation = c6;
  g.assertTypeCastExpression = p6;
  g.assertTypeParameter = f6;
  g.assertTypeParameterDeclaration = h6;
  g.assertTypeParameterInstantiation = d6;
  g.assertTypeScript = u7;
  g.assertTypeofTypeAnnotation = l6;
  g.assertUnaryExpression = Nj;
  g.assertUnaryLike = J9;
  g.assertUnionTypeAnnotation = m6;
  g.assertUpdateExpression = Oj;
  g.assertUserWhitespacable = V9;
  g.assertV8IntrinsicIdentifier = J6;
  g.assertVariableDeclaration = kj;
  g.assertVariableDeclarator = Dj;
  g.assertVariance = y6;
  g.assertVoidTypeAnnotation = T6;
  g.assertWhile = N9;
  g.assertWhileStatement = _j;
  g.assertWithStatement = Lj;
  g.assertYieldExpression = n8;
  var F5 = cn(), ga = ua();
  function A(t, e, r) {
    if (!(0, F5.default)(t, e, r))
      throw new Error(`Expected type "${t}" with option ${JSON.stringify(r)}, but instead got "${e.type}".`);
  }
  n(A, "assert");
  function j5(t, e) {
    A("ArrayExpression", t, e);
  }
  n(j5, "assertArrayExpression");
  function R5(t, e) {
    A("AssignmentExpression", t, e);
  }
  n(R5, "assertAssignmentExpression");
  function U5(t, e) {
    A("BinaryExpression", t, e);
  }
  n(U5, "assertBinaryExpression");
  function q5(t, e) {
    A("InterpreterDirective", t, e);
  }
  n(q5, "assertInterpreterDirective");
  function V5(t, e) {
    A("Directive", t, e);
  }
  n(V5, "assertDirective");
  function K5(t, e) {
    A("DirectiveLiteral", t, e);
  }
  n(K5, "assertDirectiveLiteral");
  function W5(t, e) {
    A("BlockStatement", t, e);
  }
  n(W5, "assertBlockStatement");
  function Y5(t, e) {
    A("BreakStatement", t, e);
  }
  n(Y5, "assertBreakStatement");
  function J5(t, e) {
    A("CallExpression", t, e);
  }
  n(J5, "assertCallExpression");
  function X5(t, e) {
    A("CatchClause", t, e);
  }
  n(X5, "assertCatchClause");
  function $5(t, e) {
    A("ConditionalExpression", t, e);
  }
  n($5, "assertConditionalExpression");
  function H5(t, e) {
    A("ContinueStatement", t, e);
  }
  n(H5, "assertContinueStatement");
  function z5(t, e) {
    A("DebuggerStatement", t, e);
  }
  n(z5, "assertDebuggerStatement");
  function G5(t, e) {
    A("DoWhileStatement", t, e);
  }
  n(G5, "assertDoWhileStatement");
  function Q5(t, e) {
    A("EmptyStatement", t, e);
  }
  n(Q5, "assertEmptyStatement");
  function Z5(t, e) {
    A("ExpressionStatement", t, e);
  }
  n(Z5, "assertExpressionStatement");
  function ej(t, e) {
    A("File", t, e);
  }
  n(ej, "assertFile");
  function tj(t, e) {
    A("ForInStatement", t, e);
  }
  n(tj, "assertForInStatement");
  function rj(t, e) {
    A("ForStatement", t, e);
  }
  n(rj, "assertForStatement");
  function sj(t, e) {
    A("FunctionDeclaration", t, e);
  }
  n(sj, "assertFunctionDeclaration");
  function ij(t, e) {
    A("FunctionExpression", t, e);
  }
  n(ij, "assertFunctionExpression");
  function nj(t, e) {
    A("Identifier", t, e);
  }
  n(nj, "assertIdentifier");
  function aj(t, e) {
    A("IfStatement", t, e);
  }
  n(aj, "assertIfStatement");
  function oj(t, e) {
    A("LabeledStatement", t, e);
  }
  n(oj, "assertLabeledStatement");
  function lj(t, e) {
    A("StringLiteral", t, e);
  }
  n(lj, "assertStringLiteral");
  function uj(t, e) {
    A("NumericLiteral", t, e);
  }
  n(uj, "assertNumericLiteral");
  function cj(t, e) {
    A("NullLiteral", t, e);
  }
  n(cj, "assertNullLiteral");
  function pj(t, e) {
    A("BooleanLiteral", t, e);
  }
  n(pj, "assertBooleanLiteral");
  function fj(t, e) {
    A("RegExpLiteral", t, e);
  }
  n(fj, "assertRegExpLiteral");
  function hj(t, e) {
    A("LogicalExpression", t, e);
  }
  n(hj, "assertLogicalExpression");
  function dj(t, e) {
    A("MemberExpression", t, e);
  }
  n(dj, "assertMemberExpression");
  function mj(t, e) {
    A("NewExpression", t, e);
  }
  n(mj, "assertNewExpression");
  function yj(t, e) {
    A("Program", t, e);
  }
  n(yj, "assertProgram");
  function Tj(t, e) {
    A("ObjectExpression", t, e);
  }
  n(Tj, "assertObjectExpression");
  function bj(t, e) {
    A("ObjectMethod", t, e);
  }
  n(bj, "assertObjectMethod");
  function xj(t, e) {
    A("ObjectProperty", t, e);
  }
  n(xj, "assertObjectProperty");
  function Sj(t, e) {
    A("RestElement", t, e);
  }
  n(Sj, "assertRestElement");
  function gj(t, e) {
    A("ReturnStatement", t, e);
  }
  n(gj, "assertReturnStatement");
  function Pj(t, e) {
    A("SequenceExpression", t, e);
  }
  n(Pj, "assertSequenceExpression");
  function Ej(t, e) {
    A("ParenthesizedExpression", t, e);
  }
  n(Ej, "assertParenthesizedExpression");
  function Aj(t, e) {
    A("SwitchCase", t, e);
  }
  n(Aj, "assertSwitchCase");
  function vj(t, e) {
    A("SwitchStatement", t, e);
  }
  n(vj, "assertSwitchStatement");
  function Cj(t, e) {
    A("ThisExpression", t, e);
  }
  n(Cj, "assertThisExpression");
  function Ij(t, e) {
    A("ThrowStatement", t, e);
  }
  n(Ij, "assertThrowStatement");
  function wj(t, e) {
    A("TryStatement", t, e);
  }
  n(wj, "assertTryStatement");
  function Nj(t, e) {
    A("UnaryExpression", t, e);
  }
  n(Nj, "assertUnaryExpression");
  function Oj(t, e) {
    A("UpdateExpression", t, e);
  }
  n(Oj, "assertUpdateExpression");
  function kj(t, e) {
    A("VariableDeclaration", t, e);
  }
  n(kj, "assertVariableDeclaration");
  function Dj(t, e) {
    A("VariableDeclarator", t, e);
  }
  n(Dj, "assertVariableDeclarator");
  function _j(t, e) {
    A("WhileStatement", t, e);
  }
  n(_j, "assertWhileStatement");
  function Lj(t, e) {
    A("WithStatement", t, e);
  }
  n(Lj, "assertWithStatement");
  function Mj(t, e) {
    A("AssignmentPattern", t, e);
  }
  n(Mj, "assertAssignmentPattern");
  function Bj(t, e) {
    A("ArrayPattern", t, e);
  }
  n(Bj, "assertArrayPattern");
  function Fj(t, e) {
    A("ArrowFunctionExpression", t, e);
  }
  n(Fj, "assertArrowFunctionExpression");
  function jj(t, e) {
    A("ClassBody", t, e);
  }
  n(jj, "assertClassBody");
  function Rj(t, e) {
    A("ClassExpression", t, e);
  }
  n(Rj, "assertClassExpression");
  function Uj(t, e) {
    A("ClassDeclaration", t, e);
  }
  n(Uj, "assertClassDeclaration");
  function qj(t, e) {
    A("ExportAllDeclaration", t, e);
  }
  n(qj, "assertExportAllDeclaration");
  function Vj(t, e) {
    A("ExportDefaultDeclaration", t, e);
  }
  n(Vj, "assertExportDefaultDeclaration");
  function Kj(t, e) {
    A("ExportNamedDeclaration", t, e);
  }
  n(Kj, "assertExportNamedDeclaration");
  function Wj(t, e) {
    A("ExportSpecifier", t, e);
  }
  n(Wj, "assertExportSpecifier");
  function Yj(t, e) {
    A("ForOfStatement", t, e);
  }
  n(Yj, "assertForOfStatement");
  function Jj(t, e) {
    A("ImportDeclaration", t, e);
  }
  n(Jj, "assertImportDeclaration");
  function Xj(t, e) {
    A("ImportDefaultSpecifier", t, e);
  }
  n(Xj, "assertImportDefaultSpecifier");
  function $j(t, e) {
    A("ImportNamespaceSpecifier", t, e);
  }
  n($j, "assertImportNamespaceSpecifier");
  function Hj(t, e) {
    A("ImportSpecifier", t, e);
  }
  n(Hj, "assertImportSpecifier");
  function zj(t, e) {
    A("ImportExpression", t, e);
  }
  n(zj, "assertImportExpression");
  function Gj(t, e) {
    A("MetaProperty", t, e);
  }
  n(Gj, "assertMetaProperty");
  function Qj(t, e) {
    A("ClassMethod", t, e);
  }
  n(Qj, "assertClassMethod");
  function Zj(t, e) {
    A("ObjectPattern", t, e);
  }
  n(Zj, "assertObjectPattern");
  function e8(t, e) {
    A("SpreadElement", t, e);
  }
  n(e8, "assertSpreadElement");
  function t8(t, e) {
    A("Super", t, e);
  }
  n(t8, "assertSuper");
  function r8(t, e) {
    A("TaggedTemplateExpression", t, e);
  }
  n(r8, "assertTaggedTemplateExpression");
  function s8(t, e) {
    A("TemplateElement", t, e);
  }
  n(s8, "assertTemplateElement");
  function i8(t, e) {
    A("TemplateLiteral", t, e);
  }
  n(i8, "assertTemplateLiteral");
  function n8(t, e) {
    A("YieldExpression", t, e);
  }
  n(n8, "assertYieldExpression");
  function a8(t, e) {
    A("AwaitExpression", t, e);
  }
  n(a8, "assertAwaitExpression");
  function o8(t, e) {
    A("Import", t, e);
  }
  n(o8, "assertImport");
  function l8(t, e) {
    A("BigIntLiteral", t, e);
  }
  n(l8, "assertBigIntLiteral");
  function u8(t, e) {
    A("ExportNamespaceSpecifier", t, e);
  }
  n(u8, "assertExportNamespaceSpecifier");
  function c8(t, e) {
    A("OptionalMemberExpression", t, e);
  }
  n(c8, "assertOptionalMemberExpression");
  function p8(t, e) {
    A("OptionalCallExpression", t, e);
  }
  n(p8, "assertOptionalCallExpression");
  function f8(t, e) {
    A("ClassProperty", t, e);
  }
  n(f8, "assertClassProperty");
  function h8(t, e) {
    A("ClassAccessorProperty", t, e);
  }
  n(h8, "assertClassAccessorProperty");
  function d8(t, e) {
    A("ClassPrivateProperty", t, e);
  }
  n(d8, "assertClassPrivateProperty");
  function m8(t, e) {
    A("ClassPrivateMethod", t, e);
  }
  n(m8, "assertClassPrivateMethod");
  function y8(t, e) {
    A("PrivateName", t, e);
  }
  n(y8, "assertPrivateName");
  function T8(t, e) {
    A("StaticBlock", t, e);
  }
  n(T8, "assertStaticBlock");
  function b8(t, e) {
    A("AnyTypeAnnotation", t, e);
  }
  n(b8, "assertAnyTypeAnnotation");
  function x8(t, e) {
    A("ArrayTypeAnnotation", t, e);
  }
  n(x8, "assertArrayTypeAnnotation");
  function S8(t, e) {
    A("BooleanTypeAnnotation", t, e);
  }
  n(S8, "assertBooleanTypeAnnotation");
  function g8(t, e) {
    A("BooleanLiteralTypeAnnotation", t, e);
  }
  n(g8, "assertBooleanLiteralTypeAnnotation");
  function P8(t, e) {
    A("NullLiteralTypeAnnotation", t, e);
  }
  n(P8, "assertNullLiteralTypeAnnotation");
  function E8(t, e) {
    A("ClassImplements", t, e);
  }
  n(E8, "assertClassImplements");
  function A8(t, e) {
    A("DeclareClass", t, e);
  }
  n(A8, "assertDeclareClass");
  function v8(t, e) {
    A("DeclareFunction", t, e);
  }
  n(v8, "assertDeclareFunction");
  function C8(t, e) {
    A("DeclareInterface", t, e);
  }
  n(C8, "assertDeclareInterface");
  function I8(t, e) {
    A("DeclareModule", t, e);
  }
  n(I8, "assertDeclareModule");
  function w8(t, e) {
    A("DeclareModuleExports", t, e);
  }
  n(w8, "assertDeclareModuleExports");
  function N8(t, e) {
    A("DeclareTypeAlias", t, e);
  }
  n(N8, "assertDeclareTypeAlias");
  function O8(t, e) {
    A("DeclareOpaqueType", t, e);
  }
  n(O8, "assertDeclareOpaqueType");
  function k8(t, e) {
    A("DeclareVariable", t, e);
  }
  n(k8, "assertDeclareVariable");
  function D8(t, e) {
    A("DeclareExportDeclaration", t, e);
  }
  n(D8, "assertDeclareExportDeclaration");
  function _8(t, e) {
    A("DeclareExportAllDeclaration", t, e);
  }
  n(_8, "assertDeclareExportAllDeclaration");
  function L8(t, e) {
    A("DeclaredPredicate", t, e);
  }
  n(L8, "assertDeclaredPredicate");
  function M8(t, e) {
    A("ExistsTypeAnnotation", t, e);
  }
  n(M8, "assertExistsTypeAnnotation");
  function B8(t, e) {
    A("FunctionTypeAnnotation", t, e);
  }
  n(B8, "assertFunctionTypeAnnotation");
  function F8(t, e) {
    A("FunctionTypeParam", t, e);
  }
  n(F8, "assertFunctionTypeParam");
  function j8(t, e) {
    A("GenericTypeAnnotation", t, e);
  }
  n(j8, "assertGenericTypeAnnotation");
  function R8(t, e) {
    A("InferredPredicate", t, e);
  }
  n(R8, "assertInferredPredicate");
  function U8(t, e) {
    A("InterfaceExtends", t, e);
  }
  n(U8, "assertInterfaceExtends");
  function q8(t, e) {
    A("InterfaceDeclaration", t, e);
  }
  n(q8, "assertInterfaceDeclaration");
  function V8(t, e) {
    A("InterfaceTypeAnnotation", t, e);
  }
  n(V8, "assertInterfaceTypeAnnotation");
  function K8(t, e) {
    A("IntersectionTypeAnnotation", t, e);
  }
  n(K8, "assertIntersectionTypeAnnotation");
  function W8(t, e) {
    A("MixedTypeAnnotation", t, e);
  }
  n(W8, "assertMixedTypeAnnotation");
  function Y8(t, e) {
    A("EmptyTypeAnnotation", t, e);
  }
  n(Y8, "assertEmptyTypeAnnotation");
  function J8(t, e) {
    A("NullableTypeAnnotation", t, e);
  }
  n(J8, "assertNullableTypeAnnotation");
  function X8(t, e) {
    A("NumberLiteralTypeAnnotation", t, e);
  }
  n(X8, "assertNumberLiteralTypeAnnotation");
  function $8(t, e) {
    A("NumberTypeAnnotation", t, e);
  }
  n($8, "assertNumberTypeAnnotation");
  function H8(t, e) {
    A("ObjectTypeAnnotation", t, e);
  }
  n(H8, "assertObjectTypeAnnotation");
  function z8(t, e) {
    A("ObjectTypeInternalSlot", t, e);
  }
  n(z8, "assertObjectTypeInternalSlot");
  function G8(t, e) {
    A("ObjectTypeCallProperty", t, e);
  }
  n(G8, "assertObjectTypeCallProperty");
  function Q8(t, e) {
    A("ObjectTypeIndexer", t, e);
  }
  n(Q8, "assertObjectTypeIndexer");
  function Z8(t, e) {
    A("ObjectTypeProperty", t, e);
  }
  n(Z8, "assertObjectTypeProperty");
  function e6(t, e) {
    A("ObjectTypeSpreadProperty", t, e);
  }
  n(e6, "assertObjectTypeSpreadProperty");
  function t6(t, e) {
    A("OpaqueType", t, e);
  }
  n(t6, "assertOpaqueType");
  function r6(t, e) {
    A("QualifiedTypeIdentifier", t, e);
  }
  n(r6, "assertQualifiedTypeIdentifier");
  function s6(t, e) {
    A("StringLiteralTypeAnnotation", t, e);
  }
  n(s6, "assertStringLiteralTypeAnnotation");
  function i6(t, e) {
    A("StringTypeAnnotation", t, e);
  }
  n(i6, "assertStringTypeAnnotation");
  function n6(t, e) {
    A("SymbolTypeAnnotation", t, e);
  }
  n(n6, "assertSymbolTypeAnnotation");
  function a6(t, e) {
    A("ThisTypeAnnotation", t, e);
  }
  n(a6, "assertThisTypeAnnotation");
  function o6(t, e) {
    A("TupleTypeAnnotation", t, e);
  }
  n(o6, "assertTupleTypeAnnotation");
  function l6(t, e) {
    A("TypeofTypeAnnotation", t, e);
  }
  n(l6, "assertTypeofTypeAnnotation");
  function u6(t, e) {
    A("TypeAlias", t, e);
  }
  n(u6, "assertTypeAlias");
  function c6(t, e) {
    A("TypeAnnotation", t, e);
  }
  n(c6, "assertTypeAnnotation");
  function p6(t, e) {
    A("TypeCastExpression", t, e);
  }
  n(p6, "assertTypeCastExpression");
  function f6(t, e) {
    A("TypeParameter", t, e);
  }
  n(f6, "assertTypeParameter");
  function h6(t, e) {
    A("TypeParameterDeclaration", t, e);
  }
  n(h6, "assertTypeParameterDeclaration");
  function d6(t, e) {
    A("TypeParameterInstantiation", t, e);
  }
  n(d6, "assertTypeParameterInstantiation");
  function m6(t, e) {
    A("UnionTypeAnnotation", t, e);
  }
  n(m6, "assertUnionTypeAnnotation");
  function y6(t, e) {
    A("Variance", t, e);
  }
  n(y6, "assertVariance");
  function T6(t, e) {
    A("VoidTypeAnnotation", t, e);
  }
  n(T6, "assertVoidTypeAnnotation");
  function b6(t, e) {
    A("EnumDeclaration", t, e);
  }
  n(b6, "assertEnumDeclaration");
  function x6(t, e) {
    A("EnumBooleanBody", t, e);
  }
  n(x6, "assertEnumBooleanBody");
  function S6(t, e) {
    A("EnumNumberBody", t, e);
  }
  n(S6, "assertEnumNumberBody");
  function g6(t, e) {
    A("EnumStringBody", t, e);
  }
  n(g6, "assertEnumStringBody");
  function P6(t, e) {
    A("EnumSymbolBody", t, e);
  }
  n(P6, "assertEnumSymbolBody");
  function E6(t, e) {
    A("EnumBooleanMember", t, e);
  }
  n(E6, "assertEnumBooleanMember");
  function A6(t, e) {
    A("EnumNumberMember", t, e);
  }
  n(A6, "assertEnumNumberMember");
  function v6(t, e) {
    A("EnumStringMember", t, e);
  }
  n(v6, "assertEnumStringMember");
  function C6(t, e) {
    A("EnumDefaultedMember", t, e);
  }
  n(C6, "assertEnumDefaultedMember");
  function I6(t, e) {
    A("IndexedAccessType", t, e);
  }
  n(I6, "assertIndexedAccessType");
  function w6(t, e) {
    A("OptionalIndexedAccessType", t, e);
  }
  n(w6, "assertOptionalIndexedAccessType");
  function N6(t, e) {
    A("JSXAttribute", t, e);
  }
  n(N6, "assertJSXAttribute");
  function O6(t, e) {
    A("JSXClosingElement", t, e);
  }
  n(O6, "assertJSXClosingElement");
  function k6(t, e) {
    A("JSXElement", t, e);
  }
  n(k6, "assertJSXElement");
  function D6(t, e) {
    A("JSXEmptyExpression", t, e);
  }
  n(D6, "assertJSXEmptyExpression");
  function _6(t, e) {
    A("JSXExpressionContainer", t, e);
  }
  n(_6, "assertJSXExpressionContainer");
  function L6(t, e) {
    A("JSXSpreadChild", t, e);
  }
  n(L6, "assertJSXSpreadChild");
  function M6(t, e) {
    A("JSXIdentifier", t, e);
  }
  n(M6, "assertJSXIdentifier");
  function B6(t, e) {
    A("JSXMemberExpression", t, e);
  }
  n(B6, "assertJSXMemberExpression");
  function F6(t, e) {
    A("JSXNamespacedName", t, e);
  }
  n(F6, "assertJSXNamespacedName");
  function j6(t, e) {
    A("JSXOpeningElement", t, e);
  }
  n(j6, "assertJSXOpeningElement");
  function R6(t, e) {
    A("JSXSpreadAttribute", t, e);
  }
  n(R6, "assertJSXSpreadAttribute");
  function U6(t, e) {
    A("JSXText", t, e);
  }
  n(U6, "assertJSXText");
  function q6(t, e) {
    A("JSXFragment", t, e);
  }
  n(q6, "assertJSXFragment");
  function V6(t, e) {
    A("JSXOpeningFragment", t, e);
  }
  n(V6, "assertJSXOpeningFragment");
  function K6(t, e) {
    A("JSXClosingFragment", t, e);
  }
  n(K6, "assertJSXClosingFragment");
  function W6(t, e) {
    A("Noop", t, e);
  }
  n(W6, "assertNoop");
  function Y6(t, e) {
    A("Placeholder", t, e);
  }
  n(Y6, "assertPlaceholder");
  function J6(t, e) {
    A("V8IntrinsicIdentifier", t, e);
  }
  n(J6, "assertV8IntrinsicIdentifier");
  function X6(t, e) {
    A("ArgumentPlaceholder", t, e);
  }
  n(X6, "assertArgumentPlaceholder");
  function $6(t, e) {
    A("BindExpression", t, e);
  }
  n($6, "assertBindExpression");
  function H6(t, e) {
    A("ImportAttribute", t, e);
  }
  n(H6, "assertImportAttribute");
  function z6(t, e) {
    A("Decorator", t, e);
  }
  n(z6, "assertDecorator");
  function G6(t, e) {
    A("DoExpression", t, e);
  }
  n(G6, "assertDoExpression");
  function Q6(t, e) {
    A("ExportDefaultSpecifier", t, e);
  }
  n(Q6, "assertExportDefaultSpecifier");
  function Z6(t, e) {
    A("RecordExpression", t, e);
  }
  n(Z6, "assertRecordExpression");
  function eR(t, e) {
    A("TupleExpression", t, e);
  }
  n(eR, "assertTupleExpression");
  function tR(t, e) {
    A("DecimalLiteral", t, e);
  }
  n(tR, "assertDecimalLiteral");
  function rR(t, e) {
    A("ModuleExpression", t, e);
  }
  n(rR, "assertModuleExpression");
  function sR(t, e) {
    A("TopicReference", t, e);
  }
  n(sR, "assertTopicReference");
  function iR(t, e) {
    A("PipelineTopicExpression", t, e);
  }
  n(iR, "assertPipelineTopicExpression");
  function nR(t, e) {
    A("PipelineBareFunction", t, e);
  }
  n(nR, "assertPipelineBareFunction");
  function aR(t, e) {
    A("PipelinePrimaryTopicReference", t, e);
  }
  n(aR, "assertPipelinePrimaryTopicReference");
  function oR(t, e) {
    A("TSParameterProperty", t, e);
  }
  n(oR, "assertTSParameterProperty");
  function lR(t, e) {
    A("TSDeclareFunction", t, e);
  }
  n(lR, "assertTSDeclareFunction");
  function uR(t, e) {
    A("TSDeclareMethod", t, e);
  }
  n(uR, "assertTSDeclareMethod");
  function cR(t, e) {
    A("TSQualifiedName", t, e);
  }
  n(cR, "assertTSQualifiedName");
  function pR(t, e) {
    A("TSCallSignatureDeclaration", t, e);
  }
  n(pR, "assertTSCallSignatureDeclaration");
  function fR(t, e) {
    A("TSConstructSignatureDeclaration", t, e);
  }
  n(fR, "assertTSConstructSignatureDeclaration");
  function hR(t, e) {
    A("TSPropertySignature", t, e);
  }
  n(hR, "assertTSPropertySignature");
  function dR(t, e) {
    A("TSMethodSignature", t, e);
  }
  n(dR, "assertTSMethodSignature");
  function mR(t, e) {
    A("TSIndexSignature", t, e);
  }
  n(mR, "assertTSIndexSignature");
  function yR(t, e) {
    A("TSAnyKeyword", t, e);
  }
  n(yR, "assertTSAnyKeyword");
  function TR(t, e) {
    A("TSBooleanKeyword", t, e);
  }
  n(TR, "assertTSBooleanKeyword");
  function bR(t, e) {
    A("TSBigIntKeyword", t, e);
  }
  n(bR, "assertTSBigIntKeyword");
  function xR(t, e) {
    A("TSIntrinsicKeyword", t, e);
  }
  n(xR, "assertTSIntrinsicKeyword");
  function SR(t, e) {
    A("TSNeverKeyword", t, e);
  }
  n(SR, "assertTSNeverKeyword");
  function gR(t, e) {
    A("TSNullKeyword", t, e);
  }
  n(gR, "assertTSNullKeyword");
  function PR(t, e) {
    A("TSNumberKeyword", t, e);
  }
  n(PR, "assertTSNumberKeyword");
  function ER(t, e) {
    A("TSObjectKeyword", t, e);
  }
  n(ER, "assertTSObjectKeyword");
  function AR(t, e) {
    A("TSStringKeyword", t, e);
  }
  n(AR, "assertTSStringKeyword");
  function vR(t, e) {
    A("TSSymbolKeyword", t, e);
  }
  n(vR, "assertTSSymbolKeyword");
  function CR(t, e) {
    A("TSUndefinedKeyword", t, e);
  }
  n(CR, "assertTSUndefinedKeyword");
  function IR(t, e) {
    A("TSUnknownKeyword", t, e);
  }
  n(IR, "assertTSUnknownKeyword");
  function wR(t, e) {
    A("TSVoidKeyword", t, e);
  }
  n(wR, "assertTSVoidKeyword");
  function NR(t, e) {
    A("TSThisType", t, e);
  }
  n(NR, "assertTSThisType");
  function OR(t, e) {
    A("TSFunctionType", t, e);
  }
  n(OR, "assertTSFunctionType");
  function kR(t, e) {
    A("TSConstructorType", t, e);
  }
  n(kR, "assertTSConstructorType");
  function DR(t, e) {
    A("TSTypeReference", t, e);
  }
  n(DR, "assertTSTypeReference");
  function _R(t, e) {
    A("TSTypePredicate", t, e);
  }
  n(_R, "assertTSTypePredicate");
  function LR(t, e) {
    A("TSTypeQuery", t, e);
  }
  n(LR, "assertTSTypeQuery");
  function MR(t, e) {
    A("TSTypeLiteral", t, e);
  }
  n(MR, "assertTSTypeLiteral");
  function BR(t, e) {
    A("TSArrayType", t, e);
  }
  n(BR, "assertTSArrayType");
  function FR(t, e) {
    A("TSTupleType", t, e);
  }
  n(FR, "assertTSTupleType");
  function jR(t, e) {
    A("TSOptionalType", t, e);
  }
  n(jR, "assertTSOptionalType");
  function RR(t, e) {
    A("TSRestType", t, e);
  }
  n(RR, "assertTSRestType");
  function UR(t, e) {
    A("TSNamedTupleMember", t, e);
  }
  n(UR, "assertTSNamedTupleMember");
  function qR(t, e) {
    A("TSUnionType", t, e);
  }
  n(qR, "assertTSUnionType");
  function VR(t, e) {
    A("TSIntersectionType", t, e);
  }
  n(VR, "assertTSIntersectionType");
  function KR(t, e) {
    A("TSConditionalType", t, e);
  }
  n(KR, "assertTSConditionalType");
  function WR(t, e) {
    A("TSInferType", t, e);
  }
  n(WR, "assertTSInferType");
  function YR(t, e) {
    A("TSParenthesizedType", t, e);
  }
  n(YR, "assertTSParenthesizedType");
  function JR(t, e) {
    A("TSTypeOperator", t, e);
  }
  n(JR, "assertTSTypeOperator");
  function XR(t, e) {
    A("TSIndexedAccessType", t, e);
  }
  n(XR, "assertTSIndexedAccessType");
  function $R(t, e) {
    A("TSMappedType", t, e);
  }
  n($R, "assertTSMappedType");
  function HR(t, e) {
    A("TSLiteralType", t, e);
  }
  n(HR, "assertTSLiteralType");
  function zR(t, e) {
    A("TSExpressionWithTypeArguments", t, e);
  }
  n(zR, "assertTSExpressionWithTypeArguments");
  function GR(t, e) {
    A("TSInterfaceDeclaration", t, e);
  }
  n(GR, "assertTSInterfaceDeclaration");
  function QR(t, e) {
    A("TSInterfaceBody", t, e);
  }
  n(QR, "assertTSInterfaceBody");
  function ZR(t, e) {
    A("TSTypeAliasDeclaration", t, e);
  }
  n(ZR, "assertTSTypeAliasDeclaration");
  function e9(t, e) {
    A("TSInstantiationExpression", t, e);
  }
  n(e9, "assertTSInstantiationExpression");
  function t9(t, e) {
    A("TSAsExpression", t, e);
  }
  n(t9, "assertTSAsExpression");
  function r9(t, e) {
    A("TSSatisfiesExpression", t, e);
  }
  n(r9, "assertTSSatisfiesExpression");
  function s9(t, e) {
    A("TSTypeAssertion", t, e);
  }
  n(s9, "assertTSTypeAssertion");
  function i9(t, e) {
    A("TSEnumDeclaration", t, e);
  }
  n(i9, "assertTSEnumDeclaration");
  function n9(t, e) {
    A("TSEnumMember", t, e);
  }
  n(n9, "assertTSEnumMember");
  function a9(t, e) {
    A("TSModuleDeclaration", t, e);
  }
  n(a9, "assertTSModuleDeclaration");
  function o9(t, e) {
    A("TSModuleBlock", t, e);
  }
  n(o9, "assertTSModuleBlock");
  function l9(t, e) {
    A("TSImportType", t, e);
  }
  n(l9, "assertTSImportType");
  function u9(t, e) {
    A("TSImportEqualsDeclaration", t, e);
  }
  n(u9, "assertTSImportEqualsDeclaration");
  function c9(t, e) {
    A("TSExternalModuleReference", t, e);
  }
  n(c9, "assertTSExternalModuleReference");
  function p9(t, e) {
    A("TSNonNullExpression", t, e);
  }
  n(p9, "assertTSNonNullExpression");
  function f9(t, e) {
    A("TSExportAssignment", t, e);
  }
  n(f9, "assertTSExportAssignment");
  function h9(t, e) {
    A("TSNamespaceExportDeclaration", t, e);
  }
  n(h9, "assertTSNamespaceExportDeclaration");
  function d9(t, e) {
    A("TSTypeAnnotation", t, e);
  }
  n(d9, "assertTSTypeAnnotation");
  function m9(t, e) {
    A("TSTypeParameterInstantiation", t, e);
  }
  n(m9, "assertTSTypeParameterInstantiation");
  function y9(t, e) {
    A("TSTypeParameterDeclaration", t, e);
  }
  n(y9, "assertTSTypeParameterDeclaration");
  function T9(t, e) {
    A("TSTypeParameter", t, e);
  }
  n(T9, "assertTSTypeParameter");
  function b9(t, e) {
    A("Standardized", t, e);
  }
  n(b9, "assertStandardized");
  function x9(t, e) {
    A("Expression", t, e);
  }
  n(x9, "assertExpression");
  function S9(t, e) {
    A("Binary", t, e);
  }
  n(S9, "assertBinary");
  function g9(t, e) {
    A("Scopable", t, e);
  }
  n(g9, "assertScopable");
  function P9(t, e) {
    A("BlockParent", t, e);
  }
  n(P9, "assertBlockParent");
  function E9(t, e) {
    A("Block", t, e);
  }
  n(E9, "assertBlock");
  function A9(t, e) {
    A("Statement", t, e);
  }
  n(A9, "assertStatement");
  function v9(t, e) {
    A("Terminatorless", t, e);
  }
  n(v9, "assertTerminatorless");
  function C9(t, e) {
    A("CompletionStatement", t, e);
  }
  n(C9, "assertCompletionStatement");
  function I9(t, e) {
    A("Conditional", t, e);
  }
  n(I9, "assertConditional");
  function w9(t, e) {
    A("Loop", t, e);
  }
  n(w9, "assertLoop");
  function N9(t, e) {
    A("While", t, e);
  }
  n(N9, "assertWhile");
  function O9(t, e) {
    A("ExpressionWrapper", t, e);
  }
  n(O9, "assertExpressionWrapper");
  function k9(t, e) {
    A("For", t, e);
  }
  n(k9, "assertFor");
  function D9(t, e) {
    A("ForXStatement", t, e);
  }
  n(D9, "assertForXStatement");
  function _9(t, e) {
    A("Function", t, e);
  }
  n(_9, "assertFunction");
  function L9(t, e) {
    A("FunctionParent", t, e);
  }
  n(L9, "assertFunctionParent");
  function M9(t, e) {
    A("Pureish", t, e);
  }
  n(M9, "assertPureish");
  function B9(t, e) {
    A("Declaration", t, e);
  }
  n(B9, "assertDeclaration");
  function F9(t, e) {
    A("PatternLike", t, e);
  }
  n(F9, "assertPatternLike");
  function j9(t, e) {
    A("LVal", t, e);
  }
  n(j9, "assertLVal");
  function R9(t, e) {
    A("TSEntityName", t, e);
  }
  n(R9, "assertTSEntityName");
  function U9(t, e) {
    A("Literal", t, e);
  }
  n(U9, "assertLiteral");
  function q9(t, e) {
    A("Immutable", t, e);
  }
  n(q9, "assertImmutable");
  function V9(t, e) {
    A("UserWhitespacable", t, e);
  }
  n(V9, "assertUserWhitespacable");
  function K9(t, e) {
    A("Method", t, e);
  }
  n(K9, "assertMethod");
  function W9(t, e) {
    A("ObjectMember", t, e);
  }
  n(W9, "assertObjectMember");
  function Y9(t, e) {
    A("Property", t, e);
  }
  n(Y9, "assertProperty");
  function J9(t, e) {
    A("UnaryLike", t, e);
  }
  n(J9, "assertUnaryLike");
  function X9(t, e) {
    A("Pattern", t, e);
  }
  n(X9, "assertPattern");
  function $9(t, e) {
    A("Class", t, e);
  }
  n($9, "assertClass");
  function H9(t, e) {
    A("ImportOrExportDeclaration", t, e);
  }
  n(H9, "assertImportOrExportDeclaration");
  function z9(t, e) {
    A("ExportDeclaration", t, e);
  }
  n(z9, "assertExportDeclaration");
  function G9(t, e) {
    A("ModuleSpecifier", t, e);
  }
  n(G9, "assertModuleSpecifier");
  function Q9(t, e) {
    A("Accessor", t, e);
  }
  n(Q9, "assertAccessor");
  function Z9(t, e) {
    A("Private", t, e);
  }
  n(Z9, "assertPrivate");
  function e7(t, e) {
    A("Flow", t, e);
  }
  n(e7, "assertFlow");
  function t7(t, e) {
    A("FlowType", t, e);
  }
  n(t7, "assertFlowType");
  function r7(t, e) {
    A("FlowBaseAnnotation", t, e);
  }
  n(r7, "assertFlowBaseAnnotation");
  function s7(t, e) {
    A("FlowDeclaration", t, e);
  }
  n(s7, "assertFlowDeclaration");
  function i7(t, e) {
    A("FlowPredicate", t, e);
  }
  n(i7, "assertFlowPredicate");
  function n7(t, e) {
    A("EnumBody", t, e);
  }
  n(n7, "assertEnumBody");
  function a7(t, e) {
    A("EnumMember", t, e);
  }
  n(a7, "assertEnumMember");
  function o7(t, e) {
    A("JSX", t, e);
  }
  n(o7, "assertJSX");
  function l7(t, e) {
    A("Miscellaneous", t, e);
  }
  n(l7, "assertMiscellaneous");
  function u7(t, e) {
    A("TypeScript", t, e);
  }
  n(u7, "assertTypeScript");
  function c7(t, e) {
    A("TSTypeElement", t, e);
  }
  n(c7, "assertTSTypeElement");
  function p7(t, e) {
    A("TSType", t, e);
  }
  n(p7, "assertTSType");
  function f7(t, e) {
    A("TSBaseType", t, e);
  }
  n(f7, "assertTSBaseType");
  function h7(t, e) {
    (0, ga.default)("assertNumberLiteral", "assertNumericLiteral"), A("NumberLiteral", t, e);
  }
  n(h7, "assertNumberLiteral");
  function d7(t, e) {
    (0, ga.default)("assertRegexLiteral", "assertRegExpLiteral"), A("RegexLiteral", t, e);
  }
  n(d7, "assertRegexLiteral");
  function m7(t, e) {
    (0, ga.default)("assertRestProperty", "assertRestElement"), A("RestProperty", t, e);
  }
  n(m7, "assertRestProperty");
  function y7(t, e) {
    (0, ga.default)("assertSpreadProperty", "assertSpreadElement"), A("SpreadProperty", t, e);
  }
  n(y7, "assertSpreadProperty");
  function T7(t, e) {
    (0, ga.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), A("ModuleDeclaration", t, e);
  }
  n(T7, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var zx = w((gl) => {
  "use strict";
  Object.defineProperty(gl, "__esModule", {
    value: !0
  });
  gl.default = void 0;
  var Yr = pr(), vMe = gl.default = b7;
  function b7(t) {
    switch (t) {
      case "string":
        return (0, Yr.stringTypeAnnotation)();
      case "number":
        return (0, Yr.numberTypeAnnotation)();
      case "undefined":
        return (0, Yr.voidTypeAnnotation)();
      case "boolean":
        return (0, Yr.booleanTypeAnnotation)();
      case "function":
        return (0, Yr.genericTypeAnnotation)((0, Yr.identifier)("Function"));
      case "object":
        return (0, Yr.genericTypeAnnotation)((0, Yr.identifier)("Object"));
      case "symbol":
        return (0, Yr.genericTypeAnnotation)((0, Yr.identifier)("Symbol"));
      case "bigint":
        return (0, Yr.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + t);
  }
  n(b7, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var Fp = w((Bp) => {
  "use strict";
  Object.defineProperty(Bp, "__esModule", {
    value: !0
  });
  Bp.default = Qx;
  var Pa = jt();
  function Gx(t) {
    return (0, Pa.isIdentifier)(t) ? t.name : `${t.id.name}.${Gx(t.qualification)}`;
  }
  n(Gx, "getQualifiedName");
  function Qx(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Pa.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, Pa.isFlowBaseAnnotation)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, Pa.isUnionTypeAnnotation)(l)) {
          i.has(l.types) || (e.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, Pa.isGenericTypeAnnotation)(l)) {
          let u = Gx(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = Qx(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(Qx, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var Zx = w((jp) => {
  "use strict";
  Object.defineProperty(jp, "__esModule", {
    value: !0
  });
  jp.default = g7;
  var x7 = pr(), S7 = Fp();
  function g7(t) {
    let e = (0, S7.default)(t);
    return e.length === 1 ? e[0] : (0, x7.unionTypeAnnotation)(e);
  }
  n(g7, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var rS = w((Rp) => {
  "use strict";
  Object.defineProperty(Rp, "__esModule", {
    value: !0
  });
  Rp.default = tS;
  var Ea = jt();
  function eS(t) {
    return (0, Ea.isIdentifier)(t) ? t.name : `${t.right.name}.${eS(t.left)}`;
  }
  n(eS, "getQualifiedName");
  function tS(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Ea.isTSAnyKeyword)(l))
          return [l];
        if ((0, Ea.isTSBaseType)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, Ea.isTSUnionType)(l)) {
          i.has(l.types) || (e.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, Ea.isTSTypeReference)(l) && l.typeParameters) {
          let u = eS(l.typeName);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = tS(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(tS, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var sS = w((Up) => {
  "use strict";
  Object.defineProperty(Up, "__esModule", {
    value: !0
  });
  Up.default = v7;
  var P7 = pr(), E7 = rS(), A7 = jt();
  function v7(t) {
    let e = t.map((s) => (0, A7.isTSTypeAnnotation)(s) ? s.typeAnnotation : s), r = (0, E7.default)(e);
    return r.length === 1 ? r[0] : (0, P7.tsUnionType)(r);
  }
  n(v7, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var iS = w((N) => {
  "use strict";
  Object.defineProperty(N, "__esModule", {
    value: !0
  });
  Object.defineProperty(N, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(N, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.arrayExpression;
    }, "get")
  });
  Object.defineProperty(N, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.arrayPattern;
    }, "get")
  });
  Object.defineProperty(N, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(N, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(N, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(N, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.awaitExpression;
    }, "get")
  });
  Object.defineProperty(N, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(N, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.binaryExpression;
    }, "get")
  });
  Object.defineProperty(N, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.bindExpression;
    }, "get")
  });
  Object.defineProperty(N, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.blockStatement;
    }, "get")
  });
  Object.defineProperty(N, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(N, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.breakStatement;
    }, "get")
  });
  Object.defineProperty(N, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.callExpression;
    }, "get")
  });
  Object.defineProperty(N, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.catchClause;
    }, "get")
  });
  Object.defineProperty(N, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(N, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classBody;
    }, "get")
  });
  Object.defineProperty(N, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classExpression;
    }, "get")
  });
  Object.defineProperty(N, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classImplements;
    }, "get")
  });
  Object.defineProperty(N, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classMethod;
    }, "get")
  });
  Object.defineProperty(N, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(N, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(N, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.classProperty;
    }, "get")
  });
  Object.defineProperty(N, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(N, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.continueStatement;
    }, "get")
  });
  Object.defineProperty(N, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(N, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(N, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareClass;
    }, "get")
  });
  Object.defineProperty(N, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareFunction;
    }, "get")
  });
  Object.defineProperty(N, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareInterface;
    }, "get")
  });
  Object.defineProperty(N, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareModule;
    }, "get")
  });
  Object.defineProperty(N, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(N, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(N, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(N, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declareVariable;
    }, "get")
  });
  Object.defineProperty(N, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(N, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.decorator;
    }, "get")
  });
  Object.defineProperty(N, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.directive;
    }, "get")
  });
  Object.defineProperty(N, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(N, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.doExpression;
    }, "get")
  });
  Object.defineProperty(N, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(N, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.emptyStatement;
    }, "get")
  });
  Object.defineProperty(N, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(N, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(N, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(N, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(N, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(N, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumStringBody;
    }, "get")
  });
  Object.defineProperty(N, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumStringMember;
    }, "get")
  });
  Object.defineProperty(N, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(N, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.expressionStatement;
    }, "get")
  });
  Object.defineProperty(N, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.file;
    }, "get")
  });
  Object.defineProperty(N, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.forInStatement;
    }, "get")
  });
  Object.defineProperty(N, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.forOfStatement;
    }, "get")
  });
  Object.defineProperty(N, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.forStatement;
    }, "get")
  });
  Object.defineProperty(N, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.functionExpression;
    }, "get")
  });
  Object.defineProperty(N, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(N, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.identifier;
    }, "get")
  });
  Object.defineProperty(N, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.ifStatement;
    }, "get")
  });
  Object.defineProperty(N, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.import;
    }, "get")
  });
  Object.defineProperty(N, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importAttribute;
    }, "get")
  });
  Object.defineProperty(N, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importExpression;
    }, "get")
  });
  Object.defineProperty(N, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.importSpecifier;
    }, "get")
  });
  Object.defineProperty(N, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(N, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(N, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(N, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(N, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(N, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(N, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(N, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxElement;
    }, "get")
  });
  Object.defineProperty(N, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(N, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(N, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxFragment;
    }, "get")
  });
  Object.defineProperty(N, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(N, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(N, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(N, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(N, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(N, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(N, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(N, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.jsxText;
    }, "get")
  });
  Object.defineProperty(N, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.labeledStatement;
    }, "get")
  });
  Object.defineProperty(N, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.logicalExpression;
    }, "get")
  });
  Object.defineProperty(N, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.memberExpression;
    }, "get")
  });
  Object.defineProperty(N, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.metaProperty;
    }, "get")
  });
  Object.defineProperty(N, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.moduleExpression;
    }, "get")
  });
  Object.defineProperty(N, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.newExpression;
    }, "get")
  });
  Object.defineProperty(N, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.noop;
    }, "get")
  });
  Object.defineProperty(N, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.nullLiteral;
    }, "get")
  });
  Object.defineProperty(N, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.numberLiteral;
    }, "get")
  });
  Object.defineProperty(N, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.numericLiteral;
    }, "get")
  });
  Object.defineProperty(N, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectExpression;
    }, "get")
  });
  Object.defineProperty(N, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectMethod;
    }, "get")
  });
  Object.defineProperty(N, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectPattern;
    }, "get")
  });
  Object.defineProperty(N, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectProperty;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(N, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(N, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.opaqueType;
    }, "get")
  });
  Object.defineProperty(N, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(N, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(N, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(N, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(N, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(N, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(N, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(N, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.placeholder;
    }, "get")
  });
  Object.defineProperty(N, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.privateName;
    }, "get")
  });
  Object.defineProperty(N, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.program;
    }, "get")
  });
  Object.defineProperty(N, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(N, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.recordExpression;
    }, "get")
  });
  Object.defineProperty(N, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(N, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.regexLiteral;
    }, "get")
  });
  Object.defineProperty(N, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.restElement;
    }, "get")
  });
  Object.defineProperty(N, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.restProperty;
    }, "get")
  });
  Object.defineProperty(N, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.returnStatement;
    }, "get")
  });
  Object.defineProperty(N, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(N, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.spreadElement;
    }, "get")
  });
  Object.defineProperty(N, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.spreadProperty;
    }, "get")
  });
  Object.defineProperty(N, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.staticBlock;
    }, "get")
  });
  Object.defineProperty(N, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.stringLiteral;
    }, "get")
  });
  Object.defineProperty(N, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.super;
    }, "get")
  });
  Object.defineProperty(N, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.switchCase;
    }, "get")
  });
  Object.defineProperty(N, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.switchStatement;
    }, "get")
  });
  Object.defineProperty(N, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsArrayType;
    }, "get")
  });
  Object.defineProperty(N, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(N, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(N, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(N, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(N, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(N, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(N, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(N, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(N, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(N, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(N, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsImportType;
    }, "get")
  });
  Object.defineProperty(N, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(N, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(N, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsInferType;
    }, "get")
  });
  Object.defineProperty(N, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(N, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(N, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(N, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(N, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsMappedType;
    }, "get")
  });
  Object.defineProperty(N, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(N, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(N, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(N, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(N, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(N, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(N, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(N, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(N, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(N, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsRestType;
    }, "get")
  });
  Object.defineProperty(N, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(N, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsThisType;
    }, "get")
  });
  Object.defineProperty(N, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTupleType;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(N, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(N, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(N, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsUnionType;
    }, "get")
  });
  Object.defineProperty(N, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(N, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(N, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.templateElement;
    }, "get")
  });
  Object.defineProperty(N, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.templateLiteral;
    }, "get")
  });
  Object.defineProperty(N, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.thisExpression;
    }, "get")
  });
  Object.defineProperty(N, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.throwStatement;
    }, "get")
  });
  Object.defineProperty(N, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.topicReference;
    }, "get")
  });
  Object.defineProperty(N, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tryStatement;
    }, "get")
  });
  Object.defineProperty(N, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tupleExpression;
    }, "get")
  });
  Object.defineProperty(N, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeAlias;
    }, "get")
  });
  Object.defineProperty(N, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(N, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeParameter;
    }, "get")
  });
  Object.defineProperty(N, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(N, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.unaryExpression;
    }, "get")
  });
  Object.defineProperty(N, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.updateExpression;
    }, "get")
  });
  Object.defineProperty(N, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(N, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(N, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(N, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.variance;
    }, "get")
  });
  Object.defineProperty(N, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(N, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.whileStatement;
    }, "get")
  });
  Object.defineProperty(N, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.withStatement;
    }, "get")
  });
  Object.defineProperty(N, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k.yieldExpression;
    }, "get")
  });
  var k = pr();
});

// ../node_modules/@babel/types/lib/builders/productions.js
var Vp = w((qp) => {
  "use strict";
  Object.defineProperty(qp, "__esModule", {
    value: !0
  });
  qp.buildUndefinedNode = C7;
  var nS = pr();
  function C7() {
    return (0, nS.unaryExpression)("void", (0, nS.numericLiteral)(0), !0);
  }
  n(C7, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var Hs = w((Kp) => {
  "use strict";
  Object.defineProperty(Kp, "__esModule", {
    value: !0
  });
  Kp.default = I7;
  var aS = Br(), oS = jt(), {
    hasOwn: ys
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function lS(t, e, r, s) {
    return t && typeof t.type == "string" ? cS(t, e, r, s) : t;
  }
  n(lS, "cloneIfNode");
  function uS(t, e, r, s) {
    return Array.isArray(t) ? t.map((i) => lS(i, e, r, s)) : lS(t, e, r, s);
  }
  n(uS, "cloneIfNodeOrArray");
  function I7(t, e = !0, r = !1) {
    return cS(t, e, r, /* @__PURE__ */ new Map());
  }
  n(I7, "cloneNode");
  function cS(t, e = !0, r = !1, s) {
    if (!t) return t;
    let {
      type: i
    } = t, a = {
      type: t.type
    };
    if ((0, oS.isIdentifier)(t))
      a.name = t.name, ys(t, "optional") && typeof t.optional == "boolean" && (a.optional = t.optional), ys(t, "typeAnnotation") && (a.typeAnnotation =
      e ? uS(t.typeAnnotation, !0, r, s) : t.typeAnnotation);
    else if (ys(aS.NODE_FIELDS, i))
      for (let o of Object.keys(aS.NODE_FIELDS[i]))
        ys(t, o) && (e ? a[o] = (0, oS.isFile)(t) && o === "comments" ? Pl(t.comments, e, r, s) : uS(t[o], !0, r, s) : a[o] = t[o]);
    else
      throw new Error(`Unknown node type: "${i}"`);
    return ys(t, "loc") && (r ? a.loc = null : a.loc = t.loc), ys(t, "leadingComments") && (a.leadingComments = Pl(t.leadingComments, e, r, s)),
    ys(t, "innerComments") && (a.innerComments = Pl(t.innerComments, e, r, s)), ys(t, "trailingComments") && (a.trailingComments = Pl(t.trailingComments,
    e, r, s)), ys(t, "extra") && (a.extra = Object.assign({}, t.extra)), a;
  }
  n(cS, "cloneNodeInternal");
  function Pl(t, e, r, s) {
    return !t || !e ? t : t.map((i) => {
      let a = s.get(i);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = i, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), s.set(i, c), c;
    });
  }
  n(Pl, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var pS = w((Wp) => {
  "use strict";
  Object.defineProperty(Wp, "__esModule", {
    value: !0
  });
  Wp.default = N7;
  var w7 = Hs();
  function N7(t) {
    return (0, w7.default)(t, !1);
  }
  n(N7, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var fS = w((Yp) => {
  "use strict";
  Object.defineProperty(Yp, "__esModule", {
    value: !0
  });
  Yp.default = k7;
  var O7 = Hs();
  function k7(t) {
    return (0, O7.default)(t);
  }
  n(k7, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var hS = w((Jp) => {
  "use strict";
  Object.defineProperty(Jp, "__esModule", {
    value: !0
  });
  Jp.default = _7;
  var D7 = Hs();
  function _7(t) {
    return (0, D7.default)(t, !0, !0);
  }
  n(_7, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var dS = w((Xp) => {
  "use strict";
  Object.defineProperty(Xp, "__esModule", {
    value: !0
  });
  Xp.default = M7;
  var L7 = Hs();
  function M7(t) {
    return (0, L7.default)(t, !1, !0);
  }
  n(M7, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var Hp = w(($p) => {
  "use strict";
  Object.defineProperty($p, "__esModule", {
    value: !0
  });
  $p.default = B7;
  function B7(t, e, r) {
    if (!r || !t) return t;
    let s = `${e}Comments`;
    return t[s] ? e === "leading" ? t[s] = r.concat(t[s]) : t[s].push(...r) : t[s] = r, t;
  }
  n(B7, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var mS = w((zp) => {
  "use strict";
  Object.defineProperty(zp, "__esModule", {
    value: !0
  });
  zp.default = j7;
  var F7 = Hp();
  function j7(t, e, r, s) {
    return (0, F7.default)(t, e, [{
      type: s ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  n(j7, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var El = w((Gp) => {
  "use strict";
  Object.defineProperty(Gp, "__esModule", {
    value: !0
  });
  Gp.default = R7;
  function R7(t, e, r) {
    e && r && (e[t] = Array.from(new Set([].concat(e[t], r[t]).filter(Boolean))));
  }
  n(R7, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var Zp = w((Qp) => {
  "use strict";
  Object.defineProperty(Qp, "__esModule", {
    value: !0
  });
  Qp.default = q7;
  var U7 = El();
  function q7(t, e) {
    (0, U7.default)("innerComments", t, e);
  }
  n(q7, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var tf = w((ef) => {
  "use strict";
  Object.defineProperty(ef, "__esModule", {
    value: !0
  });
  ef.default = K7;
  var V7 = El();
  function K7(t, e) {
    (0, V7.default)("leadingComments", t, e);
  }
  n(K7, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var sf = w((rf) => {
  "use strict";
  Object.defineProperty(rf, "__esModule", {
    value: !0
  });
  rf.default = Y7;
  var W7 = El();
  function Y7(t, e) {
    (0, W7.default)("trailingComments", t, e);
  }
  n(Y7, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var af = w((nf) => {
  "use strict";
  Object.defineProperty(nf, "__esModule", {
    value: !0
  });
  nf.default = H7;
  var J7 = sf(), X7 = tf(), $7 = Zp();
  function H7(t, e) {
    return (0, J7.default)(t, e), (0, X7.default)(t, e), (0, $7.default)(t, e), t;
  }
  n(H7, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var yS = w((of) => {
  "use strict";
  Object.defineProperty(of, "__esModule", {
    value: !0
  });
  of.default = G7;
  var z7 = Js();
  function G7(t) {
    return z7.COMMENT_KEYS.forEach((e) => {
      t[e] = null;
    }), t;
  }
  n(G7, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var TS = w((H) => {
  "use strict";
  Object.defineProperty(H, "__esModule", {
    value: !0
  });
  H.WHILE_TYPES = H.USERWHITESPACABLE_TYPES = H.UNARYLIKE_TYPES = H.TYPESCRIPT_TYPES = H.TSTYPE_TYPES = H.TSTYPEELEMENT_TYPES = H.TSENTITYNAME_TYPES =
  H.TSBASETYPE_TYPES = H.TERMINATORLESS_TYPES = H.STATEMENT_TYPES = H.STANDARDIZED_TYPES = H.SCOPABLE_TYPES = H.PUREISH_TYPES = H.PROPERTY_TYPES =
  H.PRIVATE_TYPES = H.PATTERN_TYPES = H.PATTERNLIKE_TYPES = H.OBJECTMEMBER_TYPES = H.MODULESPECIFIER_TYPES = H.MODULEDECLARATION_TYPES = H.MISCELLANEOUS_TYPES =
  H.METHOD_TYPES = H.LVAL_TYPES = H.LOOP_TYPES = H.LITERAL_TYPES = H.JSX_TYPES = H.IMPORTOREXPORTDECLARATION_TYPES = H.IMMUTABLE_TYPES = H.FUNCTION_TYPES =
  H.FUNCTIONPARENT_TYPES = H.FOR_TYPES = H.FORXSTATEMENT_TYPES = H.FLOW_TYPES = H.FLOWTYPE_TYPES = H.FLOWPREDICATE_TYPES = H.FLOWDECLARATION_TYPES =
  H.FLOWBASEANNOTATION_TYPES = H.EXPRESSION_TYPES = H.EXPRESSIONWRAPPER_TYPES = H.EXPORTDECLARATION_TYPES = H.ENUMMEMBER_TYPES = H.ENUMBODY_TYPES =
  H.DECLARATION_TYPES = H.CONDITIONAL_TYPES = H.COMPLETIONSTATEMENT_TYPES = H.CLASS_TYPES = H.BLOCK_TYPES = H.BLOCKPARENT_TYPES = H.BINARY_TYPES =
  H.ACCESSOR_TYPES = void 0;
  var Fe = Br(), f3e = H.STANDARDIZED_TYPES = Fe.FLIPPED_ALIAS_KEYS.Standardized, h3e = H.EXPRESSION_TYPES = Fe.FLIPPED_ALIAS_KEYS.Expression,
  d3e = H.BINARY_TYPES = Fe.FLIPPED_ALIAS_KEYS.Binary, m3e = H.SCOPABLE_TYPES = Fe.FLIPPED_ALIAS_KEYS.Scopable, y3e = H.BLOCKPARENT_TYPES = Fe.
  FLIPPED_ALIAS_KEYS.BlockParent, T3e = H.BLOCK_TYPES = Fe.FLIPPED_ALIAS_KEYS.Block, b3e = H.STATEMENT_TYPES = Fe.FLIPPED_ALIAS_KEYS.Statement,
  x3e = H.TERMINATORLESS_TYPES = Fe.FLIPPED_ALIAS_KEYS.Terminatorless, S3e = H.COMPLETIONSTATEMENT_TYPES = Fe.FLIPPED_ALIAS_KEYS.CompletionStatement,
  g3e = H.CONDITIONAL_TYPES = Fe.FLIPPED_ALIAS_KEYS.Conditional, P3e = H.LOOP_TYPES = Fe.FLIPPED_ALIAS_KEYS.Loop, E3e = H.WHILE_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  While, A3e = H.EXPRESSIONWRAPPER_TYPES = Fe.FLIPPED_ALIAS_KEYS.ExpressionWrapper, v3e = H.FOR_TYPES = Fe.FLIPPED_ALIAS_KEYS.For, C3e = H.FORXSTATEMENT_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.ForXStatement, I3e = H.FUNCTION_TYPES = Fe.FLIPPED_ALIAS_KEYS.Function, w3e = H.FUNCTIONPARENT_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  FunctionParent, N3e = H.PUREISH_TYPES = Fe.FLIPPED_ALIAS_KEYS.Pureish, O3e = H.DECLARATION_TYPES = Fe.FLIPPED_ALIAS_KEYS.Declaration, k3e = H.
  PATTERNLIKE_TYPES = Fe.FLIPPED_ALIAS_KEYS.PatternLike, D3e = H.LVAL_TYPES = Fe.FLIPPED_ALIAS_KEYS.LVal, _3e = H.TSENTITYNAME_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  TSEntityName, L3e = H.LITERAL_TYPES = Fe.FLIPPED_ALIAS_KEYS.Literal, M3e = H.IMMUTABLE_TYPES = Fe.FLIPPED_ALIAS_KEYS.Immutable, B3e = H.USERWHITESPACABLE_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.UserWhitespacable, F3e = H.METHOD_TYPES = Fe.FLIPPED_ALIAS_KEYS.Method, j3e = H.OBJECTMEMBER_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  ObjectMember, R3e = H.PROPERTY_TYPES = Fe.FLIPPED_ALIAS_KEYS.Property, U3e = H.UNARYLIKE_TYPES = Fe.FLIPPED_ALIAS_KEYS.UnaryLike, q3e = H.
  PATTERN_TYPES = Fe.FLIPPED_ALIAS_KEYS.Pattern, V3e = H.CLASS_TYPES = Fe.FLIPPED_ALIAS_KEYS.Class, Q7 = H.IMPORTOREXPORTDECLARATION_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, K3e = H.EXPORTDECLARATION_TYPES = Fe.FLIPPED_ALIAS_KEYS.ExportDeclaration, W3e = H.MODULESPECIFIER_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.ModuleSpecifier, Y3e = H.ACCESSOR_TYPES = Fe.FLIPPED_ALIAS_KEYS.Accessor, J3e = H.PRIVATE_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  Private, X3e = H.FLOW_TYPES = Fe.FLIPPED_ALIAS_KEYS.Flow, $3e = H.FLOWTYPE_TYPES = Fe.FLIPPED_ALIAS_KEYS.FlowType, H3e = H.FLOWBASEANNOTATION_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, z3e = H.FLOWDECLARATION_TYPES = Fe.FLIPPED_ALIAS_KEYS.FlowDeclaration, G3e = H.FLOWPREDICATE_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.FlowPredicate, Q3e = H.ENUMBODY_TYPES = Fe.FLIPPED_ALIAS_KEYS.EnumBody, Z3e = H.ENUMMEMBER_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  EnumMember, eBe = H.JSX_TYPES = Fe.FLIPPED_ALIAS_KEYS.JSX, tBe = H.MISCELLANEOUS_TYPES = Fe.FLIPPED_ALIAS_KEYS.Miscellaneous, rBe = H.TYPESCRIPT_TYPES =
  Fe.FLIPPED_ALIAS_KEYS.TypeScript, sBe = H.TSTYPEELEMENT_TYPES = Fe.FLIPPED_ALIAS_KEYS.TSTypeElement, iBe = H.TSTYPE_TYPES = Fe.FLIPPED_ALIAS_KEYS.
  TSType, nBe = H.TSBASETYPE_TYPES = Fe.FLIPPED_ALIAS_KEYS.TSBaseType, aBe = H.MODULEDECLARATION_TYPES = Q7;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var cf = w((uf) => {
  "use strict";
  Object.defineProperty(uf, "__esModule", {
    value: !0
  });
  uf.default = Z7;
  var Al = jt(), lf = pr();
  function Z7(t, e) {
    if ((0, Al.isBlockStatement)(t))
      return t;
    let r = [];
    return (0, Al.isEmptyStatement)(t) ? r = [] : ((0, Al.isStatement)(t) || ((0, Al.isFunction)(e) ? t = (0, lf.returnStatement)(t) : t = (0, lf.
    expressionStatement)(t)), r = [t]), (0, lf.blockStatement)(r);
  }
  n(Z7, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var bS = w((pf) => {
  "use strict";
  Object.defineProperty(pf, "__esModule", {
    value: !0
  });
  pf.default = tU;
  var eU = cf();
  function tU(t, e = "body") {
    let r = (0, eU.default)(t[e], t);
    return t[e] = r, r;
  }
  n(tU, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var hf = w((ff) => {
  "use strict";
  Object.defineProperty(ff, "__esModule", {
    value: !0
  });
  ff.default = iU;
  var rU = pn(), sU = ya();
  function iU(t) {
    t = t + "";
    let e = "";
    for (let r of t)
      e += (0, sU.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return e = e.replace(/^[-0-9]+/, ""), e = e.replace(/[-\s]+(.)?/g, function(r, s) {
      return s ? s.toUpperCase() : "";
    }), (0, rU.default)(e) || (e = `_${e}`), e || "_";
  }
  n(iU, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var xS = w((df) => {
  "use strict";
  Object.defineProperty(df, "__esModule", {
    value: !0
  });
  df.default = aU;
  var nU = hf();
  function aU(t) {
    return t = (0, nU.default)(t), (t === "eval" || t === "arguments") && (t = "_" + t), t;
  }
  n(aU, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var SS = w((mf) => {
  "use strict";
  Object.defineProperty(mf, "__esModule", {
    value: !0
  });
  mf.default = uU;
  var oU = jt(), lU = pr();
  function uU(t, e = t.key || t.property) {
    return !t.computed && (0, oU.isIdentifier)(e) && (e = (0, lU.stringLiteral)(e.name)), e;
  }
  n(uU, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var gS = w((vl) => {
  "use strict";
  Object.defineProperty(vl, "__esModule", {
    value: !0
  });
  vl.default = void 0;
  var Aa = jt(), bBe = vl.default = cU;
  function cU(t) {
    if ((0, Aa.isExpressionStatement)(t) && (t = t.expression), (0, Aa.isExpression)(t))
      return t;
    if ((0, Aa.isClass)(t) ? t.type = "ClassExpression" : (0, Aa.isFunction)(t) && (t.type = "FunctionExpression"), !(0, Aa.isExpression)(t))
      throw new Error(`cannot turn ${t.type} to an expression`);
    return t;
  }
  n(cU, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var bf = w((Tf) => {
  "use strict";
  Object.defineProperty(Tf, "__esModule", {
    value: !0
  });
  Tf.default = yf;
  var pU = Br();
  function yf(t, e, r) {
    if (!t) return;
    let s = pU.VISITOR_KEYS[t.type];
    if (s) {
      r = r || {}, e(t, r);
      for (let i of s) {
        let a = t[i];
        if (Array.isArray(a))
          for (let o of a)
            yf(o, e, r);
        else
          yf(a, e, r);
      }
    }
  }
  n(yf, "traverseFast");
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var Sf = w((xf) => {
  "use strict";
  Object.defineProperty(xf, "__esModule", {
    value: !0
  });
  xf.default = dU;
  var fU = Js(), PS = ["tokens", "start", "end", "loc", "raw", "rawValue"], hU = [...fU.COMMENT_KEYS, "comments", ...PS];
  function dU(t, e = {}) {
    let r = e.preserveComments ? PS : hU;
    for (let i of r)
      t[i] != null && (t[i] = void 0);
    for (let i of Object.keys(t))
      i[0] === "_" && t[i] != null && (t[i] = void 0);
    let s = Object.getOwnPropertySymbols(t);
    for (let i of s)
      t[i] = null;
  }
  n(dU, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var Pf = w((gf) => {
  "use strict";
  Object.defineProperty(gf, "__esModule", {
    value: !0
  });
  gf.default = TU;
  var mU = bf(), yU = Sf();
  function TU(t, e) {
    return (0, mU.default)(t, yU.default, e), t;
  }
  n(TU, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var AS = w((Ef) => {
  "use strict";
  Object.defineProperty(Ef, "__esModule", {
    value: !0
  });
  Ef.default = Ni;
  var ES = jt(), bU = Hs(), xU = Pf();
  function Ni(t, e = t.key) {
    let r;
    return t.kind === "method" ? Ni.increment() + "" : ((0, ES.isIdentifier)(e) ? r = e.name : (0, ES.isStringLiteral)(e) ? r = JSON.stringify(
    e.value) : r = JSON.stringify((0, xU.default)((0, bU.default)(e))), t.computed && (r = `[${r}]`), t.static && (r = `static:${r}`), r);
  }
  n(Ni, "toKeyAlias");
  Ni.uid = 0;
  Ni.increment = function() {
    return Ni.uid >= Number.MAX_SAFE_INTEGER ? Ni.uid = 0 : Ni.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var vS = w((Il) => {
  "use strict";
  Object.defineProperty(Il, "__esModule", {
    value: !0
  });
  Il.default = void 0;
  var Cl = jt(), SU = pr(), NBe = Il.default = gU;
  function gU(t, e) {
    if ((0, Cl.isStatement)(t))
      return t;
    let r = !1, s;
    if ((0, Cl.isClass)(t))
      r = !0, s = "ClassDeclaration";
    else if ((0, Cl.isFunction)(t))
      r = !0, s = "FunctionDeclaration";
    else if ((0, Cl.isAssignmentExpression)(t))
      return (0, SU.expressionStatement)(t);
    if (r && !t.id && (s = !1), !s) {
      if (e)
        return !1;
      throw new Error(`cannot turn ${t.type} to a statement`);
    }
    return t.type = s, t;
  }
  n(gU, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var CS = w((wl) => {
  "use strict";
  Object.defineProperty(wl, "__esModule", {
    value: !0
  });
  wl.default = void 0;
  var PU = pn(), rr = pr(), DBe = wl.default = Af, EU = Function.call.bind(Object.prototype.toString);
  function AU(t) {
    return EU(t) === "[object RegExp]";
  }
  n(AU, "isRegExp");
  function vU(t) {
    if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
      return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null;
  }
  n(vU, "isPlainObject");
  function Af(t) {
    if (t === void 0)
      return (0, rr.identifier)("undefined");
    if (t === !0 || t === !1)
      return (0, rr.booleanLiteral)(t);
    if (t === null)
      return (0, rr.nullLiteral)();
    if (typeof t == "string")
      return (0, rr.stringLiteral)(t);
    if (typeof t == "number") {
      let e;
      if (Number.isFinite(t))
        e = (0, rr.numericLiteral)(Math.abs(t));
      else {
        let r;
        Number.isNaN(t) ? r = (0, rr.numericLiteral)(0) : r = (0, rr.numericLiteral)(1), e = (0, rr.binaryExpression)("/", r, (0, rr.numericLiteral)(
        0));
      }
      return (t < 0 || Object.is(t, -0)) && (e = (0, rr.unaryExpression)("-", e)), e;
    }
    if (AU(t)) {
      let e = t.source, r = t.toString().match(/\/([a-z]+|)$/)[1];
      return (0, rr.regExpLiteral)(e, r);
    }
    if (Array.isArray(t))
      return (0, rr.arrayExpression)(t.map(Af));
    if (vU(t)) {
      let e = [];
      for (let r of Object.keys(t)) {
        let s;
        (0, PU.default)(r) ? s = (0, rr.identifier)(r) : s = (0, rr.stringLiteral)(r), e.push((0, rr.objectProperty)(s, Af(t[r])));
      }
      return (0, rr.objectExpression)(e);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  n(Af, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var IS = w((vf) => {
  "use strict";
  Object.defineProperty(vf, "__esModule", {
    value: !0
  });
  vf.default = IU;
  var CU = pr();
  function IU(t, e, r = !1) {
    return t.object = (0, CU.memberExpression)(t.object, t.property, t.computed), t.property = e, t.computed = !!r, t;
  }
  n(IU, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var NS = w((Cf) => {
  "use strict";
  Object.defineProperty(Cf, "__esModule", {
    value: !0
  });
  Cf.default = NU;
  var wS = Js(), wU = af();
  function NU(t, e) {
    if (!t || !e) return t;
    for (let r of wS.INHERIT_KEYS.optional)
      t[r] == null && (t[r] = e[r]);
    for (let r of Object.keys(e))
      r[0] === "_" && r !== "__clone" && (t[r] = e[r]);
    for (let r of wS.INHERIT_KEYS.force)
      t[r] = e[r];
    return (0, wU.default)(t, e), t;
  }
  n(NU, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var OS = w((If) => {
  "use strict";
  Object.defineProperty(If, "__esModule", {
    value: !0
  });
  If.default = DU;
  var OU = pr(), kU = Ce();
  function DU(t, e) {
    if ((0, kU.isSuper)(t.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return t.object = (0, OU.memberExpression)(e, t.object), t;
  }
  n(DU, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var va = w((Nf) => {
  "use strict";
  Object.defineProperty(Nf, "__esModule", {
    value: !0
  });
  Nf.default = wf;
  var Ts = jt();
  function wf(t, e, r, s) {
    let i = [].concat(t), a = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let o = i.shift();
      if (!o || s && ((0, Ts.isAssignmentExpression)(o) || (0, Ts.isUnaryExpression)(o) || (0, Ts.isUpdateExpression)(o)))
        continue;
      if ((0, Ts.isIdentifier)(o)) {
        e ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, Ts.isExportDeclaration)(o) && !(0, Ts.isExportAllDeclaration)(o)) {
        (0, Ts.isDeclaration)(o.declaration) && i.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, Ts.isFunctionDeclaration)(o)) {
          i.push(o.id);
          continue;
        }
        if ((0, Ts.isFunctionExpression)(o))
          continue;
      }
      let l = wf.keys[o.type];
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], p = o[c];
          p && (Array.isArray(p) ? i.push(...p) : i.push(p));
        }
    }
    return a;
  }
  n(wf, "getBindingIdentifiers");
  wf.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var kS = w((Nl) => {
  "use strict";
  Object.defineProperty(Nl, "__esModule", {
    value: !0
  });
  Nl.default = void 0;
  var _U = va(), KBe = Nl.default = LU;
  function LU(t, e) {
    return (0, _U.default)(t, e, !0);
  }
  n(LU, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var DS = w((kf) => {
  "use strict";
  Object.defineProperty(kf, "__esModule", {
    value: !0
  });
  kf.default = BU;
  var MU = Br();
  function BU(t, e, r) {
    typeof e == "function" && (e = {
      enter: e
    });
    let {
      enter: s,
      exit: i
    } = e;
    Of(t, s, i, r, []);
  }
  n(BU, "traverse");
  function Of(t, e, r, s, i) {
    let a = MU.VISITOR_KEYS[t.type];
    if (a) {
      e && e(t, i, s);
      for (let o of a) {
        let l = t[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (i.push({
              node: t,
              key: o,
              index: u
            }), Of(c, e, r, s, i), i.pop());
          }
        else l && (i.push({
          node: t,
          key: o
        }), Of(l, e, r, s, i), i.pop());
      }
      r && r(t, i, s);
    }
  }
  n(Of, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var _S = w((Df) => {
  "use strict";
  Object.defineProperty(Df, "__esModule", {
    value: !0
  });
  Df.default = jU;
  var FU = va();
  function jU(t, e, r) {
    if (r && t.type === "Identifier" && e.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let s = FU.default.keys[e.type];
    if (s)
      for (let i = 0; i < s.length; i++) {
        let a = s[i], o = e[a];
        if (Array.isArray(o)) {
          if (o.indexOf(t) >= 0) return !0;
        } else if (o === t) return !0;
      }
    return !1;
  }
  n(jU, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var Lf = w((_f) => {
  "use strict";
  Object.defineProperty(_f, "__esModule", {
    value: !0
  });
  _f.default = qU;
  var RU = jt(), UU = Js();
  function qU(t) {
    return (0, RU.isVariableDeclaration)(t) && (t.kind !== "var" || t[UU.BLOCK_SCOPED_SYMBOL]);
  }
  n(qU, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var MS = w((Mf) => {
  "use strict";
  Object.defineProperty(Mf, "__esModule", {
    value: !0
  });
  Mf.default = KU;
  var LS = jt(), VU = Lf();
  function KU(t) {
    return (0, LS.isFunctionDeclaration)(t) || (0, LS.isClassDeclaration)(t) || (0, VU.default)(t);
  }
  n(KU, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var BS = w((Bf) => {
  "use strict";
  Object.defineProperty(Bf, "__esModule", {
    value: !0
  });
  Bf.default = JU;
  var WU = cl(), YU = jt();
  function JU(t) {
    return (0, WU.default)(t.type, "Immutable") ? !0 : (0, YU.isIdentifier)(t) ? t.name === "undefined" : !1;
  }
  n(JU, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var jS = w((jf) => {
  "use strict";
  Object.defineProperty(jf, "__esModule", {
    value: !0
  });
  jf.default = Ff;
  var FS = Br();
  function Ff(t, e) {
    if (typeof t != "object" || typeof e != "object" || t == null || e == null)
      return t === e;
    if (t.type !== e.type)
      return !1;
    let r = Object.keys(FS.NODE_FIELDS[t.type] || t.type), s = FS.VISITOR_KEYS[t.type];
    for (let i of r) {
      let a = t[i], o = e[i];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!Ff(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(s != null && s.includes(i))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!Ff(a, o))
          return !1;
      }
    }
    return !0;
  }
  n(Ff, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var RS = w((Rf) => {
  "use strict";
  Object.defineProperty(Rf, "__esModule", {
    value: !0
  });
  Rf.default = XU;
  function XU(t, e, r) {
    switch (e.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e.property === t ? !!e.computed : e.object === t;
      case "JSXMemberExpression":
        return e.object === t;
      case "VariableDeclarator":
        return e.init === t;
      case "ArrowFunctionExpression":
        return e.body === t;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return e.key === t ? !!e.computed : !1;
      case "ObjectProperty":
        return e.key === t ? !!e.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return e.key === t ? !!e.computed : !0;
      case "ClassPrivateProperty":
        return e.key !== t;
      case "ClassDeclaration":
      case "ClassExpression":
        return e.superClass === t;
      case "AssignmentExpression":
        return e.right === t;
      case "AssignmentPattern":
        return e.right === t;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : e.local === t;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return e.key !== t;
      case "TSEnumMember":
        return e.id !== t;
      case "TSPropertySignature":
        return e.key === t ? !!e.computed : !0;
    }
    return !0;
  }
  n(XU, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var US = w((Uf) => {
  "use strict";
  Object.defineProperty(Uf, "__esModule", {
    value: !0
  });
  Uf.default = $U;
  var Oi = jt();
  function $U(t, e) {
    return (0, Oi.isBlockStatement)(t) && ((0, Oi.isFunction)(e) || (0, Oi.isCatchClause)(e)) ? !1 : (0, Oi.isPattern)(t) && ((0, Oi.isFunction)(
    e) || (0, Oi.isCatchClause)(e)) ? !0 : (0, Oi.isScopable)(t);
  }
  n($U, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var VS = w((qf) => {
  "use strict";
  Object.defineProperty(qf, "__esModule", {
    value: !0
  });
  qf.default = HU;
  var qS = jt();
  function HU(t) {
    return (0, qS.isImportDefaultSpecifier)(t) || (0, qS.isIdentifier)(t.imported || t.exported, {
      name: "default"
    });
  }
  n(HU, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var KS = w((Vf) => {
  "use strict";
  Object.defineProperty(Vf, "__esModule", {
    value: !0
  });
  Vf.default = QU;
  var zU = pn(), GU = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implement\
s", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transie\
nt", "volatile"]);
  function QU(t) {
    return (0, zU.default)(t) && !GU.has(t);
  }
  n(QU, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var WS = w((Kf) => {
  "use strict";
  Object.defineProperty(Kf, "__esModule", {
    value: !0
  });
  Kf.default = tq;
  var ZU = jt(), eq = Js();
  function tq(t) {
    return (0, ZU.isVariableDeclaration)(t, {
      kind: "var"
    }) && !t[eq.BLOCK_SCOPED_SYMBOL];
  }
  n(tq, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var YS = w((Jf) => {
  "use strict";
  Object.defineProperty(Jf, "__esModule", {
    value: !0
  });
  Jf.default = Ol;
  var rq = va(), ki = jt(), Wf = pr(), Yf = Vp(), sq = Hs();
  function Ol(t, e) {
    let r = [], s = !0;
    for (let i of t)
      if ((0, ki.isEmptyStatement)(i) || (s = !1), (0, ki.isExpression)(i))
        r.push(i);
      else if ((0, ki.isExpressionStatement)(i))
        r.push(i.expression);
      else if ((0, ki.isVariableDeclaration)(i)) {
        if (i.kind !== "var") return;
        for (let a of i.declarations) {
          let o = (0, rq.default)(a);
          for (let l of Object.keys(o))
            e.push({
              kind: i.kind,
              id: (0, sq.default)(o[l])
            });
          a.init && r.push((0, Wf.assignmentExpression)("=", a.id, a.init));
        }
        s = !0;
      } else if ((0, ki.isIfStatement)(i)) {
        let a = i.consequent ? Ol([i.consequent], e) : (0, Yf.buildUndefinedNode)(), o = i.alternate ? Ol([i.alternate], e) : (0, Yf.buildUndefinedNode)();
        if (!a || !o) return;
        r.push((0, Wf.conditionalExpression)(i.test, a, o));
      } else if ((0, ki.isBlockStatement)(i)) {
        let a = Ol(i.body, e);
        if (!a) return;
        r.push(a);
      } else if ((0, ki.isEmptyStatement)(i))
        t.indexOf(i) === 0 && (s = !0);
      else
        return;
    return s && r.push((0, Yf.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, Wf.sequenceExpression)(r);
  }
  n(Ol, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var JS = w((Xf) => {
  "use strict";
  Object.defineProperty(Xf, "__esModule", {
    value: !0
  });
  Xf.default = nq;
  var iq = YS();
  function nq(t, e) {
    if (!(t != null && t.length)) return;
    let r = [], s = (0, iq.default)(t, r);
    if (s) {
      for (let i of r)
        e.push(i);
      return s;
    }
  }
  n(nq, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var Ce = w((te) => {
  "use strict";
  Object.defineProperty(te, "__esModule", {
    value: !0
  });
  var bs = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(te, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return oV.default;
    }, "get")
  });
  Object.defineProperty(te, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Tq.default;
    }, "get")
  });
  Object.defineProperty(te, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bq.default;
    }, "get")
  });
  Object.defineProperty(te, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return _q.default;
    }, "get")
  });
  Object.defineProperty(te, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return uq.default;
    }, "get")
  });
  Object.defineProperty(te, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return aV.default;
    }, "get")
  });
  Object.defineProperty(te, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hq.default;
    }, "get")
  });
  Object.defineProperty(te, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return dq.default;
    }, "get")
  });
  Object.defineProperty(te, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return mq.default;
    }, "get")
  });
  Object.defineProperty(te, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fq.default;
    }, "get")
  });
  Object.defineProperty(te, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yq.default;
    }, "get")
  });
  Object.defineProperty(te, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return XS.default;
    }, "get")
  });
  Object.defineProperty(te, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pq.default;
    }, "get")
  });
  Object.defineProperty(te, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return cq.default;
    }, "get")
  });
  Object.defineProperty(te, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return XS.default;
    }, "get")
  });
  Object.defineProperty(te, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Aq.default;
    }, "get")
  });
  Object.defineProperty(te, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Rq.default;
    }, "get")
  });
  Object.defineProperty(te, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uq.default;
    }, "get")
  });
  Object.defineProperty(te, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xq.default;
    }, "get")
  });
  Object.defineProperty(te, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Sq.default;
    }, "get")
  });
  Object.defineProperty(te, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Pq.default;
    }, "get")
  });
  Object.defineProperty(te, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Lq.default;
    }, "get")
  });
  Object.defineProperty(te, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gq.default;
    }, "get")
  });
  Object.defineProperty(te, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Kq.default;
    }, "get")
  });
  Object.defineProperty(te, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Wq.default;
    }, "get")
  });
  Object.defineProperty(te, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Yq.default;
    }, "get")
  });
  Object.defineProperty(te, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Jq.default;
    }, "get")
  });
  Object.defineProperty(te, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Xq.default;
    }, "get")
  });
  Object.defineProperty(te, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $q.default;
    }, "get")
  });
  Object.defineProperty(te, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Hq.default;
    }, "get")
  });
  Object.defineProperty(te, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return zq.default;
    }, "get")
  });
  Object.defineProperty(te, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gq.default;
    }, "get")
  });
  Object.defineProperty(te, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qq.default;
    }, "get")
  });
  Object.defineProperty(te, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Zq.default;
    }, "get")
  });
  Object.defineProperty(te, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return eV.default;
    }, "get")
  });
  Object.defineProperty(te, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return tV.default;
    }, "get")
  });
  Object.defineProperty(te, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rV.default;
    }, "get")
  });
  Object.defineProperty(te, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return sV.default;
    }, "get")
  });
  Object.defineProperty(te, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return iV.default;
    }, "get")
  });
  Object.defineProperty(te, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Mq.default;
    }, "get")
  });
  te.react = void 0;
  Object.defineProperty(te, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Eq.default;
    }, "get")
  });
  Object.defineProperty(te, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bq.default;
    }, "get")
  });
  Object.defineProperty(te, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Fq.default;
    }, "get")
  });
  Object.defineProperty(te, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jq.default;
    }, "get")
  });
  Object.defineProperty(te, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Vq.default;
    }, "get")
  });
  Object.defineProperty(te, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vq.default;
    }, "get")
  });
  Object.defineProperty(te, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Cq.default;
    }, "get")
  });
  Object.defineProperty(te, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Iq.default;
    }, "get")
  });
  Object.defineProperty(te, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wq.default;
    }, "get")
  });
  Object.defineProperty(te, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Nq.default;
    }, "get")
  });
  Object.defineProperty(te, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Oq.default;
    }, "get")
  });
  Object.defineProperty(te, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kq.default;
    }, "get")
  });
  Object.defineProperty(te, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kl.default;
    }, "get")
  });
  Object.defineProperty(te, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return qq.default;
    }, "get")
  });
  Object.defineProperty(te, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nV.default;
    }, "get")
  });
  Object.defineProperty(te, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Dq.default;
    }, "get")
  });
  var aq = Zb(), oq = ex(), lq = Xx(), uq = $x(), $f = Hx();
  Object.keys($f).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === $f[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return $f[t];
      }, "get")
    });
  });
  var cq = zx(), XS = Zx(), pq = sS(), Hf = pr();
  Object.keys(Hf).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === Hf[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Hf[t];
      }, "get")
    });
  });
  var zf = iS();
  Object.keys(zf).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === zf[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return zf[t];
      }, "get")
    });
  });
  var Gf = Vp();
  Object.keys(Gf).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === Gf[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Gf[t];
      }, "get")
    });
  });
  var fq = Hs(), hq = pS(), dq = fS(), mq = hS(), yq = dS(), Tq = mS(), bq = Hp(), xq = Zp(), Sq = tf(), gq = af(), Pq = sf(), Eq = yS(), Qf = TS();
  Object.keys(Qf).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === Qf[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Qf[t];
      }, "get")
    });
  });
  var Zf = Js();
  Object.keys(Zf).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === Zf[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Zf[t];
      }, "get")
    });
  });
  var Aq = bS(), vq = xS(), Cq = cf(), Iq = SS(), wq = gS(), Nq = hf(), Oq = AS(), kq = vS(), Dq = CS(), eh = Br();
  Object.keys(eh).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === eh[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return eh[t];
      }, "get")
    });
  });
  var _q = IS(), Lq = NS(), Mq = OS(), Bq = Sf(), Fq = Pf(), jq = Fp(), Rq = va(), Uq = kS(), kl = DS();
  Object.keys(kl).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === kl[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return kl[t];
      }, "get")
    });
  });
  var qq = bf(), Vq = ll(), Kq = cn(), Wq = _S(), Yq = MS(), Jq = BS(), Xq = Lf(), $q = Lp(), Hq = jS(), zq = op(), Gq = RS(), Qq = US(), Zq = VS(),
  eV = cl(), tV = KS(), rV = pn(), sV = WS(), iV = ep(), nV = ml(), aV = rp(), th = jt();
  Object.keys(th).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(bs, t) || t in te && te[t] === th[t] || Object.defineProperty(
    te, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return th[t];
      }, "get")
    });
  });
  var oV = ua(), bFe = te.react = {
    isReactComponent: aq.default,
    isCompatTag: oq.default,
    buildChildren: lq.default
  };
  te.toSequenceExpression = JS().default;
});

// ../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var HS = w((Dl, $S) => {
  (function(t, e) {
    typeof Dl == "object" && typeof $S < "u" ? e(Dl) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.setArray = {}));
  })(Dl, function(t) {
    "use strict";
    class e {
      static {
        n(this, "SetArray");
      }
      constructor() {
        this._indexes = { __proto__: null }, this.array = [];
      }
    }
    function r(l) {
      return l;
    }
    n(r, "cast");
    function s(l, u) {
      return l._indexes[u];
    }
    n(s, "get");
    function i(l, u) {
      let c = s(l, u);
      if (c !== void 0)
        return c;
      let { array: p, _indexes: f } = l, m = p.push(u);
      return f[u] = m - 1;
    }
    n(i, "put");
    function a(l) {
      let { array: u, _indexes: c } = l;
      if (u.length === 0)
        return;
      let p = u.pop();
      c[p] = void 0;
    }
    n(a, "pop");
    function o(l, u) {
      let c = s(l, u);
      if (c === void 0)
        return;
      let { array: p, _indexes: f } = l;
      for (let m = c + 1; m < p.length; m++) {
        let y = p[m];
        p[m - 1] = y, f[y]--;
      }
      f[u] = void 0, p.pop();
    }
    n(o, "remove"), t.SetArray = e, t.get = s, t.pop = a, t.put = i, t.remove = o, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var rh = w((_l, zS) => {
  (function(t, e) {
    typeof _l == "object" && typeof zS < "u" ? e(_l) : typeof define == "function" && define.amd ? define(["exports"], e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, e(t.sourcemapCodec = {}));
  })(_l, function(t) {
    "use strict";
    let s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = new Uint8Array(64), a = new Uint8Array(128);
    for (let L = 0; L < s.length; L++) {
      let q = s.charCodeAt(L);
      i[L] = q, a[q] = L;
    }
    let o = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
      decode(L) {
        return Buffer.from(L.buffer, L.byteOffset, L.byteLength).toString();
      }
    } : {
      decode(L) {
        let q = "";
        for (let _ = 0; _ < L.length; _++)
          q += String.fromCharCode(L[_]);
        return q;
      }
    };
    function l(L) {
      let q = new Int32Array(5), _ = [], U = 0;
      do {
        let J = u(L, U), ie = [], de = !0, ne = 0;
        q[0] = 0;
        for (let Be = U; Be < J; Be++) {
          let bt;
          Be = c(L, Be, q, 0);
          let Et = q[0];
          Et < ne && (de = !1), ne = Et, p(L, Be, J) ? (Be = c(L, Be, q, 1), Be = c(L, Be, q, 2), Be = c(L, Be, q, 3), p(L, Be, J) ? (Be = c(
          L, Be, q, 4), bt = [Et, q[1], q[2], q[3], q[4]]) : bt = [Et, q[1], q[2], q[3]]) : bt = [Et], ie.push(bt);
        }
        de || f(ie), _.push(ie), U = J + 1;
      } while (U <= L.length);
      return _;
    }
    n(l, "decode");
    function u(L, q) {
      let _ = L.indexOf(";", q);
      return _ === -1 ? L.length : _;
    }
    n(u, "indexOf");
    function c(L, q, _, U) {
      let J = 0, ie = 0, de = 0;
      do {
        let Be = L.charCodeAt(q++);
        de = a[Be], J |= (de & 31) << ie, ie += 5;
      } while (de & 32);
      let ne = J & 1;
      return J >>>= 1, ne && (J = -2147483648 | -J), _[U] += J, q;
    }
    n(c, "decodeInteger");
    function p(L, q, _) {
      return q >= _ ? !1 : L.charCodeAt(q) !== 44;
    }
    n(p, "hasMoreVlq");
    function f(L) {
      L.sort(m);
    }
    n(f, "sort");
    function m(L, q) {
      return L[0] - q[0];
    }
    n(m, "sortComparator");
    function y(L) {
      let q = new Int32Array(5), _ = 1024 * 16, U = _ - 36, J = new Uint8Array(_), ie = J.subarray(0, U), de = 0, ne = "";
      for (let Be = 0; Be < L.length; Be++) {
        let bt = L[Be];
        if (Be > 0 && (de === _ && (ne += o.decode(J), de = 0), J[de++] = 59), bt.length !== 0) {
          q[0] = 0;
          for (let Et = 0; Et < bt.length; Et++) {
            let Jt = bt[Et];
            de > U && (ne += o.decode(ie), J.copyWithin(0, U, de), de -= U), Et > 0 && (J[de++] = 44), de = T(J, de, q, Jt, 0), Jt.length !==
            1 && (de = T(J, de, q, Jt, 1), de = T(J, de, q, Jt, 2), de = T(J, de, q, Jt, 3), Jt.length !== 4 && (de = T(J, de, q, Jt, 4)));
          }
        }
      }
      return ne + o.decode(J.subarray(0, de));
    }
    n(y, "encode");
    function T(L, q, _, U, J) {
      let ie = U[J], de = ie - _[J];
      _[J] = ie, de = de < 0 ? -de << 1 | 1 : de << 1;
      do {
        let ne = de & 31;
        de >>>= 5, de > 0 && (ne |= 32), L[q++] = i[ne];
      } while (de > 0);
      return q;
    }
    n(T, "encodeInteger"), t.decode = l, t.encode = y, Object.defineProperty(t, "__esModule", { value: !0 });
  });
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var GS = w((sh, ih) => {
  (function(t, e) {
    typeof sh == "object" && typeof ih < "u" ? ih.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis <
    "u" ? globalThis : t || self, t.resolveURI = e());
  })(sh, function() {
    "use strict";
    let t = /^[\w+.-]+:\/\//, e = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var s;
    (function(_) {
      _[_.Empty = 1] = "Empty", _[_.Hash = 2] = "Hash", _[_.Query = 3] = "Query", _[_.RelativePath = 4] = "RelativePath", _[_.AbsolutePath =
      5] = "AbsolutePath", _[_.SchemeRelative = 6] = "SchemeRelative", _[_.Absolute = 7] = "Absolute";
    })(s || (s = {}));
    function i(_) {
      return t.test(_);
    }
    n(i, "isAbsoluteUrl");
    function a(_) {
      return _.startsWith("//");
    }
    n(a, "isSchemeRelativeUrl");
    function o(_) {
      return _.startsWith("/");
    }
    n(o, "isAbsolutePath");
    function l(_) {
      return _.startsWith("file:");
    }
    n(l, "isFileUrl");
    function u(_) {
      return /^[.?#]/.test(_);
    }
    n(u, "isRelative");
    function c(_) {
      let U = e.exec(_);
      return f(U[1], U[2] || "", U[3], U[4] || "", U[5] || "/", U[6] || "", U[7] || "");
    }
    n(c, "parseAbsoluteUrl");
    function p(_) {
      let U = r.exec(_), J = U[2];
      return f("file:", "", U[1] || "", "", o(J) ? J : "/" + J, U[3] || "", U[4] || "");
    }
    n(p, "parseFileUrl");
    function f(_, U, J, ie, de, ne, Be) {
      return {
        scheme: _,
        user: U,
        host: J,
        port: ie,
        path: de,
        query: ne,
        hash: Be,
        type: s.Absolute
      };
    }
    n(f, "makeUrl");
    function m(_) {
      if (a(_)) {
        let J = c("http:" + _);
        return J.scheme = "", J.type = s.SchemeRelative, J;
      }
      if (o(_)) {
        let J = c("http://foo.com" + _);
        return J.scheme = "", J.host = "", J.type = s.AbsolutePath, J;
      }
      if (l(_))
        return p(_);
      if (i(_))
        return c(_);
      let U = c("http://foo.com/" + _);
      return U.scheme = "", U.host = "", U.type = _ ? _.startsWith("?") ? s.Query : _.startsWith("#") ? s.Hash : s.RelativePath : s.Empty, U;
    }
    n(m, "parseUrl");
    function y(_) {
      if (_.endsWith("/.."))
        return _;
      let U = _.lastIndexOf("/");
      return _.slice(0, U + 1);
    }
    n(y, "stripPathFilename");
    function T(_, U) {
      L(U, U.type), _.path === "/" ? _.path = U.path : _.path = y(U.path) + _.path;
    }
    n(T, "mergePaths");
    function L(_, U) {
      let J = U <= s.RelativePath, ie = _.path.split("/"), de = 1, ne = 0, Be = !1;
      for (let Et = 1; Et < ie.length; Et++) {
        let Jt = ie[Et];
        if (!Jt) {
          Be = !0;
          continue;
        }
        if (Be = !1, Jt !== ".") {
          if (Jt === "..") {
            ne ? (Be = !0, ne--, de--) : J && (ie[de++] = Jt);
            continue;
          }
          ie[de++] = Jt, ne++;
        }
      }
      let bt = "";
      for (let Et = 1; Et < de; Et++)
        bt += "/" + ie[Et];
      (!bt || Be && !bt.endsWith("/..")) && (bt += "/"), _.path = bt;
    }
    n(L, "normalizePath");
    function q(_, U) {
      if (!_ && !U)
        return "";
      let J = m(_), ie = J.type;
      if (U && ie !== s.Absolute) {
        let ne = m(U), Be = ne.type;
        switch (ie) {
          case s.Empty:
            J.hash = ne.hash;
          case s.Hash:
            J.query = ne.query;
          case s.Query:
          case s.RelativePath:
            T(J, ne);
          case s.AbsolutePath:
            J.user = ne.user, J.host = ne.host, J.port = ne.port;
          case s.SchemeRelative:
            J.scheme = ne.scheme;
        }
        Be > ie && (ie = Be);
      }
      L(J, ie);
      let de = J.query + J.hash;
      switch (ie) {
        case s.Hash:
        case s.Query:
          return de;
        case s.RelativePath: {
          let ne = J.path.slice(1);
          return ne ? u(U || _) && !u(ne) ? "./" + ne + de : ne + de : de || ".";
        }
        case s.AbsolutePath:
          return J.path + de;
        default:
          return J.scheme + "//" + J.user + J.host + J.port + J.path + de;
      }
    }
    return n(q, "resolve"), q;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var Ml = w((Ll, QS) => {
  (function(t, e) {
    typeof Ll == "object" && typeof QS < "u" ? e(Ll, rh(), GS()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewe\
ll/sourcemap-codec", "@jridgewell/resolve-uri"], e) : (t = typeof globalThis < "u" ? globalThis : t || self, e(t.traceMapping = {}, t.sourcemapCodec,
    t.resolveURI));
  })(Ll, function(t, e, r) {
    "use strict";
    function s(Y, G) {
      return G && !G.endsWith("/") && (G += "/"), r(Y, G);
    }
    n(s, "resolve");
    function i(Y) {
      if (!Y)
        return "";
      let G = Y.lastIndexOf("/");
      return Y.slice(0, G + 1);
    }
    n(i, "stripFilename");
    let a = 0, o = 1, l = 2, u = 3, c = 4, p = 1, f = 2;
    function m(Y, G) {
      let Z = y(Y, 0);
      if (Z === Y.length)
        return Y;
      G || (Y = Y.slice());
      for (let ue = Z; ue < Y.length; ue = y(Y, ue + 1))
        Y[ue] = L(Y[ue], G);
      return Y;
    }
    n(m, "maybeSort");
    function y(Y, G) {
      for (let Z = G; Z < Y.length; Z++)
        if (!T(Y[Z]))
          return Z;
      return Y.length;
    }
    n(y, "nextUnsortedSegmentLine");
    function T(Y) {
      for (let G = 1; G < Y.length; G++)
        if (Y[G][a] < Y[G - 1][a])
          return !1;
      return !0;
    }
    n(T, "isSorted");
    function L(Y, G) {
      return G || (Y = Y.slice()), Y.sort(q);
    }
    n(L, "sortSegments");
    function q(Y, G) {
      return Y[a] - G[a];
    }
    n(q, "sortComparator");
    let _ = !1;
    function U(Y, G, Z, ue) {
      for (; Z <= ue; ) {
        let Re = Z + (ue - Z >> 1), we = Y[Re][a] - G;
        if (we === 0)
          return _ = !0, Re;
        we < 0 ? Z = Re + 1 : ue = Re - 1;
      }
      return _ = !1, Z - 1;
    }
    n(U, "binarySearch");
    function J(Y, G, Z) {
      for (let ue = Z + 1; ue < Y.length && Y[ue][a] === G; Z = ue++)
        ;
      return Z;
    }
    n(J, "upperBound");
    function ie(Y, G, Z) {
      for (let ue = Z - 1; ue >= 0 && Y[ue][a] === G; Z = ue--)
        ;
      return Z;
    }
    n(ie, "lowerBound");
    function de() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    n(de, "memoizedState");
    function ne(Y, G, Z, ue) {
      let { lastKey: Re, lastNeedle: we, lastIndex: at } = Z, vt = 0, ze = Y.length - 1;
      if (ue === Re) {
        if (G === we)
          return _ = at !== -1 && Y[at][a] === G, at;
        G >= we ? vt = at === -1 ? 0 : at : ze = at;
      }
      return Z.lastKey = ue, Z.lastNeedle = G, Z.lastIndex = U(Y, G, vt, ze);
    }
    n(ne, "memoizedBinarySearch");
    function Be(Y, G) {
      let Z = G.map(Et);
      for (let ue = 0; ue < Y.length; ue++) {
        let Re = Y[ue];
        for (let we = 0; we < Re.length; we++) {
          let at = Re[we];
          if (at.length === 1)
            continue;
          let vt = at[o], ze = at[l], Ct = at[u], Ir = Z[vt], Ft = Ir[ze] || (Ir[ze] = []), Mt = G[vt], or = J(Ft, Ct, ne(Ft, Ct, Mt, ze));
          Mt.lastIndex = ++or, bt(Ft, or, [Ct, ue, at[a]]);
        }
      }
      return Z;
    }
    n(Be, "buildBySources");
    function bt(Y, G, Z) {
      for (let ue = Y.length; ue > G; ue--)
        Y[ue] = Y[ue - 1];
      Y[G] = Z;
    }
    n(bt, "insert");
    function Et() {
      return { __proto__: null };
    }
    n(Et, "buildNullArray");
    let Jt = /* @__PURE__ */ n(function(Y, G) {
      let Z = ts(Y);
      if (!("sections" in Z))
        return new xt(Z, G);
      let ue = [], Re = [], we = [], at = [], vt = [];
      Ys(Z, G, ue, Re, we, at, vt, 0, 0, 1 / 0, 1 / 0);
      let ze = {
        version: 3,
        file: Z.file,
        names: at,
        sources: Re,
        sourcesContent: we,
        mappings: ue,
        ignoreList: vt
      };
      return Kb(ze);
    }, "AnyMap");
    function ts(Y) {
      return typeof Y == "string" ? JSON.parse(Y) : Y;
    }
    n(ts, "parse");
    function Ys(Y, G, Z, ue, Re, we, at, vt, ze, Ct, Ir) {
      let { sections: Ft } = Y;
      for (let Mt = 0; Mt < Ft.length; Mt++) {
        let { map: or, offset: ss } = Ft[Mt], vi = Ct, ln = Ir;
        if (Mt + 1 < Ft.length) {
          let un = Ft[Mt + 1].offset;
          vi = Math.min(Ct, vt + un.line), vi === Ct ? ln = Math.min(Ir, ze + un.column) : vi < Ct && (ln = ze + un.column);
        }
        rl(or, G, Z, ue, Re, we, at, vt + ss.line, ze + ss.column, vi, ln);
      }
    }
    n(Ys, "recurse");
    function rl(Y, G, Z, ue, Re, we, at, vt, ze, Ct, Ir) {
      let Ft = ts(Y);
      if ("sections" in Ft)
        return Ys(...arguments);
      let Mt = new xt(Ft, G), or = ue.length, ss = we.length, vi = Xt(Mt), { resolvedSources: ln, sourcesContent: un, ignoreList: Xc } = Mt;
      if (rs(ue, ln), rs(we, Mt.names), un)
        rs(Re, un);
      else
        for (let Mr = 0; Mr < ln.length; Mr++)
          Re.push(null);
      if (Xc)
        for (let Mr = 0; Mr < Xc.length; Mr++)
          at.push(Xc[Mr] + or);
      for (let Mr = 0; Mr < vi.length; Mr++) {
        let $c = vt + Mr;
        if ($c > Ct)
          return;
        let Yb = De(Z, $c), HN = Mr === 0 ? ze : 0, Jb = vi[Mr];
        for (let Hc = 0; Hc < Jb.length; Hc++) {
          let Ci = Jb[Hc], al = HN + Ci[a];
          if ($c === Ct && al >= Ir)
            return;
          if (Ci.length === 1) {
            Yb.push([al]);
            continue;
          }
          let Xb = or + Ci[o], $b = Ci[l], Hb = Ci[u];
          Yb.push(Ci.length === 4 ? [al, Xb, $b, Hb] : [al, Xb, $b, Hb, ss + Ci[c]]);
        }
      }
    }
    n(rl, "addSection");
    function rs(Y, G) {
      for (let Z = 0; Z < G.length; Z++)
        Y.push(G[Z]);
    }
    n(rs, "append");
    function De(Y, G) {
      for (let Z = Y.length; Z <= G; Z++)
        Y[Z] = [];
      return Y[G];
    }
    n(De, "getLine");
    let Pe = "`line` must be greater than 0 (lines start at line 1)", Me = "`column` must be greater than or equal to 0 (columns start at co\
lumn 0)", Ue = -1, At = 1;
    class xt {
      static {
        n(this, "TraceMap");
      }
      constructor(G, Z) {
        let ue = typeof G == "string";
        if (!ue && G._decodedMemo)
          return G;
        let Re = ue ? JSON.parse(G) : G, { version: we, file: at, names: vt, sourceRoot: ze, sources: Ct, sourcesContent: Ir } = Re;
        this.version = we, this.file = at, this.names = vt || [], this.sourceRoot = ze, this.sources = Ct, this.sourcesContent = Ir, this.ignoreList =
        Re.ignoreList || Re.x_google_ignoreList || void 0;
        let Ft = s(ze || "", i(Z));
        this.resolvedSources = Ct.map((or) => s(or || "", Ft));
        let { mappings: Mt } = Re;
        typeof Mt == "string" ? (this._encoded = Mt, this._decoded = void 0) : (this._encoded = void 0, this._decoded = m(Mt, ue)), this._decodedMemo =
        de(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    function wt(Y) {
      return Y;
    }
    n(wt, "cast");
    function er(Y) {
      var G, Z;
      return (G = (Z = Y)._encoded) !== null && G !== void 0 ? G : Z._encoded = e.encode(Y._decoded);
    }
    n(er, "encodedMappings");
    function Xt(Y) {
      var G;
      return (G = Y)._decoded || (G._decoded = e.decode(Y._encoded));
    }
    n(Xt, "decodedMappings");
    function aa(Y, G, Z) {
      let ue = Xt(Y);
      if (G >= ue.length)
        return null;
      let Re = ue[G], we = nl(Re, Y._decodedMemo, G, Z, At);
      return we === -1 ? null : Re[we];
    }
    n(aa, "traceSegment");
    function an(Y, G) {
      let { line: Z, column: ue, bias: Re } = G;
      if (Z--, Z < 0)
        throw new Error(Pe);
      if (ue < 0)
        throw new Error(Me);
      let we = Xt(Y);
      if (Z >= we.length)
        return il(null, null, null, null);
      let at = we[Z], vt = nl(at, Y._decodedMemo, Z, ue, Re || At);
      if (vt === -1)
        return il(null, null, null, null);
      let ze = at[vt];
      if (ze.length === 1)
        return il(null, null, null, null);
      let { names: Ct, resolvedSources: Ir } = Y;
      return il(Ir[ze[o]], ze[l] + 1, ze[u], ze.length === 5 ? Ct[ze[c]] : null);
    }
    n(an, "originalPositionFor");
    function gi(Y, G) {
      let { source: Z, line: ue, column: Re, bias: we } = G;
      return Wb(Y, Z, ue, Re, we || At, !1);
    }
    n(gi, "generatedPositionFor");
    function on(Y, G) {
      let { source: Z, line: ue, column: Re, bias: we } = G;
      return Wb(Y, Z, ue, Re, we || Ue, !0);
    }
    n(on, "allGeneratedPositionsFor");
    function Pi(Y, G) {
      let Z = Xt(Y), { names: ue, resolvedSources: Re } = Y;
      for (let we = 0; we < Z.length; we++) {
        let at = Z[we];
        for (let vt = 0; vt < at.length; vt++) {
          let ze = at[vt], Ct = we + 1, Ir = ze[0], Ft = null, Mt = null, or = null, ss = null;
          ze.length !== 1 && (Ft = Re[ze[1]], Mt = ze[2] + 1, or = ze[3]), ze.length === 5 && (ss = ue[ze[4]]), G({
            generatedLine: Ct,
            generatedColumn: Ir,
            source: Ft,
            originalLine: Mt,
            originalColumn: or,
            name: ss
          });
        }
      }
    }
    n(Pi, "eachMapping");
    function Ei(Y, G) {
      let { sources: Z, resolvedSources: ue } = Y, Re = Z.indexOf(G);
      return Re === -1 && (Re = ue.indexOf(G)), Re;
    }
    n(Ei, "sourceIndex");
    function Ai(Y, G) {
      let { sourcesContent: Z } = Y;
      if (Z == null)
        return null;
      let ue = Ei(Y, G);
      return ue === -1 ? null : Z[ue];
    }
    n(Ai, "sourceContentFor");
    function sl(Y, G) {
      let { ignoreList: Z } = Y;
      if (Z == null)
        return !1;
      let ue = Ei(Y, G);
      return ue === -1 ? !1 : Z.includes(ue);
    }
    n(sl, "isIgnored");
    function Kb(Y, G) {
      let Z = new xt(Jc(Y, []), G);
      return Z._decoded = Y.mappings, Z;
    }
    n(Kb, "presortedDecodedMap");
    function JN(Y) {
      return Jc(Y, Xt(Y));
    }
    n(JN, "decodedMap");
    function XN(Y) {
      return Jc(Y, er(Y));
    }
    n(XN, "encodedMap");
    function Jc(Y, G) {
      return {
        version: Y.version,
        file: Y.file,
        names: Y.names,
        sourceRoot: Y.sourceRoot,
        sources: Y.sources,
        sourcesContent: Y.sourcesContent,
        mappings: G,
        ignoreList: Y.ignoreList || Y.x_google_ignoreList
      };
    }
    n(Jc, "clone");
    function il(Y, G, Z, ue) {
      return { source: Y, line: G, column: Z, name: ue };
    }
    n(il, "OMapping");
    function oa(Y, G) {
      return { line: Y, column: G };
    }
    n(oa, "GMapping");
    function nl(Y, G, Z, ue, Re) {
      let we = ne(Y, ue, G, Z);
      return _ ? we = (Re === Ue ? J : ie)(Y, ue, we) : Re === Ue && we++, we === -1 || we === Y.length ? -1 : we;
    }
    n(nl, "traceSegmentInternal");
    function $N(Y, G, Z, ue, Re) {
      let we = nl(Y, G, Z, ue, At);
      if (!_ && Re === Ue && we++, we === -1 || we === Y.length)
        return [];
      let at = _ ? ue : Y[we][a];
      _ || (we = ie(Y, at, we));
      let vt = J(Y, at, we), ze = [];
      for (; we <= vt; we++) {
        let Ct = Y[we];
        ze.push(oa(Ct[p] + 1, Ct[f]));
      }
      return ze;
    }
    n($N, "sliceGeneratedPositions");
    function Wb(Y, G, Z, ue, Re, we) {
      var at;
      if (Z--, Z < 0)
        throw new Error(Pe);
      if (ue < 0)
        throw new Error(Me);
      let { sources: vt, resolvedSources: ze } = Y, Ct = vt.indexOf(G);
      if (Ct === -1 && (Ct = ze.indexOf(G)), Ct === -1)
        return we ? [] : oa(null, null);
      let Ft = ((at = Y)._bySources || (at._bySources = Be(Xt(Y), Y._bySourceMemos = vt.map(de))))[Ct][Z];
      if (Ft == null)
        return we ? [] : oa(null, null);
      let Mt = Y._bySourceMemos[Ct];
      if (we)
        return $N(Ft, Mt, Z, ue, Re);
      let or = nl(Ft, Mt, Z, ue, Re);
      if (or === -1)
        return oa(null, null);
      let ss = Ft[or];
      return oa(ss[p] + 1, ss[f]);
    }
    n(Wb, "generatedPosition"), t.AnyMap = Jt, t.GREATEST_LOWER_BOUND = At, t.LEAST_UPPER_BOUND = Ue, t.TraceMap = xt, t.allGeneratedPositionsFor =
    on, t.decodedMap = JN, t.decodedMappings = Xt, t.eachMapping = Pi, t.encodedMap = XN, t.encodedMappings = er, t.generatedPositionFor = gi,
    t.isIgnored = sl, t.originalPositionFor = an, t.presortedDecodedMap = Kb, t.sourceContentFor = Ai, t.traceSegment = aa;
  });
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var nh = w((Bl, ZS) => {
  (function(t, e) {
    typeof Bl == "object" && typeof ZS < "u" ? e(Bl, HS(), rh(), Ml()) : typeof define == "function" && define.amd ? define(["exports", "@jr\
idgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], e) : (t = typeof globalThis < "u" ? globalThis : t || self,
    e(t.genMapping = {}, t.setArray, t.sourcemapCodec, t.traceMapping));
  })(Bl, function(t, e, r, s) {
    "use strict";
    class p {
      static {
        n(this, "GenMapping");
      }
      constructor({ file: Pe, sourceRoot: Me } = {}) {
        this._names = new e.SetArray(), this._sources = new e.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = Pe, this.
        sourceRoot = Me, this._ignoreList = new e.SetArray();
      }
    }
    function f(De) {
      return De;
    }
    n(f, "cast");
    function m(De, Pe, Me, Ue, At, xt, wt, er) {
      return ne(!1, De, Pe, Me, Ue, At, xt, wt, er);
    }
    n(m, "addSegment");
    function y(De, Pe) {
      return rs(!1, De, Pe);
    }
    n(y, "addMapping");
    let T = /* @__PURE__ */ n((De, Pe, Me, Ue, At, xt, wt, er) => ne(!0, De, Pe, Me, Ue, At, xt, wt, er), "maybeAddSegment"), L = /* @__PURE__ */ n(
    (De, Pe) => rs(!0, De, Pe), "maybeAddMapping");
    function q(De, Pe, Me) {
      let { _sources: Ue, _sourcesContent: At } = De, xt = e.put(Ue, Pe);
      At[xt] = Me;
    }
    n(q, "setSourceContent");
    function _(De, Pe, Me = !0) {
      let { _sources: Ue, _sourcesContent: At, _ignoreList: xt } = De, wt = e.put(Ue, Pe);
      wt === At.length && (At[wt] = null), Me ? e.put(xt, wt) : e.remove(xt, wt);
    }
    n(_, "setIgnore");
    function U(De) {
      let { _mappings: Pe, _sources: Me, _sourcesContent: Ue, _names: At, _ignoreList: xt } = De;
      return Jt(Pe), {
        version: 3,
        file: De.file || void 0,
        names: At.array,
        sourceRoot: De.sourceRoot || void 0,
        sources: Me.array,
        sourcesContent: Ue,
        mappings: Pe,
        ignoreList: xt.array
      };
    }
    n(U, "toDecodedMap");
    function J(De) {
      let Pe = U(De);
      return Object.assign(Object.assign({}, Pe), { mappings: r.encode(Pe.mappings) });
    }
    n(J, "toEncodedMap");
    function ie(De) {
      let Pe = new s.TraceMap(De), Me = new p({ file: Pe.file, sourceRoot: Pe.sourceRoot });
      return ts(Me._names, Pe.names), ts(Me._sources, Pe.sources), Me._sourcesContent = Pe.sourcesContent || Pe.sources.map(() => null), Me.
      _mappings = s.decodedMappings(Pe), Pe.ignoreList && ts(Me._ignoreList, Pe.ignoreList), Me;
    }
    n(ie, "fromMap");
    function de(De) {
      let Pe = [], { _mappings: Me, _sources: Ue, _names: At } = De;
      for (let xt = 0; xt < Me.length; xt++) {
        let wt = Me[xt];
        for (let er = 0; er < wt.length; er++) {
          let Xt = wt[er], aa = { line: xt + 1, column: Xt[0] }, an, gi, on;
          Xt.length !== 1 && (an = Ue.array[Xt[1]], gi = { line: Xt[2] + 1, column: Xt[3] }, Xt.length === 5 && (on = At.array[Xt[4]])), Pe.
          push({ generated: aa, source: an, original: gi, name: on });
        }
      }
      return Pe;
    }
    n(de, "allMappings");
    function ne(De, Pe, Me, Ue, At, xt, wt, er, Xt) {
      let { _mappings: aa, _sources: an, _sourcesContent: gi, _names: on } = Pe, Pi = Be(aa, Me), Ei = bt(Pi, Ue);
      if (!At)
        return De && Ys(Pi, Ei) ? void 0 : Et(Pi, Ei, [Ue]);
      let Ai = e.put(an, At), sl = er ? e.put(on, er) : -1;
      if (Ai === gi.length && (gi[Ai] = Xt ?? null), !(De && rl(Pi, Ei, Ai, xt, wt, sl)))
        return Et(Pi, Ei, er ? [Ue, Ai, xt, wt, sl] : [Ue, Ai, xt, wt]);
    }
    n(ne, "addSegmentInternal");
    function Be(De, Pe) {
      for (let Me = De.length; Me <= Pe; Me++)
        De[Me] = [];
      return De[Pe];
    }
    n(Be, "getLine");
    function bt(De, Pe) {
      let Me = De.length;
      for (let Ue = Me - 1; Ue >= 0; Me = Ue--) {
        let At = De[Ue];
        if (Pe >= At[0])
          break;
      }
      return Me;
    }
    n(bt, "getColumnIndex");
    function Et(De, Pe, Me) {
      for (let Ue = De.length; Ue > Pe; Ue--)
        De[Ue] = De[Ue - 1];
      De[Pe] = Me;
    }
    n(Et, "insert");
    function Jt(De) {
      let { length: Pe } = De, Me = Pe;
      for (let Ue = Me - 1; Ue >= 0 && !(De[Ue].length > 0); Me = Ue, Ue--)
        ;
      Me < Pe && (De.length = Me);
    }
    n(Jt, "removeEmptyFinalLines");
    function ts(De, Pe) {
      for (let Me = 0; Me < Pe.length; Me++)
        e.put(De, Pe[Me]);
    }
    n(ts, "putAll");
    function Ys(De, Pe) {
      return Pe === 0 ? !0 : De[Pe - 1].length === 1;
    }
    n(Ys, "skipSourceless");
    function rl(De, Pe, Me, Ue, At, xt) {
      if (Pe === 0)
        return !1;
      let wt = De[Pe - 1];
      return wt.length === 1 ? !1 : Me === wt[1] && Ue === wt[2] && At === wt[3] && xt === (wt.length === 5 ? wt[4] : -1);
    }
    n(rl, "skipSource");
    function rs(De, Pe, Me) {
      let { generated: Ue, source: At, original: xt, name: wt, content: er } = Me;
      return At ? ne(De, Pe, Ue.line - 1, Ue.column, At, xt.line - 1, xt.column, wt, er) : ne(De, Pe, Ue.line - 1, Ue.column, null, null, null,
      null, null);
    }
    n(rs, "addMappingInternal"), t.GenMapping = p, t.addMapping = y, t.addSegment = m, t.allMappings = de, t.fromMap = ie, t.maybeAddMapping =
    L, t.maybeAddSegment = T, t.setIgnore = _, t.setSourceContent = q, t.toDecodedMap = U, t.toEncodedMap = J, Object.defineProperty(t, "__e\
sModule", { value: !0 });
  });
});

// ../node_modules/@babel/generator/lib/source-map.js
var eg = w((Fl) => {
  "use strict";
  Object.defineProperty(Fl, "__esModule", {
    value: !0
  });
  Fl.default = void 0;
  var zs = nh(), ah = Ml(), oh = class {
    static {
      n(this, "SourceMap");
    }
    constructor(e, r) {
      var s;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let i = this._map = new zs.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (s = e.sourceFileName) == null ? void 0 : s.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new ah.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, zs.setSourceContent)(i, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !e.inputSourceMap)
        (0, zs.setSourceContent)(i, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, zs.setSourceContent)(i, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, zs.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, zs.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, zs.allMappings)(this._map));
    }
    mark(e, r, s, i, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, ah.originalPositionFor)(this._inputMap, {
            line: r,
            column: s
          }), !u.name && a) {
            let c = (0, ah.originalPositionFor)(this._inputMap, a);
            c.name && (i = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: s
          };
      (0, zs.maybeAddMapping)(this._map, {
        name: i,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  Fl.default = oh;
});

// ../node_modules/@babel/generator/lib/buffer.js
var tg = w((jl) => {
  "use strict";
  Object.defineProperty(jl, "__esModule", {
    value: !0
  });
  jl.default = void 0;
  var lh = class {
    static {
      n(this, "Buffer");
    }
    constructor(e, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = r;
      for (let s = 0; s < 64; s++)
        this._fastIndentations.push(r.repeat(s));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let r = 0; r < 16; r++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, r, s, i, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = r, l.line = s, l.column = i, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let s = e ? e.get() : null;
          return r.map = s, s;
        },
        set map(s) {
          Object.defineProperty(r, "map", {
            value: s,
            writable: !0
          });
        },
        get rawMappings() {
          let s = e?.getRawMappings();
          return r.rawMappings = s, s;
        },
        set rawMappings(s) {
          Object.defineProperty(r, "rawMappings", {
            value: s,
            writable: !0
          });
        }
      };
      return r;
    }
    append(e, r) {
      this._flush(), this._append(e, this._sourcePosition, r);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let s = this._queue[this._queueCursor - 1].char;
          if (s !== 32 && s !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(e, 1, r.line, r.column, r.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, r = this._queue;
      for (let s = 0; s < e; s++) {
        let i = r[s];
        this._appendChar(i.char, i.repeat, i);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, r, s) {
      if (this._last = e, e === -1) {
        let i = this._fastIndentations[r];
        i !== void 0 ? this._str += i : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(e).repeat(r) : String.fromCharCode(e);
      e !== 10 ? (this._mark(s.line, s.column, s.identifierName, s.identifierNamePos, s.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
    }
    _append(e, r, s) {
      let i = e.length, a = this._position;
      if (this._last = e.charCodeAt(i - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !s && !this._map) {
        a.column += i;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, p = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let f = e.indexOf(`
`), m = 0;
      for (f !== 0 && this._mark(p, o, l, u, c); f !== -1; )
        a.line++, a.column = 0, m = f + 1, m < i && p !== void 0 && this._mark(++p, 0, null, null, c), f = e.indexOf(`
`, m);
      a.column += i - m;
    }
    _mark(e, r, s, i, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, r, s, i, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, r = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let s = e - 1; s >= 0 && this._queue[s].char === 10; s--)
        r++;
      return r === e && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let e = this._queue, r = this._queueCursor;
      if (r !== 0)
        return e[r - 1].char !== 10 ? void 0 : r > 1 ? e[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", e);
      let s = e.identifierName, i = this._sourcePosition;
      s && (this._canMarkIdName = !1, i.identifierName = s), r(), s && (this._canMarkIdName = !0, i.identifierName = void 0, i.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, r) {
      this._map && this._normalizePosition(e, r, 0);
    }
    sourceWithOffset(e, r, s) {
      this._map && this._normalizePosition(e, r, s);
    }
    withSource(e, r, s) {
      this._map && this.source(e, r), s();
    }
    _normalizePosition(e, r, s) {
      let i = r[e], a = this._sourcePosition;
      i && (a.line = i.line, a.column = Math.max(i.column + s, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let e = this._queue, r = this._queueCursor, s = -1, i = 0;
      for (let a = 0; a < r; a++) {
        let o = e[a];
        o.char === 10 && (s = i), i += o.repeat;
      }
      return s === -1 ? this._position.column + i : i - 1 - s;
    }
    getCurrentLine() {
      let e = 0, r = this._queue;
      for (let s = 0; s < this._queueCursor; s++)
        r[s].char === 10 && e++;
      return this._position.line + e;
    }
  };
  jl.default = lh;
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var ag = w((Ul) => {
  "use strict";
  Object.defineProperty(Ul, "__esModule", {
    value: !0
  });
  Ul.nodes = void 0;
  var lV = Ce(), {
    FLIPPED_ALIAS_KEYS: uV,
    isArrayExpression: cV,
    isAssignmentExpression: sg,
    isBinary: ig,
    isBlockStatement: pV,
    isCallExpression: ng,
    isFunction: Ca,
    isIdentifier: Rl,
    isLiteral: fV,
    isMemberExpression: uh,
    isObjectExpression: hV,
    isOptionalCallExpression: dV,
    isOptionalMemberExpression: mV,
    isStringLiteral: yV
  } = lV;
  function dn(t, e) {
    return t && (uh(t) || mV(t) ? (dn(t.object, e), t.computed && dn(t.property, e)) : ig(t) || sg(t) ? (dn(t.left, e), dn(t.right, e)) : ng(
    t) || dV(t) ? (e.hasCall = !0, dn(t.callee, e)) : Ca(t) ? e.hasFunction = !0 : Rl(t) && (e.hasHelper = e.hasHelper || t.callee && xs(t.callee))),
    e;
  }
  n(dn, "crawlInternal");
  function rg(t) {
    return dn(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  n(rg, "crawl");
  function xs(t) {
    return t ? uh(t) ? xs(t.object) || xs(t.property) : Rl(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : ng(t) ? xs(t.callee) :
    ig(t) || sg(t) ? Rl(t.left) && xs(t.left) || xs(t.right) : !1 : !1;
  }
  n(xs, "isHelper");
  function TV(t) {
    return fV(t) || hV(t) || cV(t) || Rl(t) || uh(t);
  }
  n(TV, "isType");
  var Di = Ul.nodes = {
    AssignmentExpression(t) {
      let e = rg(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (Ca(t.left) || Ca(t.right))
        return 2;
    },
    Literal(t) {
      if (yV(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (Ca(t.callee) || xs(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (Ca(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let r = t.declarations[e], s = xs(r.id) && !TV(r.init);
        if (!s && r.init) {
          let i = rg(r.init);
          s = xs(r.init) && i.hasCall || i.hasFunction;
        }
        if (s)
          return 3;
      }
    },
    IfStatement(t) {
      if (pV(t.consequent))
        return 3;
    }
  };
  Di.ObjectProperty = Di.ObjectTypeProperty = Di.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  Di.ObjectTypeCallProperty = function(t, e) {
    var r;
    if (e.callProperties[0] === t && !((r = e.properties) != null && r.length))
      return 1;
  };
  Di.ObjectTypeIndexer = function(t, e) {
    var r, s;
    if (e.indexers[0] === t && !((r = e.properties) != null && r.length) && !((s = e.callProperties) != null && s.length))
      return 1;
  };
  Di.ObjectTypeInternalSlot = function(t, e) {
    var r, s, i;
    if (e.internalSlots[0] === t && !((r = e.properties) != null && r.length) && !((s = e.callProperties) != null && s.length) && !((i = e.indexers) !=
    null && i.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(uV[t] || []).forEach(function(r) {
      let s = e ? 3 : 0;
      Di[r] = () => s;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var pg = w((ut) => {
  "use strict";
  Object.defineProperty(ut, "__esModule", {
    value: !0
  });
  ut.ArrowFunctionExpression = JV;
  ut.AssignmentExpression = $V;
  ut.Binary = LV;
  ut.BinaryExpression = qV;
  ut.ClassExpression = WV;
  ut.ConditionalExpression = ch;
  ut.DoExpression = _V;
  ut.FunctionExpression = YV;
  ut.FunctionTypeAnnotation = OV;
  ut.Identifier = zV;
  ut.LogicalExpression = HV;
  ut.NullableTypeAnnotation = NV;
  ut.ObjectExpression = DV;
  ut.OptionalIndexedAccessType = BV;
  ut.OptionalCallExpression = ut.OptionalMemberExpression = XV;
  ut.SequenceExpression = VV;
  ut.TSTypeAssertion = ut.TSSatisfiesExpression = ut.TSAsExpression = FV;
  ut.TSInferType = RV;
  ut.TSInstantiationExpression = UV;
  ut.TSIntersectionType = ut.TSUnionType = jV;
  ut.UnaryLike = cg;
  ut.IntersectionTypeAnnotation = ut.UnionTypeAnnotation = MV;
  ut.UpdateExpression = kV;
  ut.AwaitExpression = ut.YieldExpression = KV;
  var bV = Ce(), {
    isArrayTypeAnnotation: xV,
    isArrowFunctionExpression: SV,
    isBinaryExpression: gV,
    isCallExpression: PV,
    isExportDeclaration: EV,
    isForOfStatement: AV,
    isIndexedAccessType: vV,
    isMemberExpression: lg,
    isObjectPattern: CV,
    isOptionalMemberExpression: IV,
    isYieldExpression: wV
  } = bV, og = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function ug(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  n(ug, "isTSTypeExpression");
  var ql = /* @__PURE__ */ n((t, e) => {
    let r = e.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), Ia = /* @__PURE__ */ n((t, e) => {
    let r = e.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && e.object === t || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && e.callee === t || r === "TaggedTemplateExpression" && e.tag === t || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function NV(t, e) {
    return xV(e);
  }
  n(NV, "NullableTypeAnnotation");
  function OV(t, e, r) {
    if (r.length < 3) return;
    let s = e.type;
    return s === "UnionTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "ArrayTypeAnnotation" || s === "TypeAnnotation" && SV(
    r[r.length - 3]);
  }
  n(OV, "FunctionTypeAnnotation");
  function kV(t, e) {
    return Ia(t, e) || ql(t, e);
  }
  n(kV, "UpdateExpression");
  function DV(t, e, r) {
    return wa(r, 3);
  }
  n(DV, "ObjectExpression");
  function _V(t, e, r) {
    return !t.async && wa(r, 1);
  }
  n(_V, "DoExpression");
  function LV(t, e) {
    let r = e.type;
    if (t.operator === "**" && r === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (ql(t, e) || Ia(t, e) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    if (r === "BinaryExpression" || r === "LogicalExpression") {
      let s = og.get(e.operator), i = og.get(t.operator);
      if (s === i && e.right === t && r !== "LogicalExpression" || s > i)
        return !0;
    }
  }
  n(LV, "Binary");
  function MV(t, e) {
    let r = e.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  n(MV, "UnionTypeAnnotation");
  function BV(t, e) {
    return vV(e) && e.objectType === t;
  }
  n(BV, "OptionalIndexedAccessType");
  function FV() {
    return !0;
  }
  n(FV, "TSAsExpression");
  function jV(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
  }
  n(jV, "TSUnionType");
  function RV(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSOptionalType";
  }
  n(RV, "TSInferType");
  function UV(t, e) {
    let r = e.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!e.typeParameters;
  }
  n(UV, "TSInstantiationExpression");
  function qV(t, e) {
    if (t.operator === "in") {
      let r = e.type;
      return r === "VariableDeclarator" || r === "ForStatement" || r === "ForInStatement" || r === "ForOfStatement";
    }
    return !1;
  }
  n(qV, "BinaryExpression");
  function VV(t, e) {
    let r = e.type;
    return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && e.test === t || r === "Whil\
eStatement" && e.test === t || r === "ForInStatement" && e.right === t || r === "SwitchStatement" && e.discriminant === t || r === "Expressi\
onStatement" && e.expression === t);
  }
  n(VV, "SequenceExpression");
  function KV(t, e) {
    let r = e.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || Ia(t, e) || r === "A\
waitExpression" && wV(t) || r === "ConditionalExpression" && t === e.test || ql(t, e);
  }
  n(KV, "YieldExpression");
  function WV(t, e, r) {
    return wa(r, 5);
  }
  n(WV, "ClassExpression");
  function cg(t, e) {
    return Ia(t, e) || gV(e) && e.operator === "**" && e.left === t || ql(t, e);
  }
  n(cg, "UnaryLike");
  function YV(t, e, r) {
    return wa(r, 5);
  }
  n(YV, "FunctionExpression");
  function JV(t, e) {
    return EV(e) || ch(t, e);
  }
  n(JV, "ArrowFunctionExpression");
  function ch(t, e) {
    let r = e.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && e.test === t || r === "AwaitExpression" || ug(r) ? !0 : cg(t, e);
  }
  n(ch, "ConditionalExpression");
  function XV(t, e) {
    return PV(e) && e.callee === t || lg(e) && e.object === t;
  }
  n(XV, "OptionalMemberExpression");
  function $V(t, e) {
    return CV(t.left) ? !0 : ch(t, e);
  }
  n($V, "AssignmentExpression");
  function HV(t, e) {
    let r = e.type;
    if (ug(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  n(HV, "LogicalExpression");
  function zV(t, e, r) {
    var s;
    let i = e.type;
    if ((s = t.extra) != null && s.parenthesized && i === "AssignmentExpression" && e.left === t) {
      let a = e.right.type;
      if ((a === "FunctionExpression" || a === "ClassExpression") && e.right.id == null)
        return !0;
    }
    if (t.name === "let") {
      let a = lg(e, {
        object: t,
        computed: !0
      }) || IV(e, {
        object: t,
        computed: !0,
        optional: !1
      });
      return wa(r, a ? 57 : 32);
    }
    return t.name === "async" && AV(e) && t === e.left;
  }
  n(zV, "Identifier");
  function wa(t, e) {
    let r = e & 1, s = e & 2, i = e & 4, a = e & 8, o = e & 16, l = e & 32, u = t.length - 1;
    if (u <= 0) return;
    let c = t[u];
    u--;
    let p = t[u];
    for (; u >= 0; ) {
      let f = p.type;
      if (r && f === "ExpressionStatement" && p.expression === c || i && f === "ExportDefaultDeclaration" && c === p.declaration || s && f ===
      "ArrowFunctionExpression" && p.body === c || a && f === "ForStatement" && p.init === c || o && f === "ForInStatement" && p.left === c ||
      l && f === "ForOfStatement" && p.left === c)
        return !0;
      if (u > 0 && (Ia(c, p) && f !== "NewExpression" || f === "SequenceExpression" && p.expressions[0] === c || f === "UpdateExpression" &&
      !p.prefix || f === "ConditionalExpression" && p.test === c || (f === "BinaryExpression" || f === "LogicalExpression") && p.left === c ||
      f === "AssignmentExpression" && p.left === c))
        c = p, u--, p = t[u];
      else
        return !1;
    }
    return !1;
  }
  n(wa, "isFirstInContext");
});

// ../node_modules/@babel/generator/lib/node/index.js
var fh = w((mn) => {
  "use strict";
  Object.defineProperty(mn, "__esModule", {
    value: !0
  });
  mn.needsParens = uK;
  mn.needsWhitespace = ph;
  mn.needsWhitespaceAfter = lK;
  mn.needsWhitespaceBefore = oK;
  var GV = ag(), QV = pg(), ZV = Ce(), {
    FLIPPED_ALIAS_KEYS: eK,
    isCallExpression: tK,
    isExpressionStatement: rK,
    isMemberExpression: sK,
    isNewExpression: iK
  } = ZV;
  function fg(t) {
    let e = /* @__PURE__ */ new Map();
    function r(s, i) {
      let a = e.get(s);
      e.set(s, a ? function(o, l, u) {
        var c;
        return (c = a(o, l, u)) != null ? c : i(o, l, u);
      } : i);
    }
    n(r, "add");
    for (let s of Object.keys(t)) {
      let i = eK[s];
      if (i)
        for (let a of i)
          r(a, t[s]);
      else
        r(s, t[s]);
    }
    return e;
  }
  n(fg, "expandAliases");
  var nK = fg(QV), aK = fg(GV.nodes);
  function hg(t) {
    return tK(t) ? !0 : sK(t) && hg(t.object);
  }
  n(hg, "isOrHasCallExpression");
  function ph(t, e, r) {
    var s;
    if (!t) return !1;
    rK(t) && (t = t.expression);
    let i = (s = aK.get(t.type)) == null ? void 0 : s(t, e);
    return typeof i == "number" ? (i & r) !== 0 : !1;
  }
  n(ph, "needsWhitespace");
  function oK(t, e) {
    return ph(t, e, 1);
  }
  n(oK, "needsWhitespaceBefore");
  function lK(t, e) {
    return ph(t, e, 2);
  }
  n(lK, "needsWhitespaceAfter");
  function uK(t, e, r) {
    var s;
    return e ? iK(e) && e.callee === t && hg(t) ? !0 : (s = nK.get(t.type)) == null ? void 0 : s(t, e, r) : !1;
  }
  n(uK, "needsParens");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var dg = w((Na) => {
  "use strict";
  Object.defineProperty(Na, "__esModule", {
    value: !0
  });
  Na.TaggedTemplateExpression = cK;
  Na.TemplateElement = pK;
  Na.TemplateLiteral = fK;
  function cK(t) {
    this.print(t.tag, t), this.print(t.typeParameters, t), this.print(t.quasi, t);
  }
  n(cK, "TaggedTemplateExpression");
  function pK() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  n(pK, "TemplateElement");
  function fK(t) {
    let e = t.quasis, r = "`";
    for (let s = 0; s < e.length; s++)
      r += e[s].value.raw, s + 1 < e.length && (this.token(r + "${", !0), this.print(t.expressions[s], t), r = "}");
    this.token(r + "`", !0);
  }
  n(fK, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var Tg = w((yt) => {
  "use strict";
  Object.defineProperty(yt, "__esModule", {
    value: !0
  });
  yt.LogicalExpression = yt.BinaryExpression = yt.AssignmentExpression = jK;
  yt.AssignmentPattern = FK;
  yt.AwaitExpression = _K;
  yt.BindExpression = RK;
  yt.CallExpression = kK;
  yt.ConditionalExpression = gK;
  yt.Decorator = wK;
  yt.DoExpression = bK;
  yt.EmptyStatement = MK;
  yt.ExpressionStatement = BK;
  yt.Import = DK;
  yt.MemberExpression = UK;
  yt.MetaProperty = qK;
  yt.ModuleExpression = WK;
  yt.NewExpression = PK;
  yt.OptionalCallExpression = OK;
  yt.OptionalMemberExpression = NK;
  yt.ParenthesizedExpression = xK;
  yt.PrivateName = VK;
  yt.SequenceExpression = EK;
  yt.Super = vK;
  yt.ThisExpression = AK;
  yt.UnaryExpression = TK;
  yt.UpdateExpression = SK;
  yt.V8IntrinsicIdentifier = KK;
  yt.YieldExpression = LK;
  yt._shouldPrintDecoratorsBeforeExport = IK;
  var hK = Ce(), dK = fh(), {
    isCallExpression: mK,
    isLiteral: mg,
    isMemberExpression: hh,
    isNewExpression: yK
  } = hK;
  function TK(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument,
    t);
  }
  n(TK, "UnaryExpression");
  function bK(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body, t);
  }
  n(bK, "DoExpression");
  function xK(t) {
    this.tokenChar(40), this.print(t.expression, t), this.rightParens(t);
  }
  n(xK, "ParenthesizedExpression");
  function SK(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument, t)) : (this.printTerminatorless(t.argument, t, !0), this.token(t.operator));
  }
  n(SK, "UpdateExpression");
  function gK(t) {
    this.print(t.test, t), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent, t), this.space(), this.tokenChar(58), this.
    space(), this.print(t.alternate, t);
  }
  n(gK, "ConditionalExpression");
  function PK(t, e) {
    this.word("new"), this.space(), this.print(t.callee, t), !(this.format.minified && t.arguments.length === 0 && !t.optional && !mK(e, {
      callee: t
    }) && !hh(e) && !yK(e)) && (this.print(t.typeArguments, t), this.print(t.typeParameters, t), t.optional && this.token("?."), this.tokenChar(
    40), this.printList(t.arguments, t), this.rightParens(t));
  }
  n(PK, "NewExpression");
  function EK(t) {
    this.printList(t.expressions, t);
  }
  n(EK, "SequenceExpression");
  function AK() {
    this.word("this");
  }
  n(AK, "ThisExpression");
  function vK() {
    this.word("super");
  }
  n(vK, "Super");
  function yg(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && yg(t.object);
      default:
        return !1;
    }
  }
  n(yg, "isDecoratorMemberExpression");
  function CK(t) {
    return t.type === "ParenthesizedExpression" ? !1 : !yg(t.type === "CallExpression" ? t.callee : t);
  }
  n(CK, "shouldParenthesizeDecoratorExpression");
  function IK(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  n(IK, "_shouldPrintDecoratorsBeforeExport");
  function wK(t) {
    this.tokenChar(64);
    let {
      expression: e
    } = t;
    CK(e) ? (this.tokenChar(40), this.print(e, t), this.tokenChar(41)) : this.print(e, t), this.newline();
  }
  n(wK, "Decorator");
  function NK(t) {
    let {
      computed: e
    } = t, {
      optional: r,
      property: s
    } = t;
    if (this.print(t.object, t), !e && hh(s))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    mg(s) && typeof s.value == "number" && (e = !0), r && this.token("?."), e ? (this.tokenChar(91), this.print(s, t), this.tokenChar(93)) :
    (r || this.tokenChar(46), this.print(s, t));
  }
  n(NK, "OptionalMemberExpression");
  function OK(t) {
    this.print(t.callee, t), this.print(t.typeParameters, t), t.optional && this.token("?."), this.print(t.typeArguments, t), this.tokenChar(
    40), this.printList(t.arguments, t), this.rightParens(t);
  }
  n(OK, "OptionalCallExpression");
  function kK(t) {
    this.print(t.callee, t), this.print(t.typeArguments, t), this.print(t.typeParameters, t), this.tokenChar(40), this.printList(t.arguments,
    t), this.rightParens(t);
  }
  n(kK, "CallExpression");
  function DK() {
    this.word("import");
  }
  n(DK, "Import");
  function _K(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument, t, !1));
  }
  n(_K, "AwaitExpression");
  function LK(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument, t))) : t.argument && (this.
    space(), this.printTerminatorless(t.argument, t, !1));
  }
  n(LK, "YieldExpression");
  function MK() {
    this.semicolon(!0);
  }
  n(MK, "EmptyStatement");
  function BK(t) {
    this.print(t.expression, t), this.semicolon();
  }
  n(BK, "ExpressionStatement");
  function FK(t) {
    this.print(t.left, t), t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation, t), this.space(), this.tokenChar(61), this.
    space(), this.print(t.right, t);
  }
  n(FK, "AssignmentPattern");
  function jK(t, e) {
    let r = this.inForStatementInitCounter && t.operator === "in" && !dK.needsParens(t, e);
    r && this.tokenChar(40), this.print(t.left, t), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) :
    this.token(t.operator), this.space(), this.print(t.right, t), r && this.tokenChar(41);
  }
  n(jK, "AssignmentExpression");
  function RK(t) {
    this.print(t.object, t), this.token("::"), this.print(t.callee, t);
  }
  n(RK, "BindExpression");
  function UK(t) {
    if (this.print(t.object, t), !t.computed && hh(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    mg(t.property) && typeof t.property.value == "number" && (e = !0), e ? (this.tokenChar(91), this.print(t.property, t), this.tokenChar(93)) :
    (this.tokenChar(46), this.print(t.property, t));
  }
  n(UK, "MemberExpression");
  function qK(t) {
    this.print(t.meta, t), this.tokenChar(46), this.print(t.property, t);
  }
  n(qK, "MetaProperty");
  function VK(t) {
    this.tokenChar(35), this.print(t.id, t);
  }
  n(VK, "PrivateName");
  function KK(t) {
    this.tokenChar(37), this.word(t.name);
  }
  n(KK, "V8IntrinsicIdentifier");
  function WK(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e, t), this.dedent(), this.rightBrace(t);
  }
  n(WK, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var gg = w((Dt) => {
  "use strict";
  Object.defineProperty(Dt, "__esModule", {
    value: !0
  });
  Dt.BreakStatement = eW;
  Dt.CatchClause = aW;
  Dt.ContinueStatement = tW;
  Dt.DebuggerStatement = uW;
  Dt.DoWhileStatement = ZK;
  Dt.ForOfStatement = Dt.ForInStatement = void 0;
  Dt.ForStatement = GK;
  Dt.IfStatement = zK;
  Dt.LabeledStatement = iW;
  Dt.ReturnStatement = rW;
  Dt.SwitchCase = lW;
  Dt.SwitchStatement = oW;
  Dt.ThrowStatement = sW;
  Dt.TryStatement = nW;
  Dt.VariableDeclaration = cW;
  Dt.VariableDeclarator = pW;
  Dt.WhileStatement = QK;
  Dt.WithStatement = HK;
  var YK = Ce(), {
    isFor: bg,
    isForStatement: JK,
    isIfStatement: XK,
    isStatement: $K
  } = YK;
  function HK(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object, t), this.tokenChar(41), this.printBlock(t);
  }
  n(HK, "WithStatement");
  function zK(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test, t), this.tokenChar(41), this.space();
    let e = t.alternate && XK(xg(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent, t), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate, t));
  }
  n(zK, "IfStatement");
  function xg(t) {
    let {
      body: e
    } = t;
    return $K(e) === !1 ? t : xg(e);
  }
  n(xg, "getLastStatement");
  function GK(t) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(t.init, t), this.inForStatementInitCounter--,
    this.tokenChar(59), t.test && (this.space(), this.print(t.test, t)), this.tokenChar(59), t.update && (this.space(), this.print(t.update,
    t)), this.tokenChar(41), this.printBlock(t);
  }
  n(GK, "ForStatement");
  function QK(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test, t), this.tokenChar(41), this.printBlock(t);
  }
  n(QK, "WhileStatement");
  function Sg(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(t.left, t), this.space(),
    this.word(e ? "of" : "in"), this.space(), this.print(t.right, t), this.tokenChar(41), this.printBlock(t);
  }
  n(Sg, "ForXStatement");
  var UFe = Dt.ForInStatement = Sg, qFe = Dt.ForOfStatement = Sg;
  function ZK(t) {
    this.word("do"), this.space(), this.print(t.body, t), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test,
    t), this.tokenChar(41), this.semicolon();
  }
  n(ZK, "DoWhileStatement");
  function Vl(t, e, r, s) {
    e && (t.space(), t.printTerminatorless(e, r, s)), t.semicolon();
  }
  n(Vl, "printStatementAfterKeyword");
  function eW(t) {
    this.word("break"), Vl(this, t.label, t, !0);
  }
  n(eW, "BreakStatement");
  function tW(t) {
    this.word("continue"), Vl(this, t.label, t, !0);
  }
  n(tW, "ContinueStatement");
  function rW(t) {
    this.word("return"), Vl(this, t.argument, t, !1);
  }
  n(rW, "ReturnStatement");
  function sW(t) {
    this.word("throw"), Vl(this, t.argument, t, !1);
  }
  n(sW, "ThrowStatement");
  function iW(t) {
    this.print(t.label, t), this.tokenChar(58), this.space(), this.print(t.body, t);
  }
  n(iW, "LabeledStatement");
  function nW(t) {
    this.word("try"), this.space(), this.print(t.block, t), this.space(), t.handlers ? this.print(t.handlers[0], t) : this.print(t.handler, t),
    t.finalizer && (this.space(), this.word("finally"), this.space(), this.print(t.finalizer, t));
  }
  n(nW, "TryStatement");
  function aW(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param, t), this.print(t.param.typeAnnotation, t), this.tokenChar(
    41), this.space()), this.print(t.body, t);
  }
  n(aW, "CatchClause");
  function oW(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant, t), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, t, {
      indent: !0,
      addNewlines(e, r) {
        if (!e && t.cases[t.cases.length - 1] === r) return -1;
      }
    }), this.rightBrace(t);
  }
  n(oW, "SwitchStatement");
  function lW(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test, t), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, t, {
      indent: !0
    }));
  }
  n(lW, "SwitchCase");
  function uW() {
    this.word("debugger"), this.semicolon();
  }
  n(uW, "DebuggerStatement");
  function cW(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = t;
    this.word(r, r === "using" || r === "await using"), this.space();
    let s = !1;
    if (!bg(e))
      for (let i of t.declarations)
        i.init && (s = !0);
    if (this.printList(t.declarations, t, {
      separator: s ? function() {
        this.tokenChar(44), this.newline();
      } : void 0,
      indent: t.declarations.length > 1
    }), bg(e)) {
      if (JK(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  n(cW, "VariableDeclaration");
  function pW(t) {
    this.print(t.id, t), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation, t), t.init && (this.space(), this.tokenChar(61), this.
    space(), this.print(t.init, t));
  }
  n(pW, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var Pg = w((Fr) => {
  "use strict";
  Object.defineProperty(Fr, "__esModule", {
    value: !0
  });
  Fr.ClassAccessorProperty = bW;
  Fr.ClassBody = yW;
  Fr.ClassExpression = Fr.ClassDeclaration = mW;
  Fr.ClassMethod = SW;
  Fr.ClassPrivateMethod = gW;
  Fr.ClassPrivateProperty = xW;
  Fr.ClassProperty = TW;
  Fr.StaticBlock = EW;
  Fr._classMethodHead = PW;
  var fW = Ce(), {
    isExportDefaultDeclaration: hW,
    isExportNamedDeclaration: dW
  } = fW;
  function mW(t, e) {
    (!(hW(e) || dW(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators, t), t.declare && (this.word("declare"),
    this.space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id, t)), this.
    print(t.typeParameters, t), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass, t), this.print(t.
    superTypeParameters, t)), t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements, t)), this.space(),
    this.print(t.body, t);
  }
  n(mW, "ClassDeclaration");
  function yW(t) {
    this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(t.body, t, {
      indent: !0
    }), this.endsWith(10) || this.newline(), this.rightBrace(t));
  }
  n(yW, "ClassBody");
  function TW(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key, t), this.tokenChar(93)) :
    (this._variance(t), this.print(t.key, t)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation,
    t), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(TW, "ClassProperty");
  function bW(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key, t), this.tokenChar(93)) : (this._variance(t), this.print(t.key, t)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation, t), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(bW, "ClassAccessorProperty");
  function xW(t) {
    this.printJoin(t.decorators, t), t.static && (this.word("static"), this.space()), this.print(t.key, t), this.print(t.typeAnnotation, t),
    t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(xW, "ClassPrivateProperty");
  function SW(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t);
  }
  n(SW, "ClassMethod");
  function gW(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t);
  }
  n(gW, "ClassPrivateMethod");
  function PW(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  n(PW, "_classMethodHead");
  function EW(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, t, {
      indent: !0
    }), this.rightBrace(t));
  }
  n(EW, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var Eg = w((Jr) => {
  "use strict";
  Object.defineProperty(Jr, "__esModule", {
    value: !0
  });
  Jr.ArrowFunctionExpression = _W;
  Jr.FunctionDeclaration = Jr.FunctionExpression = DW;
  Jr._functionHead = kW;
  Jr._methodHead = NW;
  Jr._param = wW;
  Jr._parameters = IW;
  Jr._params = CW;
  Jr._predicate = OW;
  var AW = Ce(), {
    isIdentifier: vW
  } = AW;
  function CW(t, e, r) {
    this.print(t.typeParameters, t);
    let s = MW.call(this, e, r);
    s && this.sourceIdentifierName(s.name, s.pos), this.tokenChar(40), this._parameters(t.params, t), this.tokenChar(41);
    let i = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, t, i), this._noLineTerminator = i;
  }
  n(CW, "_params");
  function IW(t, e) {
    let r = t.length;
    for (let s = 0; s < r; s++)
      this._param(t[s], e), s < t.length - 1 && (this.tokenChar(44), this.space());
  }
  n(IW, "_parameters");
  function wW(t, e) {
    this.printJoin(t.decorators, t), this.print(t, e), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(wW, "_param");
  function NW(t) {
    let e = t.kind, r = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(r, t), this.tokenChar(93)) : this.print(r, t),
    t.optional && this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  n(NW, "_methodHead");
  function OW(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, t, e));
  }
  n(OW, "_predicate");
  function kW(t, e) {
    t.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), t.generator && (this._endsWithInnerRaw =
    !1, this.tokenChar(42)), this.space(), t.id && this.print(t.id, t), this._params(t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(
    t);
  }
  n(kW, "_functionHead");
  function DW(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body, t);
  }
  n(DW, "FunctionExpression");
  function _W(t, e) {
    t.async && (this.word("async", !0), this.space());
    let r;
    !this.format.retainLines && t.params.length === 1 && vW(r = t.params[0]) && !LW(t, r) ? this.print(r, t, !0) : this._params(t, void 0, e),
    this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(t.body, t);
  }
  n(_W, "ArrowFunctionExpression");
  function LW(t, e) {
    var r, s;
    return !!(t.typeParameters || t.returnType || t.predicate || e.typeAnnotation || e.optional || (r = e.leadingComments) != null && r.length ||
    (s = e.trailingComments) != null && s.length);
  }
  n(LW, "hasTypesOrComments");
  function MW(t, e) {
    let r = t;
    if (!r && e) {
      let u = e.type;
      u === "VariableDeclarator" ? r = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (r = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = e.key);
    }
    if (!r) return;
    let s;
    if (r.type === "Identifier") {
      var i, a;
      s = {
        pos: (i = r.loc) == null ? void 0 : i.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      s = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      s = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return s;
  }
  n(MW, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var dh = w((fr) => {
  "use strict";
  Object.defineProperty(fr, "__esModule", {
    value: !0
  });
  fr.ExportAllDeclaration = $W;
  fr.ExportDefaultDeclaration = zW;
  fr.ExportDefaultSpecifier = WW;
  fr.ExportNamedDeclaration = HW;
  fr.ExportNamespaceSpecifier = JW;
  fr.ExportSpecifier = YW;
  fr.ImportAttribute = QW;
  fr.ImportDeclaration = GW;
  fr.ImportDefaultSpecifier = KW;
  fr.ImportExpression = eY;
  fr.ImportNamespaceSpecifier = ZW;
  fr.ImportSpecifier = VW;
  fr._printAttributes = XW;
  var BW = Ce(), {
    isClassDeclaration: FW,
    isExportDefaultSpecifier: jW,
    isExportNamespaceSpecifier: RW,
    isImportDefaultSpecifier: UW,
    isImportNamespaceSpecifier: qW,
    isStatement: vg
  } = BW;
  function VW(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported, t), t.local &&
    t.local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local, t));
  }
  n(VW, "ImportSpecifier");
  function KW(t) {
    this.print(t.local, t);
  }
  n(KW, "ImportDefaultSpecifier");
  function WW(t) {
    this.print(t.exported, t);
  }
  n(WW, "ExportDefaultSpecifier");
  function YW(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local, t), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported, t));
  }
  n(YW, "ExportSpecifier");
  function JW(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported, t);
  }
  n(JW, "ExportNamespaceSpecifier");
  var Ag = !1;
  function XW(t) {
    let {
      importAttributesKeyword: e
    } = this.format, {
      attributes: r,
      assertions: s
    } = t;
    r && !e && !Ag && (Ag = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify \
the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\
\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let i = e === "assert" || !e && s;
    if (this.word(i ? "assert" : "with"), this.space(), !i && e !== "with") {
      this.printList(r || s, t);
      return;
    }
    this.tokenChar(123), this.space(), this.printList(r || s, t), this.space(), this.tokenChar(125);
  }
  n(XW, "_printAttributes");
  function $W(t) {
    var e, r;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.print(t.source, t, !0),
    this.space(), this._printAttributes(t)) : this.print(t.source, t), this.semicolon();
  }
  n($W, "ExportAllDeclaration");
  function Cg(t, e) {
    FW(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators, e);
  }
  n(Cg, "maybePrintDecoratorsBeforeExport");
  function HW(t) {
    if (Cg(this, t), this.word("export"), this.space(), t.declaration) {
      let s = t.declaration;
      this.print(s, t), vg(s) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let s = t.specifiers.slice(0), i = !1;
      for (; ; ) {
        let a = s[0];
        if (jW(a) || RW(a))
          i = !0, this.print(s.shift(), t), s.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      if ((s.length || !s.length && !i) && (this.tokenChar(123), s.length && (this.space(), this.printList(s, t), this.space()), this.tokenChar(
      125)), t.source) {
        var e, r;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.
        print(t.source, t, !0), this.space(), this._printAttributes(t)) : this.print(t.source, t);
      }
      this.semicolon();
    }
  }
  n(HW, "ExportNamedDeclaration");
  function zW(t) {
    Cg(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    let e = t.declaration;
    this.print(e, t), vg(e) || this.semicolon();
  }
  n(zW, "ExportDefaultDeclaration");
  function GW(t) {
    var e, r;
    this.word("import"), this.space();
    let s = t.importKind === "type" || t.importKind === "typeof";
    s ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let i = t.specifiers.slice(0), a = !!i.length;
    for (; a; ) {
      let o = i[0];
      if (UW(o) || qW(o))
        this.print(i.shift(), t), i.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    i.length ? (this.tokenChar(123), this.space(), this.printList(i, t), this.space(), this.tokenChar(125)) : s && !a && (this.tokenChar(123),
    this.tokenChar(125)), (a || s) && (this.space(), this.word("from"), this.space()), (e = t.attributes) != null && e.length || (r = t.assertions) !=
    null && r.length ? (this.print(t.source, t, !0), this.space(), this._printAttributes(t)) : this.print(t.source, t), this.semicolon();
  }
  n(GW, "ImportDeclaration");
  function QW(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(QW, "ImportAttribute");
  function ZW(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local, t);
  }
  n(ZW, "ImportNamespaceSpecifier");
  function eY(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source, t), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options, t)), this.tokenChar(41);
  }
  n(eY, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var mh = w((zFe, Ng) => {
  "use strict";
  var Ig = {}, tY = Ig.hasOwnProperty, wg = /* @__PURE__ */ n((t, e) => {
    for (let r in t)
      tY.call(t, r) && e(r, t[r]);
  }, "forOwn"), rY = /* @__PURE__ */ n((t, e) => (e && wg(e, (r, s) => {
    t[r] = s;
  }), t), "extend"), sY = /* @__PURE__ */ n((t, e) => {
    let r = t.length, s = -1;
    for (; ++s < r; )
      e(t[s]);
  }, "forEach"), Oa = Ig.toString, iY = Array.isArray, nY = Buffer.isBuffer, aY = /* @__PURE__ */ n((t) => Oa.call(t) == "[object Object]", "\
isObject"), oY = /* @__PURE__ */ n((t) => typeof t == "string" || Oa.call(t) == "[object String]", "isString"), lY = /* @__PURE__ */ n((t) => typeof t ==
  "number" || Oa.call(t) == "[object Number]", "isNumber"), uY = /* @__PURE__ */ n((t) => typeof t == "function", "isFunction"), cY = /* @__PURE__ */ n(
  (t) => Oa.call(t) == "[object Map]", "isMap"), pY = /* @__PURE__ */ n((t) => Oa.call(t) == "[object Set]", "isSet"), fY = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, hY = /["'\\\b\f\n\r\t]/, dY = /[0-9]/, mY = /[ !#-&\(-\[\]-_a-~]/, Gs = /* @__PURE__ */ n((t, e) => {
    let r = /* @__PURE__ */ n(() => {
      c = u, ++e.indentLevel, u = e.indent.repeat(e.indentLevel);
    }, "increaseIndentation"), s = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, i = e && e.json;
    i && (s.quotes = "double", s.wrap = !0), e = rY(s, e), e.quotes != "single" && e.quotes != "double" && e.quotes != "backtick" && (e.quotes =
    "single");
    let a = e.quotes == "double" ? '"' : e.quotes == "backtick" ? "`" : "'", o = e.compact, l = e.lowercaseHex, u = e.indent.repeat(e.indentLevel),
    c = "", p = e.__inline1__, f = e.__inline2__, m = o ? "" : `
`, y, T = !0, L = e.numbers == "binary", q = e.numbers == "octal", _ = e.numbers == "decimal", U = e.numbers == "hexadecimal";
    if (i && t && uY(t.toJSON) && (t = t.toJSON()), !oY(t)) {
      if (cY(t))
        return t.size == 0 ? "new Map()" : (o || (e.__inline1__ = !0, e.__inline2__ = !1), "new Map(" + Gs(Array.from(t), e) + ")");
      if (pY(t))
        return t.size == 0 ? "new Set()" : "new Set(" + Gs(Array.from(t), e) + ")";
      if (nY(t))
        return t.length == 0 ? "Buffer.from([])" : "Buffer.from(" + Gs(Array.from(t), e) + ")";
      if (iY(t))
        return y = [], e.wrap = !0, p && (e.__inline1__ = !1, e.__inline2__ = !0), f || r(), sY(t, (ne) => {
          T = !1, f && (e.__inline2__ = !1), y.push(
            (o || f ? "" : u) + Gs(ne, e)
          );
        }), T ? "[]" : f ? "[" + y.join(", ") + "]" : "[" + m + y.join("," + m) + m + (o ? "" : c) + "]";
      if (lY(t)) {
        if (i)
          return JSON.stringify(t);
        if (_)
          return String(t);
        if (U) {
          let ne = t.toString(16);
          return l || (ne = ne.toUpperCase()), "0x" + ne;
        }
        if (L)
          return "0b" + t.toString(2);
        if (q)
          return "0o" + t.toString(8);
      } else return aY(t) ? (y = [], e.wrap = !0, r(), wg(t, (ne, Be) => {
        T = !1, y.push(
          (o ? "" : u) + Gs(ne, e) + ":" + (o ? "" : " ") + Gs(Be, e)
        );
      }), T ? "{}" : "{" + m + y.join("," + m) + m + (o ? "" : c) + "}") : i ? JSON.stringify(t) || "null" : String(t);
    }
    let J = t, ie = -1, de = J.length;
    for (y = ""; ++ie < de; ) {
      let ne = J.charAt(ie);
      if (e.es6) {
        let ts = J.charCodeAt(ie);
        if (
          // check if its the start of a surrogate pair
          ts >= 55296 && ts <= 56319 && // high surrogate
          de > ie + 1
        ) {
          let Ys = J.charCodeAt(ie + 1);
          if (Ys >= 56320 && Ys <= 57343) {
            let rs = ((ts - 55296) * 1024 + Ys - 56320 + 65536).toString(16);
            l || (rs = rs.toUpperCase()), y += "\\u{" + rs + "}", ++ie;
            continue;
          }
        }
      }
      if (!e.escapeEverything) {
        if (mY.test(ne)) {
          y += ne;
          continue;
        }
        if (ne == '"') {
          y += a == ne ? '\\"' : ne;
          continue;
        }
        if (ne == "`") {
          y += a == ne ? "\\`" : ne;
          continue;
        }
        if (ne == "'") {
          y += a == ne ? "\\'" : ne;
          continue;
        }
      }
      if (ne == "\0" && !i && !dY.test(J.charAt(ie + 1))) {
        y += "\\0";
        continue;
      }
      if (hY.test(ne)) {
        y += fY[ne];
        continue;
      }
      let Be = ne.charCodeAt(0);
      if (e.minimal && Be != 8232 && Be != 8233) {
        y += ne;
        continue;
      }
      let bt = Be.toString(16);
      l || (bt = bt.toUpperCase());
      let Et = bt.length > 2 || i, Jt = "\\" + (Et ? "u" : "x") + ("0000" + bt).slice(Et ? -4 : -2);
      y += Jt;
    }
    return e.wrap && (y = a + y + a), a == "`" && (y = y.replace(/\$\{/g, "\\${")), e.isScriptContext ? y.replace(/<\/(script|style)/gi, "<\\\
/$1").replace(/<!--/g, i ? "\\u003C!--" : "\\x3C!--") : y;
  }, "jsesc");
  Gs.version = "2.5.2";
  Ng.exports = Gs;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var Th = w((Nt) => {
  "use strict";
  Object.defineProperty(Nt, "__esModule", {
    value: !0
  });
  Nt.ArgumentPlaceholder = xY;
  Nt.ArrayPattern = Nt.ArrayExpression = AY;
  Nt.BigIntLiteral = DY;
  Nt.BooleanLiteral = wY;
  Nt.DecimalLiteral = _Y;
  Nt.Identifier = bY;
  Nt.NullLiteral = NY;
  Nt.NumericLiteral = OY;
  Nt.ObjectPattern = Nt.ObjectExpression = gY;
  Nt.ObjectMethod = PY;
  Nt.ObjectProperty = EY;
  Nt.PipelineBareFunction = BY;
  Nt.PipelinePrimaryTopicReference = FY;
  Nt.PipelineTopicExpression = MY;
  Nt.RecordExpression = vY;
  Nt.RegExpLiteral = IY;
  Nt.SpreadElement = Nt.RestElement = SY;
  Nt.StringLiteral = kY;
  Nt.TopicReference = LY;
  Nt.TupleExpression = CY;
  var yY = Ce(), kg = mh(), {
    isAssignmentPattern: TY,
    isIdentifier: yh
  } = yY;
  function bY(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(t.name);
  }
  n(bY, "Identifier");
  function xY() {
    this.tokenChar(63);
  }
  n(xY, "ArgumentPlaceholder");
  function SY(t) {
    this.token("..."), this.print(t.argument, t);
  }
  n(SY, "RestElement");
  function gY(t) {
    let e = t.properties;
    this.tokenChar(123), e.length && (this.space(), this.printList(e, t, {
      indent: !0,
      statement: !0
    }), this.space()), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  n(gY, "ObjectExpression");
  function PY(t) {
    this.printJoin(t.decorators, t), this._methodHead(t), this.space(), this.print(t.body, t);
  }
  n(PY, "ObjectMethod");
  function EY(t) {
    if (this.printJoin(t.decorators, t), t.computed)
      this.tokenChar(91), this.print(t.key, t), this.tokenChar(93);
    else {
      if (TY(t.value) && yh(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value, t);
        return;
      }
      if (this.print(t.key, t), t.shorthand && yh(t.key) && yh(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value, t);
  }
  n(EY, "ObjectProperty");
  function AY(t) {
    let e = t.elements, r = e.length;
    this.tokenChar(91);
    for (let s = 0; s < e.length; s++) {
      let i = e[s];
      i ? (s > 0 && this.space(), this.print(i, t), s < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }
  n(AY, "ArrayExpression");
  function vY(t) {
    let e = t.properties, r, s;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", s = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", s = "}";
    }
    this.token(r), e.length && (this.space(), this.printList(e, t, {
      indent: !0,
      statement: !0
    }), this.space()), this.token(s);
  }
  n(vY, "RecordExpression");
  function CY(t) {
    let e = t.elements, r = e.length, s, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "[|", i = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      s = "#[", i = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(s);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o, t), a < r - 1 && this.tokenChar(44));
    }
    this.token(i);
  }
  n(CY, "TupleExpression");
  function IY(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  n(IY, "RegExpLiteral");
  function wY(t) {
    this.word(t.value ? "true" : "false");
  }
  n(wY, "BooleanLiteral");
  function NY() {
    this.word("null");
  }
  n(NY, "NullLiteral");
  function OY(t) {
    let e = this.getPossibleRaw(t), r = this.format.jsescOption, s = t.value, i = s + "";
    r.numbers ? this.number(kg(s, r), s) : e == null ? this.number(i, s) : this.format.minified ? this.number(e.length < i.length ? e : i, s) :
    this.number(e, s);
  }
  n(OY, "NumericLiteral");
  function kY(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let r = kg(t.value, this.format.jsescOption);
    this.token(r);
  }
  n(kY, "StringLiteral");
  function DY(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  n(DY, "BigIntLiteral");
  function _Y(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "m");
  }
  n(_Y, "DecimalLiteral");
  var Og = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function LY() {
    let {
      topicToken: t
    } = this.format;
    if (Og.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), r = Array.from(Og, (s) => JSON.stringify(s));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${e} received instead).`);
    }
  }
  n(LY, "TopicReference");
  function MY(t) {
    this.print(t.expression, t);
  }
  n(MY, "PipelineTopicExpression");
  function BY(t) {
    this.print(t.callee, t);
  }
  n(BY, "PipelineBareFunction");
  function FY() {
    this.tokenChar(35);
  }
  n(FY, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var _g = w((fe) => {
  "use strict";
  Object.defineProperty(fe, "__esModule", {
    value: !0
  });
  fe.AnyTypeAnnotation = qY;
  fe.ArrayTypeAnnotation = VY;
  fe.BooleanLiteralTypeAnnotation = WY;
  fe.BooleanTypeAnnotation = KY;
  fe.DeclareClass = JY;
  fe.DeclareExportAllDeclaration = sJ;
  fe.DeclareExportDeclaration = rJ;
  fe.DeclareFunction = XY;
  fe.DeclareInterface = zY;
  fe.DeclareModule = GY;
  fe.DeclareModuleExports = QY;
  fe.DeclareOpaqueType = eJ;
  fe.DeclareTypeAlias = ZY;
  fe.DeclareVariable = tJ;
  fe.DeclaredPredicate = HY;
  fe.EmptyTypeAnnotation = vJ;
  fe.EnumBooleanBody = nJ;
  fe.EnumBooleanMember = cJ;
  fe.EnumDeclaration = iJ;
  fe.EnumDefaultedMember = uJ;
  fe.EnumNumberBody = aJ;
  fe.EnumNumberMember = pJ;
  fe.EnumStringBody = oJ;
  fe.EnumStringMember = fJ;
  fe.EnumSymbolBody = lJ;
  fe.ExistsTypeAnnotation = dJ;
  fe.FunctionTypeAnnotation = mJ;
  fe.FunctionTypeParam = yJ;
  fe.IndexedAccessType = zJ;
  fe.InferredPredicate = $Y;
  fe.InterfaceDeclaration = SJ;
  fe.GenericTypeAnnotation = fe.ClassImplements = fe.InterfaceExtends = TJ;
  fe.InterfaceTypeAnnotation = PJ;
  fe.IntersectionTypeAnnotation = EJ;
  fe.MixedTypeAnnotation = AJ;
  fe.NullLiteralTypeAnnotation = YY;
  fe.NullableTypeAnnotation = CJ;
  Object.defineProperty(fe, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Dg.NumericLiteral;
    }, "get")
  });
  fe.NumberTypeAnnotation = IJ;
  fe.ObjectTypeAnnotation = FJ;
  fe.ObjectTypeCallProperty = RJ;
  fe.ObjectTypeIndexer = UJ;
  fe.ObjectTypeInternalSlot = jJ;
  fe.ObjectTypeProperty = qJ;
  fe.ObjectTypeSpreadProperty = VJ;
  fe.OpaqueType = BJ;
  fe.OptionalIndexedAccessType = GJ;
  fe.QualifiedTypeIdentifier = KJ;
  Object.defineProperty(fe, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Dg.StringLiteral;
    }, "get")
  });
  fe.StringTypeAnnotation = wJ;
  fe.SymbolTypeAnnotation = WJ;
  fe.ThisTypeAnnotation = NJ;
  fe.TupleTypeAnnotation = OJ;
  fe.TypeAlias = DJ;
  fe.TypeAnnotation = _J;
  fe.TypeCastExpression = XJ;
  fe.TypeParameter = MJ;
  fe.TypeParameterDeclaration = fe.TypeParameterInstantiation = LJ;
  fe.TypeofTypeAnnotation = kJ;
  fe.UnionTypeAnnotation = JJ;
  fe.Variance = $J;
  fe.VoidTypeAnnotation = HJ;
  fe._interfaceish = bJ;
  fe._variance = xJ;
  var jY = Ce(), RY = dh(), Dg = Th(), {
    isDeclareExportDeclaration: Kl,
    isStatement: UY
  } = jY;
  function qY() {
    this.word("any");
  }
  n(qY, "AnyTypeAnnotation");
  function VY(t) {
    this.print(t.elementType, t, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(VY, "ArrayTypeAnnotation");
  function KY() {
    this.word("boolean");
  }
  n(KY, "BooleanTypeAnnotation");
  function WY(t) {
    this.word(t.value ? "true" : "false");
  }
  n(WY, "BooleanLiteralTypeAnnotation");
  function YY() {
    this.word("null");
  }
  n(YY, "NullLiteralTypeAnnotation");
  function JY(t, e) {
    Kl(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  n(JY, "DeclareClass");
  function XY(t, e) {
    Kl(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id, t), this.print(t.id.typeAnnotation.
    typeAnnotation, t), t.predicate && (this.space(), this.print(t.predicate, t)), this.semicolon();
  }
  n(XY, "DeclareFunction");
  function $Y() {
    this.tokenChar(37), this.word("checks");
  }
  n($Y, "InferredPredicate");
  function HY(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value, t), this.tokenChar(41);
  }
  n(HY, "DeclaredPredicate");
  function zY(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  n(zY, "DeclareInterface");
  function GY(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id, t), this.space(), this.print(t.body, t);
  }
  n(GY, "DeclareModule");
  function QY(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation, t);
  }
  n(QY, "DeclareModuleExports");
  function ZY(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  n(ZY, "DeclareTypeAlias");
  function eJ(t, e) {
    Kl(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  n(eJ, "DeclareOpaqueType");
  function tJ(t, e) {
    Kl(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id, t), this.print(t.id.typeAnnotation, t), this.
    semicolon();
  }
  n(tJ, "DeclareVariable");
  function rJ(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), hJ.call(this, t);
  }
  n(rJ, "DeclareExportDeclaration");
  function sJ(t) {
    this.word("declare"), this.space(), RY.ExportAllDeclaration.call(this, t);
  }
  n(sJ, "DeclareExportAllDeclaration");
  function iJ(t) {
    let {
      id: e,
      body: r
    } = t;
    this.word("enum"), this.space(), this.print(e, t), this.print(r, t);
  }
  n(iJ, "EnumDeclaration");
  function Wl(t, e, r) {
    r && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  n(Wl, "enumExplicitType");
  function Yl(t, e) {
    let {
      members: r
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let s of r)
      t.print(s, e), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  n(Yl, "enumBody");
  function nJ(t) {
    let {
      explicitType: e
    } = t;
    Wl(this, "boolean", e), Yl(this, t);
  }
  n(nJ, "EnumBooleanBody");
  function aJ(t) {
    let {
      explicitType: e
    } = t;
    Wl(this, "number", e), Yl(this, t);
  }
  n(aJ, "EnumNumberBody");
  function oJ(t) {
    let {
      explicitType: e
    } = t;
    Wl(this, "string", e), Yl(this, t);
  }
  n(oJ, "EnumStringBody");
  function lJ(t) {
    Wl(this, "symbol", !0), Yl(this, t);
  }
  n(lJ, "EnumSymbolBody");
  function uJ(t) {
    let {
      id: e
    } = t;
    this.print(e, t), this.tokenChar(44);
  }
  n(uJ, "EnumDefaultedMember");
  function bh(t, e) {
    let {
      id: r,
      init: s
    } = e;
    t.print(r, e), t.space(), t.token("="), t.space(), t.print(s, e), t.token(",");
  }
  n(bh, "enumInitializedMember");
  function cJ(t) {
    bh(this, t);
  }
  n(cJ, "EnumBooleanMember");
  function pJ(t) {
    bh(this, t);
  }
  n(pJ, "EnumNumberMember");
  function fJ(t) {
    bh(this, t);
  }
  n(fJ, "EnumStringMember");
  function hJ(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e, t), UY(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers, t), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source, t)), this.semicolon();
  }
  n(hJ, "FlowExportDeclaration");
  function dJ() {
    this.tokenChar(42);
  }
  n(dJ, "ExistsTypeAnnotation");
  function mJ(t, e) {
    this.print(t.typeParameters, t), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation,
    t), (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params, t), t.rest && (t.params.length && (this.
    tokenChar(44), this.space()), this.token("..."), this.print(t.rest, t)), this.tokenChar(41);
    let r = e?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType, t);
  }
  n(mJ, "FunctionTypeAnnotation");
  function yJ(t) {
    this.print(t.name, t), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation, t);
  }
  n(yJ, "FunctionTypeParam");
  function TJ(t) {
    this.print(t.id, t), this.print(t.typeParameters, t, !0);
  }
  n(TJ, "InterfaceExtends");
  function bJ(t) {
    var e;
    if (this.print(t.id, t), this.print(t.typeParameters, t), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.
    space(), this.printList(t.extends, t)), t.type === "DeclareClass") {
      var r, s;
      (r = t.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins, t)), (s = t.implements) !=
      null && s.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements, t));
    }
    this.space(), this.print(t.body, t);
  }
  n(bJ, "_interfaceish");
  function xJ(t) {
    var e;
    let r = (e = t.variance) == null ? void 0 : e.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  n(xJ, "_variance");
  function SJ(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  n(SJ, "InterfaceDeclaration");
  function gJ() {
    this.space(), this.tokenChar(38), this.space();
  }
  n(gJ, "andSeparator");
  function PJ(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends,
    t)), this.space(), this.print(t.body, t);
  }
  n(PJ, "InterfaceTypeAnnotation");
  function EJ(t) {
    this.printJoin(t.types, t, {
      separator: gJ
    });
  }
  n(EJ, "IntersectionTypeAnnotation");
  function AJ() {
    this.word("mixed");
  }
  n(AJ, "MixedTypeAnnotation");
  function vJ() {
    this.word("empty");
  }
  n(vJ, "EmptyTypeAnnotation");
  function CJ(t) {
    this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(CJ, "NullableTypeAnnotation");
  function IJ() {
    this.word("number");
  }
  n(IJ, "NumberTypeAnnotation");
  function wJ() {
    this.word("string");
  }
  n(wJ, "StringTypeAnnotation");
  function NJ() {
    this.word("this");
  }
  n(NJ, "ThisTypeAnnotation");
  function OJ(t) {
    this.tokenChar(91), this.printList(t.types, t), this.tokenChar(93);
  }
  n(OJ, "TupleTypeAnnotation");
  function kJ(t) {
    this.word("typeof"), this.space(), this.print(t.argument, t);
  }
  n(kJ, "TypeofTypeAnnotation");
  function DJ(t) {
    this.word("type"), this.space(), this.print(t.id, t), this.print(t.typeParameters, t), this.space(), this.tokenChar(61), this.space(), this.
    print(t.right, t), this.semicolon();
  }
  n(DJ, "TypeAlias");
  function _J(t) {
    this.tokenChar(58), this.space(), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(_J, "TypeAnnotation");
  function LJ(t) {
    this.tokenChar(60), this.printList(t.params, t, {}), this.tokenChar(62);
  }
  n(LJ, "TypeParameterInstantiation");
  function MJ(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound, t), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default, t));
  }
  n(MJ, "TypeParameter");
  function BJ(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id, t), this.print(t.typeParameters, t), t.supertype &&
    (this.tokenChar(58), this.space(), this.print(t.supertype, t)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(
    t.impltype, t)), this.semicolon();
  }
  n(BJ, "OpaqueType");
  function FJ(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, t, {
      addNewlines(r) {
        if (r && !e[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: /* @__PURE__ */ n(() => {
        (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
      }, "iterator")
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  n(FJ, "ObjectTypeAnnotation");
  function jJ(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id, t), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value, t);
  }
  n(jJ, "ObjectTypeInternalSlot");
  function RJ(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value, t);
  }
  n(RJ, "ObjectTypeCallProperty");
  function UJ(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id, t), this.tokenChar(58),
    this.space()), this.print(t.key, t), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value, t);
  }
  n(UJ, "ObjectTypeIndexer");
  function qJ(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key, t), t.optional && this.tokenChar(63), t.method || (this.tokenChar(
    58), this.space()), this.print(t.value, t);
  }
  n(qJ, "ObjectTypeProperty");
  function VJ(t) {
    this.token("..."), this.print(t.argument, t);
  }
  n(VJ, "ObjectTypeSpreadProperty");
  function KJ(t) {
    this.print(t.qualification, t), this.tokenChar(46), this.print(t.id, t);
  }
  n(KJ, "QualifiedTypeIdentifier");
  function WJ() {
    this.word("symbol");
  }
  n(WJ, "SymbolTypeAnnotation");
  function YJ() {
    this.space(), this.tokenChar(124), this.space();
  }
  n(YJ, "orSeparator");
  function JJ(t) {
    this.printJoin(t.types, t, {
      separator: YJ
    });
  }
  n(JJ, "UnionTypeAnnotation");
  function XJ(t) {
    this.tokenChar(40), this.print(t.expression, t), this.print(t.typeAnnotation, t), this.tokenChar(41);
  }
  n(XJ, "TypeCastExpression");
  function $J(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  n($J, "Variance");
  function HJ() {
    this.word("void");
  }
  n(HJ, "VoidTypeAnnotation");
  function zJ(t) {
    this.print(t.objectType, t, !0), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(zJ, "IndexedAccessType");
  function GJ(t) {
    this.print(t.objectType, t), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(GJ, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var Lg = w((Ss) => {
  "use strict";
  Object.defineProperty(Ss, "__esModule", {
    value: !0
  });
  Ss.BlockStatement = eX;
  Ss.Directive = tX;
  Ss.DirectiveLiteral = iX;
  Ss.File = QJ;
  Ss.InterpreterDirective = nX;
  Ss.Placeholder = aX;
  Ss.Program = ZJ;
  function QJ(t) {
    t.program && this.print(t.program.interpreter, t), this.print(t.program, t);
  }
  n(QJ, "File");
  function ZJ(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var s;
      let i = t.body.length ? 2 : 1;
      this.printSequence(t.directives, t, {
        trailingCommentsLineOffset: i
      }), (s = t.directives[r - 1].trailingComments) != null && s.length || this.newline(i);
    }
    this.printSequence(t.body, t);
  }
  n(ZJ, "Program");
  function eX(t) {
    var e;
    this.tokenChar(123);
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var s;
      let i = t.body.length ? 2 : 1;
      this.printSequence(t.directives, t, {
        indent: !0,
        trailingCommentsLineOffset: i
      }), (s = t.directives[r - 1].trailingComments) != null && s.length || this.newline(i);
    }
    this.printSequence(t.body, t, {
      indent: !0
    }), this.rightBrace(t);
  }
  n(eX, "BlockStatement");
  function tX(t) {
    this.print(t.value, t), this.semicolon();
  }
  n(tX, "Directive");
  var rX = /(?:^|[^\\])(?:\\\\)*'/, sX = /(?:^|[^\\])(?:\\\\)*"/;
  function iX(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: r
    } = t;
    if (!sX.test(r))
      this.token(`"${r}"`);
    else if (!rX.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  n(iX, "DirectiveLiteral");
  function nX(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  n(nX, "InterpreterDirective");
  function aX(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  n(aX, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var Mg = w((Qt) => {
  "use strict";
  Object.defineProperty(Qt, "__esModule", {
    value: !0
  });
  Qt.JSXAttribute = oX;
  Qt.JSXClosingElement = bX;
  Qt.JSXClosingFragment = PX;
  Qt.JSXElement = mX;
  Qt.JSXEmptyExpression = xX;
  Qt.JSXExpressionContainer = fX;
  Qt.JSXFragment = SX;
  Qt.JSXIdentifier = lX;
  Qt.JSXMemberExpression = cX;
  Qt.JSXNamespacedName = uX;
  Qt.JSXOpeningElement = TX;
  Qt.JSXOpeningFragment = gX;
  Qt.JSXSpreadAttribute = pX;
  Qt.JSXSpreadChild = hX;
  Qt.JSXText = dX;
  function oX(t) {
    this.print(t.name, t), t.value && (this.tokenChar(61), this.print(t.value, t));
  }
  n(oX, "JSXAttribute");
  function lX(t) {
    this.word(t.name);
  }
  n(lX, "JSXIdentifier");
  function uX(t) {
    this.print(t.namespace, t), this.tokenChar(58), this.print(t.name, t);
  }
  n(uX, "JSXNamespacedName");
  function cX(t) {
    this.print(t.object, t), this.tokenChar(46), this.print(t.property, t);
  }
  n(cX, "JSXMemberExpression");
  function pX(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument, t), this.tokenChar(125);
  }
  n(pX, "JSXSpreadAttribute");
  function fX(t) {
    this.tokenChar(123), this.print(t.expression, t), this.tokenChar(125);
  }
  n(fX, "JSXExpressionContainer");
  function hX(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression, t), this.tokenChar(125);
  }
  n(hX, "JSXSpreadChild");
  function dX(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  n(dX, "JSXText");
  function mX(t) {
    let e = t.openingElement;
    if (this.print(e, t), !e.selfClosing) {
      this.indent();
      for (let r of t.children)
        this.print(r, t);
      this.dedent(), this.print(t.closingElement, t);
    }
  }
  n(mX, "JSXElement");
  function yX() {
    this.space();
  }
  n(yX, "spaceSeparator");
  function TX(t) {
    this.tokenChar(60), this.print(t.name, t), this.print(t.typeParameters, t), t.attributes.length > 0 && (this.space(), this.printJoin(t.attributes,
    t, {
      separator: yX
    })), t.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  n(TX, "JSXOpeningElement");
  function bX(t) {
    this.token("</"), this.print(t.name, t), this.tokenChar(62);
  }
  n(bX, "JSXClosingElement");
  function xX() {
    this.printInnerComments();
  }
  n(xX, "JSXEmptyExpression");
  function SX(t) {
    this.print(t.openingFragment, t), this.indent();
    for (let e of t.children)
      this.print(e, t);
    this.dedent(), this.print(t.closingFragment, t);
  }
  n(SX, "JSXFragment");
  function gX() {
    this.tokenChar(60), this.tokenChar(62);
  }
  n(gX, "JSXOpeningFragment");
  function PX() {
    this.token("</"), this.tokenChar(62);
  }
  n(PX, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var jg = w((ce) => {
  "use strict";
  Object.defineProperty(ce, "__esModule", {
    value: !0
  });
  ce.TSAnyKeyword = BX;
  ce.TSArrayType = i$;
  ce.TSSatisfiesExpression = ce.TSAsExpression = P$;
  ce.TSBigIntKeyword = FX;
  ce.TSBooleanKeyword = qX;
  ce.TSCallSignatureDeclaration = OX;
  ce.TSConditionalType = p$;
  ce.TSConstructSignatureDeclaration = kX;
  ce.TSConstructorType = GX;
  ce.TSDeclareFunction = IX;
  ce.TSDeclareMethod = wX;
  ce.TSEnumDeclaration = v$;
  ce.TSEnumMember = C$;
  ce.TSExportAssignment = _$;
  ce.TSExpressionWithTypeArguments = b$;
  ce.TSExternalModuleReference = k$;
  ce.TSFunctionType = zX;
  ce.TSImportEqualsDeclaration = O$;
  ce.TSImportType = N$;
  ce.TSIndexSignature = MX;
  ce.TSIndexedAccessType = m$;
  ce.TSInferType = f$;
  ce.TSInstantiationExpression = A$;
  ce.TSInterfaceBody = S$;
  ce.TSInterfaceDeclaration = x$;
  ce.TSIntersectionType = c$;
  ce.TSIntrinsicKeyword = $X;
  ce.TSLiteralType = T$;
  ce.TSMappedType = y$;
  ce.TSMethodSignature = LX;
  ce.TSModuleBlock = w$;
  ce.TSModuleDeclaration = I$;
  ce.TSNamedTupleMember = l$;
  ce.TSNamespaceExportDeclaration = L$;
  ce.TSNeverKeyword = XX;
  ce.TSNonNullExpression = D$;
  ce.TSNullKeyword = JX;
  ce.TSNumberKeyword = RX;
  ce.TSObjectKeyword = UX;
  ce.TSOptionalType = a$;
  ce.TSParameterProperty = CX;
  ce.TSParenthesizedType = h$;
  ce.TSPropertySignature = DX;
  ce.TSQualifiedName = NX;
  ce.TSRestType = o$;
  ce.TSStringKeyword = VX;
  ce.TSSymbolKeyword = KX;
  ce.TSThisType = HX;
  ce.TSTupleType = n$;
  ce.TSTypeAliasDeclaration = g$;
  ce.TSTypeAnnotation = EX;
  ce.TSTypeAssertion = E$;
  ce.TSTypeLiteral = r$;
  ce.TSTypeOperator = d$;
  ce.TSTypeParameter = vX;
  ce.TSTypeParameterDeclaration = ce.TSTypeParameterInstantiation = AX;
  ce.TSTypePredicate = e$;
  ce.TSTypeQuery = t$;
  ce.TSTypeReference = ZX;
  ce.TSUndefinedKeyword = YX;
  ce.TSUnionType = u$;
  ce.TSUnknownKeyword = jX;
  ce.TSVoidKeyword = WX;
  ce.tsPrintClassMemberModifiers = B$;
  ce.tsPrintFunctionOrConstructorType = QX;
  ce.tsPrintPropertyOrMethodName = _X;
  ce.tsPrintSignatureDeclarationBase = M$;
  ce.tsPrintTypeLiteralOrInterfaceBody = s$;
  function EX(t) {
    this.tokenChar(58), this.space(), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(EX, "TSTypeAnnotation");
  function AX(t, e) {
    this.tokenChar(60), this.printList(t.params, t, {}), e.type === "ArrowFunctionExpression" && t.params.length === 1 && this.tokenChar(44),
    this.tokenChar(62);
  }
  n(AX, "TSTypeParameterInstantiation");
  function vX(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint, t)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.
    default, t));
  }
  n(vX, "TSTypeParameter");
  function CX(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  n(CX, "TSParameterProperty");
  function IX(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.tokenChar(59);
  }
  n(IX, "TSDeclareFunction");
  function wX(t) {
    this._classMethodHead(t), this.tokenChar(59);
  }
  n(wX, "TSDeclareMethod");
  function NX(t) {
    this.print(t.left, t), this.tokenChar(46), this.print(t.right, t);
  }
  n(NX, "TSQualifiedName");
  function OX(t) {
    this.tsPrintSignatureDeclarationBase(t), this.tokenChar(59);
  }
  n(OX, "TSCallSignatureDeclaration");
  function kX(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), this.tokenChar(59);
  }
  n(kX, "TSConstructSignatureDeclaration");
  function DX(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation, t), this.tokenChar(59);
  }
  n(DX, "TSPropertySignature");
  function _X(t) {
    t.computed && this.tokenChar(91), this.print(t.key, t), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  n(_X, "tsPrintPropertyOrMethodName");
  function LX(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), this.tokenChar(59);
  }
  n(LX, "TSMethodSignature");
  function MX(t) {
    let {
      readonly: e,
      static: r
    } = t;
    r && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    t), this.tokenChar(93), this.print(t.typeAnnotation, t), this.tokenChar(59);
  }
  n(MX, "TSIndexSignature");
  function BX() {
    this.word("any");
  }
  n(BX, "TSAnyKeyword");
  function FX() {
    this.word("bigint");
  }
  n(FX, "TSBigIntKeyword");
  function jX() {
    this.word("unknown");
  }
  n(jX, "TSUnknownKeyword");
  function RX() {
    this.word("number");
  }
  n(RX, "TSNumberKeyword");
  function UX() {
    this.word("object");
  }
  n(UX, "TSObjectKeyword");
  function qX() {
    this.word("boolean");
  }
  n(qX, "TSBooleanKeyword");
  function VX() {
    this.word("string");
  }
  n(VX, "TSStringKeyword");
  function KX() {
    this.word("symbol");
  }
  n(KX, "TSSymbolKeyword");
  function WX() {
    this.word("void");
  }
  n(WX, "TSVoidKeyword");
  function YX() {
    this.word("undefined");
  }
  n(YX, "TSUndefinedKeyword");
  function JX() {
    this.word("null");
  }
  n(JX, "TSNullKeyword");
  function XX() {
    this.word("never");
  }
  n(XX, "TSNeverKeyword");
  function $X() {
    this.word("intrinsic");
  }
  n($X, "TSIntrinsicKeyword");
  function HX() {
    this.word("this");
  }
  n(HX, "TSThisType");
  function zX(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  n(zX, "TSFunctionType");
  function GX(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  n(GX, "TSConstructorType");
  function QX(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e, t), this.tokenChar(40), this._parameters(r, t), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    let s = t.typeAnnotation;
    this.print(s.typeAnnotation, t);
  }
  n(QX, "tsPrintFunctionOrConstructorType");
  function ZX(t) {
    this.print(t.typeName, t, !0), this.print(t.typeParameters, t, !0);
  }
  n(ZX, "TSTypeReference");
  function e$(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  n(e$, "TSTypePredicate");
  function t$(t) {
    this.word("typeof"), this.space(), this.print(t.exprName), t.typeParameters && this.print(t.typeParameters, t);
  }
  n(t$, "TSTypeQuery");
  function r$(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.members, t);
  }
  n(r$, "TSTypeLiteral");
  function s$(t, e) {
    xh(this, t, e);
  }
  n(s$, "tsPrintTypeLiteralOrInterfaceBody");
  function xh(t, e, r) {
    if (t.token("{"), e.length) {
      t.indent(), t.newline();
      for (let s of e)
        t.print(s, r), t.newline();
      t.dedent();
    }
    t.rightBrace(r);
  }
  n(xh, "tsPrintBraced");
  function i$(t) {
    this.print(t.elementType, t, !0), this.token("[]");
  }
  n(i$, "TSArrayType");
  function n$(t) {
    this.tokenChar(91), this.printList(t.elementTypes, t), this.tokenChar(93);
  }
  n(n$, "TSTupleType");
  function a$(t) {
    this.print(t.typeAnnotation, t), this.tokenChar(63);
  }
  n(a$, "TSOptionalType");
  function o$(t) {
    this.token("..."), this.print(t.typeAnnotation, t);
  }
  n(o$, "TSRestType");
  function l$(t) {
    this.print(t.label, t), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType, t);
  }
  n(l$, "TSNamedTupleMember");
  function u$(t) {
    Fg(this, t, "|");
  }
  n(u$, "TSUnionType");
  function c$(t) {
    Fg(this, t, "&");
  }
  n(c$, "TSIntersectionType");
  function Fg(t, e, r) {
    t.printJoin(e.types, e, {
      separator() {
        this.space(), this.token(r), this.space();
      }
    });
  }
  n(Fg, "tsPrintUnionOrIntersectionType");
  function p$(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  n(p$, "TSConditionalType");
  function f$(t) {
    this.token("infer"), this.space(), this.print(t.typeParameter);
  }
  n(f$, "TSInferType");
  function h$(t) {
    this.tokenChar(40), this.print(t.typeAnnotation, t), this.tokenChar(41);
  }
  n(h$, "TSParenthesizedType");
  function d$(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation, t);
  }
  n(d$, "TSTypeOperator");
  function m$(t) {
    this.print(t.objectType, t, !0), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(m$, "TSIndexedAccessType");
  function y$(t) {
    let {
      nameType: e,
      optional: r,
      readonly: s,
      typeParameter: i,
      typeAnnotation: a
    } = t;
    this.tokenChar(123), this.space(), s && (Bg(this, s), this.word("readonly"), this.space()), this.tokenChar(91), this.word(i.name), this.
    space(), this.word("in"), this.space(), this.print(i.constraint, i), e && (this.space(), this.word("as"), this.space(), this.print(e, t)),
    this.tokenChar(93), r && (Bg(this, r), this.tokenChar(63)), a && (this.tokenChar(58), this.space(), this.print(a, t)), this.space(), this.
    tokenChar(125);
  }
  n(y$, "TSMappedType");
  function Bg(t, e) {
    e !== !0 && t.token(e);
  }
  n(Bg, "tokenIfPlusMinus");
  function T$(t) {
    this.print(t.literal, t);
  }
  n(T$, "TSLiteralType");
  function b$(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t);
  }
  n(b$, "TSExpressionWithTypeArguments");
  function x$(t) {
    let {
      declare: e,
      id: r,
      typeParameters: s,
      extends: i,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, t), this.print(s, t), i != null && i.length &&
    (this.space(), this.word("extends"), this.space(), this.printList(i, t)), this.space(), this.print(a, t);
  }
  n(x$, "TSInterfaceDeclaration");
  function S$(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.body, t);
  }
  n(S$, "TSInterfaceBody");
  function g$(t) {
    let {
      declare: e,
      id: r,
      typeParameters: s,
      typeAnnotation: i
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, t), this.print(s, t), this.space(), this.tokenChar(
    61), this.space(), this.print(i, t), this.tokenChar(59);
  }
  n(g$, "TSTypeAliasDeclaration");
  function P$(t) {
    var e;
    let {
      type: r,
      expression: s,
      typeAnnotation: i
    } = t, a = !!((e = s.trailingComments) != null && e.length);
    this.print(s, t, !0, void 0, a), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i, t);
  }
  n(P$, "TSTypeExpression");
  function E$(t) {
    let {
      typeAnnotation: e,
      expression: r
    } = t;
    this.tokenChar(60), this.print(e, t), this.tokenChar(62), this.space(), this.print(r, t);
  }
  n(E$, "TSTypeAssertion");
  function A$(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t);
  }
  n(A$, "TSInstantiationExpression");
  function v$(t) {
    let {
      declare: e,
      const: r,
      id: s,
      members: i
    } = t;
    e && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(s, t), this.
    space(), xh(this, i, t);
  }
  n(v$, "TSEnumDeclaration");
  function C$(t) {
    let {
      id: e,
      initializer: r
    } = t;
    this.print(e, t), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, t)), this.tokenChar(44);
  }
  n(C$, "TSEnumMember");
  function I$(t) {
    let {
      declare: e,
      id: r
    } = t;
    if (e && (this.word("declare"), this.space()), t.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.
    print(r, t), !t.body) {
      this.tokenChar(59);
      return;
    }
    let s = t.body;
    for (; s.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(s.id, s), s = s.body;
    this.space(), this.print(s, t);
  }
  n(I$, "TSModuleDeclaration");
  function w$(t) {
    xh(this, t.body, t);
  }
  n(w$, "TSModuleBlock");
  function N$(t) {
    let {
      argument: e,
      qualifier: r,
      typeParameters: s
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e, t), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, t)), s && this.print(
    s, t);
  }
  n(N$, "TSImportType");
  function O$(t) {
    let {
      isExport: e,
      id: r,
      moduleReference: s
    } = t;
    e && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, t), this.space(), this.tokenChar(61), this.space(),
    this.print(s, t), this.tokenChar(59);
  }
  n(O$, "TSImportEqualsDeclaration");
  function k$(t) {
    this.token("require("), this.print(t.expression, t), this.tokenChar(41);
  }
  n(k$, "TSExternalModuleReference");
  function D$(t) {
    this.print(t.expression, t), this.tokenChar(33);
  }
  n(D$, "TSNonNullExpression");
  function _$(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression, t), this.tokenChar(59);
  }
  n(_$, "TSExportAssignment");
  function L$(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id, t);
  }
  n(L$, "TSNamespaceExportDeclaration");
  function M$(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e, t), this.tokenChar(40), this._parameters(r, t), this.tokenChar(41);
    let s = t.typeAnnotation;
    this.print(s, t);
  }
  n(M$, "tsPrintSignatureDeclarationBase");
  function B$(t) {
    let e = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    e && t.declare && (this.word("declare"), this.space()), t.accessibility && (this.word(t.accessibility), this.space()), t.static && (this.
    word("static"), this.space()), t.override && (this.word("override"), this.space()), t.abstract && (this.word("abstract"), this.space()),
    e && t.readonly && (this.word("readonly"), this.space());
  }
  n(B$, "tsPrintClassMemberModifiers");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var Rg = w((Ge) => {
  "use strict";
  Object.defineProperty(Ge, "__esModule", {
    value: !0
  });
  var Sh = dg();
  Object.keys(Sh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Sh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Sh[t];
      }, "get")
    });
  });
  var gh = Tg();
  Object.keys(gh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === gh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return gh[t];
      }, "get")
    });
  });
  var Ph = gg();
  Object.keys(Ph).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Ph[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ph[t];
      }, "get")
    });
  });
  var Eh = Pg();
  Object.keys(Eh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Eh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Eh[t];
      }, "get")
    });
  });
  var Ah = Eg();
  Object.keys(Ah).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Ah[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ah[t];
      }, "get")
    });
  });
  var vh = dh();
  Object.keys(vh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === vh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return vh[t];
      }, "get")
    });
  });
  var Ch = Th();
  Object.keys(Ch).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Ch[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ch[t];
      }, "get")
    });
  });
  var Ih = _g();
  Object.keys(Ih).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Ih[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ih[t];
      }, "get")
    });
  });
  var wh = Lg();
  Object.keys(wh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === wh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return wh[t];
      }, "get")
    });
  });
  var Nh = Mg();
  Object.keys(Nh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Nh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Nh[t];
      }, "get")
    });
  });
  var Oh = jg();
  Object.keys(Oh).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Ge && Ge[t] === Oh[t] || Object.defineProperty(Ge, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Oh[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/printer.js
var qg = w((Jl) => {
  "use strict";
  Object.defineProperty(Jl, "__esModule", {
    value: !0
  });
  Jl.default = void 0;
  var F$ = tg(), j$ = fh(), R$ = Ce(), U$ = Rg(), {
    isFunction: q$,
    isStatement: V$,
    isClassBody: K$,
    isTSInterfaceBody: W$,
    isTSEnumDeclaration: Y$
  } = R$, J$ = /e/i, X$ = /\.0+$/, Ug = /[\n\r\u2028\u2029]/, $$ = /[\n\r\u2028\u2029]|\*\//, {
    needsParens: H$
  } = j$, ka = class {
    static {
      n(this, "Printer");
    }
    constructor(e, r) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState =
      null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger =
      !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = e, this.
      _indentRepeat = e.indent.style.length, this._inputMap = r?._inputMap, this._buf = new F$.default(r, e.indent.style[0]);
    }
    generate(e) {
      return this.print(e), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(e = !1) {
      this._maybeAddAuxComment(), e ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      if (!this.format.compact) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let r = this.getLastChar();
          r !== 32 && r !== 10 && this._space();
        }
      }
    }
    word(e, r = !1) {
      this._maybePrintInnerComments(), (this._endsWithWord || e.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(),
      this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(e, r) {
      function s(i) {
        if (i.length > 2 && i.charCodeAt(0) === 48) {
          let a = i.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      n(s, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(r) && !s(e) && !J$.test(e) && !X$.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, r = !1) {
      this._maybePrintInnerComments();
      let s = this.getLastChar(), i = e.charCodeAt(0);
      (s === 33 && (e === "--" || i === 61) || i === 43 && s === 43 || i === 45 && s === 45 || i === 46 && this._endsWithInteger) && this._space(),
      this._maybeAddAuxComment(), this._append(e, r), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this._maybePrintInnerComments();
      let r = this.getLastChar();
      (e === 43 && r === 43 || e === 45 && r === 45 || e === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this.
      _appendChar(e), this._noLineTerminator = !1;
    }
    newline(e = 1, r) {
      if (!(e <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let s = 0; s < e; s++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, r) {
      if (!e) {
        r();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, r);
    }
    source(e, r) {
      r && (this._catchUp(e, r), this._buf.source(e, r));
    }
    sourceWithOffset(e, r, s) {
      r && (this._catchUp(e, r), this._buf.sourceWithOffset(e, r, s));
    }
    withSource(e, r, s) {
      if (!r) {
        s();
        return;
      }
      this._catchUp(e, r), this._buf.withSource(e, r, s);
    }
    sourceIdentifierName(e, r) {
      if (!this._buf._canMarkIdName) return;
      let s = this._buf._sourcePosition;
      s.identifierNamePos = r, s.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(e, r) {
      this._maybeAddParen(e), this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, r), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _appendChar(e) {
      this._maybeAddParenChar(e), this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _queue(e) {
      this._maybeAddParenChar(e), this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    _maybeAddParenChar(e) {
      let r = this._parenPushNewlineState;
      if (r && e !== 32) {
        if (e !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), r.printed = !0;
      }
    }
    _maybeAddParen(e) {
      let r = this._parenPushNewlineState;
      if (!r) return;
      let s = e.length, i;
      for (i = 0; i < s && e.charCodeAt(i) === 32; i++) ;
      if (i === s)
        return;
      let a = e.charCodeAt(i);
      if (a !== 10) {
        if (a !== 47 || i + 1 === s) {
          this._parenPushNewlineState = null;
          return;
        }
        let o = e.charCodeAt(i + 1);
        if (o === 42)
          return;
        if (o !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let r = e - this._buf.getCurrentLine();
      for (let s = 0; s < r; s++)
        this._newline();
    }
    _catchUp(e, r) {
      var s;
      if (!this.format.retainLines) return;
      let i = r == null || (s = r[e]) == null ? void 0 : s.line;
      if (i != null) {
        let a = i - this._buf.getCurrentLine();
        for (let o = 0; o < a; o++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e, r, s) {
      if (s)
        this._noLineTerminator = !0, this.print(e, r);
      else {
        let i = {
          printed: !1
        };
        this._parenPushNewlineState = i, this.print(e, r), i.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(e, r, s, i, a) {
      var o, l;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let u = e.type, c = this.format, p = c.concise;
      e._compact && (c.concise = !0);
      let f = this[u];
      if (f === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(e.constructor.name)}`);
      this._printStack.push(e);
      let m = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !m);
      let y = (o = e.extra) == null ? void 0 : o.parenthesized, T = a || y && c.retainFunctionParens && u === "FunctionExpression" || H$(e, r,
      this._printStack);
      if (!T && y && (l = e.leadingComments) != null && l.length && e.leadingComments[0].type === "CommentBlock")
        switch (r?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (r.callee !== e) break;
          default:
            T = !0;
        }
      T && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(e, r);
      let L = u === "Program" || u === "File" ? null : e.loc;
      this.exactSource(L, f.bind(this, e, r)), T ? (this._printTrailingComments(e, r), this.tokenChar(41), this._noLineTerminator = s) : s &&
      !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(e, r)) : this._printTrailingComments(e, r, i), this.
      _printStack.pop(), c.concise = p, this._insideAux = m, this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let r = e.extra;
      if (r?.raw != null && r.rawValue != null && e.value === r.rawValue)
        return r.raw;
    }
    printJoin(e, r, s = {}) {
      if (!(e != null && e.length)) return;
      let {
        indent: i
      } = s;
      if (i == null && this.format.retainLines) {
        var a;
        let f = (a = e[0].loc) == null ? void 0 : a.start.line;
        f != null && f !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let o = {
        addNewlines: s.addNewlines,
        nextNodeStartLine: 0
      }, l = s.separator ? s.separator.bind(this) : null, u = e.length;
      for (let f = 0; f < u; f++) {
        let m = e[f];
        if (m && (s.statement && this._printNewline(f === 0, o), this.print(m, r, void 0, s.trailingCommentsLineOffset || 0), s.iterator == null ||
        s.iterator(m, f), f < u - 1 && l?.(), s.statement)) {
          var c;
          if ((c = m.trailingComments) != null && c.length || (this._lastCommentLine = 0), f + 1 === u)
            this.newline(1);
          else {
            var p;
            let y = e[f + 1];
            o.nextNodeStartLine = ((p = y.loc) == null ? void 0 : p.start.line) || 0, this._printNewline(!0, o);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e, r) {
      let s = e.leadingComments && e.leadingComments.length > 0;
      s && this.indent(), this.print(e, r), s && this.dedent();
    }
    printBlock(e) {
      let r = e.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r, e);
    }
    _printTrailingComments(e, r, s) {
      let {
        innerComments: i,
        trailingComments: a
      } = e;
      i != null && i.length && this._printComments(2, i, e, r, s), a != null && a.length && this._printComments(2, a, e, r, s);
    }
    _printLeadingComments(e, r) {
      let s = e.leadingComments;
      s != null && s.length && this._printComments(0, s, e, r);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments() {
      let e = this._printStack[this._printStack.length - 1], r = e.innerComments;
      if (!(r != null && r.length)) return;
      let s = this.endsWith(32), i = this._indentInnerComments, a = this._printedComments.size;
      i && this.indent(), this._printComments(1, r, e), s && a !== this._printedComments.size && this.space(), i && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, r, s = {}) {
      var i;
      s.statement = !0, (i = s.indent) != null || (s.indent = !1), this.printJoin(e, r, s);
    }
    printList(e, r, s = {}) {
      s.separator == null && (s.separator = z$), this.printJoin(e, r, s);
    }
    _printNewline(e, r) {
      let s = this.format;
      if (s.retainLines || s.compact) return;
      if (s.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let i = r.nextNodeStartLine, a = this._lastCommentLine;
      if (i > 0 && a > 0) {
        let o = i - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e) {
      return e.ignore || this._printedComments.has(e) ? 0 : this._noLineTerminator && $$.test(e.value) ? 2 : (this._printedComments.add(e), this.
      format.shouldPrintComment(e.value) ? 1 : 0);
    }
    _printComment(e, r) {
      let s = this._noLineTerminator, i = e.type === "CommentBlock", a = i && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && this.space();
      let l;
      if (i) {
        let {
          _parenPushNewlineState: c
        } = this;
        if (c?.printed === !1 && Ug.test(e.value) && (this.tokenChar(40), this.indent(), c.printed = !0), l = `/*${e.value}*/`, this.format.
        indent.adjustMultilineComment) {
          var u;
          let p = (u = e.loc) == null ? void 0 : u.start.column;
          if (p) {
            let f = new RegExp("\\n\\s{1," + p + "}", "g");
            l = l.replace(f, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let f = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (f += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(f)}`);
          }
        }
      } else s ? l = `/*${e.value}*/` : l = `//${e.value}`;
      this.endsWith(47) && this._space(), this.source("start", e.loc), this._append(l, i), !i && !s && this.newline(1, !0), a && r !== 3 && this.
      newline(1);
    }
    _printComments(e, r, s, i, a = 0) {
      let o = s.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, p = u ? o.end.line : 0, f = 0, m = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let T = 0; T < l; T++) {
        let L = r[T], q = this._shouldPrintComment(L);
        if (q === 2) {
          u = !1;
          break;
        }
        if (u && L.loc && q === 1) {
          let _ = L.loc.start.line, U = L.loc.end.line;
          if (e === 0) {
            let J = 0;
            T === 0 ? this._buf.hasContent() && (L.type === "CommentLine" || _ !== U) && (J = m = 1) : J = _ - f, f = U, y(J), this._printComment(
            L, 1), T + 1 === l && (y(Math.max(c - f, m)), f = c);
          } else if (e === 1) {
            let J = _ - (T === 0 ? c : f);
            f = U, y(J), this._printComment(L, 1), T + 1 === l && (y(Math.min(1, p - f)), f = p);
          } else {
            let J = _ - (T === 0 ? p - a : f);
            f = U, y(J), this._printComment(L, 1);
          }
        } else {
          if (u = !1, q !== 1)
            continue;
          if (l === 1) {
            let _ = L.loc ? L.loc.start.line === L.loc.end.line : !Ug.test(L.value), U = _ && !V$(s) && !K$(i) && !W$(i) && !Y$(i);
            e === 0 ? this._printComment(L, U && s.type !== "ObjectExpression" || _ && q$(i, {
              body: s
            }) ? 1 : 0) : U && e === 2 ? this._printComment(L, 1) : this._printComment(L, 0);
          } else e === 1 && !(s.type === "ObjectExpression" && s.properties.length > 1) && s.type !== "ClassBody" && s.type !== "TSInterface\
Body" ? this._printComment(L, T === 0 ? 2 : T === l - 1 ? 3 : 0) : this._printComment(L, 0);
        }
      }
      e === 2 && u && f && (this._lastCommentLine = f);
    }
  };
  Object.assign(ka.prototype, U$);
  ka.prototype.Noop = /* @__PURE__ */ n(function() {
  }, "Noop");
  var c4e = Jl.default = ka;
  function z$() {
    this.tokenChar(44), this.space();
  }
  n(z$, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var Da = w((Xl) => {
  "use strict";
  Object.defineProperty(Xl, "__esModule", {
    value: !0
  });
  Xl.default = G$;
  var Vg = eg(), Kg = qg();
  function Wg(t, e) {
    let r = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    {
      var s;
      r.decoratorsBeforeExport = e.decoratorsBeforeExport, r.jsescOption.json = e.jsonCompatibleStrings, r.recordAndTupleSyntaxType = (s = e.
      recordAndTupleSyntaxType) != null ? s : "hash";
    }
    r.minified ? (r.compact = !0, r.shouldPrintComment = r.shouldPrintComment || (() => r.comments)) : r.shouldPrintComment = r.shouldPrintComment ||
    ((l) => r.comments || l.includes("@license") || l.includes("@preserve")), r.compact === "auto" && (r.compact = typeof t == "string" && t.
    length > 5e5, r.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds th\
e max of 500KB.`)), r.compact && (r.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: i,
      auxiliaryCommentAfter: a,
      shouldPrintComment: o
    } = r;
    return i && !o(i) && (r.auxiliaryCommentBefore = void 0), a && !o(a) && (r.auxiliaryCommentAfter = void 0), r;
  }
  n(Wg, "normalizeOptions");
  Xl.CodeGenerator = class {
    static {
      n(this, "CodeGenerator");
    }
    constructor(e, r = {}, s) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = Wg(s, r), this._map = r.sourceMaps ? new Vg.
      default(r, s) : null;
    }
    generate() {
      return new Kg.default(this._format, this._map).generate(this._ast);
    }
  };
  function G$(t, e = {}, r) {
    let s = Wg(r, e), i = e.sourceMaps ? new Vg.default(e, r) : null;
    return new Kg.default(s, i).generate(t);
  }
  n(G$, "generate");
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var kh = w((He) => {
  "use strict";
  Object.defineProperty(He, "__esModule", {
    value: !0
  });
  He.Var = He.User = He.Statement = He.SpreadProperty = He.Scope = He.RestProperty = He.ReferencedMemberExpression = He.ReferencedIdentifier =
  He.Referenced = He.Pure = He.NumericLiteralTypeAnnotation = He.Generated = He.ForAwaitStatement = He.Flow = He.Expression = He.ExistentialTypeParam =
  He.BlockScoped = He.BindingIdentifier = void 0;
  var y4e = He.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], T4e = He.ReferencedMemberExpression = ["MemberExpression"], b4e = He.
  BindingIdentifier = ["Identifier"], x4e = He.Statement = ["Statement"], S4e = He.Expression = ["Expression"], g4e = He.Scope = ["Scopable",
  "Pattern"], P4e = He.Referenced = null, E4e = He.BlockScoped = null, A4e = He.Var = ["VariableDeclaration"], v4e = He.User = null, C4e = He.
  Generated = null, I4e = He.Pure = null, w4e = He.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], N4e = He.RestProperty =
  ["RestElement"], O4e = He.SpreadProperty = ["RestElement"], k4e = He.ExistentialTypeParam = ["ExistsTypeAnnotation"], D4e = He.NumericLiteralTypeAnnotation =
  ["NumberLiteralTypeAnnotation"], _4e = He.ForAwaitStatement = ["ForOfStatement"];
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var _h = w((Ut) => {
  "use strict";
  Object.defineProperty(Ut, "__esModule", {
    value: !0
  });
  Ut.isBindingIdentifier = SH;
  Ut.isBlockScoped = vH;
  Ut.isExpression = PH;
  Ut.isFlow = OH;
  Ut.isForAwaitStatement = _H;
  Ut.isGenerated = wH;
  Ut.isPure = NH;
  Ut.isReferenced = AH;
  Ut.isReferencedIdentifier = bH;
  Ut.isReferencedMemberExpression = xH;
  Ut.isRestProperty = kH;
  Ut.isScope = EH;
  Ut.isSpreadProperty = DH;
  Ut.isStatement = gH;
  Ut.isUser = IH;
  Ut.isVar = CH;
  var Q$ = Ce(), {
    isBinding: Z$,
    isBlockScoped: eH,
    isExportDeclaration: tH,
    isExpression: rH,
    isFlow: sH,
    isForStatement: iH,
    isForXStatement: nH,
    isIdentifier: Yg,
    isImportDeclaration: aH,
    isImportSpecifier: oH,
    isJSXIdentifier: lH,
    isJSXMemberExpression: uH,
    isMemberExpression: cH,
    isRestElement: Jg,
    isReferenced: Dh,
    isScope: pH,
    isStatement: fH,
    isVar: hH,
    isVariableDeclaration: dH,
    react: mH,
    isForOfStatement: yH
  } = Q$, {
    isCompatTag: TH
  } = mH;
  function bH(t) {
    let {
      node: e,
      parent: r
    } = this;
    if (!Yg(e, t) && !uH(r, t))
      if (lH(e, t)) {
        if (TH(e.name)) return !1;
      } else
        return !1;
    return Dh(e, r, this.parentPath.parent);
  }
  n(bH, "isReferencedIdentifier");
  function xH() {
    let {
      node: t,
      parent: e
    } = this;
    return cH(t) && Dh(t, e);
  }
  n(xH, "isReferencedMemberExpression");
  function SH() {
    let {
      node: t,
      parent: e
    } = this, r = this.parentPath.parent;
    return Yg(t) && Z$(t, e, r);
  }
  n(SH, "isBindingIdentifier");
  function gH() {
    let {
      node: t,
      parent: e
    } = this;
    return fH(t) ? !(dH(t) && (nH(e, {
      left: t
    }) || iH(e, {
      init: t
    }))) : !1;
  }
  n(gH, "isStatement");
  function PH() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : rH(this.node);
  }
  n(PH, "isExpression");
  function EH() {
    return pH(this.node, this.parent);
  }
  n(EH, "isScope");
  function AH() {
    return Dh(this.node, this.parent);
  }
  n(AH, "isReferenced");
  function vH() {
    return eH(this.node);
  }
  n(vH, "isBlockScoped");
  function CH() {
    return hH(this.node);
  }
  n(CH, "isVar");
  function IH() {
    return this.node && !!this.node.loc;
  }
  n(IH, "isUser");
  function wH() {
    return !this.isUser();
  }
  n(wH, "isGenerated");
  function NH(t) {
    return this.scope.isPure(this.node, t);
  }
  n(NH, "isPure");
  function OH() {
    let {
      node: t
    } = this;
    return sH(t) ? !0 : aH(t) ? t.importKind === "type" || t.importKind === "typeof" : tH(t) ? t.exportKind === "type" : oH(t) ? t.importKind ===
    "type" || t.importKind === "typeof" : !1;
  }
  n(OH, "isFlow");
  function kH() {
    return Jg(this.node) && this.parentPath && this.parentPath.isObjectPattern();
  }
  n(kH, "isRestProperty");
  function DH() {
    return Jg(this.node) && this.parentPath && this.parentPath.isObjectExpression();
  }
  n(DH, "isSpreadProperty");
  function _H() {
    return yH(this.node, {
      await: !0
    });
  }
  n(_H, "isForAwaitStatement");
  Ut.isExistentialTypeParam = /* @__PURE__ */ n(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), Ut.isNumericLiteralTypeAnnotation = /* @__PURE__ */ n(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/traverse/lib/visitors.js
var La = w((yn) => {
  "use strict";
  Object.defineProperty(yn, "__esModule", {
    value: !0
  });
  yn.explode = rP;
  yn.isExplodedVisitor = tP;
  yn.merge = jH;
  yn.verify = sP;
  var eP = kh(), LH = _h(), MH = Ce(), {
    DEPRECATED_KEYS: Xg,
    DEPRECATED_ALIASES: $g,
    FLIPPED_ALIAS_KEYS: Hg,
    TYPES: BH,
    __internal__deprecationWarning: zg
  } = MH;
  function FH(t) {
    return t in eP;
  }
  n(FH, "isVirtualType");
  function tP(t) {
    return t?._exploded;
  }
  n(tP, "isExplodedVisitor");
  function rP(t) {
    if (tP(t)) return t;
    t._exploded = !0;
    for (let e of Object.keys(t)) {
      if (_i(e)) continue;
      let r = e.split("|");
      if (r.length === 1) continue;
      let s = t[e];
      delete t[e];
      for (let i of r)
        t[i] = s;
    }
    sP(t), delete t.__esModule, RH(t), Zg(t);
    for (let e of Object.keys(t)) {
      if (_i(e) || !FH(e)) continue;
      let r = t[e];
      for (let i of Object.keys(r))
        r[i] = UH(e, r[i]);
      delete t[e];
      let s = eP[e];
      if (s !== null)
        for (let i of s)
          t[i] ? _a(t[i], r) : t[i] = r;
      else
        _a(t, r);
    }
    for (let e of Object.keys(t)) {
      if (_i(e)) continue;
      let r = Hg[e];
      if (e in Xg) {
        let i = Xg[e];
        zg(e, i, "Visitor "), r = [i];
      } else if (e in $g) {
        let i = $g[e];
        zg(e, i, "Visitor "), r = Hg[i];
      }
      if (!r) continue;
      let s = t[e];
      delete t[e];
      for (let i of r) {
        let a = t[i];
        a ? _a(a, s) : t[i] = Object.assign({}, s);
      }
    }
    for (let e of Object.keys(t))
      _i(e) || Zg(t[e]);
    return t;
  }
  n(rP, "explode");
  function sP(t) {
    if (!t._verified) {
      if (typeof t == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let e of Object.keys(t)) {
        if ((e === "enter" || e === "exit") && Gg(e, t[e]), _i(e)) continue;
        if (BH.indexOf(e) < 0)
          throw new Error(`You gave us a visitor for the node type ${e} but it's not a valid type`);
        let r = t[e];
        if (typeof r == "object")
          for (let s of Object.keys(r))
            if (s === "enter" || s === "exit")
              Gg(`${e}.${s}`, r[s]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${e} that has the invalid property ${s}`);
      }
      t._verified = !0;
    }
  }
  n(sP, "verify");
  function Gg(t, e) {
    let r = [].concat(e);
    for (let s of r)
      if (typeof s != "function")
        throw new TypeError(`Non-function found defined in ${t} with type ${typeof s}`);
  }
  n(Gg, "validateVisitorMethods");
  function jH(t, e = [], r) {
    let s = {};
    for (let i = 0; i < t.length; i++) {
      let a = rP(t[i]), o = e[i], l = a;
      (o || r) && (l = Qg(l, o, r)), _a(s, l);
      for (let u of Object.keys(a)) {
        if (_i(u)) continue;
        let c = a[u];
        (o || r) && (c = Qg(c, o, r));
        let p = s[u] || (s[u] = {});
        _a(p, c);
      }
    }
    return s;
  }
  n(jH, "merge");
  function Qg(t, e, r) {
    let s = {};
    for (let i of ["enter", "exit"]) {
      let a = t[i];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return e && (l = /* @__PURE__ */ n(function(u) {
          o.call(e, u, e);
        }, "newFn")), r && (l = r(e?.key, i, l)), l !== o && (l.toString = () => o.toString()), l;
      }), s[i] = a);
    }
    return s;
  }
  n(Qg, "wrapWithStateOrWrapper");
  function RH(t) {
    for (let e of Object.keys(t)) {
      if (_i(e)) continue;
      let r = t[e];
      typeof r == "function" && (t[e] = {
        enter: r
      });
    }
  }
  n(RH, "ensureEntranceObjects");
  function Zg(t) {
    t.enter && !Array.isArray(t.enter) && (t.enter = [t.enter]), t.exit && !Array.isArray(t.exit) && (t.exit = [t.exit]);
  }
  n(Zg, "ensureCallbackArrays");
  function UH(t, e) {
    let r = `is${t}`, s = LH[r], i = /* @__PURE__ */ n(function(a) {
      if (s.call(a))
        return e.apply(this, arguments);
    }, "newFn");
    return i.toString = () => e.toString(), i;
  }
  n(UH, "wrapCheck");
  function _i(t) {
    return t[0] === "_" || t === "enter" || t === "exit" || t === "shouldSkip" || t === "denylist" || t === "noScope" || t === "skipKeys" ||
    t === "blacklist";
  }
  n(_i, "shouldIgnoreKey");
  function _a(t, e) {
    for (let r of ["enter", "exit"])
      e[r] && (t[r] = [].concat(t[r] || [], e[r]));
  }
  n(_a, "mergePair");
});

// ../node_modules/@babel/traverse/lib/cache.js
var Li = w((_r) => {
  "use strict";
  Object.defineProperty(_r, "__esModule", {
    value: !0
  });
  _r.clear = VH;
  _r.clearPath = iP;
  _r.clearScope = nP;
  _r.getCachedPaths = KH;
  _r.getOrCreateCachedPaths = WH;
  _r.scope = _r.path = void 0;
  var $l = _r.path = /* @__PURE__ */ new WeakMap(), qH = _r.scope = /* @__PURE__ */ new WeakMap();
  function VH() {
    iP(), nP();
  }
  n(VH, "clear");
  function iP() {
    _r.path = $l = /* @__PURE__ */ new WeakMap();
  }
  n(iP, "clearPath");
  function nP() {
    _r.scope = qH = /* @__PURE__ */ new WeakMap();
  }
  n(nP, "clearScope");
  var Lh = Object.freeze({});
  function KH(t, e) {
    var r, s;
    return t = null, (r = $l.get((s = t) != null ? s : Lh)) == null ? void 0 : r.get(e);
  }
  n(KH, "getCachedPaths");
  function WH(t, e) {
    var r, s;
    t = null;
    let i = $l.get((r = t) != null ? r : Lh);
    i || $l.set((s = t) != null ? s : Lh, i = /* @__PURE__ */ new WeakMap());
    let a = i.get(e);
    return a || i.set(e, a = /* @__PURE__ */ new Map()), a;
  }
  n(WH, "getOrCreateCachedPaths");
});

// ../node_modules/debug/node_modules/ms/index.js
var oP = w((q4e, aP) => {
  var Tn = 1e3, bn = Tn * 60, xn = bn * 60, Mi = xn * 24, YH = Mi * 7, JH = Mi * 365.25;
  aP.exports = function(t, e) {
    e = e || {};
    var r = typeof t;
    if (r === "string" && t.length > 0)
      return XH(t);
    if (r === "number" && isFinite(t))
      return e.long ? HH(t) : $H(t);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(t)
    );
  };
  function XH(t) {
    if (t = String(t), !(t.length > 100)) {
      var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        t
      );
      if (e) {
        var r = parseFloat(e[1]), s = (e[2] || "ms").toLowerCase();
        switch (s) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * JH;
          case "weeks":
          case "week":
          case "w":
            return r * YH;
          case "days":
          case "day":
          case "d":
            return r * Mi;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * xn;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * bn;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * Tn;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  n(XH, "parse");
  function $H(t) {
    var e = Math.abs(t);
    return e >= Mi ? Math.round(t / Mi) + "d" : e >= xn ? Math.round(t / xn) + "h" : e >= bn ? Math.round(t / bn) + "m" : e >= Tn ? Math.round(
    t / Tn) + "s" : t + "ms";
  }
  n($H, "fmtShort");
  function HH(t) {
    var e = Math.abs(t);
    return e >= Mi ? Hl(t, e, Mi, "day") : e >= xn ? Hl(t, e, xn, "hour") : e >= bn ? Hl(t, e, bn, "minute") : e >= Tn ? Hl(t, e, Tn, "secon\
d") : t + " ms";
  }
  n(HH, "fmtLong");
  function Hl(t, e, r, s) {
    var i = e >= r * 1.5;
    return Math.round(t / r) + " " + s + (i ? "s" : "");
  }
  n(Hl, "plural");
});

// ../node_modules/debug/src/common.js
var Mh = w((K4e, lP) => {
  function zH(t) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = a, r.enable = i, r.enabled = o, r.humanize = oP(), r.destroy = c, Object.keys(t).forEach(
    (p) => {
      r[p] = t[p];
    }), r.names = [], r.skips = [], r.formatters = {};
    function e(p) {
      let f = 0;
      for (let m = 0; m < p.length; m++)
        f = (f << 5) - f + p.charCodeAt(m), f |= 0;
      return r.colors[Math.abs(f) % r.colors.length];
    }
    n(e, "selectColor"), r.selectColor = e;
    function r(p) {
      let f, m = null, y, T;
      function L(...q) {
        if (!L.enabled)
          return;
        let _ = L, U = Number(/* @__PURE__ */ new Date()), J = U - (f || U);
        _.diff = J, _.prev = f, _.curr = U, f = U, q[0] = r.coerce(q[0]), typeof q[0] != "string" && q.unshift("%O");
        let ie = 0;
        q[0] = q[0].replace(/%([a-zA-Z%])/g, (ne, Be) => {
          if (ne === "%%")
            return "%";
          ie++;
          let bt = r.formatters[Be];
          if (typeof bt == "function") {
            let Et = q[ie];
            ne = bt.call(_, Et), q.splice(ie, 1), ie--;
          }
          return ne;
        }), r.formatArgs.call(_, q), (_.log || r.log).apply(_, q);
      }
      return n(L, "debug"), L.namespace = p, L.useColors = r.useColors(), L.color = r.selectColor(p), L.extend = s, L.destroy = r.destroy, Object.
      defineProperty(L, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ n(() => m !== null ? m : (y !== r.namespaces && (y = r.namespaces, T = r.enabled(p)), T), "get"),
        set: /* @__PURE__ */ n((q) => {
          m = q;
        }, "set")
      }), typeof r.init == "function" && r.init(L), L;
    }
    n(r, "createDebug");
    function s(p, f) {
      let m = r(this.namespace + (typeof f > "u" ? ":" : f) + p);
      return m.log = this.log, m;
    }
    n(s, "extend");
    function i(p) {
      r.save(p), r.namespaces = p, r.names = [], r.skips = [];
      let f, m = (typeof p == "string" ? p : "").split(/[\s,]+/), y = m.length;
      for (f = 0; f < y; f++)
        m[f] && (p = m[f].replace(/\*/g, ".*?"), p[0] === "-" ? r.skips.push(new RegExp("^" + p.slice(1) + "$")) : r.names.push(new RegExp("\
^" + p + "$")));
    }
    n(i, "enable");
    function a() {
      let p = [
        ...r.names.map(l),
        ...r.skips.map(l).map((f) => "-" + f)
      ].join(",");
      return r.enable(""), p;
    }
    n(a, "disable");
    function o(p) {
      if (p[p.length - 1] === "*")
        return !0;
      let f, m;
      for (f = 0, m = r.skips.length; f < m; f++)
        if (r.skips[f].test(p))
          return !1;
      for (f = 0, m = r.names.length; f < m; f++)
        if (r.names[f].test(p))
          return !0;
      return !1;
    }
    n(o, "enabled");
    function l(p) {
      return p.toString().substring(2, p.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    n(l, "toNamespace");
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    n(u, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return n(c, "destroy"), r.enable(r.load()), r;
  }
  n(zH, "setup");
  lP.exports = zH;
});

// ../node_modules/debug/src/browser.js
var uP = w((Lr, zl) => {
  Lr.formatArgs = QH;
  Lr.save = ZH;
  Lr.load = ez;
  Lr.useColors = GH;
  Lr.storage = tz();
  Lr.destroy = /* @__PURE__ */ (() => {
    let t = !1;
    return () => {
      t || (t = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  Lr.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function GH() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "\
u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement &&
    document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  n(GH, "useColors");
  function QH(t) {
    if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" +
    zl.exports.humanize(this.diff), !this.useColors)
      return;
    let e = "color: " + this.color;
    t.splice(1, 0, e, "color: inherit");
    let r = 0, s = 0;
    t[0].replace(/%[a-zA-Z%]/g, (i) => {
      i !== "%%" && (r++, i === "%c" && (s = r));
    }), t.splice(s, 0, e);
  }
  n(QH, "formatArgs");
  Lr.log = console.debug || console.log || (() => {
  });
  function ZH(t) {
    try {
      t ? Lr.storage.setItem("debug", t) : Lr.storage.removeItem("debug");
    } catch {
    }
  }
  n(ZH, "save");
  function ez() {
    let t;
    try {
      t = Lr.storage.getItem("debug");
    } catch {
    }
    return !t && typeof process < "u" && "env" in process && (t = process.env.DEBUG), t;
  }
  n(ez, "load");
  function tz() {
    try {
      return localStorage;
    } catch {
    }
  }
  n(tz, "localstorage");
  zl.exports = Mh()(Lr);
  var { formatters: rz } = zl.exports;
  rz.j = function(t) {
    try {
      return JSON.stringify(t);
    } catch (e) {
      return "[UnexpectedJSONParseError]: " + e.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var pP = w((J4e, cP) => {
  "use strict";
  cP.exports = (t, e = process.argv) => {
    let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", s = e.indexOf(r + t), i = e.indexOf("--");
    return s !== -1 && (i === -1 || s < i);
  };
});

// ../node_modules/supports-color/index.js
var dP = w((X4e, hP) => {
  "use strict";
  var sz = ds("os"), fP = ds("tty"), jr = pP(), { env: Ht } = process, Qs;
  jr("no-color") || jr("no-colors") || jr("color=false") || jr("color=never") ? Qs = 0 : (jr("color") || jr("colors") || jr("color=true") ||
  jr("color=always")) && (Qs = 1);
  "FORCE_COLOR" in Ht && (Ht.FORCE_COLOR === "true" ? Qs = 1 : Ht.FORCE_COLOR === "false" ? Qs = 0 : Qs = Ht.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(Ht.FORCE_COLOR, 10), 3));
  function Bh(t) {
    return t === 0 ? !1 : {
      level: t,
      hasBasic: !0,
      has256: t >= 2,
      has16m: t >= 3
    };
  }
  n(Bh, "translateLevel");
  function Fh(t, e) {
    if (Qs === 0)
      return 0;
    if (jr("color=16m") || jr("color=full") || jr("color=truecolor"))
      return 3;
    if (jr("color=256"))
      return 2;
    if (t && !e && Qs === void 0)
      return 0;
    let r = Qs || 0;
    if (Ht.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let s = sz.release().split(".");
      return Number(s[0]) >= 10 && Number(s[2]) >= 10586 ? Number(s[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in Ht)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((s) => s in Ht) || Ht.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in Ht)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Ht.TEAMCITY_VERSION) ? 1 : 0;
    if (Ht.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in Ht) {
      let s = parseInt((Ht.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Ht.TERM_PROGRAM) {
        case "iTerm.app":
          return s >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Ht.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Ht.TERM) || "COLORTERM" in
    Ht ? 1 : r;
  }
  n(Fh, "supportsColor");
  function iz(t) {
    let e = Fh(t, t && t.isTTY);
    return Bh(e);
  }
  n(iz, "getSupportLevel");
  hP.exports = {
    supportsColor: iz,
    stdout: Bh(Fh(!0, fP.isatty(1))),
    stderr: Bh(Fh(!0, fP.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var yP = w((zt, Ql) => {
  var nz = ds("tty"), Gl = ds("util");
  zt.init = fz;
  zt.log = uz;
  zt.formatArgs = oz;
  zt.save = cz;
  zt.load = pz;
  zt.useColors = az;
  zt.destroy = Gl.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  zt.colors = [6, 2, 3, 4, 5, 1];
  try {
    let t = dP();
    t && (t.stderr || t).level >= 2 && (zt.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  zt.inspectOpts = Object.keys(process.env).filter((t) => /^debug_/i.test(t)).reduce((t, e) => {
    let r = e.substring(6).toLowerCase().replace(/_([a-z])/g, (i, a) => a.toUpperCase()), s = process.env[e];
    return /^(yes|on|true|enabled)$/i.test(s) ? s = !0 : /^(no|off|false|disabled)$/i.test(s) ? s = !1 : s === "null" ? s = null : s = Number(
    s), t[r] = s, t;
  }, {});
  function az() {
    return "colors" in zt.inspectOpts ? !!zt.inspectOpts.colors : nz.isatty(process.stderr.fd);
  }
  n(az, "useColors");
  function oz(t) {
    let { namespace: e, useColors: r } = this;
    if (r) {
      let s = this.color, i = "\x1B[3" + (s < 8 ? s : "8;5;" + s), a = `  ${i};1m${e} \x1B[0m`;
      t[0] = a + t[0].split(`
`).join(`
` + a), t.push(i + "m+" + Ql.exports.humanize(this.diff) + "\x1B[0m");
    } else
      t[0] = lz() + e + " " + t[0];
  }
  n(oz, "formatArgs");
  function lz() {
    return zt.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  n(lz, "getDate");
  function uz(...t) {
    return process.stderr.write(Gl.formatWithOptions(zt.inspectOpts, ...t) + `
`);
  }
  n(uz, "log");
  function cz(t) {
    t ? process.env.DEBUG = t : delete process.env.DEBUG;
  }
  n(cz, "save");
  function pz() {
    return process.env.DEBUG;
  }
  n(pz, "load");
  function fz(t) {
    t.inspectOpts = {};
    let e = Object.keys(zt.inspectOpts);
    for (let r = 0; r < e.length; r++)
      t.inspectOpts[e[r]] = zt.inspectOpts[e[r]];
  }
  n(fz, "init");
  Ql.exports = Mh()(zt);
  var { formatters: mP } = Ql.exports;
  mP.o = function(t) {
    return this.inspectOpts.colors = this.useColors, Gl.inspect(t, this.inspectOpts).split(`
`).map((e) => e.trim()).join(" ");
  };
  mP.O = function(t) {
    return this.inspectOpts.colors = this.useColors, Gl.inspect(t, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var TP = w((z4e, jh) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? jh.exports = uP() : jh.exports = yP();
});

// ../node_modules/@babel/helper-split-export-declaration/lib/index.js
var SP = w((qh) => {
  "use strict";
  Object.defineProperty(qh, "__esModule", {
    value: !0
  });
  qh.default = yz;
  var hz = Ce(), {
    cloneNode: Rh,
    exportNamedDeclaration: bP,
    exportSpecifier: xP,
    identifier: Uh,
    variableDeclaration: dz,
    variableDeclarator: mz
  } = hz;
  function yz(t) {
    if (!t.isExportDeclaration() || t.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (t.isExportDefaultDeclaration()) {
      let a = t.get("declaration"), o = a.isFunctionDeclaration() || a.isClassDeclaration(), l = a.isFunctionExpression() || a.isClassExpression(),
      u = a.isScope() ? a.scope.parent : a.scope, c = a.node.id, p = !1;
      c ? l && u.hasBinding(c.name) && (p = !0, c = u.generateUidIdentifier(c.name)) : (p = !0, c = u.generateUidIdentifier("default"), (o ||
      l) && (a.node.id = Rh(c)));
      let f = o ? a.node : dz("var", [mz(Rh(c), a.node)]), m = bP(null, [xP(Rh(c), Uh("default"))]);
      return t.insertAfter(m), t.replaceWith(f), p && u.registerDeclaration(t), t;
    } else if (t.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let e = t.get("declaration"), r = e.getOuterBindingIdentifiers(), s = Object.keys(r).map((a) => xP(Uh(a), Uh(a))), i = bP(null, s);
    return t.insertAfter(i), t.replaceWith(e.node), t;
  }
  n(yz, "splitExportDeclaration");
});

// ../node_modules/@babel/helper-environment-visitor/lib/index.js
var Kh = w((Sn) => {
  "use strict";
  Object.defineProperty(Sn, "__esModule", {
    value: !0
  });
  Sn.default = void 0;
  Sn.requeueComputedKeyAndDecorators = Vh;
  Sn.skipAllButComputedKey = /* @__PURE__ */ n(function(e) {
    e.skip(), e.node.computed && e.context.maybeQueue(e.get("key"));
  }, "skipAllButComputedKey");
  function Vh(t) {
    let {
      context: e,
      node: r
    } = t;
    if (r.computed && e.maybeQueue(t.get("key")), r.decorators)
      for (let s of t.get("decorators"))
        e.maybeQueue(s);
  }
  n(Vh, "requeueComputedKeyAndDecorators");
  var Tz = {
    FunctionParent(t) {
      t.isArrowFunctionExpression() || (t.skip(), t.isMethod() && Vh(t));
    },
    Property(t) {
      t.isObjectProperty() || (t.skip(), Vh(t));
    }
  }, Z4e = Sn.default = Tz;
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var gP = w((Zl) => {
  "use strict";
  Object.defineProperty(Zl, "__esModule", {
    value: !0
  });
  Zl.default = void 0;
  var bz = SP(), xz = Ce(), Sz = Kh(), gz = eu(), Pz = La(), Ez = {
    ReferencedIdentifier({
      node: t
    }, e) {
      t.name === e.oldName && (t.name = e.newName);
    },
    Scope(t, e) {
      t.scope.bindingIdentifierEquals(e.oldName, e.binding.identifier) || (t.skip(), t.isMethod() && (0, Sz.requeueComputedKeyAndDecorators)(
      t));
    },
    ObjectProperty({
      node: t,
      scope: e
    }, r) {
      let {
        name: s
      } = t.key;
      if (t.shorthand && (s === r.oldName || s === r.newName) && e.getBindingIdentifier(s) === r.binding.identifier) {
        var i;
        t.shorthand = !1, (i = t.extra) != null && i.shorthand && (t.extra.shorthand = !1);
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(t, e) {
      if (t.isVariableDeclaration()) return;
      let r = t.getOuterBindingIdentifiers();
      for (let s in r)
        s === e.oldName && (r[s].name = e.newName);
    }
  }, Wh = class {
    static {
      n(this, "Renamer");
    }
    constructor(e, r, s) {
      this.newName = s, this.oldName = r, this.binding = e;
    }
    maybeConvertFromExportDeclaration(e) {
      let r = e.parentPath;
      if (r.isExportDeclaration()) {
        if (r.isExportDefaultDeclaration()) {
          let {
            declaration: s
          } = r.node;
          if (xz.isDeclaration(s) && !s.id)
            return;
        }
        r.isExportAllDeclaration() || (0, bz.default)(r);
      }
    }
    maybeConvertFromClassFunctionDeclaration(e) {
      return e;
    }
    maybeConvertFromClassFunctionExpression(e) {
      return e;
    }
    rename() {
      let {
        binding: e,
        oldName: r,
        newName: s
      } = this, {
        scope: i,
        path: a
      } = e, o = a.find((u) => u.isDeclaration() || u.isFunctionExpression() || u.isClassExpression());
      o && o.getOuterBindingIdentifiers()[r] === e.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || i.block;
      (0, gz.traverseNode)(l, (0, Pz.explode)(Ez), i, this, i.path, {
        discriminant: !0
      }), arguments[0] || (i.removeOwnBinding(r), i.bindings[s] = e, this.binding.identifier.name = s), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  Zl.default = Wh;
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var PP = w((tu) => {
  "use strict";
  Object.defineProperty(tu, "__esModule", {
    value: !0
  });
  tu.default = void 0;
  var Yh = class {
    static {
      n(this, "Binding");
    }
    constructor({
      identifier: e,
      scope: r,
      path: s,
      kind: i
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = e, this.scope = r, this.path = s, this.kind = i,
      (i === "var" || i === "hoisted") && Az(s) && this.reassign(s), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(e) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = e);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(e) {
      this.constant = !1, this.constantViolations.indexOf(e) === -1 && this.constantViolations.push(e);
    }
    reference(e) {
      this.referencePaths.indexOf(e) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(e));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  tu.default = Yh;
  function Az(t) {
    for (let {
      parentPath: e,
      key: r
    } = t; e; {
      parentPath: e,
      key: r
    } = e) {
      if (e.isFunctionParent()) return !1;
      if (e.isWhile() || e.isForXStatement() || e.isForStatement() && r === "body")
        return !0;
    }
    return !1;
  }
  n(Az, "isDeclaredInLoop");
});

// ../node_modules/@babel/traverse/node_modules/globals/globals.json
var EP = w((a5e, vz) => {
  vz.exports = {
    builtin: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      BigInt: !1,
      BigInt64Array: !1,
      BigUint64Array: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      globalThis: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es5: {
      Array: !1,
      Boolean: !1,
      constructor: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      propertyIsEnumerable: !1,
      RangeError: !1,
      ReferenceError: !1,
      RegExp: !1,
      String: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1
    },
    es2015: {
      Array: !1,
      ArrayBuffer: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    es2017: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1
    },
    browser: {
      AbortController: !1,
      AbortSignal: !1,
      addEventListener: !1,
      alert: !1,
      AnalyserNode: !1,
      Animation: !1,
      AnimationEffectReadOnly: !1,
      AnimationEffectTiming: !1,
      AnimationEffectTimingReadOnly: !1,
      AnimationEvent: !1,
      AnimationPlaybackEvent: !1,
      AnimationTimeline: !1,
      applicationCache: !1,
      ApplicationCache: !1,
      ApplicationCacheErrorEvent: !1,
      atob: !1,
      Attr: !1,
      Audio: !1,
      AudioBuffer: !1,
      AudioBufferSourceNode: !1,
      AudioContext: !1,
      AudioDestinationNode: !1,
      AudioListener: !1,
      AudioNode: !1,
      AudioParam: !1,
      AudioProcessingEvent: !1,
      AudioScheduledSourceNode: !1,
      "AudioWorkletGlobalScope ": !1,
      AudioWorkletNode: !1,
      AudioWorkletProcessor: !1,
      BarProp: !1,
      BaseAudioContext: !1,
      BatteryManager: !1,
      BeforeUnloadEvent: !1,
      BiquadFilterNode: !1,
      Blob: !1,
      BlobEvent: !1,
      blur: !1,
      BroadcastChannel: !1,
      btoa: !1,
      BudgetService: !1,
      ByteLengthQueuingStrategy: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      cancelAnimationFrame: !1,
      cancelIdleCallback: !1,
      CanvasCaptureMediaStreamTrack: !1,
      CanvasGradient: !1,
      CanvasPattern: !1,
      CanvasRenderingContext2D: !1,
      ChannelMergerNode: !1,
      ChannelSplitterNode: !1,
      CharacterData: !1,
      clearInterval: !1,
      clearTimeout: !1,
      clientInformation: !1,
      ClipboardEvent: !1,
      close: !1,
      closed: !1,
      CloseEvent: !1,
      Comment: !1,
      CompositionEvent: !1,
      confirm: !1,
      console: !1,
      ConstantSourceNode: !1,
      ConvolverNode: !1,
      CountQueuingStrategy: !1,
      createImageBitmap: !1,
      Credential: !1,
      CredentialsContainer: !1,
      crypto: !1,
      Crypto: !1,
      CryptoKey: !1,
      CSS: !1,
      CSSConditionRule: !1,
      CSSFontFaceRule: !1,
      CSSGroupingRule: !1,
      CSSImportRule: !1,
      CSSKeyframeRule: !1,
      CSSKeyframesRule: !1,
      CSSMediaRule: !1,
      CSSNamespaceRule: !1,
      CSSPageRule: !1,
      CSSRule: !1,
      CSSRuleList: !1,
      CSSStyleDeclaration: !1,
      CSSStyleRule: !1,
      CSSStyleSheet: !1,
      CSSSupportsRule: !1,
      CustomElementRegistry: !1,
      customElements: !1,
      CustomEvent: !1,
      DataTransfer: !1,
      DataTransferItem: !1,
      DataTransferItemList: !1,
      defaultstatus: !1,
      defaultStatus: !1,
      DelayNode: !1,
      DeviceMotionEvent: !1,
      DeviceOrientationEvent: !1,
      devicePixelRatio: !1,
      dispatchEvent: !1,
      document: !1,
      Document: !1,
      DocumentFragment: !1,
      DocumentType: !1,
      DOMError: !1,
      DOMException: !1,
      DOMImplementation: !1,
      DOMMatrix: !1,
      DOMMatrixReadOnly: !1,
      DOMParser: !1,
      DOMPoint: !1,
      DOMPointReadOnly: !1,
      DOMQuad: !1,
      DOMRect: !1,
      DOMRectReadOnly: !1,
      DOMStringList: !1,
      DOMStringMap: !1,
      DOMTokenList: !1,
      DragEvent: !1,
      DynamicsCompressorNode: !1,
      Element: !1,
      ErrorEvent: !1,
      event: !1,
      Event: !1,
      EventSource: !1,
      EventTarget: !1,
      external: !1,
      fetch: !1,
      File: !1,
      FileList: !1,
      FileReader: !1,
      find: !1,
      focus: !1,
      FocusEvent: !1,
      FontFace: !1,
      FontFaceSetLoadEvent: !1,
      FormData: !1,
      frameElement: !1,
      frames: !1,
      GainNode: !1,
      Gamepad: !1,
      GamepadButton: !1,
      GamepadEvent: !1,
      getComputedStyle: !1,
      getSelection: !1,
      HashChangeEvent: !1,
      Headers: !1,
      history: !1,
      History: !1,
      HTMLAllCollection: !1,
      HTMLAnchorElement: !1,
      HTMLAreaElement: !1,
      HTMLAudioElement: !1,
      HTMLBaseElement: !1,
      HTMLBodyElement: !1,
      HTMLBRElement: !1,
      HTMLButtonElement: !1,
      HTMLCanvasElement: !1,
      HTMLCollection: !1,
      HTMLContentElement: !1,
      HTMLDataElement: !1,
      HTMLDataListElement: !1,
      HTMLDetailsElement: !1,
      HTMLDialogElement: !1,
      HTMLDirectoryElement: !1,
      HTMLDivElement: !1,
      HTMLDListElement: !1,
      HTMLDocument: !1,
      HTMLElement: !1,
      HTMLEmbedElement: !1,
      HTMLFieldSetElement: !1,
      HTMLFontElement: !1,
      HTMLFormControlsCollection: !1,
      HTMLFormElement: !1,
      HTMLFrameElement: !1,
      HTMLFrameSetElement: !1,
      HTMLHeadElement: !1,
      HTMLHeadingElement: !1,
      HTMLHRElement: !1,
      HTMLHtmlElement: !1,
      HTMLIFrameElement: !1,
      HTMLImageElement: !1,
      HTMLInputElement: !1,
      HTMLLabelElement: !1,
      HTMLLegendElement: !1,
      HTMLLIElement: !1,
      HTMLLinkElement: !1,
      HTMLMapElement: !1,
      HTMLMarqueeElement: !1,
      HTMLMediaElement: !1,
      HTMLMenuElement: !1,
      HTMLMetaElement: !1,
      HTMLMeterElement: !1,
      HTMLModElement: !1,
      HTMLObjectElement: !1,
      HTMLOListElement: !1,
      HTMLOptGroupElement: !1,
      HTMLOptionElement: !1,
      HTMLOptionsCollection: !1,
      HTMLOutputElement: !1,
      HTMLParagraphElement: !1,
      HTMLParamElement: !1,
      HTMLPictureElement: !1,
      HTMLPreElement: !1,
      HTMLProgressElement: !1,
      HTMLQuoteElement: !1,
      HTMLScriptElement: !1,
      HTMLSelectElement: !1,
      HTMLShadowElement: !1,
      HTMLSlotElement: !1,
      HTMLSourceElement: !1,
      HTMLSpanElement: !1,
      HTMLStyleElement: !1,
      HTMLTableCaptionElement: !1,
      HTMLTableCellElement: !1,
      HTMLTableColElement: !1,
      HTMLTableElement: !1,
      HTMLTableRowElement: !1,
      HTMLTableSectionElement: !1,
      HTMLTemplateElement: !1,
      HTMLTextAreaElement: !1,
      HTMLTimeElement: !1,
      HTMLTitleElement: !1,
      HTMLTrackElement: !1,
      HTMLUListElement: !1,
      HTMLUnknownElement: !1,
      HTMLVideoElement: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      IdleDeadline: !1,
      IIRFilterNode: !1,
      Image: !1,
      ImageBitmap: !1,
      ImageBitmapRenderingContext: !1,
      ImageCapture: !1,
      ImageData: !1,
      indexedDB: !1,
      innerHeight: !1,
      innerWidth: !1,
      InputEvent: !1,
      IntersectionObserver: !1,
      IntersectionObserverEntry: !1,
      Intl: !1,
      isSecureContext: !1,
      KeyboardEvent: !1,
      KeyframeEffect: !1,
      KeyframeEffectReadOnly: !1,
      length: !1,
      localStorage: !1,
      location: !0,
      Location: !1,
      locationbar: !1,
      matchMedia: !1,
      MediaDeviceInfo: !1,
      MediaDevices: !1,
      MediaElementAudioSourceNode: !1,
      MediaEncryptedEvent: !1,
      MediaError: !1,
      MediaKeyMessageEvent: !1,
      MediaKeySession: !1,
      MediaKeyStatusMap: !1,
      MediaKeySystemAccess: !1,
      MediaList: !1,
      MediaQueryList: !1,
      MediaQueryListEvent: !1,
      MediaRecorder: !1,
      MediaSettingsRange: !1,
      MediaSource: !1,
      MediaStream: !1,
      MediaStreamAudioDestinationNode: !1,
      MediaStreamAudioSourceNode: !1,
      MediaStreamEvent: !1,
      MediaStreamTrack: !1,
      MediaStreamTrackEvent: !1,
      menubar: !1,
      MessageChannel: !1,
      MessageEvent: !1,
      MessagePort: !1,
      MIDIAccess: !1,
      MIDIConnectionEvent: !1,
      MIDIInput: !1,
      MIDIInputMap: !1,
      MIDIMessageEvent: !1,
      MIDIOutput: !1,
      MIDIOutputMap: !1,
      MIDIPort: !1,
      MimeType: !1,
      MimeTypeArray: !1,
      MouseEvent: !1,
      moveBy: !1,
      moveTo: !1,
      MutationEvent: !1,
      MutationObserver: !1,
      MutationRecord: !1,
      name: !1,
      NamedNodeMap: !1,
      NavigationPreloadManager: !1,
      navigator: !1,
      Navigator: !1,
      NetworkInformation: !1,
      Node: !1,
      NodeFilter: !1,
      NodeIterator: !1,
      NodeList: !1,
      Notification: !1,
      OfflineAudioCompletionEvent: !1,
      OfflineAudioContext: !1,
      offscreenBuffering: !1,
      OffscreenCanvas: !0,
      onabort: !0,
      onafterprint: !0,
      onanimationend: !0,
      onanimationiteration: !0,
      onanimationstart: !0,
      onappinstalled: !0,
      onauxclick: !0,
      onbeforeinstallprompt: !0,
      onbeforeprint: !0,
      onbeforeunload: !0,
      onblur: !0,
      oncancel: !0,
      oncanplay: !0,
      oncanplaythrough: !0,
      onchange: !0,
      onclick: !0,
      onclose: !0,
      oncontextmenu: !0,
      oncuechange: !0,
      ondblclick: !0,
      ondevicemotion: !0,
      ondeviceorientation: !0,
      ondeviceorientationabsolute: !0,
      ondrag: !0,
      ondragend: !0,
      ondragenter: !0,
      ondragleave: !0,
      ondragover: !0,
      ondragstart: !0,
      ondrop: !0,
      ondurationchange: !0,
      onemptied: !0,
      onended: !0,
      onerror: !0,
      onfocus: !0,
      ongotpointercapture: !0,
      onhashchange: !0,
      oninput: !0,
      oninvalid: !0,
      onkeydown: !0,
      onkeypress: !0,
      onkeyup: !0,
      onlanguagechange: !0,
      onload: !0,
      onloadeddata: !0,
      onloadedmetadata: !0,
      onloadstart: !0,
      onlostpointercapture: !0,
      onmessage: !0,
      onmessageerror: !0,
      onmousedown: !0,
      onmouseenter: !0,
      onmouseleave: !0,
      onmousemove: !0,
      onmouseout: !0,
      onmouseover: !0,
      onmouseup: !0,
      onmousewheel: !0,
      onoffline: !0,
      ononline: !0,
      onpagehide: !0,
      onpageshow: !0,
      onpause: !0,
      onplay: !0,
      onplaying: !0,
      onpointercancel: !0,
      onpointerdown: !0,
      onpointerenter: !0,
      onpointerleave: !0,
      onpointermove: !0,
      onpointerout: !0,
      onpointerover: !0,
      onpointerup: !0,
      onpopstate: !0,
      onprogress: !0,
      onratechange: !0,
      onrejectionhandled: !0,
      onreset: !0,
      onresize: !0,
      onscroll: !0,
      onsearch: !0,
      onseeked: !0,
      onseeking: !0,
      onselect: !0,
      onstalled: !0,
      onstorage: !0,
      onsubmit: !0,
      onsuspend: !0,
      ontimeupdate: !0,
      ontoggle: !0,
      ontransitionend: !0,
      onunhandledrejection: !0,
      onunload: !0,
      onvolumechange: !0,
      onwaiting: !0,
      onwheel: !0,
      open: !1,
      openDatabase: !1,
      opener: !1,
      Option: !1,
      origin: !1,
      OscillatorNode: !1,
      outerHeight: !1,
      outerWidth: !1,
      PageTransitionEvent: !1,
      pageXOffset: !1,
      pageYOffset: !1,
      PannerNode: !1,
      parent: !1,
      Path2D: !1,
      PaymentAddress: !1,
      PaymentRequest: !1,
      PaymentRequestUpdateEvent: !1,
      PaymentResponse: !1,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceLongTaskTiming: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceNavigationTiming: !1,
      PerformanceObserver: !1,
      PerformanceObserverEntryList: !1,
      PerformancePaintTiming: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      PeriodicWave: !1,
      Permissions: !1,
      PermissionStatus: !1,
      personalbar: !1,
      PhotoCapabilities: !1,
      Plugin: !1,
      PluginArray: !1,
      PointerEvent: !1,
      PopStateEvent: !1,
      postMessage: !1,
      Presentation: !1,
      PresentationAvailability: !1,
      PresentationConnection: !1,
      PresentationConnectionAvailableEvent: !1,
      PresentationConnectionCloseEvent: !1,
      PresentationConnectionList: !1,
      PresentationReceiver: !1,
      PresentationRequest: !1,
      print: !1,
      ProcessingInstruction: !1,
      ProgressEvent: !1,
      PromiseRejectionEvent: !1,
      prompt: !1,
      PushManager: !1,
      PushSubscription: !1,
      PushSubscriptionOptions: !1,
      queueMicrotask: !1,
      RadioNodeList: !1,
      Range: !1,
      ReadableStream: !1,
      registerProcessor: !1,
      RemotePlayback: !1,
      removeEventListener: !1,
      Request: !1,
      requestAnimationFrame: !1,
      requestIdleCallback: !1,
      resizeBy: !1,
      ResizeObserver: !1,
      ResizeObserverEntry: !1,
      resizeTo: !1,
      Response: !1,
      RTCCertificate: !1,
      RTCDataChannel: !1,
      RTCDataChannelEvent: !1,
      RTCDtlsTransport: !1,
      RTCIceCandidate: !1,
      RTCIceGatherer: !1,
      RTCIceTransport: !1,
      RTCPeerConnection: !1,
      RTCPeerConnectionIceEvent: !1,
      RTCRtpContributingSource: !1,
      RTCRtpReceiver: !1,
      RTCRtpSender: !1,
      RTCSctpTransport: !1,
      RTCSessionDescription: !1,
      RTCStatsReport: !1,
      RTCTrackEvent: !1,
      screen: !1,
      Screen: !1,
      screenLeft: !1,
      ScreenOrientation: !1,
      screenTop: !1,
      screenX: !1,
      screenY: !1,
      ScriptProcessorNode: !1,
      scroll: !1,
      scrollbars: !1,
      scrollBy: !1,
      scrollTo: !1,
      scrollX: !1,
      scrollY: !1,
      SecurityPolicyViolationEvent: !1,
      Selection: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerRegistration: !1,
      sessionStorage: !1,
      setInterval: !1,
      setTimeout: !1,
      ShadowRoot: !1,
      SharedWorker: !1,
      SourceBuffer: !1,
      SourceBufferList: !1,
      speechSynthesis: !1,
      SpeechSynthesisEvent: !1,
      SpeechSynthesisUtterance: !1,
      StaticRange: !1,
      status: !1,
      statusbar: !1,
      StereoPannerNode: !1,
      stop: !1,
      Storage: !1,
      StorageEvent: !1,
      StorageManager: !1,
      styleMedia: !1,
      StyleSheet: !1,
      StyleSheetList: !1,
      SubtleCrypto: !1,
      SVGAElement: !1,
      SVGAngle: !1,
      SVGAnimatedAngle: !1,
      SVGAnimatedBoolean: !1,
      SVGAnimatedEnumeration: !1,
      SVGAnimatedInteger: !1,
      SVGAnimatedLength: !1,
      SVGAnimatedLengthList: !1,
      SVGAnimatedNumber: !1,
      SVGAnimatedNumberList: !1,
      SVGAnimatedPreserveAspectRatio: !1,
      SVGAnimatedRect: !1,
      SVGAnimatedString: !1,
      SVGAnimatedTransformList: !1,
      SVGAnimateElement: !1,
      SVGAnimateMotionElement: !1,
      SVGAnimateTransformElement: !1,
      SVGAnimationElement: !1,
      SVGCircleElement: !1,
      SVGClipPathElement: !1,
      SVGComponentTransferFunctionElement: !1,
      SVGDefsElement: !1,
      SVGDescElement: !1,
      SVGDiscardElement: !1,
      SVGElement: !1,
      SVGEllipseElement: !1,
      SVGFEBlendElement: !1,
      SVGFEColorMatrixElement: !1,
      SVGFEComponentTransferElement: !1,
      SVGFECompositeElement: !1,
      SVGFEConvolveMatrixElement: !1,
      SVGFEDiffuseLightingElement: !1,
      SVGFEDisplacementMapElement: !1,
      SVGFEDistantLightElement: !1,
      SVGFEDropShadowElement: !1,
      SVGFEFloodElement: !1,
      SVGFEFuncAElement: !1,
      SVGFEFuncBElement: !1,
      SVGFEFuncGElement: !1,
      SVGFEFuncRElement: !1,
      SVGFEGaussianBlurElement: !1,
      SVGFEImageElement: !1,
      SVGFEMergeElement: !1,
      SVGFEMergeNodeElement: !1,
      SVGFEMorphologyElement: !1,
      SVGFEOffsetElement: !1,
      SVGFEPointLightElement: !1,
      SVGFESpecularLightingElement: !1,
      SVGFESpotLightElement: !1,
      SVGFETileElement: !1,
      SVGFETurbulenceElement: !1,
      SVGFilterElement: !1,
      SVGForeignObjectElement: !1,
      SVGGElement: !1,
      SVGGeometryElement: !1,
      SVGGradientElement: !1,
      SVGGraphicsElement: !1,
      SVGImageElement: !1,
      SVGLength: !1,
      SVGLengthList: !1,
      SVGLinearGradientElement: !1,
      SVGLineElement: !1,
      SVGMarkerElement: !1,
      SVGMaskElement: !1,
      SVGMatrix: !1,
      SVGMetadataElement: !1,
      SVGMPathElement: !1,
      SVGNumber: !1,
      SVGNumberList: !1,
      SVGPathElement: !1,
      SVGPatternElement: !1,
      SVGPoint: !1,
      SVGPointList: !1,
      SVGPolygonElement: !1,
      SVGPolylineElement: !1,
      SVGPreserveAspectRatio: !1,
      SVGRadialGradientElement: !1,
      SVGRect: !1,
      SVGRectElement: !1,
      SVGScriptElement: !1,
      SVGSetElement: !1,
      SVGStopElement: !1,
      SVGStringList: !1,
      SVGStyleElement: !1,
      SVGSVGElement: !1,
      SVGSwitchElement: !1,
      SVGSymbolElement: !1,
      SVGTextContentElement: !1,
      SVGTextElement: !1,
      SVGTextPathElement: !1,
      SVGTextPositioningElement: !1,
      SVGTitleElement: !1,
      SVGTransform: !1,
      SVGTransformList: !1,
      SVGTSpanElement: !1,
      SVGUnitTypes: !1,
      SVGUseElement: !1,
      SVGViewElement: !1,
      TaskAttributionTiming: !1,
      Text: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      TextEvent: !1,
      TextMetrics: !1,
      TextTrack: !1,
      TextTrackCue: !1,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TimeRanges: !1,
      toolbar: !1,
      top: !1,
      Touch: !1,
      TouchEvent: !1,
      TouchList: !1,
      TrackEvent: !1,
      TransitionEvent: !1,
      TreeWalker: !1,
      UIEvent: !1,
      URL: !1,
      URLSearchParams: !1,
      ValidityState: !1,
      visualViewport: !1,
      VisualViewport: !1,
      VTTCue: !1,
      WaveShaperNode: !1,
      WebAssembly: !1,
      WebGL2RenderingContext: !1,
      WebGLActiveInfo: !1,
      WebGLBuffer: !1,
      WebGLContextEvent: !1,
      WebGLFramebuffer: !1,
      WebGLProgram: !1,
      WebGLQuery: !1,
      WebGLRenderbuffer: !1,
      WebGLRenderingContext: !1,
      WebGLSampler: !1,
      WebGLShader: !1,
      WebGLShaderPrecisionFormat: !1,
      WebGLSync: !1,
      WebGLTexture: !1,
      WebGLTransformFeedback: !1,
      WebGLUniformLocation: !1,
      WebGLVertexArrayObject: !1,
      WebSocket: !1,
      WheelEvent: !1,
      window: !1,
      Window: !1,
      Worker: !1,
      WritableStream: !1,
      XMLDocument: !1,
      XMLHttpRequest: !1,
      XMLHttpRequestEventTarget: !1,
      XMLHttpRequestUpload: !1,
      XMLSerializer: !1,
      XPathEvaluator: !1,
      XPathExpression: !1,
      XPathResult: !1,
      XSLTProcessor: !1
    },
    worker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      clearInterval: !1,
      clearTimeout: !1,
      close: !0,
      console: !1,
      fetch: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !0,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onoffline: !0,
      ononline: !0,
      onrejectionhandled: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !0,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    node: {
      __dirname: !1,
      __filename: !1,
      Buffer: !1,
      clearImmediate: !1,
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      exports: !0,
      global: !1,
      Intl: !1,
      module: !1,
      process: !1,
      queueMicrotask: !1,
      require: !1,
      setImmediate: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1
    },
    commonjs: {
      exports: !0,
      global: !1,
      module: !1,
      require: !1
    },
    amd: {
      define: !1,
      require: !1
    },
    mocha: {
      after: !1,
      afterEach: !1,
      before: !1,
      beforeEach: !1,
      context: !1,
      describe: !1,
      it: !1,
      mocha: !1,
      run: !1,
      setup: !1,
      specify: !1,
      suite: !1,
      suiteSetup: !1,
      suiteTeardown: !1,
      teardown: !1,
      test: !1,
      xcontext: !1,
      xdescribe: !1,
      xit: !1,
      xspecify: !1
    },
    jasmine: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fail: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jasmine: !1,
      pending: !1,
      runs: !1,
      spyOn: !1,
      spyOnProperty: !1,
      waits: !1,
      waitsFor: !1,
      xdescribe: !1,
      xit: !1
    },
    jest: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jest: !1,
      pit: !1,
      require: !1,
      test: !1,
      xdescribe: !1,
      xit: !1,
      xtest: !1
    },
    qunit: {
      asyncTest: !1,
      deepEqual: !1,
      equal: !1,
      expect: !1,
      module: !1,
      notDeepEqual: !1,
      notEqual: !1,
      notOk: !1,
      notPropEqual: !1,
      notStrictEqual: !1,
      ok: !1,
      propEqual: !1,
      QUnit: !1,
      raises: !1,
      start: !1,
      stop: !1,
      strictEqual: !1,
      test: !1,
      throws: !1
    },
    phantomjs: {
      console: !0,
      exports: !0,
      phantom: !0,
      require: !0,
      WebPage: !0
    },
    couch: {
      emit: !1,
      exports: !1,
      getRow: !1,
      log: !1,
      module: !1,
      provides: !1,
      require: !1,
      respond: !1,
      send: !1,
      start: !1,
      sum: !1
    },
    rhino: {
      defineClass: !1,
      deserialize: !1,
      gc: !1,
      help: !1,
      importClass: !1,
      importPackage: !1,
      java: !1,
      load: !1,
      loadClass: !1,
      Packages: !1,
      print: !1,
      quit: !1,
      readFile: !1,
      readUrl: !1,
      runCommand: !1,
      seal: !1,
      serialize: !1,
      spawn: !1,
      sync: !1,
      toint32: !1,
      version: !1
    },
    nashorn: {
      __DIR__: !1,
      __FILE__: !1,
      __LINE__: !1,
      com: !1,
      edu: !1,
      exit: !1,
      java: !1,
      Java: !1,
      javafx: !1,
      JavaImporter: !1,
      javax: !1,
      JSAdapter: !1,
      load: !1,
      loadWithNewGlobal: !1,
      org: !1,
      Packages: !1,
      print: !1,
      quit: !1
    },
    wsh: {
      ActiveXObject: !0,
      Enumerator: !0,
      GetObject: !0,
      ScriptEngine: !0,
      ScriptEngineBuildVersion: !0,
      ScriptEngineMajorVersion: !0,
      ScriptEngineMinorVersion: !0,
      VBArray: !0,
      WScript: !0,
      WSH: !0,
      XDomainRequest: !0
    },
    jquery: {
      $: !1,
      jQuery: !1
    },
    yui: {
      YAHOO: !1,
      YAHOO_config: !1,
      YUI: !1,
      YUI_config: !1
    },
    shelljs: {
      cat: !1,
      cd: !1,
      chmod: !1,
      config: !1,
      cp: !1,
      dirs: !1,
      echo: !1,
      env: !1,
      error: !1,
      exec: !1,
      exit: !1,
      find: !1,
      grep: !1,
      ln: !1,
      ls: !1,
      mkdir: !1,
      mv: !1,
      popd: !1,
      pushd: !1,
      pwd: !1,
      rm: !1,
      sed: !1,
      set: !1,
      target: !1,
      tempdir: !1,
      test: !1,
      touch: !1,
      which: !1
    },
    prototypejs: {
      $: !1,
      $$: !1,
      $A: !1,
      $break: !1,
      $continue: !1,
      $F: !1,
      $H: !1,
      $R: !1,
      $w: !1,
      Abstract: !1,
      Ajax: !1,
      Autocompleter: !1,
      Builder: !1,
      Class: !1,
      Control: !1,
      Draggable: !1,
      Draggables: !1,
      Droppables: !1,
      Effect: !1,
      Element: !1,
      Enumerable: !1,
      Event: !1,
      Field: !1,
      Form: !1,
      Hash: !1,
      Insertion: !1,
      ObjectRange: !1,
      PeriodicalExecuter: !1,
      Position: !1,
      Prototype: !1,
      Scriptaculous: !1,
      Selector: !1,
      Sortable: !1,
      SortableObserver: !1,
      Sound: !1,
      Template: !1,
      Toggle: !1,
      Try: !1
    },
    meteor: {
      _: !1,
      $: !1,
      Accounts: !1,
      AccountsClient: !1,
      AccountsCommon: !1,
      AccountsServer: !1,
      App: !1,
      Assets: !1,
      Blaze: !1,
      check: !1,
      Cordova: !1,
      DDP: !1,
      DDPRateLimiter: !1,
      DDPServer: !1,
      Deps: !1,
      EJSON: !1,
      Email: !1,
      HTTP: !1,
      Log: !1,
      Match: !1,
      Meteor: !1,
      Mongo: !1,
      MongoInternals: !1,
      Npm: !1,
      Package: !1,
      Plugin: !1,
      process: !1,
      Random: !1,
      ReactiveDict: !1,
      ReactiveVar: !1,
      Router: !1,
      ServiceConfiguration: !1,
      Session: !1,
      share: !1,
      Spacebars: !1,
      Template: !1,
      Tinytest: !1,
      Tracker: !1,
      UI: !1,
      Utils: !1,
      WebApp: !1,
      WebAppInternals: !1
    },
    mongo: {
      _isWindows: !1,
      _rand: !1,
      BulkWriteResult: !1,
      cat: !1,
      cd: !1,
      connect: !1,
      db: !1,
      getHostName: !1,
      getMemInfo: !1,
      hostname: !1,
      ISODate: !1,
      listFiles: !1,
      load: !1,
      ls: !1,
      md5sumFile: !1,
      mkdir: !1,
      Mongo: !1,
      NumberInt: !1,
      NumberLong: !1,
      ObjectId: !1,
      PlanCache: !1,
      print: !1,
      printjson: !1,
      pwd: !1,
      quit: !1,
      removeFile: !1,
      rs: !1,
      sh: !1,
      UUID: !1,
      version: !1,
      WriteResult: !1
    },
    applescript: {
      $: !1,
      Application: !1,
      Automation: !1,
      console: !1,
      delay: !1,
      Library: !1,
      ObjC: !1,
      ObjectSpecifier: !1,
      Path: !1,
      Progress: !1,
      Ref: !1
    },
    serviceworker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      clearInterval: !1,
      clearTimeout: !1,
      Client: !1,
      clients: !1,
      Clients: !1,
      close: !0,
      console: !1,
      ExtendableEvent: !1,
      ExtendableMessageEvent: !1,
      fetch: !1,
      FetchEvent: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !1,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onfetch: !0,
      oninstall: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onmessageerror: !0,
      onnotificationclick: !0,
      onnotificationclose: !0,
      onoffline: !0,
      ononline: !0,
      onpush: !0,
      onpushsubscriptionchange: !0,
      onrejectionhandled: !0,
      onsync: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      registration: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerGlobalScope: !1,
      ServiceWorkerMessageEvent: !1,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      skipWaiting: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      WindowClient: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1
    },
    atomtest: {
      advanceClock: !1,
      fakeClearInterval: !1,
      fakeClearTimeout: !1,
      fakeSetInterval: !1,
      fakeSetTimeout: !1,
      resetTimeouts: !1,
      waitsForPromise: !1
    },
    embertest: {
      andThen: !1,
      click: !1,
      currentPath: !1,
      currentRouteName: !1,
      currentURL: !1,
      fillIn: !1,
      find: !1,
      findAll: !1,
      findWithAssert: !1,
      keyEvent: !1,
      pauseTest: !1,
      resumeTest: !1,
      triggerEvent: !1,
      visit: !1,
      wait: !1
    },
    protractor: {
      $: !1,
      $$: !1,
      browser: !1,
      by: !1,
      By: !1,
      DartObject: !1,
      element: !1,
      protractor: !1
    },
    "shared-node-browser": {
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      setInterval: !1,
      setTimeout: !1,
      URL: !1,
      URLSearchParams: !1
    },
    webextensions: {
      browser: !1,
      chrome: !1,
      opr: !1
    },
    greasemonkey: {
      cloneInto: !1,
      createObjectIn: !1,
      exportFunction: !1,
      GM: !1,
      GM_addStyle: !1,
      GM_deleteValue: !1,
      GM_getResourceText: !1,
      GM_getResourceURL: !1,
      GM_getValue: !1,
      GM_info: !1,
      GM_listValues: !1,
      GM_log: !1,
      GM_openInTab: !1,
      GM_registerMenuCommand: !1,
      GM_setClipboard: !1,
      GM_setValue: !1,
      GM_xmlhttpRequest: !1,
      unsafeWindow: !1
    },
    devtools: {
      $: !1,
      $_: !1,
      $$: !1,
      $0: !1,
      $1: !1,
      $2: !1,
      $3: !1,
      $4: !1,
      $x: !1,
      chrome: !1,
      clear: !1,
      copy: !1,
      debug: !1,
      dir: !1,
      dirxml: !1,
      getEventListeners: !1,
      inspect: !1,
      keys: !1,
      monitor: !1,
      monitorEvents: !1,
      profile: !1,
      profileEnd: !1,
      queryObjects: !1,
      table: !1,
      undebug: !1,
      unmonitor: !1,
      unmonitorEvents: !1,
      values: !1
    }
  };
});

// ../node_modules/@babel/traverse/node_modules/globals/index.js
var vP = w((o5e, AP) => {
  "use strict";
  AP.exports = EP();
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var Hh = w((su) => {
  "use strict";
  Object.defineProperty(su, "__esModule", {
    value: !0
  });
  su.default = void 0;
  var Cz = gP(), Iz = Fi(), wz = PP(), Nz = vP(), MP = Ce(), Oz = MP, CP = Li(), kz = La(), {
    NOT_LOCAL_BINDING: IP,
    callExpression: wP,
    cloneNode: NP,
    getBindingIdentifiers: Dz,
    identifier: gn,
    isArrayExpression: OP,
    isBinary: _z,
    isCallExpression: kP,
    isClass: Lz,
    isClassBody: Mz,
    isClassDeclaration: Bz,
    isExportAllDeclaration: BP,
    isExportDefaultDeclaration: Fz,
    isExportNamedDeclaration: Jh,
    isFunctionDeclaration: jz,
    isIdentifier: Bi,
    isImportDeclaration: Xh,
    isLiteral: Rz,
    isMemberExpression: Uz,
    isMethod: qz,
    isModuleSpecifier: Vz,
    isNullLiteral: Kz,
    isObjectExpression: Wz,
    isProperty: Yz,
    isPureish: Jz,
    isRegExpLiteral: Xz,
    isSuper: $z,
    isTaggedTemplateExpression: Hz,
    isTemplateLiteral: FP,
    isThisExpression: DP,
    isUnaryExpression: zz,
    isVariableDeclaration: Gz,
    matchesPattern: _P,
    memberExpression: $h,
    numericLiteral: Qz,
    toIdentifier: Zz,
    variableDeclaration: eG,
    variableDeclarator: tG,
    isRecordExpression: rG,
    isTupleExpression: sG,
    isObjectProperty: iG,
    isTopicReference: LP,
    isMetaProperty: nG,
    isPrivateName: aG,
    isExportDeclaration: oG,
    buildUndefinedNode: lG
  } = MP;
  function It(t, e) {
    switch (t?.type) {
      default:
        if (Xh(t) || oG(t)) {
          var r;
          if ((BP(t) || Jh(t) || Xh(t)) && t.source)
            It(t.source, e);
          else if ((Jh(t) || Xh(t)) && (r = t.specifiers) != null && r.length)
            for (let s of t.specifiers) It(s, e);
          else (Fz(t) || Jh(t)) && t.declaration && It(t.declaration, e);
        } else Vz(t) ? It(t.local, e) : Rz(t) && !Kz(t) && !Xz(t) && !FP(t) && e.push(t.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        It(t.object, e), It(t.property, e);
        break;
      case "Identifier":
      case "JSXIdentifier":
        e.push(t.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        It(t.callee, e);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let s of t.properties)
          It(s, e);
        break;
      case "SpreadElement":
      case "RestElement":
        It(t.argument, e);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        It(t.key, e);
        break;
      case "ThisExpression":
        e.push("this");
        break;
      case "Super":
        e.push("super");
        break;
      case "Import":
        e.push("import");
        break;
      case "DoExpression":
        e.push("do");
        break;
      case "YieldExpression":
        e.push("yield"), It(t.argument, e);
        break;
      case "AwaitExpression":
        e.push("await"), It(t.argument, e);
        break;
      case "AssignmentExpression":
        It(t.left, e);
        break;
      case "VariableDeclarator":
        It(t.id, e);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        It(t.id, e);
        break;
      case "PrivateName":
        It(t.id, e);
        break;
      case "ParenthesizedExpression":
        It(t.expression, e);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        It(t.argument, e);
        break;
      case "MetaProperty":
        It(t.meta, e), It(t.property, e);
        break;
      case "JSXElement":
        It(t.openingElement, e);
        break;
      case "JSXOpeningElement":
        It(t.name, e);
        break;
      case "JSXFragment":
        It(t.openingFragment, e);
        break;
      case "JSXOpeningFragment":
        e.push("Fragment");
        break;
      case "JSXNamespacedName":
        It(t.namespace, e), It(t.name, e);
        break;
    }
  }
  n(It, "gatherNodeParts");
  var ru = {
    ForStatement(t) {
      let e = t.get("init");
      if (e.isVar()) {
        let {
          scope: r
        } = t;
        (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", e);
      }
    },
    Declaration(t) {
      if (t.isBlockScoped() || t.isImportDeclaration() || t.isExportDeclaration()) return;
      (t.scope.getFunctionParent() || t.scope.getProgramParent()).registerDeclaration(t);
    },
    ImportDeclaration(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    ReferencedIdentifier(t, e) {
      e.references.push(t);
    },
    ForXStatement(t, e) {
      let r = t.get("left");
      if (r.isPattern() || r.isIdentifier())
        e.constantViolations.push(t);
      else if (r.isVar()) {
        let {
          scope: s
        } = t;
        (s.getFunctionParent() || s.getProgramParent()).registerBinding("var", r);
      }
    },
    ExportDeclaration: {
      exit(t) {
        let {
          node: e,
          scope: r
        } = t;
        if (BP(e)) return;
        let s = e.declaration;
        if (Bz(s) || jz(s)) {
          let i = s.id;
          if (!i) return;
          let a = r.getBinding(i.name);
          a?.reference(t);
        } else if (Gz(s))
          for (let i of s.declarations)
            for (let a of Object.keys(Dz(i))) {
              let o = r.getBinding(a);
              o?.reference(t);
            }
      }
    },
    LabeledStatement(t) {
      t.scope.getBlockParent().registerDeclaration(t);
    },
    AssignmentExpression(t, e) {
      e.assignments.push(t);
    },
    UpdateExpression(t, e) {
      e.constantViolations.push(t);
    },
    UnaryExpression(t, e) {
      t.node.operator === "delete" && e.constantViolations.push(t);
    },
    BlockScoped(t) {
      let e = t.scope;
      if (e.path === t && (e = e.parent), e.getBlockParent().registerDeclaration(t), t.isClassDeclaration() && t.node.id) {
        let i = t.node.id.name;
        t.scope.bindings[i] = t.scope.parent.getBinding(i);
      }
    },
    CatchClause(t) {
      t.scope.registerBinding("let", t);
    },
    Function(t) {
      let e = t.get("params");
      for (let r of e)
        t.scope.registerBinding("param", r);
      t.isFunctionExpression() && t.has("id") && !t.get("id").node[IP] && t.scope.registerBinding("local", t.get("id"), t);
    },
    ClassExpression(t) {
      t.has("id") && !t.get("id").node[IP] && t.scope.registerBinding("local", t);
    }
  }, uG = 0, Ma = class t {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references =
      void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: r
      } = e, s = CP.scope.get(r);
      if (s?.path === e)
        return s;
      CP.scope.set(r, this), this.uid = uG++, this.block = r, this.path = e, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var e;
      let r, s = this.path;
      do {
        let i = s.key === "key" || s.listKey === "decorators";
        s = s.parentPath, i && s.isMethod() && (s = s.parentPath), s && s.isScope() && (r = s);
      } while (s && !r);
      return (e = r) == null ? void 0 : e.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(e, r, s) {
      (0, Iz.default)(e, r, this, s, this.path);
    }
    generateDeclaredUidIdentifier(e) {
      let r = this.generateUidIdentifier(e);
      return this.push({
        id: r
      }), NP(r);
    }
    generateUidIdentifier(e) {
      return gn(this.generateUid(e));
    }
    generateUid(e = "temp") {
      e = Zz(e).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let r, s = 1;
      do
        r = this._generateUid(e, s), s++;
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
      let i = this.getProgramParent();
      return i.references[r] = !0, i.uids[r] = !0, r;
    }
    _generateUid(e, r) {
      let s = e;
      return r > 1 && (s += r), `_${s}`;
    }
    generateUidBasedOnNode(e, r) {
      let s = [];
      It(e, s);
      let i = s.join("$");
      return i = i.replace(/^_/, "") || r || "ref", this.generateUid(i.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(e, r) {
      return gn(this.generateUidBasedOnNode(e, r));
    }
    isStatic(e) {
      if (DP(e) || $z(e) || LP(e))
        return !0;
      if (Bi(e)) {
        let r = this.getBinding(e.name);
        return r ? r.constant : this.hasBinding(e.name);
      }
      return !1;
    }
    maybeGenerateMemoised(e, r) {
      if (this.isStatic(e))
        return null;
      {
        let s = this.generateUidIdentifierBasedOnNode(e);
        return r ? s : (this.push({
          id: s
        }), NP(s));
      }
    }
    checkBlockScopedCollisions(e, r, s, i) {
      if (r === "param" || e.kind === "local") return;
      if (r === "let" || e.kind === "let" || e.kind === "const" || e.kind === "module" || e.kind === "param" && r === "const")
        throw this.hub.buildError(i, `Duplicate declaration "${s}"`, TypeError);
    }
    rename(e, r) {
      let s = this.getBinding(e);
      s && (r || (r = this.generateUidIdentifier(e).name), new Cz.default(s, e, r).rename(arguments[2]));
    }
    _renameFromMap(e, r, s, i) {
      e[r] && (e[s] = i, e[r] = null);
    }
    dump() {
      let e = "-".repeat(60);
      console.log(e);
      let r = this;
      do {
        console.log("#", r.block.type);
        for (let s of Object.keys(r.bindings)) {
          let i = r.bindings[s];
          console.log(" -", s, {
            constant: i.constant,
            references: i.references,
            violations: i.constantViolations.length,
            kind: i.kind
          });
        }
      } while (r = r.parent);
      console.log(e);
    }
    toArray(e, r, s) {
      if (Bi(e)) {
        let o = this.getBinding(e.name);
        if (o != null && o.constant && o.path.isGenericType("Array"))
          return e;
      }
      if (OP(e))
        return e;
      if (Bi(e, {
        name: "arguments"
      }))
        return wP($h($h($h(gn("Array"), gn("prototype")), gn("slice")), gn("call")), [e]);
      let i, a = [e];
      return r === !0 ? i = "toConsumableArray" : typeof r == "number" ? (a.push(Qz(r)), i = "slicedToArray") : i = "toArray", s && (a.unshift(
      this.hub.addHelper(i)), i = "maybeArrayLike"), wP(this.hub.addHelper(i), a);
    }
    hasLabel(e) {
      return !!this.getLabel(e);
    }
    getLabel(e) {
      return this.labels.get(e);
    }
    registerLabel(e) {
      this.labels.set(e.node.label.name, e);
    }
    registerDeclaration(e) {
      if (e.isLabeledStatement())
        this.registerLabel(e);
      else if (e.isFunctionDeclaration())
        this.registerBinding("hoisted", e.get("id"), e);
      else if (e.isVariableDeclaration()) {
        let r = e.get("declarations"), {
          kind: s
        } = e.node;
        for (let i of r)
          this.registerBinding(s === "using" || s === "await using" ? "const" : s, i);
      } else if (e.isClassDeclaration()) {
        if (e.node.declare) return;
        this.registerBinding("let", e);
      } else if (e.isImportDeclaration()) {
        let r = e.node.importKind === "type" || e.node.importKind === "typeof", s = e.get("specifiers");
        for (let i of s) {
          let a = r || i.isImportSpecifier() && (i.node.importKind === "type" || i.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", i);
        }
      } else if (e.isExportDeclaration()) {
        let r = e.get("declaration");
        (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
      } else
        this.registerBinding("unknown", e);
    }
    buildUndefinedNode() {
      return lG();
    }
    registerConstantViolation(e) {
      let r = e.getBindingIdentifiers();
      for (let i of Object.keys(r)) {
        var s;
        (s = this.getBinding(i)) == null || s.reassign(e);
      }
    }
    registerBinding(e, r, s = r) {
      if (!e) throw new ReferenceError("no `kind`");
      if (r.isVariableDeclaration()) {
        let o = r.get("declarations");
        for (let l of o)
          this.registerBinding(e, l);
        return;
      }
      let i = this.getProgramParent(), a = r.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        i.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, e, o, l);
          }
          u ? this.registerConstantViolation(s) : this.bindings[o] = new wz.default({
            identifier: l,
            scope: this,
            path: s,
            kind: e
          });
        }
      }
    }
    addGlobal(e) {
      this.globals[e.name] = e;
    }
    hasUid(e) {
      let r = this;
      do
        if (r.uids[e]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasGlobal(e) {
      let r = this;
      do
        if (r.globals[e]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasReference(e) {
      return !!this.getProgramParent().references[e];
    }
    isPure(e, r) {
      if (Bi(e)) {
        let o = this.getBinding(e.name);
        return o ? r ? o.constant : !0 : !1;
      } else {
        if (DP(e) || nG(e) || LP(e) || aG(e))
          return !0;
        if (Lz(e)) {
          var s;
          return e.superClass && !this.isPure(e.superClass, r) || ((s = e.decorators) == null ? void 0 : s.length) > 0 ? !1 : this.isPure(e.
          body, r);
        } else if (Mz(e)) {
          for (let o of e.body)
            if (!this.isPure(o, r)) return !1;
          return !0;
        } else {
          if (_z(e))
            return this.isPure(e.left, r) && this.isPure(e.right, r);
          if (OP(e) || sG(e)) {
            for (let o of e.elements)
              if (o !== null && !this.isPure(o, r)) return !1;
            return !0;
          } else if (Wz(e) || rG(e)) {
            for (let o of e.properties)
              if (!this.isPure(o, r)) return !1;
            return !0;
          } else if (qz(e)) {
            var i;
            return !(e.computed && !this.isPure(e.key, r) || ((i = e.decorators) == null ? void 0 : i.length) > 0);
          } else if (Yz(e)) {
            var a;
            return !(e.computed && !this.isPure(e.key, r) || ((a = e.decorators) == null ? void 0 : a.length) > 0 || (iG(e) || e.static) && e.
            value !== null && !this.isPure(e.value, r));
          } else {
            if (zz(e))
              return this.isPure(e.argument, r);
            if (FP(e)) {
              for (let o of e.expressions)
                if (!this.isPure(o, r)) return !1;
              return !0;
            } else return Hz(e) ? _P(e.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(e.quasi, r) : Uz(e) ? !e.computed && Bi(e.object) && e.object.name === "Symbol" && Bi(e.property) && e.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : kP(e) ? _P(e.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && e.arguments.length === 1 && Oz.isStringLiteral(e.arguments[0]) : Jz(e);
          }
        }
      }
    }
    setData(e, r) {
      return this.data[e] = r;
    }
    getData(e) {
      let r = this;
      do {
        let s = r.data[e];
        if (s != null) return s;
      } while (r = r.parent);
    }
    removeData(e) {
      let r = this;
      do
        r.data[e] != null && (r.data[e] = null);
      while (r = r.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let e = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.
      create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      let r = this.getProgramParent();
      if (r.crawling) return;
      let s = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, e.type !== "Program" && (0, kz.isExplodedVisitor)(ru)) {
        for (let a of ru.enter)
          a.call(s, e, s);
        let i = ru[e.type];
        if (i)
          for (let a of i.enter)
            a.call(s, e, s);
      }
      e.traverse(ru, s), this.crawling = !1;
      for (let i of s.assignments) {
        let a = i.getBindingIdentifiers();
        for (let o of Object.keys(a))
          i.scope.getBinding(o) || r.addGlobal(a[o]);
        i.scope.registerConstantViolation(i);
      }
      for (let i of s.references) {
        let a = i.scope.getBinding(i.node.name);
        a ? a.reference(i) : r.addGlobal(i.node);
      }
      for (let i of s.constantViolations)
        i.scope.registerConstantViolation(i);
    }
    push(e) {
      let r = this.path;
      r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() &&
      (r = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: s,
        unique: i,
        kind: a = "var",
        id: o
      } = e;
      if (!s && !i && (a === "var" || a === "let") && r.isFunction() && !r.node.name && kP(r.parent, {
        callee: r.node
      }) && r.parent.arguments.length <= r.node.params.length && Bi(o)) {
        r.pushContainer("params", o), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
        return;
      }
      (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
      let l = e._blockHoist == null ? 2 : e._blockHoist, u = `declaration:${a}:${l}`, c = !i && r.getData(u);
      if (!c) {
        let m = eG(a, []);
        m._blockHoist = l, [c] = r.unshiftContainer("body", [m]), i || r.setData(u, c);
      }
      let p = tG(o, s), f = c.node.declarations.push(p);
      r.scope.registerBinding(a, c.get("declarations")[f - 1]);
    }
    getProgramParent() {
      let e = this;
      do
        if (e.path.isProgram())
          return e;
      while (e = e.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let e = this;
      do
        if (e.path.isFunctionParent())
          return e;
      while (e = e.parent);
      return null;
    }
    getBlockParent() {
      let e = this;
      do
        if (e.path.isBlockParent())
          return e;
      while (e = e.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let e = this;
      do
        if (!e.path.isPattern())
          return e.getBlockParent();
      while (e = e.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let e = /* @__PURE__ */ Object.create(null), r = this;
      do {
        for (let s of Object.keys(r.bindings))
          s in e || (e[s] = r.bindings[s]);
        r = r.parent;
      } while (r);
      return e;
    }
    getAllBindingsOfKind(...e) {
      let r = /* @__PURE__ */ Object.create(null);
      for (let s of e) {
        let i = this;
        do {
          for (let a of Object.keys(i.bindings)) {
            let o = i.bindings[a];
            o.kind === s && (r[a] = o);
          }
          i = i.parent;
        } while (i);
      }
      return r;
    }
    bindingIdentifierEquals(e, r) {
      return this.getBindingIdentifier(e) === r;
    }
    getBinding(e) {
      let r = this, s;
      do {
        let a = r.getOwnBinding(e);
        if (a) {
          var i;
          if (!((i = s) != null && i.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && e === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
        s = r.path;
      } while (r = r.parent);
    }
    getOwnBinding(e) {
      return this.bindings[e];
    }
    getBindingIdentifier(e) {
      var r;
      return (r = this.getBinding(e)) == null ? void 0 : r.identifier;
    }
    getOwnBindingIdentifier(e) {
      let r = this.bindings[e];
      return r?.identifier;
    }
    hasOwnBinding(e) {
      return !!this.getOwnBinding(e);
    }
    hasBinding(e, r) {
      var s, i, a;
      return e ? !!(this.hasOwnBinding(e) || (typeof r == "boolean" && (r = {
        noGlobals: r
      }), this.parentHasBinding(e, r)) || !((s = r) != null && s.noUids) && this.hasUid(e) || !((i = r) != null && i.noGlobals) && t.globals.
      includes(e) || !((a = r) != null && a.noGlobals) && t.contextVariables.includes(e)) : !1;
    }
    parentHasBinding(e, r) {
      var s;
      return (s = this.parent) == null ? void 0 : s.hasBinding(e, r);
    }
    moveBindingTo(e, r) {
      let s = this.getBinding(e);
      s && (s.scope.removeOwnBinding(e), s.scope = r, r.bindings[e] = s);
    }
    removeOwnBinding(e) {
      delete this.bindings[e];
    }
    removeBinding(e) {
      var r;
      (r = this.getBinding(e)) == null || r.scope.removeOwnBinding(e);
      let s = this;
      do
        s.uids[e] && (s.uids[e] = !1);
      while (s = s.parent);
    }
  };
  su.default = Ma;
  Ma.globals = Object.keys(Nz.builtin);
  Ma.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/source-map.js
var jP = w((iu) => {
  "use strict";
  Object.defineProperty(iu, "__esModule", {
    value: !0
  });
  iu.default = void 0;
  var Zs = nh(), zh = Ml(), Gh = class {
    static {
      n(this, "SourceMap");
    }
    constructor(e, r) {
      var s;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = void 0;
      let i = this._map = new Zs.GenMapping({
        sourceRoot: e.sourceRoot
      });
      if (this._sourceFileName = (s = e.sourceFileName) == null ? void 0 : s.replace(/\\/g, "/"), this._rawMappings = void 0, e.inputSourceMap) {
        this._inputMap = new zh.TraceMap(e.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, Zs.setSourceContent)(i, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !e.inputSourceMap)
        (0, Zs.setSourceContent)(i, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, Zs.setSourceContent)(i, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, Zs.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, Zs.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, Zs.allMappings)(this._map));
    }
    mark(e, r, s, i, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, zh.originalPositionFor)(this._inputMap, {
            line: r,
            column: s
          }), !u.name && a) {
            let c = (0, zh.originalPositionFor)(this._inputMap, a);
            c.name && (i = c.name);
          }
        } else
          u = {
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: s
          };
      (0, Zs.maybeAddMapping)(this._map, {
        name: i,
        generated: e,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  iu.default = Gh;
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/buffer.js
var RP = w((nu) => {
  "use strict";
  Object.defineProperty(nu, "__esModule", {
    value: !0
  });
  nu.default = void 0;
  var Qh = class {
    static {
      n(this, "Buffer");
    }
    constructor(e, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = e, this._indentChar = r;
      for (let s = 0; s < 64; s++)
        this._fastIndentations.push(r.repeat(s));
      this._allocQueue();
    }
    _allocQueue() {
      let e = this._queue;
      for (let r = 0; r < 16; r++)
        e.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(e, r, s, i, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = e, l.repeat = r, l.line = s, l.column = i, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let e = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: e?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let s = e ? e.get() : null;
          return r.map = s, s;
        },
        set map(s) {
          Object.defineProperty(r, "map", {
            value: s,
            writable: !0
          });
        },
        get rawMappings() {
          let s = e?.getRawMappings();
          return r.rawMappings = s, s;
        },
        set rawMappings(s) {
          Object.defineProperty(r, "rawMappings", {
            value: s,
            writable: !0
          });
        }
      };
      return r;
    }
    append(e, r) {
      this._flush(), this._append(e, this._sourcePosition, r);
    }
    appendChar(e) {
      this._flush(), this._appendChar(e, 1, this._sourcePosition);
    }
    queue(e) {
      if (e === 10)
        for (; this._queueCursor !== 0; ) {
          let s = this._queue[this._queueCursor - 1].char;
          if (s !== 32 && s !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(e, 1, r.line, r.column, r.filename);
    }
    queueIndentation(e) {
      e !== 0 && this._pushQueue(-1, e, void 0, void 0, void 0);
    }
    _flush() {
      let e = this._queueCursor, r = this._queue;
      for (let s = 0; s < e; s++) {
        let i = r[s];
        this._appendChar(i.char, i.repeat, i);
      }
      this._queueCursor = 0;
    }
    _appendChar(e, r, s) {
      if (this._last = e, e === -1) {
        let i = this._fastIndentations[r];
        i !== void 0 ? this._str += i : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(e).repeat(r) : String.fromCharCode(e);
      e !== 10 ? (this._mark(s.line, s.column, s.identifierName, s.identifierNamePos, s.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
    }
    _append(e, r, s) {
      let i = e.length, a = this._position;
      if (this._last = e.charCodeAt(i - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = e, this._appendCount =
      0) : this._str += e, !s && !this._map) {
        a.column += i;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, p = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let f = e.indexOf(`
`), m = 0;
      for (f !== 0 && this._mark(p, o, l, u, c); f !== -1; )
        a.line++, a.column = 0, m = f + 1, m < i && p !== void 0 && this._mark(++p, 0, null, null, c), f = e.indexOf(`
`, m);
      a.column += i - m;
    }
    _mark(e, r, s, i, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, e, r, s, i, a);
    }
    removeTrailingNewline() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let e = this._queueCursor;
      e !== 0 && this._queue[e - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let e = this._queueCursor;
      return e !== 0 ? this._queue[e - 1].char : this._last;
    }
    getNewlineCount() {
      let e = this._queueCursor, r = 0;
      if (e === 0) return this._last === 10 ? 1 : 0;
      for (let s = e - 1; s >= 0 && this._queue[s].char === 10; s--)
        r++;
      return r === e && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let e = this._queue, r = this._queueCursor;
      if (r !== 0)
        return e[r - 1].char !== 10 ? void 0 : r > 1 ? e[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(e, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", e);
      let s = e.identifierName, i = this._sourcePosition;
      s && (this._canMarkIdName = !1, i.identifierName = s), r(), s && (this._canMarkIdName = !0, i.identifierName = void 0, i.identifierNamePos =
      void 0), this.source("end", e);
    }
    source(e, r) {
      this._map && this._normalizePosition(e, r, 0);
    }
    sourceWithOffset(e, r, s) {
      this._map && this._normalizePosition(e, r, s);
    }
    withSource(e, r, s) {
      this._map && this.source(e, r), s();
    }
    _normalizePosition(e, r, s) {
      let i = r[e], a = this._sourcePosition;
      i && (a.line = i.line, a.column = Math.max(i.column + s, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let e = this._queue, r = this._queueCursor, s = -1, i = 0;
      for (let a = 0; a < r; a++) {
        let o = e[a];
        o.char === 10 && (s = i), i += o.repeat;
      }
      return s === -1 ? this._position.column + i : i - 1 - s;
    }
    getCurrentLine() {
      let e = 0, r = this._queue;
      for (let s = 0; s < this._queueCursor; s++)
        r[s].char === 10 && e++;
      return this._position.line + e;
    }
  };
  nu.default = Qh;
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/node/whitespace.js
var WP = w((ou) => {
  "use strict";
  Object.defineProperty(ou, "__esModule", {
    value: !0
  });
  ou.nodes = void 0;
  var cG = Ce(), {
    FLIPPED_ALIAS_KEYS: pG,
    isArrayExpression: fG,
    isAssignmentExpression: qP,
    isBinary: VP,
    isBlockStatement: hG,
    isCallExpression: KP,
    isFunction: Ba,
    isIdentifier: au,
    isLiteral: dG,
    isMemberExpression: Zh,
    isObjectExpression: mG,
    isOptionalCallExpression: yG,
    isOptionalMemberExpression: TG,
    isStringLiteral: bG
  } = cG;
  function Pn(t, e) {
    return t && (Zh(t) || TG(t) ? (Pn(t.object, e), t.computed && Pn(t.property, e)) : VP(t) || qP(t) ? (Pn(t.left, e), Pn(t.right, e)) : KP(
    t) || yG(t) ? (e.hasCall = !0, Pn(t.callee, e)) : Ba(t) ? e.hasFunction = !0 : au(t) && (e.hasHelper = e.hasHelper || t.callee && gs(t.callee))),
    e;
  }
  n(Pn, "crawlInternal");
  function UP(t) {
    return Pn(t, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  n(UP, "crawl");
  function gs(t) {
    return t ? Zh(t) ? gs(t.object) || gs(t.property) : au(t) ? t.name === "require" || t.name.charCodeAt(0) === 95 : KP(t) ? gs(t.callee) :
    VP(t) || qP(t) ? au(t.left) && gs(t.left) || gs(t.right) : !1 : !1;
  }
  n(gs, "isHelper");
  function xG(t) {
    return dG(t) || mG(t) || fG(t) || au(t) || Zh(t);
  }
  n(xG, "isType");
  var ji = ou.nodes = {
    AssignmentExpression(t) {
      let e = UP(t.right);
      if (e.hasCall && e.hasHelper || e.hasFunction)
        return e.hasFunction ? 3 : 2;
    },
    SwitchCase(t, e) {
      return (t.consequent.length || e.cases[0] === t ? 1 : 0) | (!t.consequent.length && e.cases[e.cases.length - 1] === t ? 2 : 0);
    },
    LogicalExpression(t) {
      if (Ba(t.left) || Ba(t.right))
        return 2;
    },
    Literal(t) {
      if (bG(t) && t.value === "use strict")
        return 2;
    },
    CallExpression(t) {
      if (Ba(t.callee) || gs(t))
        return 3;
    },
    OptionalCallExpression(t) {
      if (Ba(t.callee))
        return 3;
    },
    VariableDeclaration(t) {
      for (let e = 0; e < t.declarations.length; e++) {
        let r = t.declarations[e], s = gs(r.id) && !xG(r.init);
        if (!s && r.init) {
          let i = UP(r.init);
          s = gs(r.init) && i.hasCall || i.hasFunction;
        }
        if (s)
          return 3;
      }
    },
    IfStatement(t) {
      if (hG(t.consequent))
        return 3;
    }
  };
  ji.ObjectProperty = ji.ObjectTypeProperty = ji.ObjectMethod = function(t, e) {
    if (e.properties[0] === t)
      return 1;
  };
  ji.ObjectTypeCallProperty = function(t, e) {
    var r;
    if (e.callProperties[0] === t && !((r = e.properties) != null && r.length))
      return 1;
  };
  ji.ObjectTypeIndexer = function(t, e) {
    var r, s;
    if (e.indexers[0] === t && !((r = e.properties) != null && r.length) && !((s = e.callProperties) != null && s.length))
      return 1;
  };
  ji.ObjectTypeInternalSlot = function(t, e) {
    var r, s, i;
    if (e.internalSlots[0] === t && !((r = e.properties) != null && r.length) && !((s = e.callProperties) != null && s.length) && !((i = e.indexers) !=
    null && i.length))
      return 1;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  t, e]) {
    [t].concat(pG[t] || []).forEach(function(r) {
      let s = e ? 3 : 0;
      ji[r] = () => s;
    });
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/node/parentheses.js
var HP = w((ct) => {
  "use strict";
  Object.defineProperty(ct, "__esModule", {
    value: !0
  });
  ct.ArrowFunctionExpression = $G;
  ct.AssignmentExpression = zG;
  ct.Binary = BG;
  ct.BinaryExpression = KG;
  ct.ClassExpression = JG;
  ct.ConditionalExpression = ed;
  ct.DoExpression = MG;
  ct.FunctionExpression = XG;
  ct.FunctionTypeAnnotation = DG;
  ct.Identifier = QG;
  ct.LogicalExpression = GG;
  ct.NullableTypeAnnotation = kG;
  ct.ObjectExpression = LG;
  ct.OptionalIndexedAccessType = jG;
  ct.OptionalCallExpression = ct.OptionalMemberExpression = HG;
  ct.SequenceExpression = WG;
  ct.TSTypeAssertion = ct.TSSatisfiesExpression = ct.TSAsExpression = RG;
  ct.TSInferType = qG;
  ct.TSInstantiationExpression = VG;
  ct.TSIntersectionType = ct.TSUnionType = UG;
  ct.UnaryLike = $P;
  ct.IntersectionTypeAnnotation = ct.UnionTypeAnnotation = FG;
  ct.UpdateExpression = _G;
  ct.AwaitExpression = ct.YieldExpression = YG;
  var SG = Ce(), {
    isArrayTypeAnnotation: gG,
    isArrowFunctionExpression: PG,
    isBinaryExpression: EG,
    isCallExpression: AG,
    isExportDeclaration: vG,
    isForOfStatement: CG,
    isIndexedAccessType: IG,
    isMemberExpression: JP,
    isObjectPattern: wG,
    isOptionalMemberExpression: NG,
    isYieldExpression: OG
  } = SG, YP = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function XP(t) {
    return t === "TSAsExpression" || t === "TSSatisfiesExpression" || t === "TSTypeAssertion";
  }
  n(XP, "isTSTypeExpression");
  var lu = /* @__PURE__ */ n((t, e) => {
    let r = e.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && e.superClass === t;
  }, "isClassExtendsClause"), Fa = /* @__PURE__ */ n((t, e) => {
    let r = e.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && e.object === t || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && e.callee === t || r === "TaggedTemplateExpression" && e.tag === t || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function kG(t, e) {
    return gG(e);
  }
  n(kG, "NullableTypeAnnotation");
  function DG(t, e, r) {
    if (r.length < 3) return;
    let s = e.type;
    return s === "UnionTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "ArrayTypeAnnotation" || s === "TypeAnnotation" && PG(
    r[r.length - 3]);
  }
  n(DG, "FunctionTypeAnnotation");
  function _G(t, e) {
    return Fa(t, e) || lu(t, e);
  }
  n(_G, "UpdateExpression");
  function LG(t, e, r) {
    return ja(r, 3);
  }
  n(LG, "ObjectExpression");
  function MG(t, e, r) {
    return !t.async && ja(r, 1);
  }
  n(MG, "DoExpression");
  function BG(t, e) {
    let r = e.type;
    if (t.operator === "**" && r === "BinaryExpression" && e.operator === "**")
      return e.left === t;
    if (lu(t, e) || Fa(t, e) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    if (r === "BinaryExpression" || r === "LogicalExpression") {
      let s = YP.get(e.operator), i = YP.get(t.operator);
      if (s === i && e.right === t && r !== "LogicalExpression" || s > i)
        return !0;
    }
  }
  n(BG, "Binary");
  function FG(t, e) {
    let r = e.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  n(FG, "UnionTypeAnnotation");
  function jG(t, e) {
    return IG(e) && e.objectType === t;
  }
  n(jG, "OptionalIndexedAccessType");
  function RG() {
    return !0;
  }
  n(RG, "TSAsExpression");
  function UG(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSUnionType" || r === "TSRestType";
  }
  n(UG, "TSUnionType");
  function qG(t, e) {
    let r = e.type;
    return r === "TSArrayType" || r === "TSOptionalType";
  }
  n(qG, "TSInferType");
  function VG(t, e) {
    let r = e.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!e.typeParameters;
  }
  n(VG, "TSInstantiationExpression");
  function KG(t, e) {
    if (t.operator === "in") {
      let r = e.type;
      return r === "VariableDeclarator" || r === "ForStatement" || r === "ForInStatement" || r === "ForOfStatement";
    }
    return !1;
  }
  n(KG, "BinaryExpression");
  function WG(t, e) {
    let r = e.type;
    return !(r === "ForStatement" || r === "ThrowStatement" || r === "ReturnStatement" || r === "IfStatement" && e.test === t || r === "Whil\
eStatement" && e.test === t || r === "ForInStatement" && e.right === t || r === "SwitchStatement" && e.discriminant === t || r === "Expressi\
onStatement" && e.expression === t);
  }
  n(WG, "SequenceExpression");
  function YG(t, e) {
    let r = e.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || Fa(t, e) || r === "A\
waitExpression" && OG(t) || r === "ConditionalExpression" && t === e.test || lu(t, e);
  }
  n(YG, "YieldExpression");
  function JG(t, e, r) {
    return ja(r, 5);
  }
  n(JG, "ClassExpression");
  function $P(t, e) {
    return Fa(t, e) || EG(e) && e.operator === "**" && e.left === t || lu(t, e);
  }
  n($P, "UnaryLike");
  function XG(t, e, r) {
    return ja(r, 5);
  }
  n(XG, "FunctionExpression");
  function $G(t, e) {
    return vG(e) || ed(t, e);
  }
  n($G, "ArrowFunctionExpression");
  function ed(t, e) {
    let r = e.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && e.test === t || r === "AwaitExpression" || XP(r) ? !0 : $P(t, e);
  }
  n(ed, "ConditionalExpression");
  function HG(t, e) {
    return AG(e) && e.callee === t || JP(e) && e.object === t;
  }
  n(HG, "OptionalMemberExpression");
  function zG(t, e) {
    return wG(t.left) ? !0 : ed(t, e);
  }
  n(zG, "AssignmentExpression");
  function GG(t, e) {
    let r = e.type;
    if (XP(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (t.operator) {
      case "||":
        return e.operator === "??" || e.operator === "&&";
      case "&&":
        return e.operator === "??";
      case "??":
        return e.operator !== "??";
    }
  }
  n(GG, "LogicalExpression");
  function QG(t, e, r) {
    var s;
    let i = e.type;
    if ((s = t.extra) != null && s.parenthesized && i === "AssignmentExpression" && e.left === t) {
      let a = e.right.type;
      if ((a === "FunctionExpression" || a === "ClassExpression") && e.right.id == null)
        return !0;
    }
    if (t.name === "let") {
      let a = JP(e, {
        object: t,
        computed: !0
      }) || NG(e, {
        object: t,
        computed: !0,
        optional: !1
      });
      return ja(r, a ? 57 : 32);
    }
    return t.name === "async" && CG(e) && t === e.left;
  }
  n(QG, "Identifier");
  function ja(t, e) {
    let r = e & 1, s = e & 2, i = e & 4, a = e & 8, o = e & 16, l = e & 32, u = t.length - 1;
    if (u <= 0) return;
    let c = t[u];
    u--;
    let p = t[u];
    for (; u >= 0; ) {
      let f = p.type;
      if (r && f === "ExpressionStatement" && p.expression === c || i && f === "ExportDefaultDeclaration" && c === p.declaration || s && f ===
      "ArrowFunctionExpression" && p.body === c || a && f === "ForStatement" && p.init === c || o && f === "ForInStatement" && p.left === c ||
      l && f === "ForOfStatement" && p.left === c)
        return !0;
      if (u > 0 && (Fa(c, p) && f !== "NewExpression" || f === "SequenceExpression" && p.expressions[0] === c || f === "UpdateExpression" &&
      !p.prefix || f === "ConditionalExpression" && p.test === c || (f === "BinaryExpression" || f === "LogicalExpression") && p.left === c ||
      f === "AssignmentExpression" && p.left === c))
        c = p, u--, p = t[u];
      else
        return !1;
    }
    return !1;
  }
  n(ja, "isFirstInContext");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/node/index.js
var rd = w((En) => {
  "use strict";
  Object.defineProperty(En, "__esModule", {
    value: !0
  });
  En.needsParens = pQ;
  En.needsWhitespace = td;
  En.needsWhitespaceAfter = cQ;
  En.needsWhitespaceBefore = uQ;
  var ZG = WP(), eQ = HP(), tQ = Ce(), {
    FLIPPED_ALIAS_KEYS: rQ,
    isCallExpression: sQ,
    isExpressionStatement: iQ,
    isMemberExpression: nQ,
    isNewExpression: aQ
  } = tQ;
  function zP(t) {
    let e = /* @__PURE__ */ new Map();
    function r(s, i) {
      let a = e.get(s);
      e.set(s, a ? function(o, l, u) {
        var c;
        return (c = a(o, l, u)) != null ? c : i(o, l, u);
      } : i);
    }
    n(r, "add");
    for (let s of Object.keys(t)) {
      let i = rQ[s];
      if (i)
        for (let a of i)
          r(a, t[s]);
      else
        r(s, t[s]);
    }
    return e;
  }
  n(zP, "expandAliases");
  var oQ = zP(eQ), lQ = zP(ZG.nodes);
  function GP(t) {
    return sQ(t) ? !0 : nQ(t) && GP(t.object);
  }
  n(GP, "isOrHasCallExpression");
  function td(t, e, r) {
    var s;
    if (!t) return !1;
    iQ(t) && (t = t.expression);
    let i = (s = lQ.get(t.type)) == null ? void 0 : s(t, e);
    return typeof i == "number" ? (i & r) !== 0 : !1;
  }
  n(td, "needsWhitespace");
  function uQ(t, e) {
    return td(t, e, 1);
  }
  n(uQ, "needsWhitespaceBefore");
  function cQ(t, e) {
    return td(t, e, 2);
  }
  n(cQ, "needsWhitespaceAfter");
  function pQ(t, e, r) {
    var s;
    return e ? aQ(e) && e.callee === t && GP(t) ? !0 : (s = oQ.get(t.type)) == null ? void 0 : s(t, e, r) : !1;
  }
  n(pQ, "needsParens");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/template-literals.js
var QP = w((Ra) => {
  "use strict";
  Object.defineProperty(Ra, "__esModule", {
    value: !0
  });
  Ra.TaggedTemplateExpression = fQ;
  Ra.TemplateElement = hQ;
  Ra.TemplateLiteral = dQ;
  function fQ(t) {
    this.print(t.tag, t), this.print(t.typeParameters, t), this.print(t.quasi, t);
  }
  n(fQ, "TaggedTemplateExpression");
  function hQ(t, e) {
    let r = e.quasis[0] === t, s = e.quasis[e.quasis.length - 1] === t, i = (r ? "`" : "}") + t.value.raw + (s ? "`" : "${");
    this.token(i, !0);
  }
  n(hQ, "TemplateElement");
  function dQ(t) {
    let e = t.quasis;
    for (let r = 0; r < e.length; r++)
      this.print(e[r], t), r + 1 < e.length && this.print(t.expressions[r], t);
  }
  n(dQ, "TemplateLiteral");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/expressions.js
var tE = w((Tt) => {
  "use strict";
  Object.defineProperty(Tt, "__esModule", {
    value: !0
  });
  Tt.LogicalExpression = Tt.BinaryExpression = Tt.AssignmentExpression = UQ;
  Tt.AssignmentPattern = RQ;
  Tt.AwaitExpression = MQ;
  Tt.BindExpression = qQ;
  Tt.CallExpression = _Q;
  Tt.ConditionalExpression = EQ;
  Tt.Decorator = OQ;
  Tt.DoExpression = SQ;
  Tt.EmptyStatement = FQ;
  Tt.ExpressionStatement = jQ;
  Tt.Import = LQ;
  Tt.MemberExpression = VQ;
  Tt.MetaProperty = KQ;
  Tt.ModuleExpression = JQ;
  Tt.NewExpression = AQ;
  Tt.OptionalCallExpression = DQ;
  Tt.OptionalMemberExpression = kQ;
  Tt.ParenthesizedExpression = gQ;
  Tt.PrivateName = WQ;
  Tt.SequenceExpression = vQ;
  Tt.Super = IQ;
  Tt.ThisExpression = CQ;
  Tt.UnaryExpression = xQ;
  Tt.UpdateExpression = PQ;
  Tt.V8IntrinsicIdentifier = YQ;
  Tt.YieldExpression = BQ;
  Tt._shouldPrintDecoratorsBeforeExport = NQ;
  var mQ = Ce(), yQ = rd(), {
    isCallExpression: TQ,
    isLiteral: ZP,
    isMemberExpression: sd,
    isNewExpression: bQ
  } = mQ;
  function xQ(t) {
    let {
      operator: e
    } = t;
    e === "void" || e === "delete" || e === "typeof" || e === "throw" ? (this.word(e), this.space()) : this.token(e), this.print(t.argument,
    t);
  }
  n(xQ, "UnaryExpression");
  function SQ(t) {
    t.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(t.body, t);
  }
  n(SQ, "DoExpression");
  function gQ(t) {
    this.tokenChar(40), this.print(t.expression, t), this.rightParens(t);
  }
  n(gQ, "ParenthesizedExpression");
  function PQ(t) {
    t.prefix ? (this.token(t.operator), this.print(t.argument, t)) : (this.printTerminatorless(t.argument, t, !0), this.token(t.operator));
  }
  n(PQ, "UpdateExpression");
  function EQ(t) {
    this.print(t.test, t), this.space(), this.tokenChar(63), this.space(), this.print(t.consequent, t), this.space(), this.tokenChar(58), this.
    space(), this.print(t.alternate, t);
  }
  n(EQ, "ConditionalExpression");
  function AQ(t, e) {
    this.word("new"), this.space(), this.print(t.callee, t), !(this.format.minified && t.arguments.length === 0 && !t.optional && !TQ(e, {
      callee: t
    }) && !sd(e) && !bQ(e)) && (this.print(t.typeArguments, t), this.print(t.typeParameters, t), t.optional && this.token("?."), this.tokenChar(
    40), this.printList(t.arguments, t), this.rightParens(t));
  }
  n(AQ, "NewExpression");
  function vQ(t) {
    this.printList(t.expressions, t);
  }
  n(vQ, "SequenceExpression");
  function CQ() {
    this.word("this");
  }
  n(CQ, "ThisExpression");
  function IQ() {
    this.word("super");
  }
  n(IQ, "Super");
  function eE(t) {
    switch (t.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !t.computed && t.property.type === "Identifier" && eE(t.object);
      default:
        return !1;
    }
  }
  n(eE, "isDecoratorMemberExpression");
  function wQ(t) {
    return t.type === "ParenthesizedExpression" ? !1 : !eE(t.type === "CallExpression" ? t.callee : t);
  }
  n(wQ, "shouldParenthesizeDecoratorExpression");
  function NQ(t) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof t.start == "number" && t.start ===
    t.declaration.start;
  }
  n(NQ, "_shouldPrintDecoratorsBeforeExport");
  function OQ(t) {
    this.tokenChar(64);
    let {
      expression: e
    } = t;
    wQ(e) ? (this.tokenChar(40), this.print(e, t), this.tokenChar(41)) : this.print(e, t), this.newline();
  }
  n(OQ, "Decorator");
  function kQ(t) {
    let {
      computed: e
    } = t, {
      optional: r,
      property: s
    } = t;
    if (this.print(t.object, t), !e && sd(s))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    ZP(s) && typeof s.value == "number" && (e = !0), r && this.token("?."), e ? (this.tokenChar(91), this.print(s, t), this.tokenChar(93)) :
    (r || this.tokenChar(46), this.print(s, t));
  }
  n(kQ, "OptionalMemberExpression");
  function DQ(t) {
    this.print(t.callee, t), this.print(t.typeParameters, t), t.optional && this.token("?."), this.print(t.typeArguments, t), this.tokenChar(
    40), this.printList(t.arguments, t), this.rightParens(t);
  }
  n(DQ, "OptionalCallExpression");
  function _Q(t) {
    this.print(t.callee, t), this.print(t.typeArguments, t), this.print(t.typeParameters, t), this.tokenChar(40), this.printList(t.arguments,
    t), this.rightParens(t);
  }
  n(_Q, "CallExpression");
  function LQ() {
    this.word("import");
  }
  n(LQ, "Import");
  function MQ(t) {
    this.word("await"), t.argument && (this.space(), this.printTerminatorless(t.argument, t, !1));
  }
  n(MQ, "AwaitExpression");
  function BQ(t) {
    this.word("yield", !0), t.delegate ? (this.tokenChar(42), t.argument && (this.space(), this.print(t.argument, t))) : t.argument && (this.
    space(), this.printTerminatorless(t.argument, t, !1));
  }
  n(BQ, "YieldExpression");
  function FQ() {
    this.semicolon(!0);
  }
  n(FQ, "EmptyStatement");
  function jQ(t) {
    this.print(t.expression, t), this.semicolon();
  }
  n(jQ, "ExpressionStatement");
  function RQ(t) {
    this.print(t.left, t), t.left.optional && this.tokenChar(63), this.print(t.left.typeAnnotation, t), this.space(), this.tokenChar(61), this.
    space(), this.print(t.right, t);
  }
  n(RQ, "AssignmentPattern");
  function UQ(t, e) {
    let r = this.inForStatementInitCounter && t.operator === "in" && !yQ.needsParens(t, e);
    r && this.tokenChar(40), this.print(t.left, t), this.space(), t.operator === "in" || t.operator === "instanceof" ? this.word(t.operator) :
    this.token(t.operator), this.space(), this.print(t.right, t), r && this.tokenChar(41);
  }
  n(UQ, "AssignmentExpression");
  function qQ(t) {
    this.print(t.object, t), this.token("::"), this.print(t.callee, t);
  }
  n(qQ, "BindExpression");
  function VQ(t) {
    if (this.print(t.object, t), !t.computed && sd(t.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let e = t.computed;
    ZP(t.property) && typeof t.property.value == "number" && (e = !0), e ? (this.tokenChar(91), this.print(t.property, t), this.tokenChar(93)) :
    (this.tokenChar(46), this.print(t.property, t));
  }
  n(VQ, "MemberExpression");
  function KQ(t) {
    this.print(t.meta, t), this.tokenChar(46), this.print(t.property, t);
  }
  n(KQ, "MetaProperty");
  function WQ(t) {
    this.tokenChar(35), this.print(t.id, t);
  }
  n(WQ, "PrivateName");
  function YQ(t) {
    this.tokenChar(37), this.word(t.name);
  }
  n(YQ, "V8IntrinsicIdentifier");
  function JQ(t) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: e
    } = t;
    (e.body.length || e.directives.length) && this.newline(), this.print(e, t), this.dedent(), this.rightBrace(t);
  }
  n(JQ, "ModuleExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/statements.js
var nE = w((_t) => {
  "use strict";
  Object.defineProperty(_t, "__esModule", {
    value: !0
  });
  _t.BreakStatement = rZ;
  _t.CatchClause = lZ;
  _t.ContinueStatement = sZ;
  _t.DebuggerStatement = pZ;
  _t.DoWhileStatement = tZ;
  _t.ForOfStatement = _t.ForInStatement = void 0;
  _t.ForStatement = ZQ;
  _t.IfStatement = QQ;
  _t.LabeledStatement = aZ;
  _t.ReturnStatement = iZ;
  _t.SwitchCase = cZ;
  _t.SwitchStatement = uZ;
  _t.ThrowStatement = nZ;
  _t.TryStatement = oZ;
  _t.VariableDeclaration = fZ;
  _t.VariableDeclarator = hZ;
  _t.WhileStatement = eZ;
  _t.WithStatement = GQ;
  var XQ = Ce(), {
    isFor: rE,
    isForStatement: $Q,
    isIfStatement: HQ,
    isStatement: zQ
  } = XQ;
  function GQ(t) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(t.object, t), this.tokenChar(41), this.printBlock(t);
  }
  n(GQ, "WithStatement");
  function QQ(t) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(t.test, t), this.tokenChar(41), this.space();
    let e = t.alternate && HQ(sE(t.consequent));
    e && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(t.consequent, t), e && (this.dedent(), this.newline(),
    this.tokenChar(125)), t.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    t.alternate, t));
  }
  n(QQ, "IfStatement");
  function sE(t) {
    let {
      body: e
    } = t;
    return zQ(e) === !1 ? t : sE(e);
  }
  n(sE, "getLastStatement");
  function ZQ(t) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(t.init, t), this.inForStatementInitCounter--,
    this.tokenChar(59), t.test && (this.space(), this.print(t.test, t)), this.tokenChar(59), t.update && (this.space(), this.print(t.update,
    t)), this.tokenChar(41), this.printBlock(t);
  }
  n(ZQ, "ForStatement");
  function eZ(t) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(t.test, t), this.tokenChar(41), this.printBlock(t);
  }
  n(eZ, "WhileStatement");
  function iE(t) {
    this.word("for"), this.space();
    let e = t.type === "ForOfStatement";
    e && t.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(t.left, t), this.space(),
    this.word(e ? "of" : "in"), this.space(), this.print(t.right, t), this.tokenChar(41), this.printBlock(t);
  }
  n(iE, "ForXStatement");
  var A5e = _t.ForInStatement = iE, v5e = _t.ForOfStatement = iE;
  function tZ(t) {
    this.word("do"), this.space(), this.print(t.body, t), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(t.test,
    t), this.tokenChar(41), this.semicolon();
  }
  n(tZ, "DoWhileStatement");
  function uu(t, e, r, s) {
    e && (t.space(), t.printTerminatorless(e, r, s)), t.semicolon();
  }
  n(uu, "printStatementAfterKeyword");
  function rZ(t) {
    this.word("break"), uu(this, t.label, t, !0);
  }
  n(rZ, "BreakStatement");
  function sZ(t) {
    this.word("continue"), uu(this, t.label, t, !0);
  }
  n(sZ, "ContinueStatement");
  function iZ(t) {
    this.word("return"), uu(this, t.argument, t, !1);
  }
  n(iZ, "ReturnStatement");
  function nZ(t) {
    this.word("throw"), uu(this, t.argument, t, !1);
  }
  n(nZ, "ThrowStatement");
  function aZ(t) {
    this.print(t.label, t), this.tokenChar(58), this.space(), this.print(t.body, t);
  }
  n(aZ, "LabeledStatement");
  function oZ(t) {
    this.word("try"), this.space(), this.print(t.block, t), this.space(), t.handlers ? this.print(t.handlers[0], t) : this.print(t.handler, t),
    t.finalizer && (this.space(), this.word("finally"), this.space(), this.print(t.finalizer, t));
  }
  n(oZ, "TryStatement");
  function lZ(t) {
    this.word("catch"), this.space(), t.param && (this.tokenChar(40), this.print(t.param, t), this.print(t.param.typeAnnotation, t), this.tokenChar(
    41), this.space()), this.print(t.body, t);
  }
  n(lZ, "CatchClause");
  function uZ(t) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(t.discriminant, t), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(t.cases, t, {
      indent: !0,
      addNewlines(e, r) {
        if (!e && t.cases[t.cases.length - 1] === r) return -1;
      }
    }), this.rightBrace(t);
  }
  n(uZ, "SwitchStatement");
  function cZ(t) {
    t.test ? (this.word("case"), this.space(), this.print(t.test, t), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), t.consequent.
    length && (this.newline(), this.printSequence(t.consequent, t, {
      indent: !0
    }));
  }
  n(cZ, "SwitchCase");
  function pZ() {
    this.word("debugger"), this.semicolon();
  }
  n(pZ, "DebuggerStatement");
  function fZ(t, e) {
    t.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = t;
    this.word(r, r === "using" || r === "await using"), this.space();
    let s = !1;
    if (!rE(e))
      for (let i of t.declarations)
        i.init && (s = !0);
    if (this.printList(t.declarations, t, {
      separator: s ? function() {
        this.tokenChar(44), this.newline();
      } : void 0,
      indent: t.declarations.length > 1
    }), rE(e)) {
      if ($Q(e)) {
        if (e.init === t) return;
      } else if (e.left === t) return;
    }
    this.semicolon();
  }
  n(fZ, "VariableDeclaration");
  function hZ(t) {
    this.print(t.id, t), t.definite && this.tokenChar(33), this.print(t.id.typeAnnotation, t), t.init && (this.space(), this.tokenChar(61), this.
    space(), this.print(t.init, t));
  }
  n(hZ, "VariableDeclarator");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/classes.js
var aE = w((Rr) => {
  "use strict";
  Object.defineProperty(Rr, "__esModule", {
    value: !0
  });
  Rr.ClassAccessorProperty = SZ;
  Rr.ClassBody = bZ;
  Rr.ClassExpression = Rr.ClassDeclaration = TZ;
  Rr.ClassMethod = PZ;
  Rr.ClassPrivateMethod = EZ;
  Rr.ClassPrivateProperty = gZ;
  Rr.ClassProperty = xZ;
  Rr.StaticBlock = vZ;
  Rr._classMethodHead = AZ;
  var dZ = Ce(), {
    isExportDefaultDeclaration: mZ,
    isExportNamedDeclaration: yZ
  } = dZ;
  function TZ(t, e) {
    (!(mZ(e) || yZ(e)) || !this._shouldPrintDecoratorsBeforeExport(e)) && this.printJoin(t.decorators, t), t.declare && (this.word("declare"),
    this.space()), t.abstract && (this.word("abstract"), this.space()), this.word("class"), t.id && (this.space(), this.print(t.id, t)), this.
    print(t.typeParameters, t), t.superClass && (this.space(), this.word("extends"), this.space(), this.print(t.superClass, t), this.print(t.
    superTypeParameters, t)), t.implements && (this.space(), this.word("implements"), this.space(), this.printList(t.implements, t)), this.space(),
    this.print(t.body, t);
  }
  n(TZ, "ClassDeclaration");
  function bZ(t) {
    this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(t.body, t, {
      indent: !0
    }), this.endsWith(10) || this.newline(), this.rightBrace(t));
  }
  n(bZ, "ClassBody");
  function xZ(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), t.computed ? (this.tokenChar(91), this.print(t.key, t), this.tokenChar(93)) :
    (this._variance(t), this.print(t.key, t)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(33), this.print(t.typeAnnotation,
    t), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(xZ, "ClassProperty");
  function SZ(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this.word("accessor", !0), this.space(), t.computed ? (this.tokenChar(91), this.
    print(t.key, t), this.tokenChar(93)) : (this._variance(t), this.print(t.key, t)), t.optional && this.tokenChar(63), t.definite && this.tokenChar(
    33), this.print(t.typeAnnotation, t), t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(SZ, "ClassAccessorProperty");
  function gZ(t) {
    this.printJoin(t.decorators, t), t.static && (this.word("static"), this.space()), this.print(t.key, t), this.print(t.typeAnnotation, t),
    t.value && (this.space(), this.tokenChar(61), this.space(), this.print(t.value, t)), this.semicolon();
  }
  n(gZ, "ClassPrivateProperty");
  function PZ(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t);
  }
  n(PZ, "ClassMethod");
  function EZ(t) {
    this._classMethodHead(t), this.space(), this.print(t.body, t);
  }
  n(EZ, "ClassPrivateMethod");
  function AZ(t) {
    var e;
    this.printJoin(t.decorators, t);
    let r = (e = t.key.loc) == null || (e = e.end) == null ? void 0 : e.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(t), this._methodHead(t);
  }
  n(AZ, "_classMethodHead");
  function vZ(t) {
    this.word("static"), this.space(), this.tokenChar(123), t.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    t.body, t, {
      indent: !0
    }), this.rightBrace(t));
  }
  n(vZ, "StaticBlock");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/methods.js
var oE = w((Xr) => {
  "use strict";
  Object.defineProperty(Xr, "__esModule", {
    value: !0
  });
  Xr.ArrowFunctionExpression = MZ;
  Xr.FunctionDeclaration = Xr.FunctionExpression = LZ;
  Xr._functionHead = _Z;
  Xr._methodHead = kZ;
  Xr._param = OZ;
  Xr._parameters = NZ;
  Xr._params = wZ;
  Xr._predicate = DZ;
  var CZ = Ce(), {
    isIdentifier: IZ
  } = CZ;
  function wZ(t, e, r) {
    this.print(t.typeParameters, t);
    let s = FZ.call(this, e, r);
    s && this.sourceIdentifierName(s.name, s.pos), this.tokenChar(40), this._parameters(t.params, t), this.tokenChar(41);
    let i = t.type === "ArrowFunctionExpression";
    this.print(t.returnType, t, i), this._noLineTerminator = i;
  }
  n(wZ, "_params");
  function NZ(t, e) {
    let r = t.length;
    for (let s = 0; s < r; s++)
      this._param(t[s], e), s < t.length - 1 && (this.tokenChar(44), this.space());
  }
  n(NZ, "_parameters");
  function OZ(t, e) {
    this.printJoin(t.decorators, t), this.print(t, e), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(OZ, "_param");
  function kZ(t) {
    let e = t.kind, r = t.key;
    (e === "get" || e === "set") && (this.word(e), this.space()), t.async && (this.word("async", !0), this.space()), (e === "method" || e ===
    "init") && t.generator && this.tokenChar(42), t.computed ? (this.tokenChar(91), this.print(r, t), this.tokenChar(93)) : this.print(r, t),
    t.optional && this.tokenChar(63), this._params(t, t.computed && t.key.type !== "StringLiteral" ? void 0 : t.key, void 0);
  }
  n(kZ, "_methodHead");
  function DZ(t, e) {
    t.predicate && (t.returnType || this.tokenChar(58), this.space(), this.print(t.predicate, t, e));
  }
  n(DZ, "_predicate");
  function _Z(t, e) {
    t.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), t.generator && (this._endsWithInnerRaw =
    !1, this.tokenChar(42)), this.space(), t.id && this.print(t.id, t), this._params(t, t.id, e), t.type !== "TSDeclareFunction" && this._predicate(
    t);
  }
  n(_Z, "_functionHead");
  function LZ(t, e) {
    this._functionHead(t, e), this.space(), this.print(t.body, t);
  }
  n(LZ, "FunctionExpression");
  function MZ(t, e) {
    t.async && (this.word("async", !0), this.space());
    let r;
    !this.format.retainLines && t.params.length === 1 && IZ(r = t.params[0]) && !BZ(t, r) ? this.print(r, t, !0) : this._params(t, void 0, e),
    this._predicate(t, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(t.body, t);
  }
  n(MZ, "ArrowFunctionExpression");
  function BZ(t, e) {
    var r, s;
    return !!(t.typeParameters || t.returnType || t.predicate || e.typeAnnotation || e.optional || (r = e.leadingComments) != null && r.length ||
    (s = e.trailingComments) != null && s.length);
  }
  n(BZ, "hasTypesOrComments");
  function FZ(t, e) {
    let r = t;
    if (!r && e) {
      let u = e.type;
      u === "VariableDeclarator" ? r = e.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = e.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!e.computed || e.key.type === "StringLiteral") && (r = e.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = e.key);
    }
    if (!r) return;
    let s;
    if (r.type === "Identifier") {
      var i, a;
      s = {
        pos: (i = r.loc) == null ? void 0 : i.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      s = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      s = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return s;
  }
  n(FZ, "_getFuncIdName");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/modules.js
var id = w((hr) => {
  "use strict";
  Object.defineProperty(hr, "__esModule", {
    value: !0
  });
  hr.ExportAllDeclaration = zZ;
  hr.ExportDefaultDeclaration = QZ;
  hr.ExportDefaultSpecifier = JZ;
  hr.ExportNamedDeclaration = GZ;
  hr.ExportNamespaceSpecifier = $Z;
  hr.ExportSpecifier = XZ;
  hr.ImportAttribute = eee;
  hr.ImportDeclaration = ZZ;
  hr.ImportDefaultSpecifier = YZ;
  hr.ImportExpression = ree;
  hr.ImportNamespaceSpecifier = tee;
  hr.ImportSpecifier = WZ;
  hr._printAttributes = HZ;
  var jZ = Ce(), {
    isClassDeclaration: RZ,
    isExportDefaultSpecifier: UZ,
    isExportNamespaceSpecifier: qZ,
    isImportDefaultSpecifier: VZ,
    isImportNamespaceSpecifier: KZ,
    isStatement: uE
  } = jZ;
  function WZ(t) {
    (t.importKind === "type" || t.importKind === "typeof") && (this.word(t.importKind), this.space()), this.print(t.imported, t), t.local &&
    t.local.name !== t.imported.name && (this.space(), this.word("as"), this.space(), this.print(t.local, t));
  }
  n(WZ, "ImportSpecifier");
  function YZ(t) {
    this.print(t.local, t);
  }
  n(YZ, "ImportDefaultSpecifier");
  function JZ(t) {
    this.print(t.exported, t);
  }
  n(JZ, "ExportDefaultSpecifier");
  function XZ(t) {
    t.exportKind === "type" && (this.word("type"), this.space()), this.print(t.local, t), t.exported && t.local.name !== t.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(t.exported, t));
  }
  n(XZ, "ExportSpecifier");
  function $Z(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.exported, t);
  }
  n($Z, "ExportNamespaceSpecifier");
  var lE = !1;
  function HZ(t) {
    let {
      importAttributesKeyword: e
    } = this.format, {
      attributes: r,
      assertions: s
    } = t;
    r && !e && !lE && (lE = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify \
the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\
\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let i = e === "assert" || !e && s;
    if (this.word(i ? "assert" : "with"), this.space(), !i && e !== "with") {
      this.printList(r || s, t);
      return;
    }
    this.tokenChar(123), this.space(), this.printList(r || s, t), this.space(), this.tokenChar(125);
  }
  n(HZ, "_printAttributes");
  function zZ(t) {
    var e, r;
    this.word("export"), this.space(), t.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.print(t.source, t, !0),
    this.space(), this._printAttributes(t)) : this.print(t.source, t), this.semicolon();
  }
  n(zZ, "ExportAllDeclaration");
  function cE(t, e) {
    RZ(e.declaration) && t._shouldPrintDecoratorsBeforeExport(e) && t.printJoin(e.declaration.decorators, e);
  }
  n(cE, "maybePrintDecoratorsBeforeExport");
  function GZ(t) {
    if (cE(this, t), this.word("export"), this.space(), t.declaration) {
      let s = t.declaration;
      this.print(s, t), uE(s) || this.semicolon();
    } else {
      t.exportKind === "type" && (this.word("type"), this.space());
      let s = t.specifiers.slice(0), i = !1;
      for (; ; ) {
        let a = s[0];
        if (UZ(a) || qZ(a))
          i = !0, this.print(s.shift(), t), s.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      if ((s.length || !s.length && !i) && (this.tokenChar(123), s.length && (this.space(), this.printList(s, t), this.space()), this.tokenChar(
      125)), t.source) {
        var e, r;
        this.space(), this.word("from"), this.space(), (e = t.attributes) != null && e.length || (r = t.assertions) != null && r.length ? (this.
        print(t.source, t, !0), this.space(), this._printAttributes(t)) : this.print(t.source, t);
      }
      this.semicolon();
    }
  }
  n(GZ, "ExportNamedDeclaration");
  function QZ(t) {
    cE(this, t), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    let e = t.declaration;
    this.print(e, t), uE(e) || this.semicolon();
  }
  n(QZ, "ExportDefaultDeclaration");
  function ZZ(t) {
    var e, r;
    this.word("import"), this.space();
    let s = t.importKind === "type" || t.importKind === "typeof";
    s ? (this.noIndentInnerCommentsHere(), this.word(t.importKind), this.space()) : t.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : t.phase && (this.noIndentInnerCommentsHere(), this.word(t.phase), this.space());
    let i = t.specifiers.slice(0), a = !!i.length;
    for (; a; ) {
      let o = i[0];
      if (VZ(o) || KZ(o))
        this.print(i.shift(), t), i.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    i.length ? (this.tokenChar(123), this.space(), this.printList(i, t), this.space(), this.tokenChar(125)) : s && !a && (this.tokenChar(123),
    this.tokenChar(125)), (a || s) && (this.space(), this.word("from"), this.space()), (e = t.attributes) != null && e.length || (r = t.assertions) !=
    null && r.length ? (this.print(t.source, t, !0), this.space(), this._printAttributes(t)) : this.print(t.source, t), this.semicolon();
  }
  n(ZZ, "ImportDeclaration");
  function eee(t) {
    this.print(t.key), this.tokenChar(58), this.space(), this.print(t.value);
  }
  n(eee, "ImportAttribute");
  function tee(t) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(t.local, t);
  }
  n(tee, "ImportNamespaceSpecifier");
  function ree(t) {
    this.word("import"), t.phase && (this.tokenChar(46), this.word(t.phase)), this.tokenChar(40), this.print(t.source, t), t.options != null &&
    (this.tokenChar(44), this.space(), this.print(t.options, t)), this.tokenChar(41);
  }
  n(ree, "ImportExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/types.js
var ad = w((Ot) => {
  "use strict";
  Object.defineProperty(Ot, "__esModule", {
    value: !0
  });
  Ot.ArgumentPlaceholder = aee;
  Ot.ArrayPattern = Ot.ArrayExpression = pee;
  Ot.BigIntLiteral = xee;
  Ot.BooleanLiteral = mee;
  Ot.DecimalLiteral = See;
  Ot.Identifier = nee;
  Ot.NullLiteral = yee;
  Ot.NumericLiteral = Tee;
  Ot.ObjectPattern = Ot.ObjectExpression = lee;
  Ot.ObjectMethod = uee;
  Ot.ObjectProperty = cee;
  Ot.PipelineBareFunction = Eee;
  Ot.PipelinePrimaryTopicReference = Aee;
  Ot.PipelineTopicExpression = Pee;
  Ot.RecordExpression = fee;
  Ot.RegExpLiteral = dee;
  Ot.SpreadElement = Ot.RestElement = oee;
  Ot.StringLiteral = bee;
  Ot.TopicReference = gee;
  Ot.TupleExpression = hee;
  var see = Ce(), fE = mh(), {
    isAssignmentPattern: iee,
    isIdentifier: nd
  } = see;
  function nee(t) {
    var e;
    this.sourceIdentifierName(((e = t.loc) == null ? void 0 : e.identifierName) || t.name), this.word(t.name);
  }
  n(nee, "Identifier");
  function aee() {
    this.tokenChar(63);
  }
  n(aee, "ArgumentPlaceholder");
  function oee(t) {
    this.token("..."), this.print(t.argument, t);
  }
  n(oee, "RestElement");
  function lee(t) {
    let e = t.properties;
    this.tokenChar(123), e.length && (this.space(), this.printList(e, t, {
      indent: !0,
      statement: !0
    }), this.space()), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  n(lee, "ObjectExpression");
  function uee(t) {
    this.printJoin(t.decorators, t), this._methodHead(t), this.space(), this.print(t.body, t);
  }
  n(uee, "ObjectMethod");
  function cee(t) {
    if (this.printJoin(t.decorators, t), t.computed)
      this.tokenChar(91), this.print(t.key, t), this.tokenChar(93);
    else {
      if (iee(t.value) && nd(t.key) && t.key.name === t.value.left.name) {
        this.print(t.value, t);
        return;
      }
      if (this.print(t.key, t), t.shorthand && nd(t.key) && nd(t.value) && t.key.name === t.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(t.value, t);
  }
  n(cee, "ObjectProperty");
  function pee(t) {
    let e = t.elements, r = e.length;
    this.tokenChar(91);
    for (let s = 0; s < e.length; s++) {
      let i = e[s];
      i ? (s > 0 && this.space(), this.print(i, t), s < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }
  n(pee, "ArrayExpression");
  function fee(t) {
    let e = t.properties, r, s;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", s = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", s = "}";
    }
    this.token(r), e.length && (this.space(), this.printList(e, t, {
      indent: !0,
      statement: !0
    }), this.space()), this.token(s);
  }
  n(fee, "RecordExpression");
  function hee(t) {
    let e = t.elements, r = e.length, s, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "[|", i = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      s = "#[", i = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(s);
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      o && (a > 0 && this.space(), this.print(o, t), a < r - 1 && this.tokenChar(44));
    }
    this.token(i);
  }
  n(hee, "TupleExpression");
  function dee(t) {
    this.word(`/${t.pattern}/${t.flags}`);
  }
  n(dee, "RegExpLiteral");
  function mee(t) {
    this.word(t.value ? "true" : "false");
  }
  n(mee, "BooleanLiteral");
  function yee() {
    this.word("null");
  }
  n(yee, "NullLiteral");
  function Tee(t) {
    let e = this.getPossibleRaw(t), r = this.format.jsescOption, s = t.value, i = s + "";
    r.numbers ? this.number(fE(s, r), s) : e == null ? this.number(i, s) : this.format.minified ? this.number(e.length < i.length ? e : i, s) :
    this.number(e, s);
  }
  n(Tee, "NumericLiteral");
  function bee(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let r = fE(t.value, this.format.jsescOption);
    this.token(r);
  }
  n(bee, "StringLiteral");
  function xee(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "n");
  }
  n(xee, "BigIntLiteral");
  function See(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.word(e);
      return;
    }
    this.word(t.value + "m");
  }
  n(See, "DecimalLiteral");
  var pE = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function gee() {
    let {
      topicToken: t
    } = this.format;
    if (pE.has(t))
      this.token(t);
    else {
      let e = JSON.stringify(t), r = Array.from(pE, (s) => JSON.stringify(s));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${e} received instead).`);
    }
  }
  n(gee, "TopicReference");
  function Pee(t) {
    this.print(t.expression, t);
  }
  n(Pee, "PipelineTopicExpression");
  function Eee(t) {
    this.print(t.callee, t);
  }
  n(Eee, "PipelineBareFunction");
  function Aee() {
    this.tokenChar(35);
  }
  n(Aee, "PipelinePrimaryTopicReference");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/flow.js
var dE = w((he) => {
  "use strict";
  Object.defineProperty(he, "__esModule", {
    value: !0
  });
  he.AnyTypeAnnotation = wee;
  he.ArrayTypeAnnotation = Nee;
  he.BooleanLiteralTypeAnnotation = kee;
  he.BooleanTypeAnnotation = Oee;
  he.DeclareClass = _ee;
  he.DeclareExportAllDeclaration = Wee;
  he.DeclareExportDeclaration = Kee;
  he.DeclareFunction = Lee;
  he.DeclareInterface = Fee;
  he.DeclareModule = jee;
  he.DeclareModuleExports = Ree;
  he.DeclareOpaqueType = qee;
  he.DeclareTypeAlias = Uee;
  he.DeclareVariable = Vee;
  he.DeclaredPredicate = Bee;
  he.EmptyTypeAnnotation = fte;
  he.EnumBooleanBody = Jee;
  he.EnumBooleanMember = Gee;
  he.EnumDeclaration = Yee;
  he.EnumDefaultedMember = zee;
  he.EnumNumberBody = Xee;
  he.EnumNumberMember = Qee;
  he.EnumStringBody = $ee;
  he.EnumStringMember = Zee;
  he.EnumSymbolBody = Hee;
  he.ExistsTypeAnnotation = tte;
  he.FunctionTypeAnnotation = rte;
  he.FunctionTypeParam = ste;
  he.IndexedAccessType = Fte;
  he.InferredPredicate = Mee;
  he.InterfaceDeclaration = ote;
  he.GenericTypeAnnotation = he.ClassImplements = he.InterfaceExtends = ite;
  he.InterfaceTypeAnnotation = ute;
  he.IntersectionTypeAnnotation = cte;
  he.MixedTypeAnnotation = pte;
  he.NullLiteralTypeAnnotation = Dee;
  he.NullableTypeAnnotation = hte;
  Object.defineProperty(he, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hE.NumericLiteral;
    }, "get")
  });
  he.NumberTypeAnnotation = dte;
  he.ObjectTypeAnnotation = Ate;
  he.ObjectTypeCallProperty = Cte;
  he.ObjectTypeIndexer = Ite;
  he.ObjectTypeInternalSlot = vte;
  he.ObjectTypeProperty = wte;
  he.ObjectTypeSpreadProperty = Nte;
  he.OpaqueType = Ete;
  he.OptionalIndexedAccessType = jte;
  he.QualifiedTypeIdentifier = Ote;
  Object.defineProperty(he, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hE.StringLiteral;
    }, "get")
  });
  he.StringTypeAnnotation = mte;
  he.SymbolTypeAnnotation = kte;
  he.ThisTypeAnnotation = yte;
  he.TupleTypeAnnotation = Tte;
  he.TypeAlias = xte;
  he.TypeAnnotation = Ste;
  he.TypeCastExpression = Lte;
  he.TypeParameter = Pte;
  he.TypeParameterDeclaration = he.TypeParameterInstantiation = gte;
  he.TypeofTypeAnnotation = bte;
  he.UnionTypeAnnotation = _te;
  he.Variance = Mte;
  he.VoidTypeAnnotation = Bte;
  he._interfaceish = nte;
  he._variance = ate;
  var vee = Ce(), Cee = id(), hE = ad(), {
    isDeclareExportDeclaration: cu,
    isStatement: Iee
  } = vee;
  function wee() {
    this.word("any");
  }
  n(wee, "AnyTypeAnnotation");
  function Nee(t) {
    this.print(t.elementType, t, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(Nee, "ArrayTypeAnnotation");
  function Oee() {
    this.word("boolean");
  }
  n(Oee, "BooleanTypeAnnotation");
  function kee(t) {
    this.word(t.value ? "true" : "false");
  }
  n(kee, "BooleanLiteralTypeAnnotation");
  function Dee() {
    this.word("null");
  }
  n(Dee, "NullLiteralTypeAnnotation");
  function _ee(t, e) {
    cu(e) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(t);
  }
  n(_ee, "DeclareClass");
  function Lee(t, e) {
    cu(e) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(t.id, t), this.print(t.id.typeAnnotation.
    typeAnnotation, t), t.predicate && (this.space(), this.print(t.predicate, t)), this.semicolon();
  }
  n(Lee, "DeclareFunction");
  function Mee() {
    this.tokenChar(37), this.word("checks");
  }
  n(Mee, "InferredPredicate");
  function Bee(t) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(t.value, t), this.tokenChar(41);
  }
  n(Bee, "DeclaredPredicate");
  function Fee(t) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(t);
  }
  n(Fee, "DeclareInterface");
  function jee(t) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(t.id, t), this.space(), this.print(t.body, t);
  }
  n(jee, "DeclareModule");
  function Ree(t) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(t.typeAnnotation, t);
  }
  n(Ree, "DeclareModuleExports");
  function Uee(t) {
    this.word("declare"), this.space(), this.TypeAlias(t);
  }
  n(Uee, "DeclareTypeAlias");
  function qee(t, e) {
    cu(e) || (this.word("declare"), this.space()), this.OpaqueType(t);
  }
  n(qee, "DeclareOpaqueType");
  function Vee(t, e) {
    cu(e) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(t.id, t), this.print(t.id.typeAnnotation, t), this.
    semicolon();
  }
  n(Vee, "DeclareVariable");
  function Kee(t) {
    this.word("declare"), this.space(), this.word("export"), this.space(), t.default && (this.word("default"), this.space()), ete.call(this,
    t);
  }
  n(Kee, "DeclareExportDeclaration");
  function Wee(t) {
    this.word("declare"), this.space(), Cee.ExportAllDeclaration.call(this, t);
  }
  n(Wee, "DeclareExportAllDeclaration");
  function Yee(t) {
    let {
      id: e,
      body: r
    } = t;
    this.word("enum"), this.space(), this.print(e, t), this.print(r, t);
  }
  n(Yee, "EnumDeclaration");
  function pu(t, e, r) {
    r && (t.space(), t.word("of"), t.space(), t.word(e)), t.space();
  }
  n(pu, "enumExplicitType");
  function fu(t, e) {
    let {
      members: r
    } = e;
    t.token("{"), t.indent(), t.newline();
    for (let s of r)
      t.print(s, e), t.newline();
    e.hasUnknownMembers && (t.token("..."), t.newline()), t.dedent(), t.token("}");
  }
  n(fu, "enumBody");
  function Jee(t) {
    let {
      explicitType: e
    } = t;
    pu(this, "boolean", e), fu(this, t);
  }
  n(Jee, "EnumBooleanBody");
  function Xee(t) {
    let {
      explicitType: e
    } = t;
    pu(this, "number", e), fu(this, t);
  }
  n(Xee, "EnumNumberBody");
  function $ee(t) {
    let {
      explicitType: e
    } = t;
    pu(this, "string", e), fu(this, t);
  }
  n($ee, "EnumStringBody");
  function Hee(t) {
    pu(this, "symbol", !0), fu(this, t);
  }
  n(Hee, "EnumSymbolBody");
  function zee(t) {
    let {
      id: e
    } = t;
    this.print(e, t), this.tokenChar(44);
  }
  n(zee, "EnumDefaultedMember");
  function od(t, e) {
    let {
      id: r,
      init: s
    } = e;
    t.print(r, e), t.space(), t.token("="), t.space(), t.print(s, e), t.token(",");
  }
  n(od, "enumInitializedMember");
  function Gee(t) {
    od(this, t);
  }
  n(Gee, "EnumBooleanMember");
  function Qee(t) {
    od(this, t);
  }
  n(Qee, "EnumNumberMember");
  function Zee(t) {
    od(this, t);
  }
  n(Zee, "EnumStringMember");
  function ete(t) {
    if (t.declaration) {
      let e = t.declaration;
      this.print(e, t), Iee(e) || this.semicolon();
    } else
      this.tokenChar(123), t.specifiers.length && (this.space(), this.printList(t.specifiers, t), this.space()), this.tokenChar(125), t.source &&
      (this.space(), this.word("from"), this.space(), this.print(t.source, t)), this.semicolon();
  }
  n(ete, "FlowExportDeclaration");
  function tte() {
    this.tokenChar(42);
  }
  n(tte, "ExistsTypeAnnotation");
  function rte(t, e) {
    this.print(t.typeParameters, t), this.tokenChar(40), t.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(t.this.typeAnnotation,
    t), (t.params.length || t.rest) && (this.tokenChar(44), this.space())), this.printList(t.params, t), t.rest && (t.params.length && (this.
    tokenChar(44), this.space()), this.token("..."), this.print(t.rest, t)), this.tokenChar(41);
    let r = e?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    e.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(t.returnType, t);
  }
  n(rte, "FunctionTypeAnnotation");
  function ste(t) {
    this.print(t.name, t), t.optional && this.tokenChar(63), t.name && (this.tokenChar(58), this.space()), this.print(t.typeAnnotation, t);
  }
  n(ste, "FunctionTypeParam");
  function ite(t) {
    this.print(t.id, t), this.print(t.typeParameters, t, !0);
  }
  n(ite, "InterfaceExtends");
  function nte(t) {
    var e;
    if (this.print(t.id, t), this.print(t.typeParameters, t), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.
    space(), this.printList(t.extends, t)), t.type === "DeclareClass") {
      var r, s;
      (r = t.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(t.mixins, t)), (s = t.implements) !=
      null && s.length && (this.space(), this.word("implements"), this.space(), this.printList(t.implements, t));
    }
    this.space(), this.print(t.body, t);
  }
  n(nte, "_interfaceish");
  function ate(t) {
    var e;
    let r = (e = t.variance) == null ? void 0 : e.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  n(ate, "_variance");
  function ote(t) {
    this.word("interface"), this.space(), this._interfaceish(t);
  }
  n(ote, "InterfaceDeclaration");
  function lte() {
    this.space(), this.tokenChar(38), this.space();
  }
  n(lte, "andSeparator");
  function ute(t) {
    var e;
    this.word("interface"), (e = t.extends) != null && e.length && (this.space(), this.word("extends"), this.space(), this.printList(t.extends,
    t)), this.space(), this.print(t.body, t);
  }
  n(ute, "InterfaceTypeAnnotation");
  function cte(t) {
    this.printJoin(t.types, t, {
      separator: lte
    });
  }
  n(cte, "IntersectionTypeAnnotation");
  function pte() {
    this.word("mixed");
  }
  n(pte, "MixedTypeAnnotation");
  function fte() {
    this.word("empty");
  }
  n(fte, "EmptyTypeAnnotation");
  function hte(t) {
    this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(hte, "NullableTypeAnnotation");
  function dte() {
    this.word("number");
  }
  n(dte, "NumberTypeAnnotation");
  function mte() {
    this.word("string");
  }
  n(mte, "StringTypeAnnotation");
  function yte() {
    this.word("this");
  }
  n(yte, "ThisTypeAnnotation");
  function Tte(t) {
    this.tokenChar(91), this.printList(t.types, t), this.tokenChar(93);
  }
  n(Tte, "TupleTypeAnnotation");
  function bte(t) {
    this.word("typeof"), this.space(), this.print(t.argument, t);
  }
  n(bte, "TypeofTypeAnnotation");
  function xte(t) {
    this.word("type"), this.space(), this.print(t.id, t), this.print(t.typeParameters, t), this.space(), this.tokenChar(61), this.space(), this.
    print(t.right, t), this.semicolon();
  }
  n(xte, "TypeAlias");
  function Ste(t) {
    this.tokenChar(58), this.space(), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(Ste, "TypeAnnotation");
  function gte(t) {
    this.tokenChar(60), this.printList(t.params, t, {}), this.tokenChar(62);
  }
  n(gte, "TypeParameterInstantiation");
  function Pte(t) {
    this._variance(t), this.word(t.name), t.bound && this.print(t.bound, t), t.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(t.default, t));
  }
  n(Pte, "TypeParameter");
  function Ete(t) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(t.id, t), this.print(t.typeParameters, t), t.supertype &&
    (this.tokenChar(58), this.space(), this.print(t.supertype, t)), t.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(
    t.impltype, t)), this.semicolon();
  }
  n(Ete, "OpaqueType");
  function Ate(t) {
    t.exact ? this.token("{|") : this.tokenChar(123);
    let e = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
    e.length && (this.newline(), this.space(), this.printJoin(e, t, {
      addNewlines(r) {
        if (r && !e[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: /* @__PURE__ */ n(() => {
        (e.length !== 1 || t.inexact) && (this.tokenChar(44), this.space());
      }, "iterator")
    }), this.space()), t.inexact && (this.indent(), this.token("..."), e.length && this.newline(), this.dedent()), t.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  n(Ate, "ObjectTypeAnnotation");
  function vte(t) {
    t.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(t.id, t), this.tokenChar(93), this.tokenChar(
    93), t.optional && this.tokenChar(63), t.method || (this.tokenChar(58), this.space()), this.print(t.value, t);
  }
  n(vte, "ObjectTypeInternalSlot");
  function Cte(t) {
    t.static && (this.word("static"), this.space()), this.print(t.value, t);
  }
  n(Cte, "ObjectTypeCallProperty");
  function Ite(t) {
    t.static && (this.word("static"), this.space()), this._variance(t), this.tokenChar(91), t.id && (this.print(t.id, t), this.tokenChar(58),
    this.space()), this.print(t.key, t), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(t.value, t);
  }
  n(Ite, "ObjectTypeIndexer");
  function wte(t) {
    t.proto && (this.word("proto"), this.space()), t.static && (this.word("static"), this.space()), (t.kind === "get" || t.kind === "set") &&
    (this.word(t.kind), this.space()), this._variance(t), this.print(t.key, t), t.optional && this.tokenChar(63), t.method || (this.tokenChar(
    58), this.space()), this.print(t.value, t);
  }
  n(wte, "ObjectTypeProperty");
  function Nte(t) {
    this.token("..."), this.print(t.argument, t);
  }
  n(Nte, "ObjectTypeSpreadProperty");
  function Ote(t) {
    this.print(t.qualification, t), this.tokenChar(46), this.print(t.id, t);
  }
  n(Ote, "QualifiedTypeIdentifier");
  function kte() {
    this.word("symbol");
  }
  n(kte, "SymbolTypeAnnotation");
  function Dte() {
    this.space(), this.tokenChar(124), this.space();
  }
  n(Dte, "orSeparator");
  function _te(t) {
    this.printJoin(t.types, t, {
      separator: Dte
    });
  }
  n(_te, "UnionTypeAnnotation");
  function Lte(t) {
    this.tokenChar(40), this.print(t.expression, t), this.print(t.typeAnnotation, t), this.tokenChar(41);
  }
  n(Lte, "TypeCastExpression");
  function Mte(t) {
    t.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  n(Mte, "Variance");
  function Bte() {
    this.word("void");
  }
  n(Bte, "VoidTypeAnnotation");
  function Fte(t) {
    this.print(t.objectType, t, !0), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(Fte, "IndexedAccessType");
  function jte(t) {
    this.print(t.objectType, t), t.optional && this.token("?."), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(jte, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/base.js
var mE = w((Ps) => {
  "use strict";
  Object.defineProperty(Ps, "__esModule", {
    value: !0
  });
  Ps.BlockStatement = qte;
  Ps.Directive = Vte;
  Ps.DirectiveLiteral = Yte;
  Ps.File = Rte;
  Ps.InterpreterDirective = Jte;
  Ps.Placeholder = Xte;
  Ps.Program = Ute;
  function Rte(t) {
    t.program && this.print(t.program.interpreter, t), this.print(t.program, t);
  }
  n(Rte, "File");
  function Ute(t) {
    var e;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var s;
      let i = t.body.length ? 2 : 1;
      this.printSequence(t.directives, t, {
        trailingCommentsLineOffset: i
      }), (s = t.directives[r - 1].trailingComments) != null && s.length || this.newline(i);
    }
    this.printSequence(t.body, t);
  }
  n(Ute, "Program");
  function qte(t) {
    var e;
    this.tokenChar(123);
    let r = (e = t.directives) == null ? void 0 : e.length;
    if (r) {
      var s;
      let i = t.body.length ? 2 : 1;
      this.printSequence(t.directives, t, {
        indent: !0,
        trailingCommentsLineOffset: i
      }), (s = t.directives[r - 1].trailingComments) != null && s.length || this.newline(i);
    }
    this.printSequence(t.body, t, {
      indent: !0
    }), this.rightBrace(t);
  }
  n(qte, "BlockStatement");
  function Vte(t) {
    this.print(t.value, t), this.semicolon();
  }
  n(Vte, "Directive");
  var Kte = /(?:^|[^\\])(?:\\\\)*'/, Wte = /(?:^|[^\\])(?:\\\\)*"/;
  function Yte(t) {
    let e = this.getPossibleRaw(t);
    if (!this.format.minified && e !== void 0) {
      this.token(e);
      return;
    }
    let {
      value: r
    } = t;
    if (!Wte.test(r))
      this.token(`"${r}"`);
    else if (!Kte.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  n(Yte, "DirectiveLiteral");
  function Jte(t) {
    this.token(`#!${t.value}`), this.newline(1, !0);
  }
  n(Jte, "InterpreterDirective");
  function Xte(t) {
    this.token("%%"), this.print(t.name), this.token("%%"), t.expectedNode === "Statement" && this.semicolon();
  }
  n(Xte, "Placeholder");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/jsx.js
var yE = w((Zt) => {
  "use strict";
  Object.defineProperty(Zt, "__esModule", {
    value: !0
  });
  Zt.JSXAttribute = $te;
  Zt.JSXClosingElement = nre;
  Zt.JSXClosingFragment = ure;
  Zt.JSXElement = rre;
  Zt.JSXEmptyExpression = are;
  Zt.JSXExpressionContainer = Zte;
  Zt.JSXFragment = ore;
  Zt.JSXIdentifier = Hte;
  Zt.JSXMemberExpression = Gte;
  Zt.JSXNamespacedName = zte;
  Zt.JSXOpeningElement = ire;
  Zt.JSXOpeningFragment = lre;
  Zt.JSXSpreadAttribute = Qte;
  Zt.JSXSpreadChild = ere;
  Zt.JSXText = tre;
  function $te(t) {
    this.print(t.name, t), t.value && (this.tokenChar(61), this.print(t.value, t));
  }
  n($te, "JSXAttribute");
  function Hte(t) {
    this.word(t.name);
  }
  n(Hte, "JSXIdentifier");
  function zte(t) {
    this.print(t.namespace, t), this.tokenChar(58), this.print(t.name, t);
  }
  n(zte, "JSXNamespacedName");
  function Gte(t) {
    this.print(t.object, t), this.tokenChar(46), this.print(t.property, t);
  }
  n(Gte, "JSXMemberExpression");
  function Qte(t) {
    this.tokenChar(123), this.token("..."), this.print(t.argument, t), this.tokenChar(125);
  }
  n(Qte, "JSXSpreadAttribute");
  function Zte(t) {
    this.tokenChar(123), this.print(t.expression, t), this.tokenChar(125);
  }
  n(Zte, "JSXExpressionContainer");
  function ere(t) {
    this.tokenChar(123), this.token("..."), this.print(t.expression, t), this.tokenChar(125);
  }
  n(ere, "JSXSpreadChild");
  function tre(t) {
    let e = this.getPossibleRaw(t);
    e !== void 0 ? this.token(e, !0) : this.token(t.value, !0);
  }
  n(tre, "JSXText");
  function rre(t) {
    let e = t.openingElement;
    if (this.print(e, t), !e.selfClosing) {
      this.indent();
      for (let r of t.children)
        this.print(r, t);
      this.dedent(), this.print(t.closingElement, t);
    }
  }
  n(rre, "JSXElement");
  function sre() {
    this.space();
  }
  n(sre, "spaceSeparator");
  function ire(t) {
    this.tokenChar(60), this.print(t.name, t), this.print(t.typeParameters, t), t.attributes.length > 0 && (this.space(), this.printJoin(t.attributes,
    t, {
      separator: sre
    })), t.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }
  n(ire, "JSXOpeningElement");
  function nre(t) {
    this.token("</"), this.print(t.name, t), this.tokenChar(62);
  }
  n(nre, "JSXClosingElement");
  function are() {
    this.printInnerComments();
  }
  n(are, "JSXEmptyExpression");
  function ore(t) {
    this.print(t.openingFragment, t), this.indent();
    for (let e of t.children)
      this.print(e, t);
    this.dedent(), this.print(t.closingFragment, t);
  }
  n(ore, "JSXFragment");
  function lre() {
    this.tokenChar(60), this.tokenChar(62);
  }
  n(lre, "JSXOpeningFragment");
  function ure() {
    this.token("</"), this.tokenChar(62);
  }
  n(ure, "JSXClosingFragment");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/typescript.js
var xE = w((pe) => {
  "use strict";
  Object.defineProperty(pe, "__esModule", {
    value: !0
  });
  pe.TSAnyKeyword = Ere;
  pe.TSArrayType = Yre;
  pe.TSSatisfiesExpression = pe.TSAsExpression = use;
  pe.TSBigIntKeyword = Are;
  pe.TSBooleanKeyword = wre;
  pe.TSCallSignatureDeclaration = Tre;
  pe.TSConditionalType = Qre;
  pe.TSConstructSignatureDeclaration = bre;
  pe.TSConstructorType = jre;
  pe.TSDeclareFunction = dre;
  pe.TSDeclareMethod = mre;
  pe.TSEnumDeclaration = fse;
  pe.TSEnumMember = hse;
  pe.TSExportAssignment = Sse;
  pe.TSExpressionWithTypeArguments = nse;
  pe.TSExternalModuleReference = bse;
  pe.TSFunctionType = Fre;
  pe.TSImportEqualsDeclaration = Tse;
  pe.TSImportType = yse;
  pe.TSIndexSignature = Pre;
  pe.TSIndexedAccessType = rse;
  pe.TSInferType = Zre;
  pe.TSInstantiationExpression = pse;
  pe.TSInterfaceBody = ose;
  pe.TSInterfaceDeclaration = ase;
  pe.TSIntersectionType = Gre;
  pe.TSIntrinsicKeyword = Mre;
  pe.TSLiteralType = ise;
  pe.TSMappedType = sse;
  pe.TSMethodSignature = gre;
  pe.TSModuleBlock = mse;
  pe.TSModuleDeclaration = dse;
  pe.TSNamedTupleMember = Hre;
  pe.TSNamespaceExportDeclaration = gse;
  pe.TSNeverKeyword = Lre;
  pe.TSNonNullExpression = xse;
  pe.TSNullKeyword = _re;
  pe.TSNumberKeyword = Cre;
  pe.TSObjectKeyword = Ire;
  pe.TSOptionalType = Xre;
  pe.TSParameterProperty = hre;
  pe.TSParenthesizedType = ese;
  pe.TSPropertySignature = xre;
  pe.TSQualifiedName = yre;
  pe.TSRestType = $re;
  pe.TSStringKeyword = Nre;
  pe.TSSymbolKeyword = Ore;
  pe.TSThisType = Bre;
  pe.TSTupleType = Jre;
  pe.TSTypeAliasDeclaration = lse;
  pe.TSTypeAnnotation = cre;
  pe.TSTypeAssertion = cse;
  pe.TSTypeLiteral = Kre;
  pe.TSTypeOperator = tse;
  pe.TSTypeParameter = fre;
  pe.TSTypeParameterDeclaration = pe.TSTypeParameterInstantiation = pre;
  pe.TSTypePredicate = qre;
  pe.TSTypeQuery = Vre;
  pe.TSTypeReference = Ure;
  pe.TSUndefinedKeyword = Dre;
  pe.TSUnionType = zre;
  pe.TSUnknownKeyword = vre;
  pe.TSVoidKeyword = kre;
  pe.tsPrintClassMemberModifiers = Ese;
  pe.tsPrintFunctionOrConstructorType = Rre;
  pe.tsPrintPropertyOrMethodName = Sre;
  pe.tsPrintSignatureDeclarationBase = Pse;
  pe.tsPrintTypeLiteralOrInterfaceBody = Wre;
  function cre(t) {
    this.tokenChar(58), this.space(), t.optional && this.tokenChar(63), this.print(t.typeAnnotation, t);
  }
  n(cre, "TSTypeAnnotation");
  function pre(t, e) {
    this.tokenChar(60), this.printList(t.params, t, {}), e.type === "ArrowFunctionExpression" && t.params.length === 1 && this.tokenChar(44),
    this.tokenChar(62);
  }
  n(pre, "TSTypeParameterInstantiation");
  function fre(t) {
    t.in && (this.word("in"), this.space()), t.out && (this.word("out"), this.space()), this.word(t.name), t.constraint && (this.space(), this.
    word("extends"), this.space(), this.print(t.constraint, t)), t.default && (this.space(), this.tokenChar(61), this.space(), this.print(t.
    default, t));
  }
  n(fre, "TSTypeParameter");
  function hre(t) {
    t.accessibility && (this.word(t.accessibility), this.space()), t.readonly && (this.word("readonly"), this.space()), this._param(t.parameter);
  }
  n(hre, "TSParameterProperty");
  function dre(t, e) {
    t.declare && (this.word("declare"), this.space()), this._functionHead(t, e), this.tokenChar(59);
  }
  n(dre, "TSDeclareFunction");
  function mre(t) {
    this._classMethodHead(t), this.tokenChar(59);
  }
  n(mre, "TSDeclareMethod");
  function yre(t) {
    this.print(t.left, t), this.tokenChar(46), this.print(t.right, t);
  }
  n(yre, "TSQualifiedName");
  function Tre(t) {
    this.tsPrintSignatureDeclarationBase(t), this.tokenChar(59);
  }
  n(Tre, "TSCallSignatureDeclaration");
  function bre(t) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(t), this.tokenChar(59);
  }
  n(bre, "TSConstructSignatureDeclaration");
  function xre(t) {
    let {
      readonly: e
    } = t;
    e && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(t), this.print(t.typeAnnotation, t), this.tokenChar(59);
  }
  n(xre, "TSPropertySignature");
  function Sre(t) {
    t.computed && this.tokenChar(91), this.print(t.key, t), t.computed && this.tokenChar(93), t.optional && this.tokenChar(63);
  }
  n(Sre, "tsPrintPropertyOrMethodName");
  function gre(t) {
    let {
      kind: e
    } = t;
    (e === "set" || e === "get") && (this.word(e), this.space()), this.tsPrintPropertyOrMethodName(t), this.tsPrintSignatureDeclarationBase(
    t), this.tokenChar(59);
  }
  n(gre, "TSMethodSignature");
  function Pre(t) {
    let {
      readonly: e,
      static: r
    } = t;
    r && (this.word("static"), this.space()), e && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(t.parameters,
    t), this.tokenChar(93), this.print(t.typeAnnotation, t), this.tokenChar(59);
  }
  n(Pre, "TSIndexSignature");
  function Ere() {
    this.word("any");
  }
  n(Ere, "TSAnyKeyword");
  function Are() {
    this.word("bigint");
  }
  n(Are, "TSBigIntKeyword");
  function vre() {
    this.word("unknown");
  }
  n(vre, "TSUnknownKeyword");
  function Cre() {
    this.word("number");
  }
  n(Cre, "TSNumberKeyword");
  function Ire() {
    this.word("object");
  }
  n(Ire, "TSObjectKeyword");
  function wre() {
    this.word("boolean");
  }
  n(wre, "TSBooleanKeyword");
  function Nre() {
    this.word("string");
  }
  n(Nre, "TSStringKeyword");
  function Ore() {
    this.word("symbol");
  }
  n(Ore, "TSSymbolKeyword");
  function kre() {
    this.word("void");
  }
  n(kre, "TSVoidKeyword");
  function Dre() {
    this.word("undefined");
  }
  n(Dre, "TSUndefinedKeyword");
  function _re() {
    this.word("null");
  }
  n(_re, "TSNullKeyword");
  function Lre() {
    this.word("never");
  }
  n(Lre, "TSNeverKeyword");
  function Mre() {
    this.word("intrinsic");
  }
  n(Mre, "TSIntrinsicKeyword");
  function Bre() {
    this.word("this");
  }
  n(Bre, "TSThisType");
  function Fre(t) {
    this.tsPrintFunctionOrConstructorType(t);
  }
  n(Fre, "TSFunctionType");
  function jre(t) {
    t.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(t);
  }
  n(jre, "TSConstructorType");
  function Rre(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e, t), this.tokenChar(40), this._parameters(r, t), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    let s = t.typeAnnotation;
    this.print(s.typeAnnotation, t);
  }
  n(Rre, "tsPrintFunctionOrConstructorType");
  function Ure(t) {
    this.print(t.typeName, t, !0), this.print(t.typeParameters, t, !0);
  }
  n(Ure, "TSTypeReference");
  function qre(t) {
    t.asserts && (this.word("asserts"), this.space()), this.print(t.parameterName), t.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(t.typeAnnotation.typeAnnotation));
  }
  n(qre, "TSTypePredicate");
  function Vre(t) {
    this.word("typeof"), this.space(), this.print(t.exprName), t.typeParameters && this.print(t.typeParameters, t);
  }
  n(Vre, "TSTypeQuery");
  function Kre(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.members, t);
  }
  n(Kre, "TSTypeLiteral");
  function Wre(t, e) {
    ld(this, t, e);
  }
  n(Wre, "tsPrintTypeLiteralOrInterfaceBody");
  function ld(t, e, r) {
    if (t.token("{"), e.length) {
      t.indent(), t.newline();
      for (let s of e)
        t.print(s, r), t.newline();
      t.dedent();
    }
    t.rightBrace(r);
  }
  n(ld, "tsPrintBraced");
  function Yre(t) {
    this.print(t.elementType, t, !0), this.token("[]");
  }
  n(Yre, "TSArrayType");
  function Jre(t) {
    this.tokenChar(91), this.printList(t.elementTypes, t), this.tokenChar(93);
  }
  n(Jre, "TSTupleType");
  function Xre(t) {
    this.print(t.typeAnnotation, t), this.tokenChar(63);
  }
  n(Xre, "TSOptionalType");
  function $re(t) {
    this.token("..."), this.print(t.typeAnnotation, t);
  }
  n($re, "TSRestType");
  function Hre(t) {
    this.print(t.label, t), t.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(t.elementType, t);
  }
  n(Hre, "TSNamedTupleMember");
  function zre(t) {
    bE(this, t, "|");
  }
  n(zre, "TSUnionType");
  function Gre(t) {
    bE(this, t, "&");
  }
  n(Gre, "TSIntersectionType");
  function bE(t, e, r) {
    t.printJoin(e.types, e, {
      separator() {
        this.space(), this.token(r), this.space();
      }
    });
  }
  n(bE, "tsPrintUnionOrIntersectionType");
  function Qre(t) {
    this.print(t.checkType), this.space(), this.word("extends"), this.space(), this.print(t.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(t.trueType), this.space(), this.tokenChar(58), this.space(), this.print(t.falseType);
  }
  n(Qre, "TSConditionalType");
  function Zre(t) {
    this.token("infer"), this.space(), this.print(t.typeParameter);
  }
  n(Zre, "TSInferType");
  function ese(t) {
    this.tokenChar(40), this.print(t.typeAnnotation, t), this.tokenChar(41);
  }
  n(ese, "TSParenthesizedType");
  function tse(t) {
    this.word(t.operator), this.space(), this.print(t.typeAnnotation, t);
  }
  n(tse, "TSTypeOperator");
  function rse(t) {
    this.print(t.objectType, t, !0), this.tokenChar(91), this.print(t.indexType, t), this.tokenChar(93);
  }
  n(rse, "TSIndexedAccessType");
  function sse(t) {
    let {
      nameType: e,
      optional: r,
      readonly: s,
      typeParameter: i,
      typeAnnotation: a
    } = t;
    this.tokenChar(123), this.space(), s && (TE(this, s), this.word("readonly"), this.space()), this.tokenChar(91), this.word(i.name), this.
    space(), this.word("in"), this.space(), this.print(i.constraint, i), e && (this.space(), this.word("as"), this.space(), this.print(e, t)),
    this.tokenChar(93), r && (TE(this, r), this.tokenChar(63)), a && (this.tokenChar(58), this.space(), this.print(a, t)), this.space(), this.
    tokenChar(125);
  }
  n(sse, "TSMappedType");
  function TE(t, e) {
    e !== !0 && t.token(e);
  }
  n(TE, "tokenIfPlusMinus");
  function ise(t) {
    this.print(t.literal, t);
  }
  n(ise, "TSLiteralType");
  function nse(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t);
  }
  n(nse, "TSExpressionWithTypeArguments");
  function ase(t) {
    let {
      declare: e,
      id: r,
      typeParameters: s,
      extends: i,
      body: a
    } = t;
    e && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, t), this.print(s, t), i != null && i.length &&
    (this.space(), this.word("extends"), this.space(), this.printList(i, t)), this.space(), this.print(a, t);
  }
  n(ase, "TSInterfaceDeclaration");
  function ose(t) {
    this.tsPrintTypeLiteralOrInterfaceBody(t.body, t);
  }
  n(ose, "TSInterfaceBody");
  function lse(t) {
    let {
      declare: e,
      id: r,
      typeParameters: s,
      typeAnnotation: i
    } = t;
    e && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, t), this.print(s, t), this.space(), this.tokenChar(
    61), this.space(), this.print(i, t), this.tokenChar(59);
  }
  n(lse, "TSTypeAliasDeclaration");
  function use(t) {
    var e;
    let {
      type: r,
      expression: s,
      typeAnnotation: i
    } = t, a = !!((e = s.trailingComments) != null && e.length);
    this.print(s, t, !0, void 0, a), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i, t);
  }
  n(use, "TSTypeExpression");
  function cse(t) {
    let {
      typeAnnotation: e,
      expression: r
    } = t;
    this.tokenChar(60), this.print(e, t), this.tokenChar(62), this.space(), this.print(r, t);
  }
  n(cse, "TSTypeAssertion");
  function pse(t) {
    this.print(t.expression, t), this.print(t.typeParameters, t);
  }
  n(pse, "TSInstantiationExpression");
  function fse(t) {
    let {
      declare: e,
      const: r,
      id: s,
      members: i
    } = t;
    e && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(s, t), this.
    space(), ld(this, i, t);
  }
  n(fse, "TSEnumDeclaration");
  function hse(t) {
    let {
      id: e,
      initializer: r
    } = t;
    this.print(e, t), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, t)), this.tokenChar(44);
  }
  n(hse, "TSEnumMember");
  function dse(t) {
    let {
      declare: e,
      id: r
    } = t;
    if (e && (this.word("declare"), this.space()), t.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.
    print(r, t), !t.body) {
      this.tokenChar(59);
      return;
    }
    let s = t.body;
    for (; s.type === "TSModuleDeclaration"; )
      this.tokenChar(46), this.print(s.id, s), s = s.body;
    this.space(), this.print(s, t);
  }
  n(dse, "TSModuleDeclaration");
  function mse(t) {
    ld(this, t.body, t);
  }
  n(mse, "TSModuleBlock");
  function yse(t) {
    let {
      argument: e,
      qualifier: r,
      typeParameters: s
    } = t;
    this.word("import"), this.tokenChar(40), this.print(e, t), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, t)), s && this.print(
    s, t);
  }
  n(yse, "TSImportType");
  function Tse(t) {
    let {
      isExport: e,
      id: r,
      moduleReference: s
    } = t;
    e && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, t), this.space(), this.tokenChar(61), this.space(),
    this.print(s, t), this.tokenChar(59);
  }
  n(Tse, "TSImportEqualsDeclaration");
  function bse(t) {
    this.token("require("), this.print(t.expression, t), this.tokenChar(41);
  }
  n(bse, "TSExternalModuleReference");
  function xse(t) {
    this.print(t.expression, t), this.tokenChar(33);
  }
  n(xse, "TSNonNullExpression");
  function Sse(t) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(t.expression, t), this.tokenChar(59);
  }
  n(Sse, "TSExportAssignment");
  function gse(t) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(t.id, t);
  }
  n(gse, "TSNamespaceExportDeclaration");
  function Pse(t) {
    let {
      typeParameters: e
    } = t, r = t.parameters;
    this.print(e, t), this.tokenChar(40), this._parameters(r, t), this.tokenChar(41);
    let s = t.typeAnnotation;
    this.print(s, t);
  }
  n(Pse, "tsPrintSignatureDeclarationBase");
  function Ese(t) {
    let e = t.type === "ClassAccessorProperty" || t.type === "ClassProperty";
    e && t.declare && (this.word("declare"), this.space()), t.accessibility && (this.word(t.accessibility), this.space()), t.static && (this.
    word("static"), this.space()), t.override && (this.word("override"), this.space()), t.abstract && (this.word("abstract"), this.space()),
    e && t.readonly && (this.word("readonly"), this.space());
  }
  n(Ese, "tsPrintClassMemberModifiers");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/generators/index.js
var SE = w((Qe) => {
  "use strict";
  Object.defineProperty(Qe, "__esModule", {
    value: !0
  });
  var ud = QP();
  Object.keys(ud).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === ud[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ud[t];
      }, "get")
    });
  });
  var cd = tE();
  Object.keys(cd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === cd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return cd[t];
      }, "get")
    });
  });
  var pd = nE();
  Object.keys(pd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === pd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return pd[t];
      }, "get")
    });
  });
  var fd = aE();
  Object.keys(fd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === fd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return fd[t];
      }, "get")
    });
  });
  var hd = oE();
  Object.keys(hd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === hd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return hd[t];
      }, "get")
    });
  });
  var dd = id();
  Object.keys(dd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === dd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return dd[t];
      }, "get")
    });
  });
  var md = ad();
  Object.keys(md).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === md[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return md[t];
      }, "get")
    });
  });
  var yd = dE();
  Object.keys(yd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === yd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return yd[t];
      }, "get")
    });
  });
  var Td = mE();
  Object.keys(Td).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === Td[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Td[t];
      }, "get")
    });
  });
  var bd = yE();
  Object.keys(bd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === bd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return bd[t];
      }, "get")
    });
  });
  var xd = xE();
  Object.keys(xd).forEach(function(t) {
    t === "default" || t === "__esModule" || t in Qe && Qe[t] === xd[t] || Object.defineProperty(Qe, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return xd[t];
      }, "get")
    });
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/printer.js
var PE = w((hu) => {
  "use strict";
  Object.defineProperty(hu, "__esModule", {
    value: !0
  });
  hu.default = void 0;
  var Ase = RP(), vse = rd(), Cse = Ce(), Ise = SE(), {
    isFunction: wse,
    isStatement: Nse,
    isClassBody: Ose,
    isTSInterfaceBody: kse,
    isTSEnumDeclaration: Dse
  } = Cse, _se = /e/i, Lse = /\.0+$/, gE = /[\n\r\u2028\u2029]/, Mse = /[\n\r\u2028\u2029]|\*\//, {
    needsParens: Bse
  } = vse, Ua = class {
    static {
      n(this, "Printer");
    }
    constructor(e, r) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState =
      null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger =
      !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = e, this.
      _indentRepeat = e.indent.style.length, this._inputMap = r?._inputMap, this._buf = new Ase.default(r, e.indent.style[0]);
    }
    generate(e) {
      return this.print(e), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(e = !1) {
      this._maybeAddAuxComment(), e ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(e) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }
    rightParens(e) {
      this.sourceWithOffset("end", e.loc, -1), this.tokenChar(41);
    }
    space(e = !1) {
      if (!this.format.compact) {
        if (e)
          this._space();
        else if (this._buf.hasContent()) {
          let r = this.getLastChar();
          r !== 32 && r !== 10 && this._space();
        }
      }
    }
    word(e, r = !1) {
      this._maybePrintInnerComments(), (this._endsWithWord || e.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(),
      this._append(e, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(e, r) {
      function s(i) {
        if (i.length > 2 && i.charCodeAt(0) === 48) {
          let a = i.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      n(s, "isNonDecimalLiteral"), this.word(e), this._endsWithInteger = Number.isInteger(r) && !s(e) && !_se.test(e) && !Lse.test(e) && e.charCodeAt(
      e.length - 1) !== 46;
    }
    token(e, r = !1) {
      this._maybePrintInnerComments();
      let s = this.getLastChar(), i = e.charCodeAt(0);
      (s === 33 && (e === "--" || i === 61) || i === 43 && s === 43 || i === 45 && s === 45 || i === 46 && this._endsWithInteger) && this._space(),
      this._maybeAddAuxComment(), this._append(e, r), this._noLineTerminator = !1;
    }
    tokenChar(e) {
      this._maybePrintInnerComments();
      let r = this.getLastChar();
      (e === 43 && r === 43 || e === 45 && r === 45 || e === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this.
      _appendChar(e), this._noLineTerminator = !1;
    }
    newline(e = 1, r) {
      if (!(e <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        e > 2 && (e = 2), e -= this._buf.getNewlineCount();
        for (let s = 0; s < e; s++)
          this._newline();
      }
    }
    endsWith(e) {
      return this.getLastChar() === e;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e, r) {
      if (!e) {
        r();
        return;
      }
      this._catchUp("start", e), this._buf.exactSource(e, r);
    }
    source(e, r) {
      r && (this._catchUp(e, r), this._buf.source(e, r));
    }
    sourceWithOffset(e, r, s) {
      r && (this._catchUp(e, r), this._buf.sourceWithOffset(e, r, s));
    }
    withSource(e, r, s) {
      if (!r) {
        s();
        return;
      }
      this._catchUp(e, r), this._buf.withSource(e, r, s);
    }
    sourceIdentifierName(e, r) {
      if (!this._buf._canMarkIdName) return;
      let s = this._buf._sourcePosition;
      s.identifierNamePos = r, s.identifierName = e;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(e, r) {
      this._maybeAddParen(e), this._maybeIndent(e.charCodeAt(0)), this._buf.append(e, r), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _appendChar(e) {
      this._maybeAddParenChar(e), this._maybeIndent(e), this._buf.appendChar(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _queue(e) {
      this._maybeAddParenChar(e), this._maybeIndent(e), this._buf.queue(e), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(e) {
      this._indent && e !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e) {
      if (this._indent && e !== 10 && this.endsWith(10))
        return !0;
    }
    _maybeAddParenChar(e) {
      let r = this._parenPushNewlineState;
      if (r && e !== 32) {
        if (e !== 10) {
          this._parenPushNewlineState = null;
          return;
        }
        this.tokenChar(40), this.indent(), r.printed = !0;
      }
    }
    _maybeAddParen(e) {
      let r = this._parenPushNewlineState;
      if (!r) return;
      let s = e.length, i;
      for (i = 0; i < s && e.charCodeAt(i) === 32; i++) ;
      if (i === s)
        return;
      let a = e.charCodeAt(i);
      if (a !== 10) {
        if (a !== 47 || i + 1 === s) {
          this._parenPushNewlineState = null;
          return;
        }
        let o = e.charCodeAt(i + 1);
        if (o === 42)
          return;
        if (o !== 47) {
          this._parenPushNewlineState = null;
          return;
        }
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
    catchUp(e) {
      if (!this.format.retainLines) return;
      let r = e - this._buf.getCurrentLine();
      for (let s = 0; s < r; s++)
        this._newline();
    }
    _catchUp(e, r) {
      var s;
      if (!this.format.retainLines) return;
      let i = r == null || (s = r[e]) == null ? void 0 : s.line;
      if (i != null) {
        let a = i - this._buf.getCurrentLine();
        for (let o = 0; o < a; o++)
          this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e, r, s) {
      if (s)
        this._noLineTerminator = !0, this.print(e, r);
      else {
        let i = {
          printed: !1
        };
        this._parenPushNewlineState = i, this.print(e, r), i.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(e, r, s, i, a) {
      var o, l;
      if (!e) return;
      this._endsWithInnerRaw = !1;
      let u = e.type, c = this.format, p = c.concise;
      e._compact && (c.concise = !0);
      let f = this[u];
      if (f === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(e.constructor.name)}`);
      this._printStack.push(e);
      let m = this._insideAux;
      this._insideAux = e.loc == null, this._maybeAddAuxComment(this._insideAux && !m);
      let y = (o = e.extra) == null ? void 0 : o.parenthesized, T = a || y && c.retainFunctionParens && u === "FunctionExpression" || Bse(e,
      r, this._printStack);
      if (!T && y && (l = e.leadingComments) != null && l.length && e.leadingComments[0].type === "CommentBlock")
        switch (r?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (r.callee !== e) break;
          default:
            T = !0;
        }
      T && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(e, r);
      let L = u === "Program" || u === "File" ? null : e.loc;
      this.exactSource(L, f.bind(this, e, r)), T ? (this._printTrailingComments(e, r), this.tokenChar(41), this._noLineTerminator = s) : s &&
      !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(e, r)) : this._printTrailingComments(e, r, i), this.
      _printStack.pop(), c.concise = p, this._insideAux = m, this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(e) {
      e && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let e = this.format.auxiliaryCommentBefore;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let e = this.format.auxiliaryCommentAfter;
      e && this._printComment({
        type: "CommentBlock",
        value: e
      }, 0);
    }
    getPossibleRaw(e) {
      let r = e.extra;
      if (r?.raw != null && r.rawValue != null && e.value === r.rawValue)
        return r.raw;
    }
    printJoin(e, r, s = {}) {
      if (!(e != null && e.length)) return;
      let {
        indent: i
      } = s;
      if (i == null && this.format.retainLines) {
        var a;
        let f = (a = e[0].loc) == null ? void 0 : a.start.line;
        f != null && f !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let o = {
        addNewlines: s.addNewlines,
        nextNodeStartLine: 0
      }, l = s.separator ? s.separator.bind(this) : null, u = e.length;
      for (let f = 0; f < u; f++) {
        let m = e[f];
        if (m && (s.statement && this._printNewline(f === 0, o), this.print(m, r, void 0, s.trailingCommentsLineOffset || 0), s.iterator == null ||
        s.iterator(m, f), f < u - 1 && l?.(), s.statement)) {
          var c;
          if ((c = m.trailingComments) != null && c.length || (this._lastCommentLine = 0), f + 1 === u)
            this.newline(1);
          else {
            var p;
            let y = e[f + 1];
            o.nextNodeStartLine = ((p = y.loc) == null ? void 0 : p.start.line) || 0, this._printNewline(!0, o);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(e, r) {
      let s = e.leadingComments && e.leadingComments.length > 0;
      s && this.indent(), this.print(e, r), s && this.dedent();
    }
    printBlock(e) {
      let r = e.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r, e);
    }
    _printTrailingComments(e, r, s) {
      let {
        innerComments: i,
        trailingComments: a
      } = e;
      i != null && i.length && this._printComments(2, i, e, r, s), a != null && a.length && this._printComments(2, a, e, r, s);
    }
    _printLeadingComments(e, r) {
      let s = e.leadingComments;
      s != null && s.length && this._printComments(0, s, e, r);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments() {
      let e = this._printStack[this._printStack.length - 1], r = e.innerComments;
      if (!(r != null && r.length)) return;
      let s = this.endsWith(32), i = this._indentInnerComments, a = this._printedComments.size;
      i && this.indent(), this._printComments(1, r, e), s && a !== this._printedComments.size && this.space(), i && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(e, r, s = {}) {
      var i;
      s.statement = !0, (i = s.indent) != null || (s.indent = !1), this.printJoin(e, r, s);
    }
    printList(e, r, s = {}) {
      s.separator == null && (s.separator = Fse), this.printJoin(e, r, s);
    }
    _printNewline(e, r) {
      let s = this.format;
      if (s.retainLines || s.compact) return;
      if (s.concise) {
        this.space();
        return;
      }
      if (!e)
        return;
      let i = r.nextNodeStartLine, a = this._lastCommentLine;
      if (i > 0 && a > 0) {
        let o = i - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e) {
      return e.ignore || this._printedComments.has(e) ? 0 : this._noLineTerminator && Mse.test(e.value) ? 2 : (this._printedComments.add(e),
      this.format.shouldPrintComment(e.value) ? 1 : 0);
    }
    _printComment(e, r) {
      let s = this._noLineTerminator, i = e.type === "CommentBlock", a = i && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && this.space();
      let l;
      if (i) {
        let {
          _parenPushNewlineState: c
        } = this;
        if (c?.printed === !1 && gE.test(e.value) && (this.tokenChar(40), this.indent(), c.printed = !0), l = `/*${e.value}*/`, this.format.
        indent.adjustMultilineComment) {
          var u;
          let p = (u = e.loc) == null ? void 0 : u.start.column;
          if (p) {
            let f = new RegExp("\\n\\s{1," + p + "}", "g");
            l = l.replace(f, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let f = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (f += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(f)}`);
          }
        }
      } else s ? l = `/*${e.value}*/` : l = `//${e.value}`;
      this.endsWith(47) && this._space(), this.source("start", e.loc), this._append(l, i), !i && !s && this.newline(1, !0), a && r !== 3 && this.
      newline(1);
    }
    _printComments(e, r, s, i, a = 0) {
      let o = s.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, p = u ? o.end.line : 0, f = 0, m = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let T = 0; T < l; T++) {
        let L = r[T], q = this._shouldPrintComment(L);
        if (q === 2) {
          u = !1;
          break;
        }
        if (u && L.loc && q === 1) {
          let _ = L.loc.start.line, U = L.loc.end.line;
          if (e === 0) {
            let J = 0;
            T === 0 ? this._buf.hasContent() && (L.type === "CommentLine" || _ != U) && (J = m = 1) : J = _ - f, f = U, y(J), this._printComment(
            L, 1), T + 1 === l && (y(Math.max(c - f, m)), f = c);
          } else if (e === 1) {
            let J = _ - (T === 0 ? c : f);
            f = U, y(J), this._printComment(L, 1), T + 1 === l && (y(Math.min(1, p - f)), f = p);
          } else {
            let J = _ - (T === 0 ? p - a : f);
            f = U, y(J), this._printComment(L, 1);
          }
        } else {
          if (u = !1, q !== 1)
            continue;
          if (l === 1) {
            let _ = L.loc ? L.loc.start.line === L.loc.end.line : !gE.test(L.value), U = _ && !Nse(s) && !Ose(i) && !kse(i) && !Dse(i);
            e === 0 ? this._printComment(L, U && s.type !== "ObjectExpression" || _ && wse(i, {
              body: s
            }) ? 1 : 0) : U && e === 2 ? this._printComment(L, 1) : this._printComment(L, 0);
          } else e === 1 && !(s.type === "ObjectExpression" && s.properties.length > 1) && s.type !== "ClassBody" && s.type !== "TSInterface\
Body" ? this._printComment(L, T === 0 ? 2 : T === l - 1 ? 3 : 0) : this._printComment(L, 0);
        }
      }
      e === 2 && u && f && (this._lastCommentLine = f);
    }
  };
  Object.assign(Ua.prototype, Ise);
  Ua.prototype.Noop = /* @__PURE__ */ n(function() {
  }, "Noop");
  var J5e = hu.default = Ua;
  function Fse() {
    this.tokenChar(44), this.space();
  }
  n(Fse, "commaSeparator");
});

// ../node_modules/@babel/traverse/node_modules/@babel/generator/lib/index.js
var CE = w((du) => {
  "use strict";
  Object.defineProperty(du, "__esModule", {
    value: !0
  });
  du.default = jse;
  var EE = jP(), AE = PE();
  function vE(t, e) {
    var r;
    let s = {
      auxiliaryCommentBefore: e.auxiliaryCommentBefore,
      auxiliaryCommentAfter: e.auxiliaryCommentAfter,
      shouldPrintComment: e.shouldPrintComment,
      retainLines: e.retainLines,
      retainFunctionParens: e.retainFunctionParens,
      comments: e.comments == null || e.comments,
      compact: e.compact,
      minified: e.minified,
      concise: e.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, e.jsescOption),
      recordAndTupleSyntaxType: (r = e.recordAndTupleSyntaxType) != null ? r : "hash",
      topicToken: e.topicToken,
      importAttributesKeyword: e.importAttributesKeyword
    };
    s.decoratorsBeforeExport = e.decoratorsBeforeExport, s.jsescOption.json = e.jsonCompatibleStrings, s.minified ? (s.compact = !0, s.shouldPrintComment =
    s.shouldPrintComment || (() => s.comments)) : s.shouldPrintComment = s.shouldPrintComment || ((l) => s.comments || l.includes("@license") ||
    l.includes("@preserve")), s.compact === "auto" && (s.compact = typeof t == "string" && t.length > 5e5, s.compact && console.error(`[BABE\
L] Note: The code generator has deoptimised the styling of ${e.filename} as it exceeds the max of 500KB.`)), s.compact && (s.indent.adjustMultilineComment =
    !1);
    let {
      auxiliaryCommentBefore: i,
      auxiliaryCommentAfter: a,
      shouldPrintComment: o
    } = s;
    return i && !o(i) && (s.auxiliaryCommentBefore = void 0), a && !o(a) && (s.auxiliaryCommentAfter = void 0), s;
  }
  n(vE, "normalizeOptions");
  du.CodeGenerator = class {
    static {
      n(this, "CodeGenerator");
    }
    constructor(e, r = {}, s) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = vE(s, r), this._map = r.sourceMaps ? new EE.
      default(r, s) : null;
    }
    generate() {
      return new AE.default(this._format, this._map).generate(this._ast);
    }
  };
  function jse(t, e = {}, r) {
    let s = vE(r, e), i = e.sourceMaps ? new EE.default(e, r) : null;
    return new AE.default(s, i).generate(t);
  }
  n(jse, "generate");
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var IE = w((Ur) => {
  "use strict";
  Object.defineProperty(Ur, "__esModule", {
    value: !0
  });
  Ur.find = Vse;
  Ur.findParent = qse;
  Ur.getAncestry = Xse;
  Ur.getDeepestCommonAncestorFrom = Jse;
  Ur.getEarliestCommonAncestorFrom = Yse;
  Ur.getFunctionParent = Kse;
  Ur.getStatementParent = Wse;
  Ur.inType = zse;
  Ur.isAncestor = $se;
  Ur.isDescendant = Hse;
  var Rse = Ce(), {
    VISITOR_KEYS: Use
  } = Rse;
  function qse(t) {
    let e = this;
    for (; e = e.parentPath; )
      if (t(e)) return e;
    return null;
  }
  n(qse, "findParent");
  function Vse(t) {
    let e = this;
    do
      if (t(e)) return e;
    while (e = e.parentPath);
    return null;
  }
  n(Vse, "find");
  function Kse() {
    return this.findParent((t) => t.isFunction());
  }
  n(Kse, "getFunctionParent");
  function Wse() {
    let t = this;
    do {
      if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
        break;
      t = t.parentPath;
    } while (t);
    if (t && (t.isProgram() || t.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return t;
  }
  n(Wse, "getStatementParent");
  function Yse(t) {
    return this.getDeepestCommonAncestorFrom(t, function(e, r, s) {
      let i, a = Use[e.type];
      for (let o of s) {
        let l = o[r + 1];
        if (!i) {
          i = l;
          continue;
        }
        if (l.listKey && i.listKey === l.listKey && l.key < i.key) {
          i = l;
          continue;
        }
        let u = a.indexOf(i.parentKey), c = a.indexOf(l.parentKey);
        u > c && (i = l);
      }
      return i;
    });
  }
  n(Yse, "getEarliestCommonAncestorFrom");
  function Jse(t, e) {
    if (!t.length)
      return this;
    if (t.length === 1)
      return t[0];
    let r = 1 / 0, s, i, a = t.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < r && (r = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < r; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      s = l, i = u;
    }
    if (i)
      return e ? e(i, s, a) : i;
    throw new Error("Couldn't find intersection");
  }
  n(Jse, "getDeepestCommonAncestorFrom");
  function Xse() {
    let t = this, e = [];
    do
      e.push(t);
    while (t = t.parentPath);
    return e;
  }
  n(Xse, "getAncestry");
  function $se(t) {
    return t.isDescendant(this);
  }
  n($se, "isAncestor");
  function Hse(t) {
    return !!this.findParent((e) => e === t);
  }
  n(Hse, "isDescendant");
  function zse(...t) {
    let e = this;
    for (; e; ) {
      for (let r of t)
        if (e.node.type === r) return !0;
      e = e.parentPath;
    }
    return !1;
  }
  n(zse, "inType");
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var gd = w((Sd) => {
  "use strict";
  Object.defineProperty(Sd, "__esModule", {
    value: !0
  });
  Sd.createUnionType = tie;
  var Gse = Ce(), {
    createFlowUnionType: wE,
    createTSUnionType: NE,
    createUnionTypeAnnotation: Qse,
    isFlowType: Zse,
    isTSType: eie
  } = Gse;
  function tie(t) {
    {
      if (t.every((e) => Zse(e)))
        return wE ? wE(t) : Qse(t);
      if (t.every((e) => eie(e)) && NE)
        return NE(t);
    }
  }
  n(tie, "createUnionType");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var LE = w((Pd) => {
  "use strict";
  Object.defineProperty(Pd, "__esModule", {
    value: !0
  });
  Pd.default = aie;
  var rie = Ce(), kE = gd(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: sie,
    createTypeAnnotationBasedOnTypeof: iie,
    numberTypeAnnotation: DE,
    voidTypeAnnotation: nie
  } = rie;
  function aie(t) {
    if (!this.isReferenced()) return;
    let e = this.scope.getBinding(t.name);
    if (e)
      return e.identifier.typeAnnotation ? e.identifier.typeAnnotation : oie(e, this, t.name);
    if (t.name === "undefined")
      return nie();
    if (t.name === "NaN" || t.name === "Infinity")
      return DE();
    t.name;
  }
  n(aie, "_default");
  function oie(t, e, r) {
    let s = [], i = [], a = OE(t, e, i), o = _E(t, e, r);
    if (o) {
      let l = OE(t, o.ifStatement);
      a = a.filter((u) => l.indexOf(u) < 0), s.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...i);
      for (let l of a)
        s.push(l.getTypeAnnotation());
    }
    if (s.length)
      return (0, kE.createUnionType)(s);
  }
  n(oie, "getTypeAnnotationBindingConstantViolations");
  function OE(t, e, r) {
    let s = t.constantViolations.slice();
    return s.unshift(t.path), s.filter((i) => {
      i = i.resolve();
      let a = i._guessExecutionStatusRelativeTo(e);
      return r && a === "unknown" && r.push(i), a === "before";
    });
  }
  n(OE, "getConstantViolationsBefore");
  function lie(t, e) {
    let r = e.node.operator, s = e.get("right").resolve(), i = e.get("left").resolve(), a;
    if (i.isIdentifier({
      name: t
    }) ? a = s : s.isIdentifier({
      name: t
    }) && (a = i), a)
      return r === "===" ? a.getTypeAnnotation() : sie.indexOf(r) >= 0 ? DE() : void 0;
    if (r !== "===" && r !== "==") return;
    let o, l;
    if (i.isUnaryExpression({
      operator: "typeof"
    }) ? (o = i, l = s) : s.isUnaryExpression({
      operator: "typeof"
    }) && (o = s, l = i), !o || !o.get("argument").isIdentifier({
      name: t
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return iie(u);
  }
  n(lie, "inferAnnotationFromBinaryExpression");
  function uie(t, e, r) {
    let s;
    for (; s = e.parentPath; ) {
      if (s.isIfStatement() || s.isConditionalExpression())
        return e.key === "test" ? void 0 : s;
      if (s.isFunction() && s.parentPath.scope.getBinding(r) !== t)
        return;
      e = s;
    }
  }
  n(uie, "getParentConditionalPath");
  function _E(t, e, r) {
    let s = uie(t, e, r);
    if (!s) return;
    let a = [s.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = lie(r, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, kE.createUnionType)(o),
      ifStatement: s
    } : _E(t, s, r);
  }
  n(_E, "getConditionalAnnotation");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var VE = w((pt) => {
  "use strict";
  Object.defineProperty(pt, "__esModule", {
    value: !0
  });
  pt.ArrayExpression = RE;
  pt.AssignmentExpression = Die;
  pt.BinaryExpression = Iie;
  pt.BooleanLiteral = Bie;
  pt.CallExpression = Yie;
  pt.ConditionalExpression = Nie;
  pt.ClassDeclaration = pt.ClassExpression = pt.FunctionDeclaration = pt.ArrowFunctionExpression = pt.FunctionExpression = Uie;
  Object.defineProperty(pt, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pie.default;
    }, "get")
  });
  pt.LogicalExpression = wie;
  pt.NewExpression = Aie;
  pt.NullLiteral = Fie;
  pt.NumericLiteral = Mie;
  pt.ObjectExpression = Rie;
  pt.ParenthesizedExpression = kie;
  pt.RegExpLiteral = jie;
  pt.RestElement = UE;
  pt.SequenceExpression = Oie;
  pt.StringLiteral = Lie;
  pt.TSAsExpression = jE;
  pt.TSNonNullExpression = Eie;
  pt.TaggedTemplateExpression = Jie;
  pt.TemplateLiteral = vie;
  pt.TypeCastExpression = FE;
  pt.UnaryExpression = Cie;
  pt.UpdateExpression = _ie;
  pt.VariableDeclarator = Pie;
  var cie = Ce(), pie = LE(), BE = gd(), {
    BOOLEAN_BINARY_OPERATORS: fie,
    BOOLEAN_UNARY_OPERATORS: hie,
    NUMBER_BINARY_OPERATORS: die,
    NUMBER_UNARY_OPERATORS: mie,
    STRING_UNARY_OPERATORS: yie,
    anyTypeAnnotation: ME,
    arrayTypeAnnotation: Ed,
    booleanTypeAnnotation: Ad,
    buildMatchMemberExpression: mu,
    genericTypeAnnotation: ei,
    identifier: Ri,
    nullLiteralTypeAnnotation: Tie,
    numberTypeAnnotation: An,
    stringTypeAnnotation: Ui,
    tupleTypeAnnotation: bie,
    unionTypeAnnotation: xie,
    voidTypeAnnotation: Sie,
    isIdentifier: gie
  } = cie;
  function Pie() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  n(Pie, "VariableDeclarator");
  function FE(t) {
    return t.typeAnnotation;
  }
  n(FE, "TypeCastExpression");
  FE.validParent = !0;
  function jE(t) {
    return t.typeAnnotation;
  }
  n(jE, "TSAsExpression");
  jE.validParent = !0;
  function Eie() {
    return this.get("expression").getTypeAnnotation();
  }
  n(Eie, "TSNonNullExpression");
  function Aie(t) {
    if (t.callee.type === "Identifier")
      return ei(t.callee);
  }
  n(Aie, "NewExpression");
  function vie() {
    return Ui();
  }
  n(vie, "TemplateLiteral");
  function Cie(t) {
    let e = t.operator;
    if (e === "void")
      return Sie();
    if (mie.indexOf(e) >= 0)
      return An();
    if (yie.indexOf(e) >= 0)
      return Ui();
    if (hie.indexOf(e) >= 0)
      return Ad();
  }
  n(Cie, "UnaryExpression");
  function Iie(t) {
    let e = t.operator;
    if (die.indexOf(e) >= 0)
      return An();
    if (fie.indexOf(e) >= 0)
      return Ad();
    if (e === "+") {
      let r = this.get("right"), s = this.get("left");
      return s.isBaseType("number") && r.isBaseType("number") ? An() : s.isBaseType("string") || r.isBaseType("string") ? Ui() : xie([Ui(), An()]);
    }
  }
  n(Iie, "BinaryExpression");
  function wie() {
    let t = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, BE.createUnionType)(t);
  }
  n(wie, "LogicalExpression");
  function Nie() {
    let t = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, BE.createUnionType)(t);
  }
  n(Nie, "ConditionalExpression");
  function Oie() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  n(Oie, "SequenceExpression");
  function kie() {
    return this.get("expression").getTypeAnnotation();
  }
  n(kie, "ParenthesizedExpression");
  function Die() {
    return this.get("right").getTypeAnnotation();
  }
  n(Die, "AssignmentExpression");
  function _ie(t) {
    let e = t.operator;
    if (e === "++" || e === "--")
      return An();
  }
  n(_ie, "UpdateExpression");
  function Lie() {
    return Ui();
  }
  n(Lie, "StringLiteral");
  function Mie() {
    return An();
  }
  n(Mie, "NumericLiteral");
  function Bie() {
    return Ad();
  }
  n(Bie, "BooleanLiteral");
  function Fie() {
    return Tie();
  }
  n(Fie, "NullLiteral");
  function jie() {
    return ei(Ri("RegExp"));
  }
  n(jie, "RegExpLiteral");
  function Rie() {
    return ei(Ri("Object"));
  }
  n(Rie, "ObjectExpression");
  function RE() {
    return ei(Ri("Array"));
  }
  n(RE, "ArrayExpression");
  function UE() {
    return RE();
  }
  n(UE, "RestElement");
  UE.validParent = !0;
  function Uie() {
    return ei(Ri("Function"));
  }
  n(Uie, "Func");
  var qie = mu("Array.from"), Vie = mu("Object.keys"), Kie = mu("Object.values"), Wie = mu("Object.entries");
  function Yie() {
    let {
      callee: t
    } = this.node;
    return Vie(t) ? Ed(Ui()) : qie(t) || Kie(t) || gie(t, {
      name: "Array"
    }) ? Ed(ME()) : Wie(t) ? Ed(bie([Ui(), ME()])) : qE(this.get("callee"));
  }
  n(Yie, "CallExpression");
  function Jie() {
    return qE(this.get("tag"));
  }
  n(Jie, "TaggedTemplateExpression");
  function qE(t) {
    if (t = t.resolve(), t.isFunction()) {
      let {
        node: e
      } = t;
      if (e.async)
        return e.generator ? ei(Ri("AsyncIterator")) : ei(Ri("Promise"));
      if (e.generator)
        return ei(Ri("Iterator"));
      if (t.node.returnType)
        return t.node.returnType;
    }
  }
  n(qE, "resolveCall");
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var JE = w((ti) => {
  "use strict";
  Object.defineProperty(ti, "__esModule", {
    value: !0
  });
  ti._getTypeAnnotation = fne;
  ti.baseTypeStrictlyMatches = mne;
  ti.couldBeBaseType = dne;
  ti.getTypeAnnotation = pne;
  ti.isBaseType = hne;
  ti.isGenericType = yne;
  var KE = VE(), Xie = Ce(), {
    anyTypeAnnotation: YE,
    isAnyTypeAnnotation: yu,
    isArrayTypeAnnotation: $ie,
    isBooleanTypeAnnotation: Hie,
    isEmptyTypeAnnotation: zie,
    isFlowBaseAnnotation: Gie,
    isGenericTypeAnnotation: Qie,
    isIdentifier: WE,
    isMixedTypeAnnotation: Zie,
    isNumberTypeAnnotation: ene,
    isStringTypeAnnotation: tne,
    isTSArrayType: rne,
    isTSTypeAnnotation: sne,
    isTSTypeReference: ine,
    isTupleTypeAnnotation: nne,
    isTypeAnnotation: ane,
    isUnionTypeAnnotation: one,
    isVoidTypeAnnotation: lne,
    stringTypeAnnotation: une,
    voidTypeAnnotation: cne
  } = Xie;
  function pne() {
    let t = this.getData("typeAnnotation");
    return t != null || (t = this._getTypeAnnotation() || YE(), (ane(t) || sne(t)) && (t = t.typeAnnotation), this.setData("typeAnnotation",
    t)), t;
  }
  n(pne, "getTypeAnnotation");
  var vd = /* @__PURE__ */ new WeakSet();
  function fne() {
    let t = this.node;
    if (!t)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let r = this.parentPath.parentPath, s = r.parentPath;
        return r.key === "left" && s.isForInStatement() ? une() : r.key === "left" && s.isForOfStatement() ? YE() : cne();
      } else
        return;
    if (t.typeAnnotation)
      return t.typeAnnotation;
    if (!vd.has(t)) {
      vd.add(t);
      try {
        var e;
        let r = KE[t.type];
        if (r)
          return r.call(this, t);
        if (r = KE[this.parentPath.type], (e = r) != null && e.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        vd.delete(t);
      }
    }
  }
  n(fne, "_getTypeAnnotation");
  function hne(t, e) {
    return Cd(t, this.getTypeAnnotation(), e);
  }
  n(hne, "isBaseType");
  function Cd(t, e, r) {
    if (t === "string")
      return tne(e);
    if (t === "number")
      return ene(e);
    if (t === "boolean")
      return Hie(e);
    if (t === "any")
      return yu(e);
    if (t === "mixed")
      return Zie(e);
    if (t === "empty")
      return zie(e);
    if (t === "void")
      return lne(e);
    if (r)
      return !1;
    throw new Error(`Unknown base type ${t}`);
  }
  n(Cd, "_isBaseType");
  function dne(t) {
    let e = this.getTypeAnnotation();
    if (yu(e)) return !0;
    if (one(e)) {
      for (let r of e.types)
        if (yu(r) || Cd(t, r, !0))
          return !0;
      return !1;
    } else
      return Cd(t, e, !0);
  }
  n(dne, "couldBeBaseType");
  function mne(t) {
    let e = this.getTypeAnnotation(), r = t.getTypeAnnotation();
    return !yu(e) && Gie(e) ? r.type === e.type : !1;
  }
  n(mne, "baseTypeStrictlyMatches");
  function yne(t) {
    let e = this.getTypeAnnotation();
    return t === "Array" && (rne(e) || $ie(e) || nne(e)) ? !0 : Qie(e) && WE(e.id, {
      name: t
    }) || ine(e) && WE(e.typeName, {
      name: t
    });
  }
  n(yne, "isGenericType");
});

// ../node_modules/js-tokens/index.js
var Id = w((Tu) => {
  Object.defineProperty(Tu, "__esModule", {
    value: !0
  });
  Tu.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  Tu.matchToToken = function(t) {
    var e = { type: "invalid", value: t[0], closed: void 0 };
    return t[1] ? (e.type = "string", e.closed = !!(t[3] || t[4])) : t[5] ? e.type = "comment" : t[6] ? (e.type = "comment", e.closed = !!t[7]) :
    t[8] ? e.type = "regex" : t[9] ? e.type = "number" : t[10] ? e.type = "name" : t[11] ? e.type = "punctuator" : t[12] && (e.type = "white\
space"), e;
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-validator-identifier/lib/identifier.js
var GE = w((qa) => {
  "use strict";
  Object.defineProperty(qa, "__esModule", {
    value: !0
  });
  qa.isIdentifierChar = zE;
  qa.isIdentifierName = Sne;
  qa.isIdentifierStart = HE;
  var Nd = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  XE = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", Tne = new RegExp("[" + Nd + "]"), bne = new RegExp("[" + Nd + XE + "\
]");
  Nd = XE = null;
  var $E = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], xne = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function wd(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(wd, "isInAstralSet");
  function HE(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && Tne.test(String.fromCharCode(t)) :
    wd(t, $E);
  }
  n(HE, "isIdentifierStart");
  function zE(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && bne.test(
    String.fromCharCode(t)) : wd(t, $E) || wd(t, xne);
  }
  n(zE, "isIdentifierChar");
  function Sne(t) {
    let e = !0;
    for (let r = 0; r < t.length; r++) {
      let s = t.charCodeAt(r);
      if ((s & 64512) === 55296 && r + 1 < t.length) {
        let i = t.charCodeAt(++r);
        (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
      }
      if (e) {
        if (e = !1, !HE(s))
          return !1;
      } else if (!zE(s))
        return !1;
    }
    return !e;
  }
  n(Sne, "isIdentifierName");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-validator-identifier/lib/keyword.js
var tA = w((qi) => {
  "use strict";
  Object.defineProperty(qi, "__esModule", {
    value: !0
  });
  qi.isKeyword = vne;
  qi.isReservedWord = QE;
  qi.isStrictBindOnlyReservedWord = eA;
  qi.isStrictBindReservedWord = Ane;
  qi.isStrictReservedWord = ZE;
  var Od = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, gne = new Set(Od.keyword), Pne = new Set(Od.strict), Ene = new Set(Od.strictBind);
  function QE(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(QE, "isReservedWord");
  function ZE(t, e) {
    return QE(t, e) || Pne.has(t);
  }
  n(ZE, "isStrictReservedWord");
  function eA(t) {
    return Ene.has(t);
  }
  n(eA, "isStrictBindOnlyReservedWord");
  function Ane(t, e) {
    return ZE(t, e) || eA(t);
  }
  n(Ane, "isStrictBindReservedWord");
  function vne(t) {
    return gne.has(t);
  }
  n(vne, "isKeyword");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-validator-identifier/lib/index.js
var Ka = w((ns) => {
  "use strict";
  Object.defineProperty(ns, "__esModule", {
    value: !0
  });
  Object.defineProperty(ns, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kd.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(ns, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kd.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(ns, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kd.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(ns, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Va.isKeyword;
    }, "get")
  });
  Object.defineProperty(ns, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Va.isReservedWord;
    }, "get")
  });
  Object.defineProperty(ns, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Va.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(ns, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Va.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(ns, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Va.isStrictReservedWord;
    }, "get")
  });
  var kd = GE(), Va = tA();
});

// ../node_modules/picocolors/picocolors.js
var Wa = w((mje, Dd) => {
  var rA = process.argv || [], bu = process.env, Cne = !("NO_COLOR" in bu || rA.includes("--no-color")) && ("FORCE_COLOR" in bu || rA.includes(
  "--color") || process.platform === "win32" || ds != null && ds("tty").isatty(1) && bu.TERM !== "dumb" || "CI" in bu), Ine = /* @__PURE__ */ n(
  (t, e, r = t) => (s) => {
    let i = "" + s, a = i.indexOf(e, t.length);
    return ~a ? t + wne(i, e, r, a) + e : t + i + e;
  }, "formatter"), wne = /* @__PURE__ */ n((t, e, r, s) => {
    let i = "", a = 0;
    do
      i += t.substring(a, s) + r, a = s + e.length, s = t.indexOf(e, a);
    while (~s);
    return i + t.substring(a);
  }, "replaceClose"), sA = /* @__PURE__ */ n((t = Cne) => {
    let e = t ? Ine : () => String;
    return {
      isColorSupported: t,
      reset: e("\x1B[0m", "\x1B[0m"),
      bold: e("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: e("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: e("\x1B[3m", "\x1B[23m"),
      underline: e("\x1B[4m", "\x1B[24m"),
      inverse: e("\x1B[7m", "\x1B[27m"),
      hidden: e("\x1B[8m", "\x1B[28m"),
      strikethrough: e("\x1B[9m", "\x1B[29m"),
      black: e("\x1B[30m", "\x1B[39m"),
      red: e("\x1B[31m", "\x1B[39m"),
      green: e("\x1B[32m", "\x1B[39m"),
      yellow: e("\x1B[33m", "\x1B[39m"),
      blue: e("\x1B[34m", "\x1B[39m"),
      magenta: e("\x1B[35m", "\x1B[39m"),
      cyan: e("\x1B[36m", "\x1B[39m"),
      white: e("\x1B[37m", "\x1B[39m"),
      gray: e("\x1B[90m", "\x1B[39m"),
      bgBlack: e("\x1B[40m", "\x1B[49m"),
      bgRed: e("\x1B[41m", "\x1B[49m"),
      bgGreen: e("\x1B[42m", "\x1B[49m"),
      bgYellow: e("\x1B[43m", "\x1B[49m"),
      bgBlue: e("\x1B[44m", "\x1B[49m"),
      bgMagenta: e("\x1B[45m", "\x1B[49m"),
      bgCyan: e("\x1B[46m", "\x1B[49m"),
      bgWhite: e("\x1B[47m", "\x1B[49m")
    };
  }, "createColors");
  Dd.exports = sA();
  Dd.exports.createColors = sA;
});

// ../node_modules/escape-string-regexp/index.js
var _d = w((Tje, iA) => {
  "use strict";
  var Nne = /[|\\{}()[\]^$+*?.]/g;
  iA.exports = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(Nne, "\\$&");
  };
});

// ../node_modules/@babel/traverse/node_modules/color-name/index.js
var aA = w((bje, nA) => {
  "use strict";
  nA.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../node_modules/@babel/traverse/node_modules/color-convert/conversions.js
var Ld = w((xje, cA) => {
  var Vi = aA(), uA = {};
  for (xu in Vi)
    Vi.hasOwnProperty(xu) && (uA[Vi[xu]] = xu);
  var xu, Se = cA.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (dr in Se)
    if (Se.hasOwnProperty(dr)) {
      if (!("channels" in Se[dr]))
        throw new Error("missing channels property: " + dr);
      if (!("labels" in Se[dr]))
        throw new Error("missing channel labels property: " + dr);
      if (Se[dr].labels.length !== Se[dr].channels)
        throw new Error("channel and label counts mismatch: " + dr);
      oA = Se[dr].channels, lA = Se[dr].labels, delete Se[dr].channels, delete Se[dr].labels, Object.defineProperty(Se[dr], "channels", { value: oA }),
      Object.defineProperty(Se[dr], "labels", { value: lA });
    }
  var oA, lA, dr;
  Se.rgb.hsl = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i = Math.min(e, r, s), a = Math.max(e, r, s), o = a - i, l, u, c;
    return a === i ? l = 0 : e === a ? l = (r - s) / o : r === a ? l = 2 + (s - e) / o : s === a && (l = 4 + (e - r) / o), l = Math.min(l * 60,
    360), l < 0 && (l += 360), c = (i + a) / 2, a === i ? u = 0 : c <= 0.5 ? u = o / (a + i) : u = o / (2 - a - i), [l, u * 100, c * 100];
  };
  Se.rgb.hsv = function(t) {
    var e, r, s, i, a, o = t[0] / 255, l = t[1] / 255, u = t[2] / 255, c = Math.max(o, l, u), p = c - Math.min(o, l, u), f = /* @__PURE__ */ n(
    function(m) {
      return (c - m) / 6 / p + 1 / 2;
    }, "diffc");
    return p === 0 ? i = a = 0 : (a = p / c, e = f(o), r = f(l), s = f(u), o === c ? i = s - r : l === c ? i = 1 / 3 + e - s : u === c && (i =
    2 / 3 + r - e), i < 0 ? i += 1 : i > 1 && (i -= 1)), [
      i * 360,
      a * 100,
      c * 100
    ];
  };
  Se.rgb.hwb = function(t) {
    var e = t[0], r = t[1], s = t[2], i = Se.rgb.hsl(t)[0], a = 1 / 255 * Math.min(e, Math.min(r, s));
    return s = 1 - 1 / 255 * Math.max(e, Math.max(r, s)), [i, a * 100, s * 100];
  };
  Se.rgb.cmyk = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i, a, o, l;
    return l = Math.min(1 - e, 1 - r, 1 - s), i = (1 - e - l) / (1 - l) || 0, a = (1 - r - l) / (1 - l) || 0, o = (1 - s - l) / (1 - l) || 0,
    [i * 100, a * 100, o * 100, l * 100];
  };
  function One(t, e) {
    return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2);
  }
  n(One, "comparativeDistance");
  Se.rgb.keyword = function(t) {
    var e = uA[t];
    if (e)
      return e;
    var r = 1 / 0, s;
    for (var i in Vi)
      if (Vi.hasOwnProperty(i)) {
        var a = Vi[i], o = One(t, a);
        o < r && (r = o, s = i);
      }
    return s;
  };
  Se.keyword.rgb = function(t) {
    return Vi[t];
  };
  Se.rgb.xyz = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255;
    e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, s = s >
    0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
    var i = e * 0.4124 + r * 0.3576 + s * 0.1805, a = e * 0.2126 + r * 0.7152 + s * 0.0722, o = e * 0.0193 + r * 0.1192 + s * 0.9505;
    return [i * 100, a * 100, o * 100];
  };
  Se.rgb.lab = function(t) {
    var e = Se.rgb.xyz(t), r = e[0], s = e[1], i = e[2], a, o, l;
    return r /= 95.047, s /= 100, i /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 /
    3) : 7.787 * s + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, a = 116 * s - 16, o = 500 * (r - s), l = 200 * (s -
    i), [a, o, l];
  };
  Se.hsl.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100, i, a, o, l, u;
    if (r === 0)
      return u = s * 255, [u, u, u];
    s < 0.5 ? a = s * (1 + r) : a = s + r - s * r, i = 2 * s - a, l = [0, 0, 0];
    for (var c = 0; c < 3; c++)
      o = e + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? u = i + (a - i) * 6 * o : 2 * o < 1 ? u = a : 3 * o < 2 ? u = i + (a -
      i) * (2 / 3 - o) * 6 : u = i, l[c] = u * 255;
    return l;
  };
  Se.hsl.hsv = function(t) {
    var e = t[0], r = t[1] / 100, s = t[2] / 100, i = r, a = Math.max(s, 0.01), o, l;
    return s *= 2, r *= s <= 1 ? s : 2 - s, i *= a <= 1 ? a : 2 - a, l = (s + r) / 2, o = s === 0 ? 2 * i / (a + i) : 2 * r / (s + r), [e, o *
    100, l * 100];
  };
  Se.hsv.rgb = function(t) {
    var e = t[0] / 60, r = t[1] / 100, s = t[2] / 100, i = Math.floor(e) % 6, a = e - Math.floor(e), o = 255 * s * (1 - r), l = 255 * s * (1 -
    r * a), u = 255 * s * (1 - r * (1 - a));
    switch (s *= 255, i) {
      case 0:
        return [s, u, o];
      case 1:
        return [l, s, o];
      case 2:
        return [o, s, u];
      case 3:
        return [o, l, s];
      case 4:
        return [u, o, s];
      case 5:
        return [s, o, l];
    }
  };
  Se.hsv.hsl = function(t) {
    var e = t[0], r = t[1] / 100, s = t[2] / 100, i = Math.max(s, 0.01), a, o, l;
    return l = (2 - r) * s, a = (2 - r) * i, o = r * i, o /= a <= 1 ? a : 2 - a, o = o || 0, l /= 2, [e, o * 100, l * 100];
  };
  Se.hwb.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100, i = r + s, a, o, l, u;
    i > 1 && (r /= i, s /= i), a = Math.floor(6 * e), o = 1 - s, l = 6 * e - a, a & 1 && (l = 1 - l), u = r + l * (o - r);
    var c, p, f;
    switch (a) {
      default:
      case 6:
      case 0:
        c = o, p = u, f = r;
        break;
      case 1:
        c = u, p = o, f = r;
        break;
      case 2:
        c = r, p = o, f = u;
        break;
      case 3:
        c = r, p = u, f = o;
        break;
      case 4:
        c = u, p = r, f = o;
        break;
      case 5:
        c = o, p = r, f = u;
        break;
    }
    return [c * 255, p * 255, f * 255];
  };
  Se.cmyk.rgb = function(t) {
    var e = t[0] / 100, r = t[1] / 100, s = t[2] / 100, i = t[3] / 100, a, o, l;
    return a = 1 - Math.min(1, e * (1 - i) + i), o = 1 - Math.min(1, r * (1 - i) + i), l = 1 - Math.min(1, s * (1 - i) + i), [a * 255, o * 255,
    l * 255];
  };
  Se.xyz.rgb = function(t) {
    var e = t[0] / 100, r = t[1] / 100, s = t[2] / 100, i, a, o;
    return i = e * 3.2406 + r * -1.5372 + s * -0.4986, a = e * -0.9689 + r * 1.8758 + s * 0.0415, o = e * 0.0557 + r * -0.204 + s * 1.057, i =
    i > 31308e-7 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, o =
    o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, i = Math.min(Math.max(0, i), 1), a = Math.min(Math.max(0, a), 1), o = Math.
    min(Math.max(0, o), 1), [i * 255, a * 255, o * 255];
  };
  Se.xyz.lab = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return e /= 95.047, r /= 100, s /= 108.883, e = e > 8856e-6 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 /
    3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, i = 116 * r - 16, a = 500 * (e - r), o = 200 * (r -
    s), [i, a, o];
  };
  Se.lab.xyz = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    a = (e + 16) / 116, i = r / 500 + a, o = a - s / 200;
    var l = Math.pow(a, 3), u = Math.pow(i, 3), c = Math.pow(o, 3);
    return a = l > 8856e-6 ? l : (a - 16 / 116) / 7.787, i = u > 8856e-6 ? u : (i - 16 / 116) / 7.787, o = c > 8856e-6 ? c : (o - 16 / 116) /
    7.787, i *= 95.047, a *= 100, o *= 108.883, [i, a, o];
  };
  Se.lab.lch = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return i = Math.atan2(s, r), a = i * 360 / 2 / Math.PI, a < 0 && (a += 360), o = Math.sqrt(r * r + s * s), [e, o, a];
  };
  Se.lch.lab = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return o = s / 360 * 2 * Math.PI, i = r * Math.cos(o), a = r * Math.sin(o), [e, i, a];
  };
  Se.rgb.ansi16 = function(t) {
    var e = t[0], r = t[1], s = t[2], i = 1 in arguments ? arguments[1] : Se.rgb.hsv(t)[2];
    if (i = Math.round(i / 50), i === 0)
      return 30;
    var a = 30 + (Math.round(s / 255) << 2 | Math.round(r / 255) << 1 | Math.round(e / 255));
    return i === 2 && (a += 60), a;
  };
  Se.hsv.ansi16 = function(t) {
    return Se.rgb.ansi16(Se.hsv.rgb(t), t[2]);
  };
  Se.rgb.ansi256 = function(t) {
    var e = t[0], r = t[1], s = t[2];
    if (e === r && r === s)
      return e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232;
    var i = 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(s / 255 * 5);
    return i;
  };
  Se.ansi16.rgb = function(t) {
    var e = t % 10;
    if (e === 0 || e === 7)
      return t > 50 && (e += 3.5), e = e / 10.5 * 255, [e, e, e];
    var r = (~~(t > 50) + 1) * 0.5, s = (e & 1) * r * 255, i = (e >> 1 & 1) * r * 255, a = (e >> 2 & 1) * r * 255;
    return [s, i, a];
  };
  Se.ansi256.rgb = function(t) {
    if (t >= 232) {
      var e = (t - 232) * 10 + 8;
      return [e, e, e];
    }
    t -= 16;
    var r, s = Math.floor(t / 36) / 5 * 255, i = Math.floor((r = t % 36) / 6) / 5 * 255, a = r % 6 / 5 * 255;
    return [s, i, a];
  };
  Se.rgb.hex = function(t) {
    var e = ((Math.round(t[0]) & 255) << 16) + ((Math.round(t[1]) & 255) << 8) + (Math.round(t[2]) & 255), r = e.toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  Se.hex.rgb = function(t) {
    var e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!e)
      return [0, 0, 0];
    var r = e[0];
    e[0].length === 3 && (r = r.split("").map(function(l) {
      return l + l;
    }).join(""));
    var s = parseInt(r, 16), i = s >> 16 & 255, a = s >> 8 & 255, o = s & 255;
    return [i, a, o];
  };
  Se.rgb.hcg = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i = Math.max(Math.max(e, r), s), a = Math.min(Math.min(e, r), s), o = i - a, l, u;
    return o < 1 ? l = a / (1 - o) : l = 0, o <= 0 ? u = 0 : i === e ? u = (r - s) / o % 6 : i === r ? u = 2 + (s - e) / o : u = 4 + (e - r) /
    o + 4, u /= 6, u %= 1, [u * 360, o * 100, l * 100];
  };
  Se.hsl.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = 1, i = 0;
    return r < 0.5 ? s = 2 * e * r : s = 2 * e * (1 - r), s < 1 && (i = (r - 0.5 * s) / (1 - s)), [t[0], s * 100, i * 100];
  };
  Se.hsv.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e * r, i = 0;
    return s < 1 && (i = (r - s) / (1 - s)), [t[0], s * 100, i * 100];
  };
  Se.hcg.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100;
    if (r === 0)
      return [s * 255, s * 255, s * 255];
    var i = [0, 0, 0], a = e % 1 * 6, o = a % 1, l = 1 - o, u = 0;
    switch (Math.floor(a)) {
      case 0:
        i[0] = 1, i[1] = o, i[2] = 0;
        break;
      case 1:
        i[0] = l, i[1] = 1, i[2] = 0;
        break;
      case 2:
        i[0] = 0, i[1] = 1, i[2] = o;
        break;
      case 3:
        i[0] = 0, i[1] = l, i[2] = 1;
        break;
      case 4:
        i[0] = o, i[1] = 0, i[2] = 1;
        break;
      default:
        i[0] = 1, i[1] = 0, i[2] = l;
    }
    return u = (1 - r) * s, [
      (r * i[0] + u) * 255,
      (r * i[1] + u) * 255,
      (r * i[2] + u) * 255
    ];
  };
  Se.hcg.hsv = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e + r * (1 - e), i = 0;
    return s > 0 && (i = e / s), [t[0], i * 100, s * 100];
  };
  Se.hcg.hsl = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = r * (1 - e) + 0.5 * e, i = 0;
    return s > 0 && s < 0.5 ? i = e / (2 * s) : s >= 0.5 && s < 1 && (i = e / (2 * (1 - s))), [t[0], i * 100, s * 100];
  };
  Se.hcg.hwb = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e + r * (1 - e);
    return [t[0], (s - e) * 100, (1 - s) * 100];
  };
  Se.hwb.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = 1 - r, i = s - e, a = 0;
    return i < 1 && (a = (s - i) / (1 - i)), [t[0], i * 100, a * 100];
  };
  Se.apple.rgb = function(t) {
    return [t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255];
  };
  Se.rgb.apple = function(t) {
    return [t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535];
  };
  Se.gray.rgb = function(t) {
    return [t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255];
  };
  Se.gray.hsl = Se.gray.hsv = function(t) {
    return [0, 0, t[0]];
  };
  Se.gray.hwb = function(t) {
    return [0, 100, t[0]];
  };
  Se.gray.cmyk = function(t) {
    return [0, 0, 0, t[0]];
  };
  Se.gray.lab = function(t) {
    return [t[0], 0, 0];
  };
  Se.gray.hex = function(t) {
    var e = Math.round(t[0] / 100 * 255) & 255, r = (e << 16) + (e << 8) + e, s = r.toString(16).toUpperCase();
    return "000000".substring(s.length) + s;
  };
  Se.rgb.gray = function(t) {
    var e = (t[0] + t[1] + t[2]) / 3;
    return [e / 255 * 100];
  };
});

// ../node_modules/@babel/traverse/node_modules/color-convert/route.js
var fA = w((gje, pA) => {
  var Su = Ld();
  function kne() {
    for (var t = {}, e = Object.keys(Su), r = e.length, s = 0; s < r; s++)
      t[e[s]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return t;
  }
  n(kne, "buildGraph");
  function Dne(t) {
    var e = kne(), r = [t];
    for (e[t].distance = 0; r.length; )
      for (var s = r.pop(), i = Object.keys(Su[s]), a = i.length, o = 0; o < a; o++) {
        var l = i[o], u = e[l];
        u.distance === -1 && (u.distance = e[s].distance + 1, u.parent = s, r.unshift(l));
      }
    return e;
  }
  n(Dne, "deriveBFS");
  function _ne(t, e) {
    return function(r) {
      return e(t(r));
    };
  }
  n(_ne, "link");
  function Lne(t, e) {
    for (var r = [e[t].parent, t], s = Su[e[t].parent][t], i = e[t].parent; e[i].parent; )
      r.unshift(e[i].parent), s = _ne(Su[e[i].parent][i], s), i = e[i].parent;
    return s.conversion = r, s;
  }
  n(Lne, "wrapConversion");
  pA.exports = function(t) {
    for (var e = Dne(t), r = {}, s = Object.keys(e), i = s.length, a = 0; a < i; a++) {
      var o = s[a], l = e[o];
      l.parent !== null && (r[o] = Lne(o, e));
    }
    return r;
  };
});

// ../node_modules/@babel/traverse/node_modules/color-convert/index.js
var dA = w((Eje, hA) => {
  var Md = Ld(), Mne = fA(), vn = {}, Bne = Object.keys(Md);
  function Fne(t) {
    var e = /* @__PURE__ */ n(function(r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), t(r));
    }, "wrappedFn");
    return "conversion" in t && (e.conversion = t.conversion), e;
  }
  n(Fne, "wrapRaw");
  function jne(t) {
    var e = /* @__PURE__ */ n(function(r) {
      if (r == null)
        return r;
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
      var s = t(r);
      if (typeof s == "object")
        for (var i = s.length, a = 0; a < i; a++)
          s[a] = Math.round(s[a]);
      return s;
    }, "wrappedFn");
    return "conversion" in t && (e.conversion = t.conversion), e;
  }
  n(jne, "wrapRounded");
  Bne.forEach(function(t) {
    vn[t] = {}, Object.defineProperty(vn[t], "channels", { value: Md[t].channels }), Object.defineProperty(vn[t], "labels", { value: Md[t].labels });
    var e = Mne(t), r = Object.keys(e);
    r.forEach(function(s) {
      var i = e[s];
      vn[t][s] = jne(i), vn[t][s].raw = Fne(i);
    });
  });
  hA.exports = vn;
});

// ../node_modules/@babel/traverse/node_modules/ansi-styles/index.js
var yA = w((vje, mA) => {
  "use strict";
  var Cn = dA(), gu = /* @__PURE__ */ n((t, e) => function() {
    return `\x1B[${t.apply(Cn, arguments) + e}m`;
  }, "wrapAnsi16"), Pu = /* @__PURE__ */ n((t, e) => function() {
    let r = t.apply(Cn, arguments);
    return `\x1B[${38 + e};5;${r}m`;
  }, "wrapAnsi256"), Eu = /* @__PURE__ */ n((t, e) => function() {
    let r = t.apply(Cn, arguments);
    return `\x1B[${38 + e};2;${r[0]};${r[1]};${r[2]}m`;
  }, "wrapAnsi16m");
  function Rne() {
    let t = /* @__PURE__ */ new Map(), e = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    e.color.grey = e.color.gray;
    for (let i of Object.keys(e)) {
      let a = e[i];
      for (let o of Object.keys(a)) {
        let l = a[o];
        e[o] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, a[o] = e[o], t.set(l[0], l[1]);
      }
      Object.defineProperty(e, i, {
        value: a,
        enumerable: !1
      }), Object.defineProperty(e, "codes", {
        value: t,
        enumerable: !1
      });
    }
    let r = /* @__PURE__ */ n((i) => i, "ansi2ansi"), s = /* @__PURE__ */ n((i, a, o) => [i, a, o], "rgb2rgb");
    e.color.close = "\x1B[39m", e.bgColor.close = "\x1B[49m", e.color.ansi = {
      ansi: gu(r, 0)
    }, e.color.ansi256 = {
      ansi256: Pu(r, 0)
    }, e.color.ansi16m = {
      rgb: Eu(s, 0)
    }, e.bgColor.ansi = {
      ansi: gu(r, 10)
    }, e.bgColor.ansi256 = {
      ansi256: Pu(r, 10)
    }, e.bgColor.ansi16m = {
      rgb: Eu(s, 10)
    };
    for (let i of Object.keys(Cn)) {
      if (typeof Cn[i] != "object")
        continue;
      let a = Cn[i];
      i === "ansi16" && (i = "ansi"), "ansi16" in a && (e.color.ansi[i] = gu(a.ansi16, 0), e.bgColor.ansi[i] = gu(a.ansi16, 10)), "ansi256" in
      a && (e.color.ansi256[i] = Pu(a.ansi256, 0), e.bgColor.ansi256[i] = Pu(a.ansi256, 10)), "rgb" in a && (e.color.ansi16m[i] = Eu(a.rgb, 0),
      e.bgColor.ansi16m[i] = Eu(a.rgb, 10));
    }
    return e;
  }
  n(Rne, "assembleStyles");
  Object.defineProperty(mA, "exports", {
    enumerable: !0,
    get: Rne
  });
});

// ../node_modules/@babel/traverse/node_modules/has-flag/index.js
var bA = w((Ije, TA) => {
  "use strict";
  TA.exports = (t, e) => {
    e = e || process.argv;
    let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", s = e.indexOf(r + t), i = e.indexOf("--");
    return s !== -1 && (i === -1 ? !0 : s < i);
  };
});

// ../node_modules/@babel/traverse/node_modules/supports-color/index.js
var SA = w((wje, xA) => {
  "use strict";
  var Une = ds("os"), $r = bA(), sr = process.env, In;
  $r("no-color") || $r("no-colors") || $r("color=false") ? In = !1 : ($r("color") || $r("colors") || $r("color=true") || $r("color=always")) &&
  (In = !0);
  "FORCE_COLOR" in sr && (In = sr.FORCE_COLOR.length === 0 || parseInt(sr.FORCE_COLOR, 10) !== 0);
  function qne(t) {
    return t === 0 ? !1 : {
      level: t,
      hasBasic: !0,
      has256: t >= 2,
      has16m: t >= 3
    };
  }
  n(qne, "translateLevel");
  function Vne(t) {
    if (In === !1)
      return 0;
    if ($r("color=16m") || $r("color=full") || $r("color=truecolor"))
      return 3;
    if ($r("color=256"))
      return 2;
    if (t && !t.isTTY && In !== !0)
      return 0;
    let e = In ? 1 : 0;
    if (process.platform === "win32") {
      let r = Une.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in sr)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in sr) || sr.CI_NAME === "codeship" ? 1 : e;
    if ("TEAMCITY_VERSION" in sr)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(sr.TEAMCITY_VERSION) ? 1 : 0;
    if (sr.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in sr) {
      let r = parseInt((sr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (sr.TERM_PROGRAM) {
        case "iTerm.app":
          return r >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(sr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(sr.TERM) || "COLORTERM" in
    sr ? 1 : (sr.TERM === "dumb", e);
  }
  n(Vne, "supportsColor");
  function Bd(t) {
    let e = Vne(t);
    return qne(e);
  }
  n(Bd, "getSupportLevel");
  xA.exports = {
    supportsColor: Bd,
    stdout: Bd(process.stdout),
    stderr: Bd(process.stderr)
  };
});

// ../node_modules/@babel/traverse/node_modules/chalk/templates.js
var vA = w((Oje, AA) => {
  "use strict";
  var Kne = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  gA = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Wne = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Yne = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Jne = /* @__PURE__ */ new Map(
  [
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function EA(t) {
    return t[0] === "u" && t.length === 5 || t[0] === "x" && t.length === 3 ? String.fromCharCode(parseInt(t.slice(1), 16)) : Jne.get(t) || t;
  }
  n(EA, "unescape");
  function Xne(t, e) {
    let r = [], s = e.trim().split(/\s*,\s*/g), i;
    for (let a of s)
      if (!isNaN(a))
        r.push(Number(a));
      else if (i = a.match(Wne))
        r.push(i[2].replace(Yne, (o, l, u) => l ? EA(l) : u));
      else
        throw new Error(`Invalid Chalk template style argument: ${a} (in style '${t}')`);
    return r;
  }
  n(Xne, "parseArguments");
  function $ne(t) {
    gA.lastIndex = 0;
    let e = [], r;
    for (; (r = gA.exec(t)) !== null; ) {
      let s = r[1];
      if (r[2]) {
        let i = Xne(s, r[2]);
        e.push([s].concat(i));
      } else
        e.push([s]);
    }
    return e;
  }
  n($ne, "parseStyle");
  function PA(t, e) {
    let r = {};
    for (let i of e)
      for (let a of i.styles)
        r[a[0]] = i.inverse ? null : a.slice(1);
    let s = t;
    for (let i of Object.keys(r))
      if (Array.isArray(r[i])) {
        if (!(i in s))
          throw new Error(`Unknown Chalk style: ${i}`);
        r[i].length > 0 ? s = s[i].apply(s, r[i]) : s = s[i];
      }
    return s;
  }
  n(PA, "buildStyle");
  AA.exports = (t, e) => {
    let r = [], s = [], i = [];
    if (e.replace(Kne, (a, o, l, u, c, p) => {
      if (o)
        i.push(EA(o));
      else if (u) {
        let f = i.join("");
        i = [], s.push(r.length === 0 ? f : PA(t, r)(f)), r.push({ inverse: l, styles: $ne(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        s.push(PA(t, r)(i.join(""))), i = [], r.pop();
      } else
        i.push(p);
    }), s.push(i.join("")), r.length > 0) {
      let a = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(a);
    }
    return s.join("");
  };
});

// ../node_modules/@babel/traverse/node_modules/chalk/index.js
var OA = w((Dje, Ja) => {
  "use strict";
  var jd = _d(), qt = yA(), Fd = SA().stdout, Hne = vA(), IA = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith(
  "xterm"), wA = ["ansi", "ansi", "ansi256", "ansi16m"], NA = /* @__PURE__ */ new Set(["gray"]), wn = /* @__PURE__ */ Object.create(null);
  function CA(t, e) {
    e = e || {};
    let r = Fd ? Fd.level : 0;
    t.level = e.level === void 0 ? r : e.level, t.enabled = "enabled" in e ? e.enabled : t.level > 0;
  }
  n(CA, "applyOptions");
  function Ya(t) {
    if (!this || !(this instanceof Ya) || this.template) {
      let e = {};
      return CA(e, t), e.template = function() {
        let r = [].slice.call(arguments);
        return Qne.apply(null, [e.template].concat(r));
      }, Object.setPrototypeOf(e, Ya.prototype), Object.setPrototypeOf(e.template, e), e.template.constructor = Ya, e.template;
    }
    CA(this, t);
  }
  n(Ya, "Chalk");
  IA && (qt.blue.open = "\x1B[94m");
  for (let t of Object.keys(qt))
    qt[t].closeRe = new RegExp(jd(qt[t].close), "g"), wn[t] = {
      get() {
        let e = qt[t];
        return Au.call(this, this._styles ? this._styles.concat(e) : [e], this._empty, t);
      }
    };
  wn.visible = {
    get() {
      return Au.call(this, this._styles || [], !0, "visible");
    }
  };
  qt.color.closeRe = new RegExp(jd(qt.color.close), "g");
  for (let t of Object.keys(qt.color.ansi))
    NA.has(t) || (wn[t] = {
      get() {
        let e = this.level;
        return function() {
          let s = {
            open: qt.color[wA[e]][t].apply(null, arguments),
            close: qt.color.close,
            closeRe: qt.color.closeRe
          };
          return Au.call(this, this._styles ? this._styles.concat(s) : [s], this._empty, t);
        };
      }
    });
  qt.bgColor.closeRe = new RegExp(jd(qt.bgColor.close), "g");
  for (let t of Object.keys(qt.bgColor.ansi)) {
    if (NA.has(t))
      continue;
    let e = "bg" + t[0].toUpperCase() + t.slice(1);
    wn[e] = {
      get() {
        let r = this.level;
        return function() {
          let i = {
            open: qt.bgColor[wA[r]][t].apply(null, arguments),
            close: qt.bgColor.close,
            closeRe: qt.bgColor.closeRe
          };
          return Au.call(this, this._styles ? this._styles.concat(i) : [i], this._empty, t);
        };
      }
    };
  }
  var zne = Object.defineProperties(() => {
  }, wn);
  function Au(t, e, r) {
    let s = /* @__PURE__ */ n(function() {
      return Gne.apply(s, arguments);
    }, "builder");
    s._styles = t, s._empty = e;
    let i = this;
    return Object.defineProperty(s, "level", {
      enumerable: !0,
      get() {
        return i.level;
      },
      set(a) {
        i.level = a;
      }
    }), Object.defineProperty(s, "enabled", {
      enumerable: !0,
      get() {
        return i.enabled;
      },
      set(a) {
        i.enabled = a;
      }
    }), s.hasGrey = this.hasGrey || r === "gray" || r === "grey", s.__proto__ = zne, s;
  }
  n(Au, "build");
  function Gne() {
    let t = arguments, e = t.length, r = String(arguments[0]);
    if (e === 0)
      return "";
    if (e > 1)
      for (let i = 1; i < e; i++)
        r += " " + t[i];
    if (!this.enabled || this.level <= 0 || !r)
      return this._empty ? "" : r;
    let s = qt.dim.open;
    IA && this.hasGrey && (qt.dim.open = "");
    for (let i of this._styles.slice().reverse())
      r = i.open + r.replace(i.closeRe, i.open) + i.close, r = r.replace(/\r?\n/g, `${i.close}$&${i.open}`);
    return qt.dim.open = s, r;
  }
  n(Gne, "applyStyle");
  function Qne(t, e) {
    if (!Array.isArray(e))
      return [].slice.call(arguments, 1).join(" ");
    let r = [].slice.call(arguments, 2), s = [e.raw[0]];
    for (let i = 1; i < e.length; i++)
      s.push(String(r[i - 1]).replace(/[{}\\]/g, "\\$&")), s.push(String(e.raw[i]));
    return Hne(t, s.join(""));
  }
  n(Qne, "chalkTag");
  Object.defineProperties(Ya.prototype, wn);
  Ja.exports = Ya();
  Ja.exports.supportsColor = Fd;
  Ja.exports.default = Ja.exports;
});

// ../node_modules/@babel/traverse/node_modules/@babel/code-frame/node_modules/@babel/highlight/lib/index.js
var jA = w((Xa) => {
  "use strict";
  Object.defineProperty(Xa, "__esModule", {
    value: !0
  });
  Xa.default = aae;
  Xa.shouldHighlight = FA;
  var kA = Id(), DA = Ka(), Ud = Zne(Wa(), !0);
  function LA(t) {
    if (typeof WeakMap != "function") return null;
    var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (LA = /* @__PURE__ */ n(function(s) {
      return s ? r : e;
    }, "_getRequireWildcardCache"))(t);
  }
  n(LA, "_getRequireWildcardCache");
  function Zne(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
    var r = LA(e);
    if (r && r.has(t)) return r.get(t);
    var s = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t) if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(t, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = t[a];
    }
    return s.default = t, r && r.set(t, s), s;
  }
  n(Zne, "_interopRequireWildcard");
  var MA = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Ud.createColors)(!1) :
  Ud.default, _A = /* @__PURE__ */ n((t, e) => (r) => t(e(r)), "compose"), eae = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of",
  "set"]);
  function tae(t) {
    return {
      keyword: t.cyan,
      capitalized: t.yellow,
      jsxIdentifier: t.yellow,
      punctuator: t.yellow,
      number: t.magenta,
      string: t.green,
      regex: t.magenta,
      comment: t.gray,
      invalid: _A(_A(t.white, t.bgRed), t.bold)
    };
  }
  n(tae, "getDefs");
  var rae = /\r\n|[\n\r\u2028\u2029]/, sae = /^[()[\]{}]$/, BA;
  {
    let t = /^[a-z][\w-]*$/i, e = /* @__PURE__ */ n(function(r, s, i) {
      if (r.type === "name") {
        if ((0, DA.isKeyword)(r.value) || (0, DA.isStrictReservedWord)(r.value, !0) || eae.has(r.value))
          return "keyword";
        if (t.test(r.value) && (i[s - 1] === "<" || i.slice(s - 2, s) == "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && sae.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punc\
tuator" : r.type;
    }, "getTokenType");
    BA = /* @__PURE__ */ n(function* (r) {
      let s;
      for (; s = kA.default.exec(r); ) {
        let i = kA.matchToToken(s);
        yield {
          type: e(i, s.index, r),
          value: i.value
        };
      }
    }, "tokenize");
  }
  function iae(t, e) {
    let r = "";
    for (let {
      type: s,
      value: i
    } of BA(e)) {
      let a = t[s];
      a ? r += i.split(rae).map((o) => a(o)).join(`
`) : r += i;
    }
    return r;
  }
  n(iae, "highlightTokens");
  function FA(t) {
    return MA.isColorSupported || t.forceColor;
  }
  n(FA, "shouldHighlight");
  var Rd;
  function nae(t) {
    if (t) {
      var e;
      return (e = Rd) != null || (Rd = (0, Ud.createColors)(!0)), Rd;
    }
    return MA;
  }
  n(nae, "getColors");
  function aae(t, e = {}) {
    if (t !== "" && FA(e)) {
      let r = tae(nae(e.forceColor));
      return iae(r, t);
    } else
      return t;
  }
  n(aae, "highlight");
  {
    let t, e;
    Xa.getChalk = ({
      forceColor: r
    }) => {
      var s;
      if ((s = t) != null || (t = OA()), r) {
        var i;
        return (i = e) != null || (e = new t.constructor({
          enabled: !0,
          level: 1
        })), e;
      }
      return t;
    };
  }
});

// ../node_modules/@babel/traverse/node_modules/@babel/code-frame/lib/index.js
var YA = w((vu) => {
  "use strict";
  Object.defineProperty(vu, "__esModule", {
    value: !0
  });
  vu.codeFrameColumns = WA;
  vu.default = fae;
  var RA = jA(), Vd = oae(Wa(), !0);
  function KA(t) {
    if (typeof WeakMap != "function") return null;
    var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (KA = /* @__PURE__ */ n(function(s) {
      return s ? r : e;
    }, "_getRequireWildcardCache"))(t);
  }
  n(KA, "_getRequireWildcardCache");
  function oae(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
    var r = KA(e);
    if (r && r.has(t)) return r.get(t);
    var s = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t) if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(t, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = t[a];
    }
    return s.default = t, r && r.set(t, s), s;
  }
  n(oae, "_interopRequireWildcard");
  var lae = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, Vd.createColors)(!1) :
  Vd.default, UA = /* @__PURE__ */ n((t, e) => (r) => t(e(r)), "compose"), qd;
  function uae(t) {
    if (t) {
      var e;
      return (e = qd) != null || (qd = (0, Vd.createColors)(!0)), qd;
    }
    return lae;
  }
  n(uae, "getColors");
  var qA = !1;
  function cae(t) {
    return {
      gutter: t.gray,
      marker: UA(t.red, t.bold),
      message: UA(t.red, t.bold)
    };
  }
  n(cae, "getDefs");
  var VA = /\r\n|[\n\r\u2028\u2029]/;
  function pae(t, e, r) {
    let s = Object.assign({
      column: 0,
      line: -1
    }, t.start), i = Object.assign({}, s, t.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = s.line, u = s.column, c = i.line, p = i.column, f = Math.max(l - (a + 1), 0), m = Math.min(e.length, c + o);
    l === -1 && (f = 0), c === -1 && (m = e.length);
    let y = c - l, T = {};
    if (y)
      for (let L = 0; L <= y; L++) {
        let q = L + l;
        if (!u)
          T[q] = !0;
        else if (L === 0) {
          let _ = e[q - 1].length;
          T[q] = [u, _ - u + 1];
        } else if (L === y)
          T[q] = [0, p];
        else {
          let _ = e[q - L].length;
          T[q] = [0, _];
        }
      }
    else
      u === p ? u ? T[l] = [u, 0] : T[l] = !0 : T[l] = [u, p - u];
    return {
      start: f,
      end: m,
      markerLines: T
    };
  }
  n(pae, "getMarkerLines");
  function WA(t, e, r = {}) {
    let s = (r.highlightCode || r.forceColor) && (0, RA.shouldHighlight)(r), i = uae(r.forceColor), a = cae(i), o = /* @__PURE__ */ n((L, q) => s ?
    L(q) : q, "maybeHighlight"), l = t.split(VA), {
      start: u,
      end: c,
      markerLines: p
    } = pae(e, l, r), f = e.start && typeof e.start.column == "number", m = String(c).length, T = (s ? (0, RA.default)(t, r) : t).split(VA, c).
    slice(u, c).map((L, q) => {
      let _ = u + 1 + q, J = ` ${` ${_}`.slice(-m)} |`, ie = p[_], de = !p[_ + 1];
      if (ie) {
        let ne = "";
        if (Array.isArray(ie)) {
          let Be = L.slice(0, Math.max(ie[0] - 1, 0)).replace(/[^\t]/g, " "), bt = ie[1] || 1;
          ne = [`
 `, o(a.gutter, J.replace(/\d/g, " ")), " ", Be, o(a.marker, "^").repeat(bt)].join(""), de && r.message && (ne += " " + o(a.message, r.message));
        }
        return [o(a.marker, ">"), o(a.gutter, J), L.length > 0 ? ` ${L}` : "", ne].join("");
      } else
        return ` ${o(a.gutter, J)}${L.length > 0 ? ` ${L}` : ""}`;
    }).join(`
`);
    return r.message && !f && (T = `${" ".repeat(m + 1)}${r.message}
${T}`), s ? i.reset(T) : T;
  }
  n(WA, "codeFrameColumns");
  function fae(t, e, r, s = {}) {
    if (!qA) {
      qA = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), WA(t, {
      start: {
        column: r,
        line: e
      }
    }, s);
  }
  n(fae, "_default");
});

// ../node_modules/@babel/traverse/node_modules/@babel/parser/lib/index.js
var v1 = w((io) => {
  "use strict";
  Object.defineProperty(io, "__esModule", {
    value: !0
  });
  function l1(t, e) {
    if (t == null) return {};
    var r = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r;
  }
  n(l1, "_objectWithoutPropertiesLoose");
  var os = class {
    static {
      n(this, "Position");
    }
    constructor(e, r, s) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = r, this.index = s;
    }
  }, Dn = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = r;
    }
  };
  function yr(t, e) {
    let {
      line: r,
      column: s,
      index: i
    } = t;
    return new os(r, s + e, i + e);
  }
  n(yr, "createPositionWithColumnOffset");
  var JA = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", hae = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: JA
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: JA
    }
  }, XA = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, wu = /* @__PURE__ */ n(({
    type: t,
    prefix: e
  }) => t === "UpdateExpression" ? XA.UpdateExpression[String(e)] : XA[t], "toNodeDescription"), dae = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ n(({
      maxArgumentCount: t
    }) => `\`import()\` requires exactly ${t === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${wu(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${wu(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${wu(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, mae = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, yae = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Tae = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${wu({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, bae = ["toMessage"], xae = ["message"];
  function $A(t, e, r) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  n($A, "defineHidden");
  function Sae(t) {
    let {
      toMessage: e
    } = t, r = l1(t, bae);
    return /* @__PURE__ */ n(function s(i, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: i,
        pos: i.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), $A(o, "clone", /* @__PURE__ */ n(function(u = {}) {
        var c;
        let {
          line: p,
          column: f,
          index: m
        } = (c = u.loc) != null ? c : i;
        return s(new os(p, f, m), Object.assign({}, a, u.details));
      }, "clone")), $A(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${e(a)} (${i.line}:${i.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  n(Sae, "toParseErrorConstructor");
  function Cs(t, e) {
    if (Array.isArray(t))
      return (s) => Cs(s, t[0]);
    let r = {};
    for (let s of Object.keys(t)) {
      let i = t[s], a = typeof i == "string" ? {
        message: /* @__PURE__ */ n(() => i, "message")
      } : typeof i == "function" ? {
        message: i
      } : i, {
        message: o
      } = a, l = l1(a, xae), u = typeof o == "string" ? () => o : o;
      r[s] = Sae(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: s,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return r;
  }
  n(Cs, "ParseErrorEnum");
  var F = Object.assign({}, Cs(hae), Cs(dae), Cs(mae), Cs`pipelineOperator`(Tae)), {
    defineProperty: gae
  } = Object, HA = /* @__PURE__ */ n((t, e) => gae(t, e, {
    enumerable: !1,
    value: t[e]
  }), "toUnenumerable");
  function $a(t) {
    return t.loc.start && HA(t.loc.start, "index"), t.loc.end && HA(t.loc.end, "index"), t;
  }
  n($a, "toESTreeLocation");
  var Pae = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let r = $a(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map($a)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: s
    }) {
      let i = null;
      try {
        i = new RegExp(r, s);
      } catch {
      }
      let a = this.estreeParseLiteral(i);
      return a.regex = {
        pattern: r,
        flags: s
      }, a;
    }
    parseBigIntLiteral(r) {
      let s;
      try {
        s = BigInt(r);
      } catch {
        s = null;
      }
      let i = this.estreeParseLiteral(s);
      return i.bigint = String(i.value || r), i;
    }
    parseDecimalLiteral(r) {
      let i = this.estreeParseLiteral(null);
      return i.decimal = String(i.value || r), i;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let s = r.value;
      delete r.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let i = r;
      return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
    }
    initFunction(r, s) {
      super.initFunction(r, s), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var s;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((s = r.expression.
      extra) != null && s.parenthesized);
    }
    parseBlockBody(r, s, i, a, o) {
      super.parseBlockBody(r, s, i, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, s, i, a, o, l) {
      this.parseMethod(s, i, a, o, l, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters),
      r.body.push(s);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let s = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = s, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, s) {
      let i = super.parseLiteral(r, s);
      return i.raw = i.extra.raw, delete i.extra, i;
    }
    parseFunctionBody(r, s, i = !1) {
      super.parseFunctionBody(r, s, i), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, s, i, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, s, i, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    parseClassProperty(...r) {
      let s = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
    }
    parseClassPrivateProperty(...r) {
      let s = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
    }
    parseObjectMethod(r, s, i, a, o) {
      let l = super.parseObjectMethod(r, s, i, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, s, i, a) {
      let o = super.parseObjectProperty(r, s, i, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, s, i) {
      return r === "Property" ? "value" : super.isValidLVal(r, s, i);
    }
    isAssignable(r, s) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: i,
          value: a
        } = r;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(r, s);
    }
    toAssignableObjectExpressionProp(r, s, i) {
      r.kind === "get" || r.kind === "set" ? this.raise(F.PatternHasAccessor, r.key) : r.method ? this.raise(F.PatternHasMethod, r.key) : super.
      toAssignableObjectExpressionProp(r, s, i);
    }
    finishCallExpression(r, s) {
      let i = super.finishCallExpression(r, s);
      if (i.callee.type === "Import") {
        if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          i.options = (a = i.arguments[1]) != null ? a : null, i.attributes = (o = i.arguments[1]) != null ? o : null;
        }
        delete i.arguments, delete i.callee;
      }
      return i;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, s) {
      let i = this.state.lastTokStartLoc, a = super.parseExport(r, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, i);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, s, i, a) {
      let o = super.parseSubscript(r, s, i, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.method || r.kind === "get" || r.kind === "set";
    }
    finishNodeAt(r, s, i) {
      return $a(super.finishNodeAt(r, s, i));
    }
    resetStartLocation(r, s) {
      super.resetStartLocation(r, s), $a(r);
    }
    resetEndLocation(r, s = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, s), $a(r);
    }
  }, "estree"), Wi = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!r;
    }
  }, St = {
    brace: new Wi("{"),
    j_oTag: new Wi("<tag"),
    j_cTag: new Wi("</tag"),
    j_expr: new Wi("<tag>...</tag>", !0)
  };
  St.template = new Wi("`", !0);
  var We = !0, ae = !0, Kd = !0, Ha = !0, ri = !0, Eae = !0, Du = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, dm = /* @__PURE__ */ new Map();
  function Ze(t, e = {}) {
    e.keyword = t;
    let r = Ee(t, e);
    return dm.set(t, r), r;
  }
  n(Ze, "createKeyword");
  function mr(t, e) {
    return Ee(t, {
      beforeExpr: We,
      binop: e
    });
  }
  n(mr, "createBinop");
  var Za = -1, As = [], mm = [], ym = [], Tm = [], bm = [], xm = [];
  function Ee(t, e = {}) {
    var r, s, i, a;
    return ++Za, mm.push(t), ym.push((r = e.binop) != null ? r : -1), Tm.push((s = e.beforeExpr) != null ? s : !1), bm.push((i = e.startsExpr) !=
    null ? i : !1), xm.push((a = e.prefix) != null ? a : !1), As.push(new Du(t, e)), Za;
  }
  n(Ee, "createToken");
  function Ke(t, e = {}) {
    var r, s, i, a;
    return ++Za, dm.set(t, Za), mm.push(t), ym.push((r = e.binop) != null ? r : -1), Tm.push((s = e.beforeExpr) != null ? s : !1), bm.push((i =
    e.startsExpr) != null ? i : !1), xm.push((a = e.prefix) != null ? a : !1), As.push(new Du("name", e)), Za;
  }
  n(Ke, "createKeywordLike");
  var Aae = {
    bracketL: Ee("[", {
      beforeExpr: We,
      startsExpr: ae
    }),
    bracketHashL: Ee("#[", {
      beforeExpr: We,
      startsExpr: ae
    }),
    bracketBarL: Ee("[|", {
      beforeExpr: We,
      startsExpr: ae
    }),
    bracketR: Ee("]"),
    bracketBarR: Ee("|]"),
    braceL: Ee("{", {
      beforeExpr: We,
      startsExpr: ae
    }),
    braceBarL: Ee("{|", {
      beforeExpr: We,
      startsExpr: ae
    }),
    braceHashL: Ee("#{", {
      beforeExpr: We,
      startsExpr: ae
    }),
    braceR: Ee("}"),
    braceBarR: Ee("|}"),
    parenL: Ee("(", {
      beforeExpr: We,
      startsExpr: ae
    }),
    parenR: Ee(")"),
    comma: Ee(",", {
      beforeExpr: We
    }),
    semi: Ee(";", {
      beforeExpr: We
    }),
    colon: Ee(":", {
      beforeExpr: We
    }),
    doubleColon: Ee("::", {
      beforeExpr: We
    }),
    dot: Ee("."),
    question: Ee("?", {
      beforeExpr: We
    }),
    questionDot: Ee("?."),
    arrow: Ee("=>", {
      beforeExpr: We
    }),
    template: Ee("template"),
    ellipsis: Ee("...", {
      beforeExpr: We
    }),
    backQuote: Ee("`", {
      startsExpr: ae
    }),
    dollarBraceL: Ee("${", {
      beforeExpr: We,
      startsExpr: ae
    }),
    templateTail: Ee("...`", {
      startsExpr: ae
    }),
    templateNonTail: Ee("...${", {
      beforeExpr: We,
      startsExpr: ae
    }),
    at: Ee("@"),
    hash: Ee("#", {
      startsExpr: ae
    }),
    interpreterDirective: Ee("#!..."),
    eq: Ee("=", {
      beforeExpr: We,
      isAssign: Ha
    }),
    assign: Ee("_=", {
      beforeExpr: We,
      isAssign: Ha
    }),
    slashAssign: Ee("_=", {
      beforeExpr: We,
      isAssign: Ha
    }),
    xorAssign: Ee("_=", {
      beforeExpr: We,
      isAssign: Ha
    }),
    moduloAssign: Ee("_=", {
      beforeExpr: We,
      isAssign: Ha
    }),
    incDec: Ee("++/--", {
      prefix: ri,
      postfix: Eae,
      startsExpr: ae
    }),
    bang: Ee("!", {
      beforeExpr: We,
      prefix: ri,
      startsExpr: ae
    }),
    tilde: Ee("~", {
      beforeExpr: We,
      prefix: ri,
      startsExpr: ae
    }),
    doubleCaret: Ee("^^", {
      startsExpr: ae
    }),
    doubleAt: Ee("@@", {
      startsExpr: ae
    }),
    pipeline: mr("|>", 0),
    nullishCoalescing: mr("??", 1),
    logicalOR: mr("||", 1),
    logicalAND: mr("&&", 2),
    bitwiseOR: mr("|", 3),
    bitwiseXOR: mr("^", 4),
    bitwiseAND: mr("&", 5),
    equality: mr("==/!=/===/!==", 6),
    lt: mr("</>/<=/>=", 7),
    gt: mr("</>/<=/>=", 7),
    relational: mr("</>/<=/>=", 7),
    bitShift: mr("<</>>/>>>", 8),
    bitShiftL: mr("<</>>/>>>", 8),
    bitShiftR: mr("<</>>/>>>", 8),
    plusMin: Ee("+/-", {
      beforeExpr: We,
      binop: 9,
      prefix: ri,
      startsExpr: ae
    }),
    modulo: Ee("%", {
      binop: 10,
      startsExpr: ae
    }),
    star: Ee("*", {
      binop: 10
    }),
    slash: mr("/", 10),
    exponent: Ee("**", {
      beforeExpr: We,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Ze("in", {
      beforeExpr: We,
      binop: 7
    }),
    _instanceof: Ze("instanceof", {
      beforeExpr: We,
      binop: 7
    }),
    _break: Ze("break"),
    _case: Ze("case", {
      beforeExpr: We
    }),
    _catch: Ze("catch"),
    _continue: Ze("continue"),
    _debugger: Ze("debugger"),
    _default: Ze("default", {
      beforeExpr: We
    }),
    _else: Ze("else", {
      beforeExpr: We
    }),
    _finally: Ze("finally"),
    _function: Ze("function", {
      startsExpr: ae
    }),
    _if: Ze("if"),
    _return: Ze("return", {
      beforeExpr: We
    }),
    _switch: Ze("switch"),
    _throw: Ze("throw", {
      beforeExpr: We,
      prefix: ri,
      startsExpr: ae
    }),
    _try: Ze("try"),
    _var: Ze("var"),
    _const: Ze("const"),
    _with: Ze("with"),
    _new: Ze("new", {
      beforeExpr: We,
      startsExpr: ae
    }),
    _this: Ze("this", {
      startsExpr: ae
    }),
    _super: Ze("super", {
      startsExpr: ae
    }),
    _class: Ze("class", {
      startsExpr: ae
    }),
    _extends: Ze("extends", {
      beforeExpr: We
    }),
    _export: Ze("export"),
    _import: Ze("import", {
      startsExpr: ae
    }),
    _null: Ze("null", {
      startsExpr: ae
    }),
    _true: Ze("true", {
      startsExpr: ae
    }),
    _false: Ze("false", {
      startsExpr: ae
    }),
    _typeof: Ze("typeof", {
      beforeExpr: We,
      prefix: ri,
      startsExpr: ae
    }),
    _void: Ze("void", {
      beforeExpr: We,
      prefix: ri,
      startsExpr: ae
    }),
    _delete: Ze("delete", {
      beforeExpr: We,
      prefix: ri,
      startsExpr: ae
    }),
    _do: Ze("do", {
      isLoop: Kd,
      beforeExpr: We
    }),
    _for: Ze("for", {
      isLoop: Kd
    }),
    _while: Ze("while", {
      isLoop: Kd
    }),
    _as: Ke("as", {
      startsExpr: ae
    }),
    _assert: Ke("assert", {
      startsExpr: ae
    }),
    _async: Ke("async", {
      startsExpr: ae
    }),
    _await: Ke("await", {
      startsExpr: ae
    }),
    _defer: Ke("defer", {
      startsExpr: ae
    }),
    _from: Ke("from", {
      startsExpr: ae
    }),
    _get: Ke("get", {
      startsExpr: ae
    }),
    _let: Ke("let", {
      startsExpr: ae
    }),
    _meta: Ke("meta", {
      startsExpr: ae
    }),
    _of: Ke("of", {
      startsExpr: ae
    }),
    _sent: Ke("sent", {
      startsExpr: ae
    }),
    _set: Ke("set", {
      startsExpr: ae
    }),
    _source: Ke("source", {
      startsExpr: ae
    }),
    _static: Ke("static", {
      startsExpr: ae
    }),
    _using: Ke("using", {
      startsExpr: ae
    }),
    _yield: Ke("yield", {
      startsExpr: ae
    }),
    _asserts: Ke("asserts", {
      startsExpr: ae
    }),
    _checks: Ke("checks", {
      startsExpr: ae
    }),
    _exports: Ke("exports", {
      startsExpr: ae
    }),
    _global: Ke("global", {
      startsExpr: ae
    }),
    _implements: Ke("implements", {
      startsExpr: ae
    }),
    _intrinsic: Ke("intrinsic", {
      startsExpr: ae
    }),
    _infer: Ke("infer", {
      startsExpr: ae
    }),
    _is: Ke("is", {
      startsExpr: ae
    }),
    _mixins: Ke("mixins", {
      startsExpr: ae
    }),
    _proto: Ke("proto", {
      startsExpr: ae
    }),
    _require: Ke("require", {
      startsExpr: ae
    }),
    _satisfies: Ke("satisfies", {
      startsExpr: ae
    }),
    _keyof: Ke("keyof", {
      startsExpr: ae
    }),
    _readonly: Ke("readonly", {
      startsExpr: ae
    }),
    _unique: Ke("unique", {
      startsExpr: ae
    }),
    _abstract: Ke("abstract", {
      startsExpr: ae
    }),
    _declare: Ke("declare", {
      startsExpr: ae
    }),
    _enum: Ke("enum", {
      startsExpr: ae
    }),
    _module: Ke("module", {
      startsExpr: ae
    }),
    _namespace: Ke("namespace", {
      startsExpr: ae
    }),
    _interface: Ke("interface", {
      startsExpr: ae
    }),
    _type: Ke("type", {
      startsExpr: ae
    }),
    _opaque: Ke("opaque", {
      startsExpr: ae
    }),
    name: Ee("name", {
      startsExpr: ae
    }),
    string: Ee("string", {
      startsExpr: ae
    }),
    num: Ee("num", {
      startsExpr: ae
    }),
    bigint: Ee("bigint", {
      startsExpr: ae
    }),
    decimal: Ee("decimal", {
      startsExpr: ae
    }),
    regexp: Ee("regexp", {
      startsExpr: ae
    }),
    privateName: Ee("#name", {
      startsExpr: ae
    }),
    eof: Ee("eof"),
    jsxName: Ee("jsxName"),
    jsxText: Ee("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Ee("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Ee("jsxTagEnd"),
    placeholder: Ee("%%", {
      startsExpr: !0
    })
  };
  function ft(t) {
    return t >= 93 && t <= 132;
  }
  n(ft, "tokenIsIdentifier");
  function vae(t) {
    return t <= 92;
  }
  n(vae, "tokenKeywordOrIdentifierIsKeyword");
  function Hr(t) {
    return t >= 58 && t <= 132;
  }
  n(Hr, "tokenIsKeywordOrIdentifier");
  function u1(t) {
    return t >= 58 && t <= 136;
  }
  n(u1, "tokenIsLiteralPropertyName");
  function Cae(t) {
    return Tm[t];
  }
  n(Cae, "tokenComesBeforeExpression");
  function $d(t) {
    return bm[t];
  }
  n($d, "tokenCanStartExpression");
  function Iae(t) {
    return t >= 29 && t <= 33;
  }
  n(Iae, "tokenIsAssignment");
  function zA(t) {
    return t >= 129 && t <= 131;
  }
  n(zA, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function wae(t) {
    return t >= 90 && t <= 92;
  }
  n(wae, "tokenIsLoop");
  function Sm(t) {
    return t >= 58 && t <= 92;
  }
  n(Sm, "tokenIsKeyword");
  function Nae(t) {
    return t >= 39 && t <= 59;
  }
  n(Nae, "tokenIsOperator");
  function Oae(t) {
    return t === 34;
  }
  n(Oae, "tokenIsPostfix");
  function kae(t) {
    return xm[t];
  }
  n(kae, "tokenIsPrefix");
  function Dae(t) {
    return t >= 121 && t <= 123;
  }
  n(Dae, "tokenIsTSTypeOperator");
  function _ae(t) {
    return t >= 124 && t <= 130;
  }
  n(_ae, "tokenIsTSDeclarationStart");
  function ni(t) {
    return mm[t];
  }
  n(ni, "tokenLabelName");
  function Nu(t) {
    return ym[t];
  }
  n(Nu, "tokenOperatorPrecedence");
  function Lae(t) {
    return t === 57;
  }
  n(Lae, "tokenIsRightAssociative");
  function _u(t) {
    return t >= 24 && t <= 25;
  }
  n(_u, "tokenIsTemplate");
  function Es(t) {
    return As[t];
  }
  n(Es, "getExportedToken");
  As[8].updateContext = (t) => {
    t.pop();
  }, As[5].updateContext = As[7].updateContext = As[23].updateContext = (t) => {
    t.push(St.brace);
  }, As[22].updateContext = (t) => {
    t[t.length - 1] === St.template ? t.pop() : t.push(St.template);
  }, As[142].updateContext = (t) => {
    t.push(St.j_expr, St.j_oTag);
  };
  var gm = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  c1 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", Mae = new RegExp("[" + gm + "]"), Bae = new RegExp("[" + gm + c1 + "\
]");
  gm = c1 = null;
  var p1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Fae = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Hd(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(Hd, "isInAstralSet");
  function vs(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && Mae.test(String.fromCharCode(t)) :
    Hd(t, p1);
  }
  n(vs, "isIdentifierStart");
  function On(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && Bae.test(
    String.fromCharCode(t)) : Hd(t, p1) || Hd(t, Fae);
  }
  n(On, "isIdentifierChar");
  var Pm = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, jae = new Set(Pm.keyword), Rae = new Set(Pm.strict), Uae = new Set(Pm.strictBind);
  function f1(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(f1, "isReservedWord");
  function h1(t, e) {
    return f1(t, e) || Rae.has(t);
  }
  n(h1, "isStrictReservedWord");
  function d1(t) {
    return Uae.has(t);
  }
  n(d1, "isStrictBindOnlyReservedWord");
  function m1(t, e) {
    return h1(t, e) || d1(t);
  }
  n(m1, "isStrictBindReservedWord");
  function qae(t) {
    return jae.has(t);
  }
  n(qae, "isKeyword");
  function Vae(t, e, r) {
    return t === 64 && e === 64 && vs(r);
  }
  n(Vae, "isIteratorStart");
  var Kae = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Wae(t) {
    return Kae.has(t);
  }
  n(Wae, "canBeReservedWord");
  var to = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, ro = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new to(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(i, e, r, s);
        let a = i.names.get(e) || 0;
        r & 16 ? a = a | 4 : (i.firstLexicalName || (i.firstLexicalName = e), a = a | 2), i.names.set(e, a), r & 8 && this.maybeExportDefined(
        i, e);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (i = this.scopeStack[a], this.checkRedeclarationInScope(i, e, r, s), i.names.set(
        e, (i.names.get(e) || 0) | 1), this.maybeExportDefined(i, e), !(i.flags & 387)); --a)
          ;
      this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(e, r, s, i) {
      this.isRedeclaredInScope(e, r, s) && this.parser.raise(F.VarRedeclaration, i, {
        identifierName: r
      });
    }
    isRedeclaredInScope(e, r, s) {
      if (!(s & 1)) return !1;
      if (s & 8)
        return e.names.has(r);
      let i = e.names.get(r);
      return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (i & 1) > 0 : (i & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(e) && (i & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, zd = class extends to {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, Gd = class extends ro {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new zd(e);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(e, r, s);
    }
    isRedeclaredInScope(e, r, s) {
      if (super.isRedeclaredInScope(e, r, s)) return !0;
      if (s & 2048 && !e.declareFunctions.has(r)) {
        let i = e.names.get(r);
        return (i & 4) > 0 || (i & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, Qd = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [r, s] = e;
        if (!this.hasPlugin(r))
          return !1;
        let i = this.plugins.get(r);
        for (let a of Object.keys(s))
          if (i?.[a] !== s[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, r) {
      var s;
      return (s = this.plugins.get(e)) == null ? void 0 : s[r];
    }
  };
  function y1(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(y1, "setTrailingComments");
  function Yae(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(Yae, "setLeadingComments");
  function so(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(so, "setInnerComments");
  function za(t, e, r) {
    let s = null, i = e.length;
    for (; s === null && i > 0; )
      s = e[--i];
    s === null || s.start > r.start ? so(t, r.comments) : y1(s, r.comments);
  }
  n(za, "adjustInnerComments");
  var Zd = class extends Qd {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length != r && (this.comments.length = r), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: r
      } = this.state, s = r.length;
      if (s === 0) return;
      let i = s - 1, a = r[i];
      a.start === e.end && (a.leadingNode = e, i--);
      let {
        start: o
      } = e;
      for (; i >= 0; i--) {
        let l = r[i], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), r.splice(i, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: r
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && y1(e.leadingNode, r), e.trailingNode !== null && Yae(e.trailingNode, r);
      else {
        let {
          containingNode: s,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (s.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              za(s, s.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              za(s, s.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              za(s, s.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              za(s, s.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              za(s, s.specifiers, e);
              break;
            default:
              so(s, r);
          }
        else
          so(s, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let r = e.length - 1; r >= 0; r--)
        this.finalizeComment(e[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      if (s === 0) return;
      let i = r[s - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      s !== 0 && (r[s - 1].trailingNode === e ? r[s - 1].trailingNode = null : s >= 2 && r[s - 2].trailingNode === e && (r[s - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, r, s) {
      let {
        commentStack: i
      } = this.state, a = i.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = i[o], u = l.end;
        if (l.start === s)
          l.leadingNode = e;
        else if (u === r)
          l.trailingNode = e;
        else if (u < r)
          break;
      }
    }
  }, T1 = /\r\n?|[\n\u2028\u2029]/, Cu = new RegExp(T1.source, "g");
  function eo(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(eo, "isNewLine");
  var Wd = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ou = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, GA = new RegExp("(?=(" + Ou.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Jae(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(Jae, "isWhitespace");
  var em = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [St.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: r,
      startLine: s,
      startColumn: i
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : r === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new os(
      s, i, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new os(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.startLoc, e.endLoc = this.endLoc,
      e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.slice(), e.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.slice(), e.commentsLen = this.commentsLen,
      e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value = this.value, e.start = this.start, e.end = this.
      end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.context = this.context.slice(), e.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors, e.tokensLength = this.tokensLength, e;
    }
  }, Xae = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), QA = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Iu = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function ZA(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if ($ae(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = Hae(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(ZA, "readStringContents");
  function $ae(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n($ae, "isStringEnd");
  function Hae(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = tm(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = x1(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(Hae, "readEscapedChar");
  function tm(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = b1(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(tm, "readHexChar");
  function b1(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? QA.hex : QA.decBinOct, m = i === 16 ? Iu.hex : i === 10 ? Iu.dec : i === 8 ? Iu.oct : Iu.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : Xae(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(b1, "readInt");
  function x1(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = tm(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = tm(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(x1, "readCodePoint");
  function Ga(t, e, r) {
    return new os(r, t - e, t);
  }
  n(Ga, "buildPosition");
  var zae = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), as = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new Dn(e.startLoc, e.endLoc);
    }
  }, rm = class extends Zd {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((s, i, a, o) => this.options.errorRecovery ? (this.raise(F.InvalidDigit, Ga(s, i, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(F.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(F.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(F.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(F.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((s, i, a) => {
          this.recordStrictModeErrors(F.StrictNumericEscape, Ga(s, i, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(F.UnterminatedString, Ga(s - 1, i, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(F.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(F.UnterminatedTemplate, Ga(s, i, a));
        }, "unterminated")
      }), this.state = new em(), this.state.init(e), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new as(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = e, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return Wd.lastIndex = e, Wd.test(this.input) ? Wd.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Ou.lastIndex = e, Ou.test(this.input) ? Ou.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e);
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        let s = this.input.charCodeAt(e);
        (s & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (s & 1023));
      }
      return r;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([r, s]) => this.raise(r, s)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let s = this.state.pos, i = this.input.indexOf(e, s + 2);
      if (i === -1)
        throw this.raise(F.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = i + e.length, Cu.lastIndex = s + 2; Cu.test(this.input) && Cu.lastIndex <= i; )
        ++this.state.curLine, this.state.lineStart = Cu.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(s + 2, i),
        start: s,
        end: i + e.length,
        loc: new Dn(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let r = this.state.pos, s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !eo(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + e, a),
        start: r,
        end: a,
        loc: new Dn(s, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let i = this.skipBlockComment("*/");
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              case 47: {
                let i = this.skipLineComment(2);
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Jae(s))
              ++this.state.pos;
            else if (s === 45 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (s === 60 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let s = this.state.pos, i = {
          start: e,
          end: s,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s = this.state.type;
      this.state.type = e, this.state.value = r, this.isLookahead || this.updateContext(s);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, r = this.codePointAtPos(e);
      if (r >= 48 && r <= 57)
        throw this.raise(F.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? F.RecordExpressionHashIncorrectStartSyntaxType : F.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else vs(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !eo(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let s = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, s), !0;
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), r = 57), i === 61 && !this.state.inType && (s++, r = e ===
      37 ? 33 : 30), this.finishOp(r, s);
    }
    readToken_pipe_amp(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(F.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(F.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 62) {
        let s = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + s) === 61) {
          this.finishOp(30, s + 1);
          return;
        }
        this.finishOp(52, s);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(F.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(F.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (vs(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(F.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, r) {
      let s = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(e, s);
    }
    readRegexp() {
      let e = this.state.startLoc, r = this.state.start + 1, s, i, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(F.UnterminatedRegExp, yr(e, 1));
        let c = this.input.charCodeAt(a);
        if (eo(c))
          throw this.raise(F.UnterminatedRegExp, yr(e, 1));
        if (s)
          s = !1;
        else {
          if (c === 91)
            i = !0;
          else if (c === 93 && i)
            i = !1;
          else if (c === 47 && !i)
            break;
          s = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => yr(e, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (zae.has(c))
          c === 118 ? l.includes("u") && this.raise(F.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(F.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(F.DuplicateRegExpFlags, u());
        else if (On(c) || c === 92)
          this.raise(F.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, r, s = !1, i = !0) {
      let {
        n: a,
        pos: o
      } = b1(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, r, s, i, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let r = this.state.curPosition(), s = !1;
      this.state.pos += 2;
      let i = this.readInt(e);
      i == null && this.raise(F.InvalidDigit, yr(r, 2), {
        radix: e
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, s = !0;
      else if (a === 109)
        throw this.raise(F.InvalidDecimal, r);
      if (vs(this.codePointAtPos(this.state.pos)))
        throw this.raise(F.NumberIdentifier, this.state.curPosition());
      if (s) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, i);
    }
    readNumber(e) {
      let r = this.state.pos, s = this.state.curPosition(), i = !1, a = !1, o = !1, l = !1, u = !1;
      !e && this.readInt(10) === null && this.raise(F.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let y = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(F.StrictOctalLiteral, s), !this.state.strict) {
          let T = y.indexOf("_");
          T > 0 && this.raise(F.ZeroDigitNumericSeparator, yr(s, T));
        }
        u = c && !/[89]/.test(y);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !u && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      F.InvalidOrMissingExponent, s), i = !0, l = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((i || c) && this.raise(F.InvalidBigIntLiteral,
      s), ++this.state.pos, a = !0), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(F.InvalidDecimal,
      s), ++this.state.pos, o = !0), vs(this.codePointAtPos(this.state.pos)))
        throw this.raise(F.NumberIdentifier, this.state.curPosition());
      let f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, f);
        return;
      }
      if (o) {
        this.finishToken(136, f);
        return;
      }
      let m = u ? parseInt(f, 8) : parseFloat(f);
      this.finishToken(134, m);
    }
    readCodePoint(e) {
      let {
        code: r,
        pos: s
      } = x1(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = s, r;
    }
    readString(e) {
      let {
        str: r,
        pos: s,
        curLine: i,
        lineStart: a
      } = ZA(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: s,
        pos: i,
        curLine: a,
        lineStart: o
      } = ZA("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = i + 1, this.state.lineStart = o, this.state.curLine = a, s && (this.state.firstInvalidTemplateEscapePos = new os(s.curLine,
      s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : e + r + "`") : (this.state.pos++, this.
      finishToken(25, s ? null : e + r + "${"));
    }
    recordStrictModeErrors(e, r) {
      let s = r.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(e, r) : this.state.strictErrors.set(s, [e, r]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let r = "", s = this.state.pos, i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (On(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(i, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === s ? vs : On;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(F.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(F.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), i = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      let r = this.readWord1(e), s = dm.get(r);
      s !== void 0 ? this.finishToken(s, ni(s)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      Sm(e) && this.state.containsEsc && this.raise(F.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: ni(e)
      });
    }
    raise(e, r, s = {}) {
      let i = r instanceof os ? r : r.loc.start, a = e(i, s);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, r, s = {}) {
      let i = r instanceof os ? r : r.loc.start, a = i.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(i, s);
        if (u.loc.index < a) break;
      }
      return this.raise(e, r, s);
    }
    updateContext(e) {
    }
    unexpected(e, r) {
      throw this.raise(F.UnexpectedToken, e ?? this.state.startLoc, {
        expected: r ? ni(r) : null
      });
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(F.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(F.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (r, s, i) => {
        this.raise(e, Ga(r, s, i));
      };
    }
  }, sm = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, im = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new sm());
    }
    exit() {
      let e = this.stack.pop(), r = this.current();
      for (let [s, i] of Array.from(e.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(s) || r.undefinedPrivateNames.set(s, i) : this.parser.raise(F.InvalidPrivateFieldResolution, i, {
          identifierName: s
        });
    }
    declarePrivateName(e, r, s) {
      let {
        privateNames: i,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = i.has(e);
      if (r & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = r & 4, f = u & 3, m = r & 3;
          l = f === m || c !== p, l || a.delete(e);
        } else l || a.set(e, r);
      }
      l && this.parser.raise(F.PrivateNameRedeclaration, s, {
        identifierName: e
      }), i.add(e), o.delete(e);
    }
    usePrivateName(e, r) {
      let s;
      for (s of this.stack)
        if (s.privateNames.has(e)) return;
      s ? s.undefinedPrivateNames.set(e, r) : this.parser.raise(F.InvalidPrivateFieldResolution, r, {
        identifierName: e
      });
    }
  }, _n = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Lu = class extends _n {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, r) {
      let s = r.index;
      this.declarationErrors.set(s, [e, r]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, nm = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new _n()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, r) {
      let s = r.loc.start, {
        stack: i
      } = this, a = i.length - 1, o = i[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, s);
        else
          return;
        o = i[--a];
      }
      this.parser.raise(e, s);
    }
    recordArrowParameterBindingError(e, r) {
      let {
        stack: s
      } = this, i = s[s.length - 1], a = r.loc.start;
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: r
      } = this, s = r.length - 1, i = r[s];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === 2 && i.recordDeclarationError(F.AwaitBindingIdentifier, e), i = r[--s];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, r = e[e.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([s, i]) => {
        this.parser.raise(s, i);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(i.index), o = e[--a];
      });
    }
  };
  function Gae() {
    return new _n(3);
  }
  n(Gae, "newParameterDeclarationScope");
  function Qae() {
    return new Lu(1);
  }
  n(Qae, "newArrowHeadScope");
  function Zae() {
    return new Lu(2);
  }
  n(Zae, "newAsyncArrowScope");
  function S1() {
    return new _n();
  }
  n(S1, "newExpressionScope");
  var am = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function ku(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(ku, "functionFlags");
  var om = class extends rm {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, r, s, i = !0) {
      if (!e) return;
      let a = e.extra = e.extra || {};
      i ? a[r] = s : Object.defineProperty(a, r, {
        enumerable: i,
        value: s
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, r) {
      let s = e + r.length;
      if (this.input.slice(e, s) === r) {
        let i = this.input.charCodeAt(s);
        return !(On(i) || (i & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return T1.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return GA.lastIndex = this.state.end, GA.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(F.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e);
    }
    tryParse(e, r = this.state.clone()) {
      let s = {
        node: null
      };
      try {
        let i = e((a = null) => {
          throw s.node = a, s;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: i,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: i,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (i) {
        let a = this.state;
        if (this.state = r, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (i === s)
          return {
            node: s.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw i;
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: s,
        doubleProtoLoc: i,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!s || !!i || !!o || !!a;
      if (!r)
        return l;
      s != null && this.raise(F.InvalidCoverInitializedName, s), i != null && this.raise(F.DuplicateProto, i), a != null && this.raise(F.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return u1(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let s = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let i = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new am();
      let u = this.classScope;
      this.classScope = new im(this);
      let c = this.expressionScope;
      return this.expressionScope = new nm(this), () => {
        this.state.labels = r, this.exportedIdentifiers = s, this.inModule = i, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: r
      } = e;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, kn = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Ln = class {
    static {
      n(this, "Node");
    }
    constructor(e, r, s) {
      this.type = "", this.start = r, this.end = 0, this.loc = new Dn(s), e != null && e.options.ranges && (this.range = [r, 0]), e != null &&
      e.filename && (this.loc.filename = e.filename);
    }
  }, Em = Ln.prototype;
  Em.__clone = function() {
    let t = new Ln(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let r = 0, s = e.length; r < s; r++) {
      let i = e[r];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
    }
    return t;
  };
  function eoe(t) {
    return Is(t);
  }
  n(eoe, "clonePlaceholder");
  function Is(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(Em);
    return u.type = e, u.start = r, u.end = s, u.loc = i, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(Is, "cloneIdentifier");
  function toe(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return eoe(t);
    let l = Object.create(Em);
    return l.type = e, l.start = r, l.end = s, l.loc = i, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(toe, "cloneStringLiteral");
  var lm = class extends om {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new Ln(this, e.index, e);
    }
    startNodeAt(e) {
      return new Ln(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, r, s) {
      return e.type = r, e.end = s.index, e.loc.end = s, this.options.ranges && (e.range[1] = s.index), this.options.attachComment && this.processComment(
      e), e;
    }
    resetStartLocation(e, r) {
      e.start = r.index, e.loc.start = r, this.options.ranges && (e.range[0] = r.index);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index);
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.loc.start);
    }
  }, roe = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), Ne = Cs`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: r
    }) => `Enum \`${t}\` has type \`${r}\`, so the initializer of \`${e}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${r}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function soe(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(soe, "isEsModuleType");
  function e1(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n(e1, "hasTypeImportKind");
  var ioe = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function noe(t, e) {
    let r = [], s = [];
    for (let i = 0; i < t.length; i++)
      (e(t[i], i, t) ? r : s).push(t[i]);
    return [r, s];
  }
  n(noe, "partition");
  var aoe = /\*?\s*@((?:no)?flow)\b/, ooe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Gd;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, s) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, s);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let s = aoe.exec(r.value);
        if (s) if (s[1] === "flow")
          this.flowPragma = "flow";
        else if (s[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let i = this.flowParseType();
      return this.state.inType = s, i;
    }
    flowParsePredicate() {
      let r = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(Ne.UnexpectedSpaceBetweenModuloChecks,
      s), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let s = null, i = null;
      return this.match(54) ? (this.state.inType = r, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = r, this.
      match(54) && (i = this.flowParsePredicate())), [s, i];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let s = r.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
      this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return i.params = o.params, i.rest = o.rest, i.this = o._this, this.expect(11), [i.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      s), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (s && this.raise(Ne.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, s);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let s = r.body = this.startNode(), i = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Ne.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, Ne.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), i.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, o = !1;
      return i.forEach((l) => {
        soe(l) ? (a === "CommonJS" && this.raise(Ne.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(Ne.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(Ne.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
        let i = this.state.value;
        throw this.raise(Ne.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: i,
          suggestion: ioe[i]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let s = this.flowParseTypeAlias(r);
      return s.type = "DeclareTypeAlias", s;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let s = this.flowParseOpaqueType(r, !0);
      return s.type = "DeclareOpaqueType", s;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, s) {
      if (r.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(r.id.name, s ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: s,
        allowExact: !1,
        allowSpread: !1,
        allowProto: s,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(Ne.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, s, i) {
      roe.has(r) && this.raise(i ? Ne.AssignReservedType : Ne.UnexpectedReservedType, s, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, s) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, s || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return i.name = o.name, i.variance = a, i.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) :
      r && this.raise(Ne.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = !1;
      do {
        let a = this.flowParseTypeParameter(i);
        s.params.push(a), a.default && (i = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), s = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), s = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, s, i) {
      return r.static = s, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = i, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, s) {
      return r.static = s, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, s) {
      let i = this.startNode();
      return r.static = s, r.value = this.flowParseObjectTypeMethodish(i), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: s,
      allowSpread: i,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, f = !1;
      for (s && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let y = !1, T = null, L = null, q = this.startNode();
        if (a && this.isContextual(118)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), T = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), y = !0);
        }
        let _ = this.flowParseVariance();
        if (this.eat(0))
          T != null && this.unexpected(T), this.eat(0) ? (_ && this.unexpected(_.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          q, y))) : u.indexers.push(this.flowParseObjectTypeIndexer(q, y, _));
        else if (this.match(10) || this.match(47))
          T != null && this.unexpected(T), _ && this.unexpected(_.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(q, y));
        else {
          let U = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let ie = this.lookahead();
            u1(ie.type) && (U = this.state.value, this.next());
          }
          let J = this.flowParseObjectTypeProperty(q, y, T, _, U, i, o ?? !p);
          J === null ? (f = !0, L = this.state.lastTokStartLoc) : u.properties.push(J);
        }
        this.flowObjectTypeSemicolon(), L && !this.match(8) && !this.match(9) && this.raise(Ne.UnexpectedExplicitInexactInObject, L);
      }
      this.expect(c), i && (u.inexact = f);
      let m = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, m;
    }
    flowParseObjectTypeProperty(r, s, i, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(Ne.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(Ne.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(Ne.InexactVariance, a), null) : (l || this.raise(
        Ne.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), a && this.raise(Ne.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = s, r.proto = i != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(Ne.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let s = r.kind === "get" ? 0 : 1, i = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? Ne.GetterMayNotHaveThisParam : Ne.SetterMayNotHaveThisParam, r.value.this), i !== s && this.
      raise(r.kind === "get" ? F.BadGetterArity : F.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(F.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, s) {
      var i;
      (i = r) != null || (r = this.state.startLoc);
      let a = s || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, s) {
      let i = this.startNodeAt(r);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(r, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let s = null, i = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(Ne.ThisParamMustBeFirst, o), s = this.parseIdentifier(u), this.eat(17) &&
      (i = !0, u && this.raise(Ne.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = s,
      o.optional = i, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let s = this.startNodeAt(r.loc.start);
      return s.name = null, s.optional = !1, s.typeAnnotation = r, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let s = null, i = null;
      for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: s,
        _this: i
      };
    }
    flowIdentToTypeAnnotation(r, s, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(r, i);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, s = this.startNode(), i, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47:
          return s.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), s.params =
          i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), this.finishNode(
          s, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (ft(this.state.type) || this.match(78)) {
              let u = this.lookahead().type;
              o = u !== 17 && u !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(),
          s.params = i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), s.typeParameters =
          null, this.finishNode(s, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(Ne.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Sm(this.state.type)) {
            let u = ni(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (ft(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, s = this.flowParsePrimaryType(), i = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        i = i || o, this.expect(0), !o && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = o, s = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(r.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(r)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.
        typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [s]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? s : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (r.types = [s]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? s : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let s = this.flowParseUnionType();
      return this.state.inType = r, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(r, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let s = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, s, i = !1) {
      if (s) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, i));
        return;
      }
      super.parseFunctionBody(r, !1, i);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, s, i);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let i = this.lookahead();
        if (Hr(i.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      let s = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(r, s, i) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || ft(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ft(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(r);
          if (s.name === "type")
            return this.flowParseTypeAlias(r);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return zA(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return zA(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, s, i) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let m = this.lookaheadCharCode();
        if (m === 44 || m === 61 || m === 58 || m === 41)
          return this.setOptionalParametersError(i), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(s), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, f] = this.getArrowLikeExpressions(u);
      if (c || f.length > 0) {
        let m = [...o];
        if (f.length > 0) {
          this.state = a, this.state.noArrowAt = m;
          for (let y = 0; y < f.length; y++)
            m.push(f[y].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, f] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(Ne.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, m.push(p[0].start),
        this.state.noArrowAt = m, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: s
      };
    }
    getArrowLikeExpressions(r, s) {
      let i = [r], a = [];
      for (; i.length !== 0; ) {
        let o = i.pop();
        o.type === "ArrowFunctionExpression" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(o) : a.push(o), i.push(o.body)) :
        o.type === "ConditionalExpression" && (i.push(o.consequent), i.push(o.alternate));
      }
      return s ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : noe(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var s;
      this.toAssignableList(r.params, (s = r.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, s) {
      let i;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i =
      s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
    }
    parseParenItem(r, s) {
      if (r = super.parseParenItem(r, s), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let i = this.startNodeAt(s);
        return i.expression = r, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
      }
      return r;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        s);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: s
      } = this.state, i = super.maybeParseExportNamespaceSpecifier(r);
      return i && r.exportKind === "type" && this.unexpected(s), i;
    }
    parseClassId(r, s, i) {
      super.parseClassId(r, s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, s, i) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, s))
          return;
        s.declare = !0;
      }
      super.parseClassMember(r, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "Property\
Definition" ? this.raise(Ne.DeclareClassElement, a) : s.value && this.raise(Ne.DeclareClassFieldInitializer, s.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), s = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(F.InvalidIdentifier, this.state.curPosition(), {
        identifierName: s
      }), this.finishToken(132, s);
    }
    getTokenFromCode(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Vae(r, s, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, s) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      !s && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, s);
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    toReferencedList(r, s) {
      for (let a = 0; a < r.length; a++) {
        var i;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((i = o.extra) != null && i.parenthesized) && (r.length > 1 || !s) && this.raise(Ne.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return s && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, s, i) {
      return r === "TypeCastExpression" || super.isValidLVal(r, s, i);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, s, i, a, o, l), s.params && o) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ne.ThisParamBannedInConstructor, s);
      } else if (s.type === "MethodDefinition" && o && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Ne.ThisParamBannedInConstructor, s);
      }
    }
    pushClassPrivateMethod(r, s, i, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, s, i, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let s = r.implements = [];
        do {
          let i = this.startNode();
          i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.
          typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let s = this.getObjectOrClassMethodParams(r);
      if (s.length > 0) {
        let i = s[0];
        this.isThisParam(i) && r.kind === "get" ? this.raise(Ne.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(Ne.SetterMayNotHaveThisParam,
        i);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, s, i, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(Ne.PatternIsOptional, r), this.isThisParam(r) && this.raise(Ne.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(Ne.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(Ne.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Ne.TypeBeforeInitializer,
      i.typeAnnotation), i;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Ne.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, s, i) {
      s.local = e1(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(s,
      i));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let s = this.lookaheadCharCode();
        return s === 123 || s === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      if (super.applyImportPhase(r, s, i, a), s) {
        if (!i && this.match(65))
          return;
        r.exportKind = i === "type" ? i : "value";
      } else
        i === "type" && this.match(55) && this.unexpected(), r.importKind = i === "type" || i === "typeof" ? i : "value";
    }
    parseImportSpecifier(r, s, i, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let f = this.parseIdentifier(!0);
        u !== null && !Hr(this.state.type) ? (r.imported = f, r.importKind = u, r.local = Is(f)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && Hr(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (s)
            throw this.raise(F.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = Is(r.imported));
      }
      let p = e1(r);
      return i && p && this.raise(Ne.ImportTypeShorthandOnlyInPureImport, r), (i || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !i && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, s) {
      let i = r.kind;
      i !== "get" && i !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      if (this.match(14)) {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
      }
      return super.parseAsyncArrowFromCallExpression(r, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, s) {
      var i;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, s), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === St.j_oTag || p === St.j_expr) && c.pop();
      }
      if ((i = o) != null && i.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((m) => {
          var y;
          c = this.flowParseTypeParameterDeclaration();
          let T = this.forwardNoArrowParamsConversionAt(c, () => {
            let q = super.parseMaybeAssign(r, s);
            return this.resetStartLocationFromNode(q, c), q;
          });
          (y = T.extra) != null && y.parenthesized && m();
          let L = this.maybeUnwrapTypeCastExpression(T);
          return L.type !== "ArrowFunctionExpression" && m(), L.typeParameters = c, this.resetStartLocationFromNode(L, c), T;
        }, a), f = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(Ne.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          f = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (f)
          return this.state = p.failState, f;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(Ne.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let i = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown) return null;
        s.error && (this.state = s.failState), r.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, s) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = s : super.setArrowFunctionParameters(r, s);
    }
    checkParams(r, s, i, a = !0) {
      if (!(i && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(Ne.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, s, i, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, s, i) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, s, i), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, s, i);
    }
    parseSubscript(r, s, i, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, i)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(s);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(s);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      s;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let s = this.startNodeAt(r);
      if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, s) {
      let i = super.parseTopLevel(r, s);
      return this.state.hasFlowComment && this.raise(Ne.UnterminatedFlowComment, this.state.curPosition()), i;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Ne.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + s)); )
        s++;
      let i = this.input.charCodeAt(s + r), a = this.input.charCodeAt(s + r + 1);
      return i === 58 && a === 58 ? s + 2 : this.input.slice(s + r, s + r + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(F.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: s,
      memberName: i
    }) {
      this.raise(Ne.EnumBooleanMemberNotInitialized, r, {
        memberName: i,
        enumName: s
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? Ne.EnumInvalidMemberInitializerSymbolType : Ne.EnumInvalidMemberInitializerPrimaryType :
      Ne.EnumInvalidMemberInitializerUnknownType, r, s);
    }
    flowEnumErrorNumberMemberNotInitialized(r, s) {
      this.raise(Ne.EnumNumberMemberNotInitialized, r, s);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, s) {
      this.raise(Ne.EnumStringMemberInconsistentlyInitialized, r, s);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, s = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let i = this.parseNumericLiteral(this.state.value);
          return s() ? {
            type: "number",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let i = this.parseStringLiteral(this.state.value);
          return s() ? {
            type: "string",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let i = this.parseBooleanLiteral(this.match(85));
          return s() ? {
            type: "boolean",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, s = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: s,
        init: i
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, s, i) {
      let {
        explicitType: a
      } = s;
      a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(r, s);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: s
    }) {
      let i = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(Ne.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), i.has(p) && this.raise(Ne.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), i.add(p);
        let f = {
          enumName: r,
          explicitType: s,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, f);
          case "none":
            switch (s) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, f);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, f);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, s, {
      enumName: i
    }) {
      if (r.length === 0)
        return s;
      if (s.length === 0)
        return r;
      if (s.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return s;
      } else {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ft(this.state.type))
        throw this.raise(Ne.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: s
      } = this.state;
      return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(Ne.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: s
      }), s;
    }
    flowEnumBody(r, s) {
      let i = s.name, a = s.loc.start, o = this.flowEnumParseExplicitType({
        enumName: i
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: i,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, f = l.numberMembers.length, m = l.stringMembers.length, y = l.defaultedMembers.length;
          if (!p && !f && !m && !y)
            return c();
          if (!p && !f)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: i
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!f && !m && p >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !m && f >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(Ne.EnumInconsistentMemberValues, a, {
              enumName: i
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let s = this.parseIdentifier();
      return r.id = s, r.body = this.flowEnumBody(this.startNode(), s), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let s = this.input.charCodeAt(r + 1);
        return s !== 60 && s !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), loe = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Ki = Cs`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function si(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(si, "isFragment");
  function Nn(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Nn(t.object) + "." + Nn(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(Nn, "getQualifiedJSXName");
  var uoe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Ki.UnterminatedJsxContent, this.state.startLoc);
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
              return;
            }
            r += this.input.slice(s, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(s, this.state.pos), r += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            eo(i) ? (r += this.input.slice(s, this.state.pos), r += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let s = this.input.charCodeAt(this.state.pos), i;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = r ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
    }
    jsxReadString(r) {
      let s = "", i = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(F.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : eo(a) ? (s += this.input.slice(
        i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let i = this.readInt(s, void 0, !1, "bail");
        if (i !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(i);
      } else {
        let s = 0, i = !1;
        for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (i) {
          let a = this.input.slice(r, this.state.pos), o = loe[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, s = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (On(r) || r === 45);
      this.finishToken(140, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : Sm(this.state.type) ? r.name = ni(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14)) return s;
      let i = this.startNodeAt(r);
      return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let i = this.startNodeAt(r);
        i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(St.brace), this.next(), r = this.jsxParseExpressionContainer(r, St.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Ki.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Ki.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(St.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, s) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let i = this.parseExpression();
        r.expression = i;
      }
      return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(St.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      St.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      s));
    }
    jsxParseOpeningElementAfterName(r) {
      let s = [];
      for (; !this.match(56) && !this.match(143); )
        s.push(this.jsxParseAttribute());
      return r.attributes = s, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      s, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let s = this.startNodeAt(r), i = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              i.push(this.jsxParseElementAt(r));
              break;
            case 141:
              i.push(this.parseExprAtom());
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(St.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(l)) : i.push(this.jsxParseExpressionContainer(
              l, St.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        si(a) && !si(o) && o !== null ? this.raise(Ki.MissingClosingTagFragment, o) : !si(a) && si(o) ? this.raise(Ki.MissingClosingTagElement,
        o, {
          openingTagName: Nn(a.name)
        }) : !si(a) && !si(o) && Nn(o.name) !== Nn(a.name) && this.raise(Ki.MissingClosingTagElement, o, {
          openingTagName: Nn(a.name)
        });
      }
      if (si(a) ? (s.openingFragment = a, s.closingFragment = o) : (s.openingElement = a, s.closingElement = o), s.children = i, this.match(
      47))
        throw this.raise(Ki.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return si(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: s
      } = this.state;
      s[s.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) &&
      this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let s = this.curContext();
      if (s === St.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === St.j_oTag || s === St.j_cTag) {
        if (vs(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && s === St.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: s,
        type: i
      } = this.state;
      if (i === 56 && r === 142)
        s.splice(-2, 2, St.j_cTag), this.state.canStartJSXElement = !1;
      else if (i === 142)
        s.push(St.j_oTag);
      else if (i === 143) {
        let a = s[s.length - 1];
        a === St.j_oTag && r === 56 || a === St.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === St.j_expr) : (this.setContext(
        St.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = Cae(i);
    }
  }, "jsx"), um = class extends to {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, cm = class extends ro {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new um(e);
    }
    enter(e) {
      e == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e == 256 && this.importsStack.pop(), e;
    }
    hasImport(e, r) {
      let s = this.importsStack.length;
      if (this.importsStack[s - 1].has(e))
        return !0;
      if (!r && s > 1) {
        for (let i = 0; i < s - 1; i++)
          if (this.importsStack[i].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, r, s) {
      if (r & 4096) {
        this.hasImport(e, !0) && this.parser.raise(F.VarRedeclaration, s, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let i = this.currentScope(), a = i.tsNames.get(e) || 0;
      if (r & 1024) {
        this.maybeExportDefined(i, e), i.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, r, s), r & 2 && (r & 1 || (this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && i.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, r, s) {
      let i = e.tsNames.get(r);
      if ((i & 2) > 0) {
        if (s & 256) {
          let a = !!(s & 512), o = (i & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return s & 128 && (i & 8) > 0 ? e.names.get(r) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(e, r, s);
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      if (this.hasImport(r)) return;
      let s = this.scopeStack.length;
      for (let i = s - 1; i >= 0; i--) {
        let o = this.scopeStack[i].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, coe = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn$1"), g1 = /* @__PURE__ */ n((t) => t.type === "Parenthesiz\
edExpression" ? g1(t.expression) : t, "unwrapParenthesizedExpression"), pm = class extends lm {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, r = !1) {
      var s, i;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (s = e.extra) != null && s.parenthesized) && (a = g1(e), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(F.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(F.InvalidParenthesizedAssignment, e) : this.raise(F.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], f = l === c;
            this.toAssignableObjectExpressionProp(p, f, r), f && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(F.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(F.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, r, s) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? F.PatternHasAccessor : F.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let i = e.argument;
        this.checkToRestConversion(i, !1), this.toAssignable(i, s), r || this.raise(F.RestTrailingComma, e);
      } else
        this.toAssignable(e, s);
    }
    toAssignableList(e, r, s) {
      let i = e.length - 1;
      for (let a = 0; a <= i; a++) {
        let o = e[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, s);
          } else
            this.toAssignable(o, s);
          o.type === "RestElement" && (a < i ? this.raise(F.RestTrailingComma, o) : r && this.raise(F.RestTrailingComma, r));
        }
      }
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let s = e.properties.length - 1;
          return e.properties.every((i, a) => i.type !== "ObjectMethod" && (a === s || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((s) => s === null || this.isAssignable(s));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(e, r) {
      return e;
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r);
      for (let s of e)
        s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
    }
    parseSpread(e) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, r, s) {
      let i = s & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), i && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(r)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(F.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(s, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let e = this.startNode(), {
        type: r,
        startLoc: s
      } = this.state;
      return r === 21 ? this.parseBindingRestProperty(e) : (r === 138 ? (this.expectPlugin("destructuringPrivate", s), this.classScope.usePrivateName(
      this.state.value, s), e.key = this.parsePrivateName()) : this.parsePropertyName(e), e.method = !1, this.parseObjPropValue(e, s, !1, !1,
      !0, !1));
    }
    parseAssignableListItem(e, r) {
      let s = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s, e);
      let i = this.parseMaybeDefault(s.loc.start, s);
      return r.length && (s.decorators = r), i;
    }
    parseAssignableListItemTypes(e, r) {
      return e;
    }
    parseMaybeDefault(e, r) {
      var s, i;
      if ((s = e) != null || (e = this.state.startLoc), r = (i = r) != null ? i : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(e);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(e, r, s) {
      return coe({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, {
      in: r,
      binding: s = 64,
      checkClashes: i = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), r.type !== "AssignmentExpression" && this.raise(F.InvalidLhsOptionalChaining,
        e, {
          ancestor: r
        })), s !== 64 && this.raise(F.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, s, a);
        let {
          name: T
        } = e;
        i && (i.has(T) ? this.raise(F.ParamDupe, e) : i.add(T));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", s);
      if (p === !0) return;
      if (p === !1) {
        let T = s === 64 ? F.InvalidLhs : F.InvalidLhsBinding;
        this.raise(T, e, {
          ancestor: r
        });
        return;
      }
      let [f, m] = Array.isArray(p) ? p : [p, u === "ParenthesizedExpression"], y = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let T of [].concat(e[f]))
        T && this.checkLVal(T, {
          in: y,
          binding: s,
          checkClashes: i,
          strictModeChanged: a,
          hasParenthesizedAncestor: m
        });
    }
    checkIdentifier(e, r, s = !1) {
      this.state.strict && (s ? m1(e.name, this.inModule) : d1(e.name)) && (r === 64 ? this.raise(F.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(F.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), r & 8192 && e.name === "let" && this.raise(F.LetInLexicalBinding, e), r & 64 || this.declareNameFromIdentifier(e, r);
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start);
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(F.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? F.RestTrailingComma : F.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, poe = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn");
  function foe(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(foe, "nonNull");
  function t1(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(t1, "assert");
  var me = Cs`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function hoe(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(hoe, "keywordTypeFromName");
  function r1(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(r1, "tsIsAccessModifier");
  function doe(t) {
    return t === "in" || t === "out";
  }
  n(doe, "tsIsVarianceAnnotations");
  var moe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: me.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: me.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: me.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return cm;
    }
    tsIsIdentifier() {
      return ft(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, s) {
      if (!ft(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let i = this.state.value;
      if (r.indexOf(i) !== -1) {
        if (s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return i;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: s,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: a = me.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, f, m) => {
        p === f && o[m] && this.raise(me.InvalidModifiersOrder, c, {
          orderedModifiers: [f, m]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, f, m) => {
        (o[f] && p === m || o[m] && p === f) && this.raise(me.IncompatibleModifiers, c, {
          modifiers: [f, m]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(s ?? []), i);
        if (!p) break;
        r1(p) ? o.accessibility ? this.raise(me.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : doe(p) ? (o[p] && this.raise(me.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(me.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), s != null && s.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, s) {
      let i = [];
      for (; !this.tsIsListTerminator(r); )
        i.push(s());
      return i;
    }
    tsParseDelimitedList(r, s, i) {
      return foe(this.tsParseDelimitedListWorker(r, s, !0, i));
    }
    tsParseDelimitedListWorker(r, s, i, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = s();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        i && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, s, i, a, o) {
      a || (i ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, s, o);
      return i ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(me.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let s = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let i = this.startNodeAtNode(s);
        i.left = s, i.right = this.parseIdentifier(r), s = this.finishNode(i, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let s = this.startNodeAtNode(r);
      return s.parameterName = r, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let s = this.startNode();
      return r(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(
      29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let s = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = {
        value: -1
      };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, i), s.params.
      length === 0 && this.raise(me.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, s) {
      let i = r === 19, a = "parameters", o = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(),
      i ? s[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (s[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let s of r) {
        let {
          type: i
        } = s;
        (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(me.UnsupportedSignatureParameterKind, s, {
          type: i
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ft(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), r.parameters = [s];
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, s) {
      this.eat(17) && (r.optional = !0);
      let i = r;
      if (this.match(10) || this.match(47)) {
        s && this.raise(me.ReadonlyForMethodSignature, r);
        let a = i;
        a.kind && this.match(47) && this.raise(me.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(F.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(me.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(F.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(me.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(me.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            me.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(me.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = i;
        s && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let i = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let s = this.tsTryParseIndexSignature(r);
      return s || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let s = !1;
      return r.elementTypes.forEach((i) => {
        let {
          type: a
        } = i;
        s && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && i.optional) && this.raise(me.OptionalTypeBeforeRequired,
        i), s || (s = a === "TSNamedTupleMember" && i.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, s = this.eat(21), i, a, o, l, c = Hr(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        i = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let p = this.state.startLoc, f = this.state.value, m = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (i = !0, a = this.createIdentifier(this.startNodeAt(p), f), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (i = !1, l = m, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), i = this.eat(14);
      if (i) {
        let p;
        a ? (p = this.startNodeAtNode(a), p.optional = o, p.label = a, p.elementType = l, this.eat(17) && (p.optional = !0, this.raise(me.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (p = this.startNodeAtNode(l), p.optional = o, this.raise(me.InvalidTupleMemberLabel, l), p.label = l,
        p.elementType = this.tsParseType()), l = this.finishNode(p, "TSNamedTupleMember");
      } else if (o) {
        let p = this.startNodeAtNode(l);
        p.typeAnnotation = l, l = this.finishNode(p, "TSOptionalType");
      }
      if (s) {
        let p = this.startNodeAt(r);
        p.typeAnnotation = l, l = this.finishNode(p, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, s) {
      let i = this.startNode();
      return r === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, i)), this.finishNode(i, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), s = this.lookahead();
            return s.type !== 134 && s.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ft(r) || r === 88 || r === 84) {
            let s = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : hoe(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let i = this.startNode();
              return this.next(), this.finishNode(i, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAtNode(r);
          s.elementType = r, this.expect(3), r = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAtNode(r);
          s.objectType = r, s.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(s, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), s = this.state.value;
      return this.next(), r.operator = s, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(me.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(s, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Dae(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, s, i) {
      let a = this.startNode(), o = this.eat(i), l = [];
      do
        l.push(s());
      while (this.eat(i));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ft(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === s;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === s;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(r);
        let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i,
          "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
        let l = this.tsParseTypeAnnotation(!1);
        return i.parameterName = o, i.typeAnnotation = l, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(
        s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ft(this.state.type) && !this.match(78) ? !1 : (r && this.raise(F.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, s = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      t1(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let s = this.startNodeAtNode(r);
      return s.checkType = r, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(me.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return i.length || this.raise(me.EmptyHeritageClauseType, s, {
        token: r
      }), i;
    }
    tsParseInterfaceDeclaration(r, s = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), s.declare && (r.declare = !0), ft(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(me.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let i = this.startNode();
      return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return r();
      } finally {
        this.state.context = s;
      }
    }
    tsInType(r) {
      let s = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, s = {}) {
      return s.const && (r.const = !0), s.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, s = !1) {
      if (r.id = this.parseIdentifier(), s || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let i = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(i, !0), r.body = i;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, s, i) {
      r.isExport = i || !1, r.id = s || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(me.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let s = this.state.clone(), i = r();
      return this.state = s, i;
    }
    tsTryParseAndCatch(r) {
      let s = this.tryParse((i) => r() || i());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(r) {
      let s = this.state.clone(), i = r();
      if (i !== void 0 && i !== !1)
        return i;
      this.state = s;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type, i;
      return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
        switch (s) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, i || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (ft(s))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, s, i) {
      switch (s.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, s.name, !1, i);
      }
    }
    tsParseDeclaration(r, s, i, a) {
      switch (s) {
        case "abstract":
          if (this.tsCheckLineTerminator(i) && (this.match(80) || ft(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(i)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ft(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(i) && ft(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(i) && ft(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let i = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!i)
        return super.parseArrowExpression(i, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(me.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      St.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return _ae(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, s) {
      let i = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(me.UnexpectedParameterModifier, i);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let f = this.startNodeAt(i);
        return s.length && (f.decorators = s), o && (f.accessibility = o), u && (f.readonly = u), l && (f.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(me.UnsupportedParameterPropertyKind, f), f.parameter = p, this.finishNode(f, "TSParamet\
erProperty");
      }
      return s.length && (c.decorators = s), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let s of r.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(me.PatternIsOptional, s);
    }
    setArrowFunctionParameters(r, s, i) {
      super.setArrowFunctionParameters(r, s, i), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(me.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, i) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, s, i));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((s) => {
        s?.type === "TSTypeCastExpression" && this.raise(me.UnexpectedTypeAnnotation, s.typeAnnotation);
      });
    }
    toReferencedList(r, s) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, s, i, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(s);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(r)) {
            let m = this.tsTryParseGenericAsyncArrowFunction(s);
            if (m)
              return m;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (_u(this.state.type)) {
            let m = super.parseTaggedTemplateExpression(r, s, a);
            return m.typeParameters = c, m;
          }
          if (!i && this.eat(10)) {
            let m = this.startNodeAt(s);
            return m.callee = r, m.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(m.arguments), m.typeParameters =
            c, a.optionalChainMember && (m.optional = o), this.finishCallExpression(m, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && $d(p) && !this.hasPrecedingLineBreak())
            return;
          let f = this.startNodeAt(s);
          return f.expression = r, f.typeParameters = c, this.finishNode(f, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          me.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      var s;
      super.parseNewCallee(r);
      let {
        callee: i
      } = r;
      i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (r.typeParameters = i.typeParameters, r.callee =
      i.expression);
    }
    parseExprOp(r, s, i) {
      let a;
      if (Nu(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(s);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(F.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, s, i);
      }
      return super.parseExprOp(r, s, i);
    }
    checkReservedWord(r, s, i, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, s, i, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(me.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let s = this.lookaheadCharCode();
        return r ? s === 123 || s === 42 : s !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      super.applyImportPhase(r, s, i, a), s ? r.exportKind = i === "type" ? "type" : "value" : r.importKind = i === "type" || i === "typeof" ?
      i : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let s;
      if (ft(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let i = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, i);
        s = super.parseImportSpecifiersAndAfter(r, i);
      } else
        s = super.parseImport(r);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(me.TypeImportCannotSpecifyDefaultAndNamed,
      s), s;
    }
    parseExport(r, s) {
      if (this.match(83)) {
        this.next();
        let i = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? i = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.
        tsParseImportEqualsDeclaration(r, i, !0);
      } else if (this.eat(29)) {
        let i = r;
        return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let i = r;
        return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, s);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, s, i = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, s, i || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (s !== "const" || l.typeAnnotation ? this.raise(me.InitializerNotAllowedInAmbientContext, u) : Toe(u, this.hasPlugin("estree")) ||
        this.raise(me.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, s) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let i = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(i, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i) return i;
      }
      return super.parseStatementContent(r, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, s) {
      return s.some((i) => r1(i) ? r.accessibility === i : !!r[i]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, s, i) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: me.InvalidModifierOnTypeParameterPositions
      }, s);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(me.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, s)) : this.parseClassMemberWithIsStatic(r, s, i, !!s.static);
      }, "callParseClassMemberWithIsStatic");
      s.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, s, i, a) {
      let o = this.tsTryParseIndexSignature(s);
      if (o) {
        r.body.push(o), s.abstract && this.raise(me.IndexSignatureHasAbstract, s), s.accessibility && this.raise(me.IndexSignatureHasAccessibility,
        s, {
          modifier: s.accessibility
        }), s.declare && this.raise(me.IndexSignatureHasDeclare, s), s.override && this.raise(me.IndexSignatureHasOverride, s);
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(me.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.
      raise(me.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(r, s, i, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(me.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(me.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, s, i) {
      return (s.type === "Identifier" ? this.tsParseExpressionStatement(r, s, i) : void 0) || super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, s, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, s, i);
      let a = this.tryParse(() => super.parseConditional(r, s));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), r);
    }
    parseParenItem(r, s) {
      if (r = super.parseParenItem(r, s), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let i = this.startNodeAt(s);
        return i.expression = r, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let s = this.state.startLoc, i = this.eatContextual(125);
      if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(me.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ft(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || i) && (r.exportKind = "type"), i && (this.resetStartLocation(
      o, s), o.declare = !0), o) : null;
    }
    parseClassId(r, s, i, a) {
      if ((!s || i) && this.isContextual(113))
        return;
      super.parseClassId(r, s, i, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let s = this.tsTryParseTypeAnnotation();
      s && (r.typeAnnotation = s);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(me.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: s
        } = r;
        this.raise(me.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: s.type === "Identifier" && !r.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(me.PrivateElementHasAbstract, r), r.accessibility && this.raise(me.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(me.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(me.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = s;
      c && (p === "get" || p === "set") && this.raise(me.DeclareAccessor, s, {
        kind: p
      }), u && (s.typeParameters = u), super.pushClassMethod(r, s, i, a, o, l);
    }
    pushClassPrivateMethod(r, s, i, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (s.typeParameters = o), super.pushClassPrivateMethod(r, s, i, a);
    }
    declareClassPrivateMethodInScope(r, s) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !r.value.body || super.declareClassPrivateMethodInScope(r, s));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, s, i, a, o, l, u);
    }
    parseFunctionParams(r, s) {
      let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      i && (r.typeParameters = i), super.parseFunctionParams(r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let i = this.tsTryParseTypeAnnotation();
      i && (r.id.typeAnnotation = i, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, s);
    }
    parseMaybeAssign(r, s) {
      var i, a, o, l, u;
      let c, p, f;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, s), c), !p.error) return p.node;
        let {
          context: T
        } = this.state, L = T[T.length - 1];
        (L === St.j_oTag || L === St.j_expr) && T.pop();
      }
      if (!((i = p) != null && i.error) && !this.match(47))
        return super.parseMaybeAssign(r, s);
      (!c || c === this.state) && (c = this.state.clone());
      let m, y = this.tryParse((T) => {
        var L, q;
        m = this.tsParseTypeParameters(this.tsParseConstModifier);
        let _ = super.parseMaybeAssign(r, s);
        return (_.type !== "ArrowFunctionExpression" || (L = _.extra) != null && L.parenthesized) && T(), ((q = m) == null ? void 0 : q.params.
        length) !== 0 && this.resetStartLocationFromNode(_, m), _.typeParameters = m, _;
      }, c);
      if (!y.error && !y.aborted)
        return m && this.reportReservedArrowTypeParam(m), y.node;
      if (!p && (t1(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, s), c), !f.error))
        return f.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (y.node)
        return this.state = y.failState, m && this.reportReservedArrowTypeParam(m), y.node;
      if ((o = f) != null && o.node)
        return this.state = f.failState, f.node;
      throw ((l = p) == null ? void 0 : l.error) || y.error || ((u = f) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var s;
      r.params.length === 1 && !r.params[0].constraint && !((s = r.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(me.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse((i) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
        });
        if (s.aborted) return;
        s.thrown || (s.error && (this.state = s.failState), r.returnType = s.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, s) {
      if (!(s & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, s) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, s);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, s);
      }
    }
    toAssignable(r, s = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(me.UnexpectedTypeCastInParameter, r) : this.raise(me.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, s);
          break;
        case "AssignmentExpression":
          !s && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, s);
      }
    }
    toAssignableParenthesizedExpression(r, s) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, s);
          break;
        default:
          super.toAssignable(r, s);
      }
    }
    checkToRestConversion(r, s) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, s);
      }
    }
    isValidLVal(r, s, i) {
      return poe({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSAsExpression: (i !== 64 || !s) && ["expression", !0],
        TSSatisfiesExpression: (i !== 64 || !s) && ["expression", !0],
        TSTypeAssertion: (i !== 64 || !s) && ["expression", !0]
      }, r) || super.isValidLVal(r, s, i);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let i = super.parseMaybeDecoratorArguments(r);
          return i.typeParameters = s, i;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(me.TypeAnnotationAfterAssign,
      i.typeAnnotation), i;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (r.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let s = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let s = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = s;
      }
    }
    parseClass(r, s, i) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, s, i);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, s) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(me.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, s, i, a, o, l, u) {
      let c = super.parseMethod(r, s, i, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: f
        } = c;
        this.raise(me.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, s, i, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, i), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, s, i, a));
    }
    parseImportSpecifier(r, s, i, a, o) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, i), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, s, i, a, i ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, s, i) {
      let a = s ? "imported" : "local", o = s ? "local" : "exported", l = r[a], u, c = !1, p = !0, f = l.loc.start;
      if (this.isContextual(93)) {
        let y = this.parseIdentifier();
        if (this.isContextual(93)) {
          let T = this.parseIdentifier();
          Hr(this.state.type) ? (c = !0, l = y, u = s ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = T, p = !1);
        } else Hr(this.state.type) ? (p = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = y);
      } else Hr(this.state.type) && (c = !0, s ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && i && this.raise(s ? me.TypeModifierIsUsedInTypeImports : me.TypeModifierIsUsedInTypeExports, f), r[a] = l, r[o] = u;
      let m = s ? "importKind" : "exportKind";
      r[m] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = s ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = Is(r[a])), s && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function yoe(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: r
    } = t;
    return e && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : E1(t.object);
  }
  n(yoe, "isPossiblyLiteralEnum");
  function Toe(t, e) {
    var r;
    let {
      type: s
    } = t;
    if ((r = t.extra) != null && r.parenthesized)
      return !1;
    if (e) {
      if (s === "Literal") {
        let {
          value: i
        } = t;
        if (typeof i == "string" || typeof i == "boolean")
          return !0;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return !0;
    return !!(P1(t, e) || boe(t, e) || s === "TemplateLiteral" && t.expressions.length === 0 || yoe(t));
  }
  n(Toe, "isValidAmbientConstInitializer");
  function P1(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(P1, "isNumber");
  function boe(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: r,
        argument: s
      } = t;
      if (r === "-" && P1(s, e))
        return !0;
    }
    return !1;
  }
  n(boe, "isNegativeNumber");
  function E1(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : E1(t.object);
  }
  n(E1, "isUncomputedMemberExpressionChain");
  var s1 = Cs`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), xoe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        s, r);
      }
    }
    finishPlaceholder(r, s) {
      let i = !!(r.expectedNode && r.type === "Placeholder");
      return r.expectedNode = s, i ? r : this.finishNode(r, "Placeholder");
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, s, i, a) {
      r !== void 0 && super.checkReservedWord(r, s, i, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, s, i) {
      return r === "Placeholder" || super.isValidLVal(r, s, i);
    }
    toAssignable(r, s) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, s);
    }
    chStartsBindingIdentifier(r, s) {
      return !!(super.chStartsBindingIdentifier(r, s) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, s) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, s);
    }
    parseExpressionStatement(r, s) {
      var i;
      if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized)
        return super.parseExpressionStatement(r, s);
      if (this.match(14)) {
        let a = r;
        return a.label = this.finishPlaceholder(s, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(a, "LabeledStatement");
      }
      return this.semicolon(), r.name = s.name, this.finishPlaceholder(r, "Statement");
    }
    parseBlock(r, s, i) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, s, i);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, s, i) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (i || !s)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(s1.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, s, i);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseExport(r, s);
      if (!this.isContextual(98) && !this.match(12))
        return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(r, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let a = this.startNode();
      return a.exported = i, r.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(r, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(ni(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, s) {
      var i;
      return (i = r.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(r, s);
    }
    checkExport(r) {
      let {
        specifiers: s
      } = r;
      s != null && s.length && (r.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = s;
    }
    parseImport(r) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let i = this.startNodeAtNode(s);
      return i.local = s, r.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(s1.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), Soe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, s = this.startNode();
        if (this.next(), ft(this.state.type)) {
          let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Vt(t, e) {
    let [r, s] = typeof e == "string" ? [e, {}] : e, i = Object.keys(s), a = i.length === 0;
    return t.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of i)
          if (u[c] !== s[c])
            return !1;
        return !0;
      }
    });
  }
  n(Vt, "hasPlugin");
  function ii(t, e, r) {
    let s = t.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return s && Array.isArray(s) && s.length > 1 ? s[1][r] : null;
  }
  n(ii, "getPluginOption");
  var i1 = ["minimal", "fsharp", "hack", "smart"], n1 = ["^^", "@@", "^", "%", "#"], a1 = ["hash", "bar"];
  function goe(t) {
    if (Vt(t, "decorators")) {
      if (Vt(t, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let e = ii(t, "decorators", "decoratorsBeforeExport");
      if (e != null && typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = ii(t, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Vt(t, "flow") && Vt(t, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Vt(t, "placeholders") && Vt(t, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Vt(t, "pipelineOperator")) {
      let e = ii(t, "pipelineOperator", "proposal");
      if (!i1.includes(e)) {
        let s = i1.map((i) => `"${i}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
      }
      let r = Vt(t, ["recordAndTuple", {
        syntaxType: "hash"
      }]);
      if (e === "hack") {
        if (Vt(t, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Vt(t, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let s = ii(t, "pipelineOperator", "topicToken");
        if (!n1.includes(s)) {
          let i = n1.map((a) => `"${a}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}\
.`);
        }
        if (s === "#" && r)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { s\
yntaxType: "hash"}]`.');
      } else if (e === "smart" && r)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}\
]`.');
    }
    if (Vt(t, "moduleAttributes")) {
      if (Vt(t, "importAssertions") || Vt(t, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (ii(t, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Vt(t, "importAssertions") && Vt(t, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Vt(t, "recordAndTuple") && ii(t, "recordAndTuple", "syntaxType") != null && !a1.includes(ii(t, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + a1.map((e) => `'${e}'`).join(", "));
    if (Vt(t, "asyncDoExpressions") && !Vt(t, "doExpressions")) {
      let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
    if (Vt(t, "optionalChainingAssign") && ii(t, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(goe, "validatePlugins");
  var A1 = {
    estree: Pae,
    jsx: uoe,
    flow: ooe,
    typescript: moe,
    v8intrinsic: Soe,
    placeholders: xoe
  }, Poe = Object.keys(A1), Yd = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function Eoe(t) {
    if (t == null)
      return Object.assign({}, Yd);
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let e = {};
    for (let s of Object.keys(Yd)) {
      var r;
      e[s] = (r = t[s]) != null ? r : Yd[s];
    }
    return e;
  }
  n(Eoe, "getOptions");
  var fm = class extends pm {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, r, s, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      let a = e.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(F.RecordNoProto, a);
          return;
        }
        s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = a.loc.start) : this.raise(F.DuplicateProto, a)), s.used = !0;
      }
    }
    shouldExitDescending(e, r) {
      return e.type === "ArrowFunctionExpression" && e.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, r) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(e) {
      let r = this.state.startLoc, s = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let i = this.startNodeAt(r);
        for (i.expressions = [s]; this.eat(12); )
          i.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
      }
      return s;
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r));
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r));
    }
    setOptionalParametersError(e, r) {
      var s;
      e.optionalParametersLoc = (s = r?.loc) != null ? s : this.state.startLoc;
    }
    parseMaybeAssign(e, r) {
      let s = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, s)), l;
      }
      let i;
      e ? i = !1 : (e = new kn(), i = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || ft(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(e);
      if (r && (o = r.call(this, o, s)), Iae(this.state.type)) {
        let l = this.startNodeAt(s), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = s.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= c && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= c && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else i && this.checkExpressionErrors(e, !0);
      return o;
    }
    parseMaybeConditional(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(e);
      return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, r, e);
    }
    parseConditional(e, r, s) {
      if (this.eat(17)) {
        let i = this.startNodeAt(r);
        return i.test = e, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(
        i, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, r, -1);
    }
    parseExprOp(e, r, s) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (s >= Nu(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(F.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let i = this.state.type;
      if (Nae(i) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Nu(i);
        if (a > s) {
          if (i === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          let o = this.startNodeAt(r);
          o.left = e, o.operator = this.state.value;
          let l = i === 41 || i === 42, u = i === 40;
          if (u && (a = Nu(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(F.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(i, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(F.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, s);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, r) {
      let s = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(F.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), s);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, r);
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      let s = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, Lae(e) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: r
      } = this.state, s = this.parseMaybeAssign();
      return yae.has(s.type) && !((e = s.extra) != null && e.parenthesized) && this.raise(F.PipeUnparenthesizedBody, r, {
        type: s.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(F.PipeTopicUnused, r), s;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(F.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, r) {
      let s = this.state.startLoc, i = this.isContextual(96);
      if (i && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(s);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (kae(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(F.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(F.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (i) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? $d(u) : $d(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(F.AwaitNotInAsyncContext, s), this.parseAwait(s);
      }
      return l;
    }
    parseUpdate(e, r, s) {
      if (r) {
        let o = e;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), e;
      }
      let i = this.state.startLoc, a = this.parseExprSubscripts(s);
      if (this.checkExpressionErrors(s, !1)) return a;
      for (; Oae(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(i);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(e);
      return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, r);
    }
    parseSubscripts(e, r, s) {
      let i = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, r, s, i), i.maybeAsyncArrow = !1;
      while (!i.stop);
      return e;
    }
    parseSubscript(e, r, s, i) {
      let {
        type: a
      } = this.state;
      if (!s && a === 15)
        return this.parseBind(e, r, s, i);
      if (_u(a))
        return this.parseTaggedTemplateExpression(e, r, i);
      let o = !1;
      if (a === 18) {
        if (s && (this.raise(F.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return i.stop = !0, e;
        i.optionalChainMember = o = !0, this.next();
      }
      if (!s && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, r, i, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, r, i, l, o) : (i.stop = !0, e);
      }
    }
    parseMember(e, r, s, i, a) {
      let o = this.startNodeAt(r);
      return o.object = e, o.computed = i, i ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (e.type === "Super" &&
      this.raise(F.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), s.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, r, s, i) {
      let a = this.startNodeAt(r);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, s);
    }
    parseCoverCallAndAsyncArrowHead(e, r, s, i) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = s;
      u && (this.expressionScope.enter(Zae()), o = new kn()), c && (l.optional = i), i ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r);
    }
    parseTaggedTemplateExpression(e, r, s) {
      let i = this.startNodeAt(r);
      return i.tag = e, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(F.OptionalChainingNoTemplate, r), this.finishNode(
      i, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(e, r) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), e.arguments.length === 0 ||
        e.arguments.length > 2)
          this.raise(F.ImportCallArity, e, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let s of e.arguments)
            s.type === "SpreadElement" && this.raise(F.ImportCallSpreadArgument, s);
      return this.finishNode(e, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, r, s, i, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          F.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, s));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var s;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(e, r.arguments, !0, (s = r.extra) == null ?
      void 0 : s.trailingCommaLoc), r.innerComments && so(e, r.innerComments), r.callee.trailingComments && so(e, r.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let r, s = null, {
        type: i
      } = this.state;
      switch (i) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(F.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          s = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(F.UnsupportedBind, a);
        }
        case 138:
          return this.raise(F.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          vs(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (ft(i)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ft(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      let s = this.getPluginOption("pipelineOperator", "proposal");
      if (s)
        return this.state.type = e, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = yr(this.state.endLoc, -1),
        this.parseTopicReference(s);
      this.unexpected();
    }
    parseTopicReference(e) {
      let r = this.startNode(), s = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(r, s, e, i);
    }
    finishTopicReference(e, r, s, i) {
      if (this.testTopicReferenceConfiguration(s, r, i)) {
        let a = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? F.PrimaryTopicNotAllowed : F.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(e, a);
      } else
        throw this.raise(F.PipeTopicUnconfiguredToken, r, {
          token: ni(i)
        });
    }
    testTopicReferenceConfiguration(e, r, s) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: ni(s)
          }]);
        case "smart":
          return s === 27;
        default:
          throw this.raise(F.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(ku(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(F.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, r, !0);
    }
    parseDo(e, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), e.async = r, this.next();
      let s = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = s, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(F.SuperNotAllowed,
      e) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(F.UnexpectedSuper, e), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(F.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), r = this.startNodeAt(yr(this.state.startLoc, 1)), s = this.state.value;
      return this.next(), e.id = this.createIdentifier(r, s), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, r, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, r, s) {
      e.meta = r;
      let i = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== s || i) && this.raise(F.UnsupportedMetaProperty, e.property, {
        target: r.name,
        onlyValidPropertyName: s
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let r = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(F.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let s = this.isContextual(105);
        if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(F.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = s ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, r, "meta");
    }
    parseLiteralAtNode(e, r, s) {
      return this.addExtra(s, "rawValue", e), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = e, this.next(), this.
      finishNode(s, r);
    }
    parseLiteral(e, r) {
      let s = this.startNode();
      return this.parseLiteralAtNode(e, r, s);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let r = this.parseLiteral(e.value, "RegExpLiteral");
      return r.pattern = e.pattern, r.flags = e.flags, r;
    }
    parseBooleanLiteral(e) {
      let r = this.startNode();
      return r.value = e, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let r = this.state.startLoc, s;
      this.next(), this.expressionScope.enter(Qae());
      let i = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new kn(), c = !0, p, f;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          f = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let T = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), T)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let m = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = a;
      let y = this.startNodeAt(r);
      return e && this.shouldParseArrow(l) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(y, l, !1), y) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), f && this.unexpected(f), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (s = this.startNodeAt(o), s.expressions = l, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s,
      m)) : s = l[0], this.wrapParenthesis(r, s));
    }
    wrapParenthesis(e, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", e.index), this.takeSurroundingComments(r, e.index, this.
        state.lastTokEndLoc.index), r;
      let s = this.startNodeAt(e);
      return s.expression = r, this.finishNode(s, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, r) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let s = this.parseMetaProperty(e, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(F.UnexpectedNewTarget,
        s), s;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), e.arguments = r;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let r = this.match(83), s = this.parseNoCallExpr();
      e.callee = s, r && (s.type === "Import" || s.type === "ImportExpression") && this.raise(F.ImportCallNotNewExpression, s);
    }
    parseTemplateElement(e) {
      let {
        start: r,
        startLoc: s,
        end: i,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(yr(s, 1));
      a === null && (e || this.raise(F.InvalidEscapeSequenceTemplate, yr(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = i + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let f = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(f, yr(this.state.lastTokEndLoc, c)), f;
    }
    parseTemplate(e) {
      let r = this.startNode();
      r.expressions = [];
      let s = this.parseTemplateElement(e);
      for (r.quasis = [s]; !s.tail; )
        r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(s = this.parseTemplateElement(e));
      return this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(i), this.checkProto(p, s, o, i)), s && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(F.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(F.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let s = this.startNode(), i = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (s.decorators = r, r = []), s.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let u = this.state.containsEsc, c = this.parsePropertyName(s, e);
      if (!l && !u && this.maybeAsyncOrAccessorProp(s)) {
        let p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        s)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), s.kind = p, this.match(55) && (l = !0, this.
        raise(F.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(s));
      }
      return this.parseObjPropValue(s, o, l, i, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var r;
      let s = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== s && this.raise(e.kind === "get" ? F.BadGetterArity : F.BadSetterArity, e), e.kind === "set" && ((r = i[i.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(F.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, r, s, i, a) {
      if (a) {
        let o = this.parseMethod(e, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (s || r || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, r, s, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, r, s, i) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), s)
          e.value = this.parseMaybeDefault(r, Is(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = a) : this.raise(F.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(r, Is(e.key));
        } else
          e.value = Is(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, r, s, i, a, o, l) {
      let u = this.parseObjectMethod(e, s, i, a, o) || this.parseObjectProperty(e, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, r) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: s,
          value: i
        } = this.state, a;
        if (Hr(s))
          a = this.parseIdentifier(!0);
        else
          switch (s) {
            case 134:
              a = this.parseNumericLiteral(i);
              break;
            case 133:
              a = this.parseStringLiteral(i);
              break;
            case 135:
              a = this.parseBigIntLiteral(i);
              break;
            case 136:
              a = this.parseDecimalLiteral(i);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(F.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        e.key = a, s !== 138 && (e.computed = !1);
      }
      return e.key;
    }
    initFunction(e, r) {
      e.id = null, e.generator = !1, e.async = r;
    }
    parseMethod(e, r, s, i, a, o, l = !1) {
      this.initFunction(e, s), e.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(ku(s, e.generator)),
      this.parseFunctionParams(e, i);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !s, i, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, s ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, r, s, i) {
      this.scope.enter(6);
      let a = ku(s, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, s);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, r, i)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, r, s) {
      this.toAssignableList(r, s, !1), e.params = r;
    }
    parseFunctionBodyAndFinish(e, r, s = !1) {
      return this.parseFunctionBody(e, !1, s), this.finishNode(e, r);
    }
    parseFunctionBody(e, r, s = !1) {
      let i = r && !this.match(5);
      if (this.expressionScope.enter(S1()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(F.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !r && !s && !u, r, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let r = 0, s = e.length; r < s; r++)
        if (!this.isSimpleParameter(e[r])) return !1;
      return !0;
    }
    checkParams(e, r, s, i = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: i
        });
    }
    parseExprList(e, r, s, i) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, s));
      }
      return a;
    }
    parseExprListItem(e, r, s) {
      let i;
      if (this.match(12))
        e || this.raise(F.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s || this.raise(F.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), i = this.finishNode(a, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      let r = this.startNode(), s = this.parseIdentifierName(e);
      return this.createIdentifier(r, s);
    }
    createIdentifier(e, r) {
      return e.name = r, e.loc.identifierName = r, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let r, {
        startLoc: s,
        type: i
      } = this.state;
      Hr(i) ? r = this.state.value : this.unexpected();
      let a = vae(i);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(r, s, a, !1), this.next(), r;
    }
    checkReservedWord(e, r, s, i) {
      if (e.length > 10 || !Wae(e))
        return;
      if (s && qae(e)) {
        this.raise(F.UnexpectedKeyword, r, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? i ? m1 : h1 : f1)(e, this.inModule)) {
        this.raise(F.UnexpectedReservedWord, r, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(F.YieldBindingIdentifier, r);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(F.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(F.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(F.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e) {
      let r = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(F.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(F.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || _u(e) || e === 102 && !this.state.containsEsc || e === 137 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield() {
      let e = this.startNode();
      this.expressionScope.recordParameterInitializerError(F.YieldInParameter, e), this.next();
      let r = !1, s = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            s = this.parseMaybeAssign();
        }
      return e.delegate = r, e.argument = s, this.finishNode(e, "YieldExpression");
    }
    parseImportCall(e) {
      return this.next(), e.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(F.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(e, r) {
      if (this.isSimpleReference(e)) {
        let s = this.startNodeAt(r);
        return s.callee = e, this.finishNode(s, "PipelineBareFunction");
      } else {
        let s = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), s.expression = e, this.finishNode(s, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(F.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(F.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, e);
      return this.state.inFSharpPipelineDirectBody = s, i;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let s = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        s();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, Jd = {
    kind: 1
  }, Aoe = {
    kind: 2
  }, voe = /[\uD800-\uDFFF]/u, Xd = /in(?:stanceof)?/y;
  function Coe(t, e) {
    for (let r = 0; r < t.length; r++) {
      let s = t[r], {
        type: i
      } = s;
      if (typeof i == "number") {
        {
          if (i === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = yr(a.start, 1);
            t.splice(r, 1, new as({
              type: Es(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }), new as({
              type: Es(132),
              value: l,
              start: c,
              end: u,
              startLoc: p,
              endLoc: a.end
            })), r++;
            continue;
          }
          if (_u(i)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = yr(a.start, 1), f;
            e.charCodeAt(o) === 96 ? f = new as({
              type: Es(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }) : f = new as({
              type: Es(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            });
            let m, y, T, L;
            i === 24 ? (y = u - 1, T = yr(a.end, -1), m = l === null ? null : l.slice(1, -1), L = new as({
              type: Es(22),
              value: "`",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })) : (y = u - 2, T = yr(a.end, -2), m = l === null ? null : l.slice(1, -2), L = new as({
              type: Es(23),
              value: "${",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })), t.splice(r, 1, f, new as({
              type: Es(20),
              value: m,
              start: c,
              end: y,
              startLoc: p,
              endLoc: T
            }), L), r += 2;
            continue;
          }
        }
        s.type = Es(i);
      }
    }
    return t;
  }
  n(Coe, "babel7CompatTokens");
  var hm = class extends fm {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, r) {
      return e.program = this.parseProgram(r), e.comments = this.comments, this.options.tokens && (e.tokens = Coe(this.tokens, this.input)),
      this.finishNode(e, "File");
    }
    parseProgram(e, r = 139, s = this.options.sourceType) {
      if (e.sourceType = s, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(F.ModuleExportUndefined, o, {
            localName: a
          });
      let i;
      return r === 139 ? i = this.finishNode(e, "Program") : i = this.finishNodeAt(e, "Program", yr(this.state.startLoc, -1)), i;
    }
    stmtToDirective(e) {
      let r = e;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let s = r.value, i = s.value, a = this.input.slice(s.start, s.end), o = s.value = a.slice(1, -1);
      return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", o), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, r) {
      if (vs(e)) {
        if (Xd.lastIndex = r, Xd.test(this.input)) {
          let s = this.codePointAtPos(Xd.lastIndex);
          if (!On(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, e);
    }
    hasInLineFollowingBindingIdentifier() {
      let e = this.nextTokenInLineStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingIdentifier(r, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: r
      } = this.lookahead();
      if (e === 102 && !r)
        return !1;
      if (ft(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let r = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(r, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, e && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(e, r);
    }
    parseStatementContent(e, r) {
      let s = this.state.type, i = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (s) {
        case 60:
          return this.parseBreakContinueStatement(i, !0);
        case 63:
          return this.parseBreakContinueStatement(i, !1);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoWhileStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? F.StrictFunction : this.options.annexB ? F.SloppyFunctionAnnexB : F.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(i, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, i), !0);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(F.UnexpectedLexicalDeclaration, i) : this.raise(F.AwaitUsingNotInAsyncContext, i),
            this.next(), this.parseVarStatement(i, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(F.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(F.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), f = this.codePointAtPos(p);
          if (f !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, p) && f !== 123))
            break;
        }
        case 75:
          a || this.raise(F.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(i, p);
        }
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(F.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return s === 83 ? (p = this.parseImport(i), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (p = this.parseExport(i, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind ===
          "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(F.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return ft(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, c, e) : this.parseExpressionStatement(i, c,
      r);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(F.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, r, s) {
      return e && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(F.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...e)) : r.decorators = e, this.resetStartLocationFromNode(
      r, e[0]), s && this.resetStartLocationFromNode(s, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(F.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(F.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, s;
        if (this.match(10)) {
          let i = this.state.startLoc;
          this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          s && this.raise(F.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (s = this.parseIdentifier(!1); this.eat(16); ) {
            let i = this.startNodeAt(r);
            i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) :
            i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(e);
        return r.callee = e, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, r) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, r), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, r) {
      let s;
      for (s = 0; s < this.state.labels.length; ++s) {
        let i = this.state.labels[s];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (r || i.kind === 1) || e.label && r))
          break;
      }
      if (s === this.state.labels.length) {
        let i = r ? "BreakStatement" : "ContinueStatement";
        this.raise(F.IllegalBreakContinue, e, {
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(Jd), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(Jd);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(e, null);
      let s = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = s && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let f = this.startNode(), m;
          u ? (m = "await using", this.isAwaitAllowed() || this.raise(F.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : m =
          this.state.value, this.next(), this.parseVar(f, !0, m);
          let y = this.finishNode(f, "VariableDeclaration"), T = this.match(58);
          return T && c && this.raise(F.ForInUsing, y), (T || this.isContextual(102)) && y.declarations.length === 1 ? this.parseForIn(e, y,
          r) : (r !== null && this.unexpected(r), this.parseFor(e, y));
        }
      }
      let i = this.isContextual(95), a = new kn(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (s && this.raise(F.ForOfLet, o), r === null && i && o.type === "Identifier" && this.raise(F.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(e, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(e, o);
    }
    parseFunctionStatement(e, r, s) {
      return this.next(), this.parseFunction(e, 1 | (s ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(F.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "Ret\
urnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let r = e.cases = [];
      this.expect(5), this.state.labels.push(Aoe), this.scope.enter(0);
      let s;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          s && this.finishNode(s, "SwitchCase"), r.push(s = this.startNode()), s.consequent = [], this.next(), a ? s.test = this.parseExpression() :
          (i && this.raise(F.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
        } else
          s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(F.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        r, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(F.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, r, s = !1) {
      return this.next(), this.parseVar(e, !1, r, s), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(Jd), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(F.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, r, s, i) {
      for (let o of this.state.labels)
        o.name === r && this.raise(F.LabelRedeclaration, s, {
          labelName: r
        });
      let a = wae(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), e.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      s, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, r, s) {
      return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, r = !0, s) {
      let i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(i, e, !1, 8, s), r && this.
      scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, r, s, i, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, s, i, a);
    }
    parseBlockOrModuleBlockBody(e, r, s, i, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(i); ) {
        let c = s ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, r) {
      return e.init = r, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, r, s) {
      let i = this.match(58);
      return this.next(), i ? s !== null && this.unexpected(s) : e.await = s !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!i || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(F.ForInOfLoopInitializer, r, {
        type: i ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(F.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = r, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, r, s, i = !1) {
      let a = e.declarations = [];
      for (e.kind = s; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, s), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !i && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(F.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(F.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: s
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, r) {
      let s = this.parseBindingAtom();
      this.checkLVal(s, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), e.id = s;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, r = 0) {
      let s = r & 2, i = !!(r & 1), a = i && !(r & 4), o = !!(r & 8);
      this.initFunction(e, o), this.match(55) && (s && this.raise(F.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), i && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(ku(o, e.generator)), i || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || ft(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, r) {
      this.expect(10), this.expressionScope.enter(Gae()), e.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, r, s) {
      this.next();
      let i = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, r, s), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.
      finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && (e.key.name === "constructor" || e.key.value === "constructor");
    }
    parseClassBody(e, r) {
      this.classScope.enter();
      let s = {
        hadConstructor: !1,
        hadSuperClass: e
      }, i = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(F.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          i.length && (o.decorators = i, this.resetStartLocationFromNode(o, i[0]), i = []), this.parseClassMember(a, o, s), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(F.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), i.length)
        throw this.raise(F.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, r) {
      let s = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let i = r;
        return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(e, i, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let i = r;
        return i.computed = !1, i.key = s, i.static = !1, e.body.push(this.parseClassProperty(i)), !0;
      }
      return this.resetPreviousNodeTrailingComments(s), !1;
    }
    parseClassMember(e, r, s) {
      let i = this.isContextual(106);
      if (i) {
        if (this.parseClassMemberFromModifier(e, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, r, s, i);
    }
    parseClassMemberWithIsStatic(e, r, s, i) {
      let a = r, o = r, l = r, u = r, c = r, p = a, f = a;
      if (r.static = i, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let q = this.match(138);
        if (this.parseClassElementName(p), q) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(F.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let m = ft(this.state.type) && !this.state.containsEsc, y = this.match(138), T = this.parseClassElementName(r), L = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
        if (p.kind = "method", y) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let q = this.isNonstaticConstructor(a), _ = !1;
        q && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(F.DuplicateConstructor, T), q && this.
        hasPlugin("typescript") && r.override && this.raise(F.OverrideOnConstructor, T), s.hadConstructor = !0, _ = s.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, q, _);
      } else if (this.isClassProperty())
        y ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (m && T.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(T);
        let q = this.eat(55);
        f.optional && this.unexpected(L), p.kind = "method";
        let _ = this.match(138);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(f), _ ? this.pushClassPrivateMethod(e, o, q, !0) : (this.isNonstaticConstructor(
        a) && this.raise(F.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, q, !0, !1, !1));
      } else if (m && (T.name === "get" || T.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(T), p.kind = T.name;
        let q = this.match(138);
        this.parseClassElementName(a), q ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(F.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (m && T.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(T);
        let q = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, q);
      } else this.isLineTerminator() ? y ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: r,
        value: s
      } = this.state;
      if ((r === 132 || r === 133) && e.static && s === "prototype" && this.raise(F.StaticPrototype, this.state.startLoc), r === 138) {
        s === "constructor" && this.raise(F.ConstructorClassPrivateField, this.state.startLoc);
        let i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e);
    }
    parseClassStaticBlock(e, r) {
      var s;
      this.scope.enter(208);
      let i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.
      finishNode(r, "StaticBlock")), (s = r.decorators) != null && s.length && this.raise(F.DecoratorStaticBlock, r);
    }
    pushClassProperty(e, r) {
      !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(F.ConstructorClassField, r.key), e.body.push(
      this.parseClassProperty(r));
    }
    pushClassPrivateProperty(e, r) {
      let s = this.parseClassPrivateProperty(r);
      e.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassAccessorProperty(e, r, s) {
      if (!s && !r.computed) {
        let a = r.key;
        (a.name === "constructor" || a.value === "constructor") && this.raise(F.ConstructorClassField, a);
      }
      let i = this.parseClassAccessorProperty(r);
      e.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassMethod(e, r, s, i, a, o) {
      e.body.push(this.parseMethod(r, s, i, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, r, s, i) {
      let a = this.parseMethod(r, s, i, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(S1()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, r, s, i = 8331) {
      if (ft(this.state.type))
        e.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(e.id, i);
      else if (s || !r)
        e.id = null;
      else
        throw this.raise(F.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, r) {
      let s = this.parseMaybeImportPhase(e, !0), i = this.maybeParseExportDefaultSpecifier(e, s), a = !i || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = i || o;
      if (o && !l) {
        if (i && this.unexpected(), r)
          throw this.raise(F.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      i && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let f;
      if (c || p) {
        if (f = !1, r)
          throw this.raise(F.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        f = this.maybeParseExportDeclaration(e);
      if (c || p || f) {
        var m;
        let y = e;
        if (this.checkExport(y, !0, !1, !!y.source), ((m = y.declaration) == null ? void 0 : m.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, y.declaration, y);
        else if (r)
          throw this.raise(F.UnsupportedDecoratorExport, e);
        return this.finishNode(y, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let y = e, T = this.parseExportDefaultExpression();
        if (y.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, T, y);
        else if (r)
          throw this.raise(F.UnsupportedDecoratorExport, e);
        return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let s = r || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
        return i.exported = s, e.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        e.specifiers || (e.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        e.specifiers || (e.specifiers = []);
        let r = e.exportKind === "type";
        return e.specifiers.push(...this.parseExportSpecifiers(r)), e.source = null, e.declaration = null, this.hasPlugin("importAssertions") &&
        (e.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions =
      []), e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(F.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(F.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (ft(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: i
          } = this.lookahead();
          if (ft(i) && i !== 98 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), s = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ft(this.state.type) && s)
        return !0;
      if (this.match(65) && s) {
        let i = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return i === 34 || i === 39;
      }
      return !1;
    }
    parseExportFrom(e, r) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(F.DecoratorBeforeExport, this.state.startLoc), !0) : e === 74 || e === 75 || e ===
      68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, r, s, i) {
      if (r) {
        var a;
        if (s) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            F.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !i && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(F.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          if (e.declaration.type === "FunctionDeclaration" || e.declaration.type === "ClassDeclaration") {
            let l = e.declaration.id;
            if (!l) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, l.name);
          } else if (e.declaration.type === "VariableDeclaration")
            for (let l of e.declaration.declarations)
              this.checkDeclaration(l.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let r of e.properties)
          this.checkDeclaration(r);
      else if (e.type === "ArrayPattern")
        for (let r of e.elements)
          r && this.checkDeclaration(r);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(F.DuplicateDefaultExport, e) : this.raise(F.DuplicateExport, e, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(e) {
      let r = [], s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else if (this.expect(12), this.eat(8)) break;
        let i = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, e, i));
      }
      return r;
    }
    parseExportSpecifier(e, r, s, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : r ? e.exported = toe(e.local) : e.exported || (e.exported =
      Is(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let e = this.parseStringLiteral(this.state.value), r = e.value.match(voe);
        return r && this.raise(F.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: r,
        value: s
      }) => s.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: r
      } = e, s = r.length === 1 ? r[0].type : null;
      if (e.phase === "source")
        s !== "ImportDefaultSpecifier" && this.raise(F.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (e.phase === "defer")
        s !== "ImportNamespaceSpecifier" && this.raise(F.DeferImportRequiresNamespace, r[0].loc.start);
      else if (e.module) {
        var i;
        s !== "ImportDefaultSpecifier" && this.raise(F.ImportReflectionNotBinding, r[0].loc.start), ((i = e.assertions) == null ? void 0 : i.
        length) > 0 && this.raise(F.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = e;
        if (r != null) {
          let s = r.find((i) => {
            let a;
            if (i.type === "ExportSpecifier" ? a = i.local : i.type === "ImportSpecifier" && (a = i.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          s !== void 0 && this.raise(F.ImportJSONBindingNotDefault, s.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, r, s, i) {
      r || (s === "module" ? (this.expectPlugin("importReflection", i), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      s === "source" ? (this.expectPlugin("sourcePhaseImports", i), e.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", i), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(e, r, null), null;
      let s = this.parseIdentifier(!0), {
        type: i
      } = this.state;
      return (Hr(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(
      e, r, s.name, s.loc.start), null) : (this.applyImportPhase(e, r, null), s);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: r
      } = this.state;
      return ft(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(e) {
      return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, r) {
      e.specifiers = [];
      let i = !this.maybeParseDefaultImportSpecifier(e, r) || this.eat(12), a = i && this.maybeParseStarImportSpecifier(e);
      return i && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var r;
      return (r = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, r, s) {
      r.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, s));
    }
    finishImportSpecifier(e, r, s = 8201) {
      return this.checkLVal(e.local, {
        in: {
          type: r
        },
        binding: s
      }), this.finishNode(e, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s = this.startNode(), i = this.state.value;
        if (r.has(i) && this.raise(F.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: i
        }), r.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(F.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        let s = this.startNode();
        if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(F.ModuleAttributeDifferentFromType, s.key), r.has(s.key.name) &&
        this.raise(F.ModuleAttributesWithDuplicateKeys, s.key, {
          key: s.key.name
        }), r.add(s.key.name), this.expect(14), !this.match(133))
          throw this.raise(F.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let r, s = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), s = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(F.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !s && this.hasPlugin("importAssertions") ? e.assertions = r : e.attributes = r;
    }
    maybeParseDefaultImportSpecifier(e, r) {
      if (r) {
        let s = this.startNodeAtNode(r);
        return s.local = r, e.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
      } else if (Hr(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(F.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let s = this.startNode(), i = this.match(133), a = this.isContextual(130);
        s.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(s, i, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, r, s, i, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (r)
          throw this.raise(F.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = Is(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, Mu = class extends hm {
    static {
      n(this, "Parser");
    }
    constructor(e, r) {
      e = Eoe(e), super(e, r), this.options = e, this.initializeScopes(), this.plugins = Ioe(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return ro;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), r = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, r), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function Ioe(t) {
    let e = /* @__PURE__ */ new Map();
    for (let r of t) {
      let [s, i] = Array.isArray(r) ? r : [r, {}];
      e.has(s) || e.set(s, i || {});
    }
    return e;
  }
  n(Ioe, "pluginsMap");
  function woe(t, e) {
    var r;
    if (((r = e) == null ? void 0 : r.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let s = Qa(e, t), i = s.parse();
        if (s.sawUnambiguousESM)
          return i;
        if (s.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", Qa(e, t).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (s) {
        try {
          return e.sourceType = "script", Qa(e, t).parse();
        } catch {
        }
        throw s;
      }
    } else
      return Qa(e, t).parse();
  }
  n(woe, "parse");
  function Noe(t, e) {
    let r = Qa(e, t);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  n(Noe, "parseExpression");
  function Ooe(t) {
    let e = {};
    for (let r of Object.keys(t))
      e[r] = Es(t[r]);
    return e;
  }
  n(Ooe, "generateExportedTokenTypes");
  var koe = Ooe(Aae);
  function Qa(t, e) {
    let r = Mu;
    return t != null && t.plugins && (goe(t.plugins), r = Doe(t.plugins)), new r(t, e);
  }
  n(Qa, "getParser");
  var o1 = {};
  function Doe(t) {
    let e = Poe.filter((i) => Vt(t, i)), r = e.join("/"), s = o1[r];
    if (!s) {
      s = Mu;
      for (let i of e)
        s = A1[i](s);
      o1[r] = s;
    }
    return s;
  }
  n(Doe, "getParserClass");
  io.parse = woe;
  io.parseExpression = Noe;
  io.tokTypes = koe;
});

// ../node_modules/@babel/helper-hoist-variables/lib/index.js
var C1 = w((Am) => {
  "use strict";
  Object.defineProperty(Am, "__esModule", {
    value: !0
  });
  Am.default = joe;
  var _oe = Ce(), {
    assignmentExpression: Loe,
    expressionStatement: Moe,
    identifier: Boe
  } = _oe, Foe = {
    Scope(t, e) {
      e.kind === "let" && t.skip();
    },
    FunctionParent(t) {
      t.skip();
    },
    VariableDeclaration(t, e) {
      if (e.kind && t.node.kind !== e.kind) return;
      let r = [], s = t.get("declarations"), i;
      for (let a of s) {
        i = a.node.id, a.node.init && r.push(Moe(Loe("=", a.node.id, a.node.init)));
        for (let o of Object.keys(a.getBindingIdentifiers()))
          e.emit(Boe(o), o, a.node.init !== null);
      }
      t.parentPath.isFor({
        left: t.node
      }) ? t.replaceWith(i) : t.replaceWithMultiple(r);
    }
  };
  function joe(t, e, r = "var") {
    t.traverse(Foe, {
      kind: r,
      emit: e
    });
  }
  n(joe, "hoistVariables");
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var L1 = w((ai) => {
  "use strict";
  Object.defineProperty(ai, "__esModule", {
    value: !0
  });
  ai._replaceWith = hle;
  ai.replaceExpressionWithStatements = dle;
  ai.replaceInline = mle;
  ai.replaceWith = fle;
  ai.replaceWithMultiple = cle;
  ai.replaceWithSourceString = ple;
  var Roe = YA(), Cm = Fi(), Uoe = oi(), k1 = Li(), qoe = v1(), Voe = Ce(), Koe = C1(), {
    FUNCTION_TYPES: I1,
    arrowFunctionExpression: Woe,
    assignmentExpression: D1,
    awaitExpression: Yoe,
    blockStatement: Joe,
    buildUndefinedNode: vm,
    callExpression: Xoe,
    cloneNode: Im,
    conditionalExpression: $oe,
    expressionStatement: Hoe,
    getBindingIdentifiers: zoe,
    identifier: Goe,
    inheritLeadingComments: Qoe,
    inheritTrailingComments: Zoe,
    inheritsComments: ele,
    isBlockStatement: tle,
    isEmptyStatement: w1,
    isExpression: _1,
    isExpressionStatement: rle,
    isIfStatement: sle,
    isProgram: ile,
    isStatement: nle,
    isVariableDeclaration: ale,
    removeComments: ole,
    returnStatement: N1,
    sequenceExpression: lle,
    validate: O1,
    yieldExpression: ule
  } = Voe;
  function cle(t) {
    var e;
    this.resync(), t = this._verifyNodeList(t), Qoe(t[0], this.node), Zoe(t[t.length - 1], this.node), (e = (0, k1.getCachedPaths)(this.hub,
    this.parent)) == null || e.delete(this.node), this.node = this.container[this.key] = null;
    let r = this.insertAfter(t);
    return this.node ? this.requeue() : this.remove(), r;
  }
  n(cle, "replaceWithMultiple");
  function ple(t) {
    this.resync();
    let e;
    try {
      t = `(${t})`, e = (0, qoe.parse)(t);
    } catch (s) {
      let i = s.loc;
      throw i && (s.message += ` - make sure this is an expression.
` + (0, Roe.codeFrameColumns)(t, {
        start: {
          line: i.line,
          column: i.column + 1
        }
      }), s.code = "BABEL_REPLACE_SOURCE_ERROR"), s;
    }
    let r = e.program.body[0].expression;
    return Cm.default.removeProperties(r), this.replaceWith(r);
  }
  n(ple, "replaceWithSourceString");
  function fle(t) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let e = t instanceof Uoe.default ? t.node : t;
    if (!e)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === e)
      return [this];
    if (this.isProgram() && !ile(e))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(e))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof e == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r = "";
    if (this.isNodeType("Statement") && _1(e) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    e) && !this.parentPath.isExportDefaultDeclaration() && (e = Hoe(e), r = "expression"), this.isNodeType("Expression") && nle(e) && !this.
    canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(e))
      return this.replaceExpressionWithStatements([e]);
    let s = this.node;
    return s && (ele(e, s), ole(s)), this._replaceWith(e), this.type = e.type, this.setScope(), this.requeue(), [r ? this.get(r) : this];
  }
  n(fle, "replaceWith");
  function hle(t) {
    var e;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? O1(this.parent, this.key, [t]) : O1(this.parent, this.key, t), this.debug(`Replace with ${t?.type}`), (e = (0, k1.getCachedPaths)(
    this.hub, this.parent)) == null || e.set(t, this).delete(this.node), this.node = this.container[this.key] = t;
  }
  n(hle, "_replaceWith");
  function dle(t) {
    this.resync();
    let e = [], r = Bu(t, e);
    if (r) {
      for (let m of e) this.scope.push({
        id: m
      });
      return this.replaceWith(r)[0].get("expressions");
    }
    let s = this.getFunctionParent(), i = s?.is("async"), a = s?.is("generator"), o = Woe([], Joe(t));
    this.replaceWith(Xoe(o, []));
    let l = this.get("callee");
    (0, Koe.default)(l.get("body"), (m) => {
      this.scope.push({
        id: m
      });
    }, "var");
    let u = this.get("callee").getCompletionRecords();
    for (let m of u) {
      if (!m.isExpressionStatement()) continue;
      let y = m.findParent((T) => T.isLoop());
      if (y) {
        let T = y.getData("expressionReplacementReturnUid");
        T ? T = Goe(T.name) : (T = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", N1(Im(T))), y.setData("\
expressionReplacementReturnUid", T)), m.get("expression").replaceWith(D1("=", Im(T), m.node.expression));
      } else
        m.replaceWith(N1(m.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, p = i && Cm.default.hasType(this.get("callee.body").node, "AwaitExpression", I1), f = a && Cm.default.hasType(this.get("calle\
e.body").node, "YieldExpression", I1);
    return p && (c.set("async", !0), f || this.replaceWith(Yoe(this.node))), f && (c.set("generator", !0), this.replaceWith(ule(this.node, !0))),
    c.get("body.body");
  }
  n(dle, "replaceExpressionWithStatements");
  function Bu(t, e) {
    let r = [], s = !0;
    for (let i of t)
      if (w1(i) || (s = !1), _1(i))
        r.push(i);
      else if (rle(i))
        r.push(i.expression);
      else if (ale(i)) {
        if (i.kind !== "var") return;
        for (let a of i.declarations) {
          let o = zoe(a);
          for (let l of Object.keys(o))
            e.push(Im(o[l]));
          a.init && r.push(D1("=", a.id, a.init));
        }
        s = !0;
      } else if (sle(i)) {
        let a = i.consequent ? Bu([i.consequent], e) : vm(), o = i.alternate ? Bu([i.alternate], e) : vm();
        if (!a || !o) return;
        r.push($oe(i.test, a, o));
      } else if (tle(i)) {
        let a = Bu(i.body, e);
        if (!a) return;
        r.push(a);
      } else if (w1(i))
        t.indexOf(i) === 0 && (s = !0);
      else
        return;
    return s && r.push(vm()), r.length === 1 ? r[0] : lle(r);
  }
  n(Bu, "gatherSequenceExpressions");
  function mle(t) {
    if (this.resync(), Array.isArray(t))
      if (Array.isArray(this.container)) {
        t = this._verifyNodeList(t);
        let e = this._containerInsertAfter(t);
        return this.remove(), e;
      } else
        return this.replaceWithMultiple(t);
    else
      return this.replaceWith(t);
  }
  n(mle, "replaceInline");
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var j1 = w((Fu) => {
  "use strict";
  Object.defineProperty(Fu, "__esModule", {
    value: !0
  });
  Fu.evaluate = Ele;
  Fu.evaluateTruthy = gle;
  var yle = ["Number", "String", "Math"], Tle = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeUR\
I", "encodeURIComponent", null, null], ble = ["random"];
  function M1(t) {
    return yle.includes(t);
  }
  n(M1, "isValidObjectCallee");
  function xle(t) {
    return Tle.includes(t);
  }
  n(xle, "isValidIdentifierCallee");
  function Sle(t) {
    return ble.includes(t);
  }
  n(Sle, "isInvalidMethod");
  function gle() {
    let t = this.evaluate();
    if (t.confident) return !!t.value;
  }
  n(gle, "evaluateTruthy");
  function ws(t, e) {
    e.confident && (e.deoptPath = t, e.confident = !1);
  }
  n(ws, "deopt");
  var B1 = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function Tr(t, e) {
    let {
      node: r
    } = t, {
      seen: s
    } = e;
    if (s.has(r)) {
      let i = s.get(r);
      if (i.resolved)
        return i.value;
      ws(t, e);
      return;
    } else {
      let i = {
        resolved: !1
      };
      s.set(r, i);
      let a = Ple(t, e);
      return e.confident && (i.resolved = !0, i.value = a), a;
    }
  }
  n(Tr, "evaluateCached");
  function Ple(t, e) {
    if (e.confident) {
      if (t.isSequenceExpression()) {
        let r = t.get("expressions");
        return Tr(r[r.length - 1], e);
      }
      if (t.isStringLiteral() || t.isNumericLiteral() || t.isBooleanLiteral())
        return t.node.value;
      if (t.isNullLiteral())
        return null;
      if (t.isTemplateLiteral())
        return F1(t, t.node.quasis, e);
      if (t.isTaggedTemplateExpression() && t.get("tag").isMemberExpression()) {
        let r = t.get("tag.object"), {
          node: {
            name: s
          }
        } = r, i = t.get("tag.property");
        if (r.isIdentifier() && s === "String" && !t.scope.getBinding(s) && i.isIdentifier() && i.node.name === "raw")
          return F1(t, t.node.quasi.quasis, e, !0);
      }
      if (t.isConditionalExpression()) {
        let r = Tr(t.get("test"), e);
        return e.confident ? Tr(r ? t.get("consequent") : t.get("alternate"), e) : void 0;
      }
      if (t.isExpressionWrapper())
        return Tr(t.get("expression"), e);
      if (t.isMemberExpression() && !t.parentPath.isCallExpression({
        callee: t.node
      })) {
        let r = t.get("property"), s = t.get("object");
        if (s.isLiteral()) {
          let i = s.node.value, a = typeof i, o = null;
          if (t.node.computed) {
            if (o = Tr(r, e), !e.confident) return;
          } else r.isIdentifier() && (o = r.node.name);
          if ((a === "number" || a === "string") && o != null && (typeof o == "number" || typeof o == "string"))
            return i[o];
        }
      }
      if (t.isReferencedIdentifier()) {
        let r = t.scope.getBinding(t.node.name);
        if (r) {
          if (r.constantViolations.length > 0 || t.node.start < r.path.node.end) {
            ws(r.path, e);
            return;
          }
          if (r.hasValue)
            return r.value;
        }
        let s = t.node.name;
        if (B1.has(s)) {
          if (!r)
            return B1.get(s);
          ws(r.path, e);
          return;
        }
        let i = t.resolve();
        if (i === t) {
          ws(t, e);
          return;
        } else
          return Tr(i, e);
      }
      if (t.isUnaryExpression({
        prefix: !0
      })) {
        if (t.node.operator === "void")
          return;
        let r = t.get("argument");
        if (t.node.operator === "typeof" && (r.isFunction() || r.isClass()))
          return "function";
        let s = Tr(r, e);
        if (!e.confident) return;
        switch (t.node.operator) {
          case "!":
            return !s;
          case "+":
            return +s;
          case "-":
            return -s;
          case "~":
            return ~s;
          case "typeof":
            return typeof s;
        }
      }
      if (t.isArrayExpression()) {
        let r = [], s = t.get("elements");
        for (let i of s) {
          let a = i.evaluate();
          if (a.confident)
            r.push(a.value);
          else {
            ws(a.deopt, e);
            return;
          }
        }
        return r;
      }
      if (t.isObjectExpression()) {
        let r = {}, s = t.get("properties");
        for (let i of s) {
          if (i.isObjectMethod() || i.isSpreadElement()) {
            ws(i, e);
            return;
          }
          let a = i.get("key"), o;
          if (i.node.computed) {
            if (o = a.evaluate(), !o.confident) {
              ws(o.deopt, e);
              return;
            }
            o = o.value;
          } else a.isIdentifier() ? o = a.node.name : o = a.node.value;
          let u = i.get("value").evaluate();
          if (!u.confident) {
            ws(u.deopt, e);
            return;
          }
          u = u.value, r[o] = u;
        }
        return r;
      }
      if (t.isLogicalExpression()) {
        let r = e.confident, s = Tr(t.get("left"), e), i = e.confident;
        e.confident = r;
        let a = Tr(t.get("right"), e), o = e.confident;
        switch (t.node.operator) {
          case "||":
            return e.confident = i && (!!s || o), e.confident ? s || a : void 0;
          case "&&":
            return e.confident = i && (!s || o), e.confident ? s && a : void 0;
          case "??":
            return e.confident = i && (s != null || o), e.confident ? s ?? a : void 0;
        }
      }
      if (t.isBinaryExpression()) {
        let r = Tr(t.get("left"), e);
        if (!e.confident) return;
        let s = Tr(t.get("right"), e);
        if (!e.confident) return;
        switch (t.node.operator) {
          case "-":
            return r - s;
          case "+":
            return r + s;
          case "/":
            return r / s;
          case "*":
            return r * s;
          case "%":
            return r % s;
          case "**":
            return Math.pow(r, s);
          case "<":
            return r < s;
          case ">":
            return r > s;
          case "<=":
            return r <= s;
          case ">=":
            return r >= s;
          case "==":
            return r == s;
          case "!=":
            return r != s;
          case "===":
            return r === s;
          case "!==":
            return r !== s;
          case "|":
            return r | s;
          case "&":
            return r & s;
          case "^":
            return r ^ s;
          case "<<":
            return r << s;
          case ">>":
            return r >> s;
          case ">>>":
            return r >>> s;
        }
      }
      if (t.isCallExpression()) {
        let r = t.get("callee"), s, i;
        if (r.isIdentifier() && !t.scope.getBinding(r.node.name) && (M1(r.node.name) || xle(r.node.name)) && (i = global[r.node.name]), r.isMemberExpression()) {
          let a = r.get("object"), o = r.get("property");
          if (a.isIdentifier() && o.isIdentifier() && M1(a.node.name) && !Sle(o.node.name)) {
            s = global[a.node.name];
            let l = o.node.name;
            hasOwnProperty.call(s, l) && (i = s[l]);
          }
          if (a.isLiteral() && o.isIdentifier()) {
            let l = typeof a.node.value;
            (l === "string" || l === "number") && (s = a.node.value, i = s[o.node.name]);
          }
        }
        if (i) {
          let a = t.get("arguments").map((o) => Tr(o, e));
          return e.confident ? i.apply(s, a) : void 0;
        }
      }
      ws(t, e);
    }
  }
  n(Ple, "_evaluate");
  function F1(t, e, r, s = !1) {
    let i = "", a = 0, o = t.isTemplateLiteral() ? t.get("expressions") : t.get("quasi.expressions");
    for (let l of e) {
      if (!r.confident) break;
      i += s ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (i += String(Tr(u, r)));
    }
    if (r.confident)
      return i;
  }
  n(F1, "evaluateQuasis");
  function Ele() {
    let t = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, e = Tr(this, t);
    return t.confident || (e = void 0), {
      confident: t.confident,
      deopt: t.deoptPath,
      value: e
    };
  }
  n(Ele, "evaluate");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/formatters.js
var R1 = w((qr) => {
  "use strict";
  Object.defineProperty(qr, "__esModule", {
    value: !0
  });
  qr.statements = qr.statement = qr.smart = qr.program = qr.expression = void 0;
  var Ale = Ce(), {
    assertExpressionStatement: vle
  } = Ale;
  function wm(t) {
    return {
      code: /* @__PURE__ */ n((e) => `/* @babel/template */;
${e}`, "code"),
      validate: /* @__PURE__ */ n(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ n((e) => t(e.program.body.slice(1)), "unwrap")
    };
  }
  n(wm, "makeStatementFormatter");
  var Qje = qr.smart = wm((t) => t.length > 1 ? t : t[0]), Zje = qr.statements = wm((t) => t), e8e = qr.statement = wm((t) => {
    if (t.length === 0)
      throw new Error("Found nothing to return.");
    if (t.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return t[0];
  }), Cle = qr.expression = {
    code: /* @__PURE__ */ n((t) => `(
${t}
)`, "code"),
    validate: /* @__PURE__ */ n((t) => {
      if (t.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (Cle.unwrap(t).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ n(({
      program: t
    }) => {
      let [e] = t.body;
      return vle(e), e.expression;
    }, "unwrap")
  }, t8e = qr.program = {
    code: /* @__PURE__ */ n((t) => t, "code"),
    validate: /* @__PURE__ */ n(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ n((t) => t.program, "unwrap")
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/options.js
var ju = w((no) => {
  "use strict";
  Object.defineProperty(no, "__esModule", {
    value: !0
  });
  no.merge = Nle;
  no.normalizeReplacements = kle;
  no.validate = Ole;
  var Ile = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function wle(t, e) {
    if (t == null) return {};
    var r = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r;
  }
  n(wle, "_objectWithoutPropertiesLoose");
  function Nle(t, e) {
    let {
      placeholderWhitelist: r = t.placeholderWhitelist,
      placeholderPattern: s = t.placeholderPattern,
      preserveComments: i = t.preserveComments,
      syntacticPlaceholders: a = t.syntacticPlaceholders
    } = e;
    return {
      parser: Object.assign({}, t.parser, e.parser),
      placeholderWhitelist: r,
      placeholderPattern: s,
      preserveComments: i,
      syntacticPlaceholders: a
    };
  }
  n(Nle, "merge");
  function Ole(t) {
    if (t != null && typeof t != "object")
      throw new Error("Unknown template options.");
    let e = t || {}, {
      placeholderWhitelist: r,
      placeholderPattern: s,
      preserveComments: i,
      syntacticPlaceholders: a
    } = e, o = wle(e, Ile);
    if (r != null && !(r instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (s != null && !(s instanceof RegExp) && s !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (i != null && typeof i != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (r != null || s != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: r || void 0,
      placeholderPattern: s ?? void 0,
      preserveComments: i ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  n(Ole, "validate");
  function kle(t) {
    if (Array.isArray(t))
      return t.reduce((e, r, s) => (e["$" + s] = r, e), {});
    if (typeof t == "object" || t == null)
      return t || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  n(kle, "normalizeReplacements");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/node_modules/@babel/parser/lib/index.js
var bv = w((To) => {
  "use strict";
  Object.defineProperty(To, "__esModule", {
    value: !0
  });
  function tv(t, e) {
    if (t == null) return {};
    var r = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r;
  }
  n(tv, "_objectWithoutPropertiesLoose");
  var us = class {
    static {
      n(this, "Position");
    }
    constructor(e, r, s) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = r, this.index = s;
    }
  }, jn = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = r;
    }
  };
  function xr(t, e) {
    let {
      line: r,
      column: s,
      index: i
    } = t;
    return new us(r, s + e, i + e);
  }
  n(xr, "createPositionWithColumnOffset");
  var U1 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Dle = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: U1
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: U1
    }
  }, q1 = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, qu = /* @__PURE__ */ n((t) => t.type === "UpdateExpression" ? q1.UpdateExpression[`${t.prefix}`] : q1[t.type], "toNodeDescription"), _le = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ n(({
      maxArgumentCount: t
    }) => `\`import()\` requires exactly ${t === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${qu(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${qu(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${qu(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, Lle = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, Mle = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Ble = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${qu({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, Fle = ["toMessage"], jle = ["message"];
  function V1(t, e, r) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  n(V1, "defineHidden");
  function Rle(t) {
    let {
      toMessage: e
    } = t, r = tv(t, Fle);
    return /* @__PURE__ */ n(function s(i, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: i,
        pos: i.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), V1(o, "clone", /* @__PURE__ */ n(function(u = {}) {
        var c;
        let {
          line: p,
          column: f,
          index: m
        } = (c = u.loc) != null ? c : i;
        return s(new us(p, f, m), Object.assign({}, a, u.details));
      }, "clone")), V1(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${e(a)} (${i.line}:${i.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  n(Rle, "toParseErrorConstructor");
  function Ds(t, e) {
    if (Array.isArray(t))
      return (s) => Ds(s, t[0]);
    let r = {};
    for (let s of Object.keys(t)) {
      let i = t[s], a = typeof i == "string" ? {
        message: /* @__PURE__ */ n(() => i, "message")
      } : typeof i == "function" ? {
        message: i
      } : i, {
        message: o
      } = a, l = tv(a, jle), u = typeof o == "string" ? () => o : o;
      r[s] = Rle(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: s,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return r;
  }
  n(Ds, "ParseErrorEnum");
  var M = Object.assign({}, Ds(Dle), Ds(_le), Ds(Lle), Ds`pipelineOperator`(Ble)), {
    defineProperty: Ule
  } = Object, K1 = /* @__PURE__ */ n((t, e) => Ule(t, e, {
    enumerable: !1,
    value: t[e]
  }), "toUnenumerable");
  function ao(t) {
    return t.loc.start && K1(t.loc.start, "index"), t.loc.end && K1(t.loc.end, "index"), t;
  }
  n(ao, "toESTreeLocation");
  var qle = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let r = ao(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(ao)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: s
    }) {
      let i = null;
      try {
        i = new RegExp(r, s);
      } catch {
      }
      let a = this.estreeParseLiteral(i);
      return a.regex = {
        pattern: r,
        flags: s
      }, a;
    }
    parseBigIntLiteral(r) {
      let s;
      try {
        s = BigInt(r);
      } catch {
        s = null;
      }
      let i = this.estreeParseLiteral(s);
      return i.bigint = String(i.value || r), i;
    }
    parseDecimalLiteral(r) {
      let i = this.estreeParseLiteral(null);
      return i.decimal = String(i.value || r), i;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let s = r.value;
      delete r.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let i = r;
      return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
    }
    initFunction(r, s) {
      super.initFunction(r, s), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var s;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((s = r.expression.
      extra) != null && s.parenthesized);
    }
    parseBlockBody(r, s, i, a, o) {
      super.parseBlockBody(r, s, i, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, s, i, a, o, l) {
      this.parseMethod(s, i, a, o, l, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters),
      r.body.push(s);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let s = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = s, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, s) {
      let i = super.parseLiteral(r, s);
      return i.raw = i.extra.raw, delete i.extra, i;
    }
    parseFunctionBody(r, s, i = !1) {
      super.parseFunctionBody(r, s, i), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, s, i, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, s, i, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let s = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
    }
    parseClassPrivateProperty(...r) {
      let s = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
    }
    parseObjectMethod(r, s, i, a, o) {
      let l = super.parseObjectMethod(r, s, i, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, s, i, a) {
      let o = super.parseObjectProperty(r, s, i, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, s, i) {
      return r === "Property" ? "value" : super.isValidLVal(r, s, i);
    }
    isAssignable(r, s) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: i,
          value: a
        } = r;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(r, s);
    }
    toAssignableObjectExpressionProp(r, s, i) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(M.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(M.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, s, i);
    }
    finishCallExpression(r, s) {
      let i = super.finishCallExpression(r, s);
      if (i.callee.type === "Import") {
        if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          i.options = (a = i.arguments[1]) != null ? a : null, i.attributes = (o = i.arguments[1]) != null ? o : null;
        }
        delete i.arguments, delete i.callee;
      }
      return i;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, s) {
      let i = this.state.lastTokStartLoc, a = super.parseExport(r, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, i);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, s, i, a) {
      let o = super.parseSubscript(r, s, i, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    finishNodeAt(r, s, i) {
      return ao(super.finishNodeAt(r, s, i));
    }
    resetStartLocation(r, s) {
      super.resetStartLocation(r, s), ao(r);
    }
    resetEndLocation(r, s = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, s), ao(r);
    }
  }, "estree"), Xi = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!r;
    }
  }, gt = {
    brace: new Xi("{"),
    j_oTag: new Xi("<tag"),
    j_cTag: new Xi("</tag"),
    j_expr: new Xi("<tag>...</tag>", !0)
  };
  gt.template = new Xi("`", !0);
  var Je = !0, oe = !0, Nm = !0, oo = !0, li = !0, Vle = !0, Yu = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, ey = /* @__PURE__ */ new Map();
  function et(t, e = {}) {
    e.keyword = t;
    let r = Ae(t, e);
    return ey.set(t, r), r;
  }
  n(et, "createKeyword");
  function br(t, e) {
    return Ae(t, {
      beforeExpr: Je,
      binop: e
    });
  }
  n(br, "createBinop");
  var po = -1, Os = [], ty = [], ry = [], sy = [], iy = [], ny = [];
  function Ae(t, e = {}) {
    var r, s, i, a;
    return ++po, ty.push(t), ry.push((r = e.binop) != null ? r : -1), sy.push((s = e.beforeExpr) != null ? s : !1), iy.push((i = e.startsExpr) !=
    null ? i : !1), ny.push((a = e.prefix) != null ? a : !1), Os.push(new Yu(t, e)), po;
  }
  n(Ae, "createToken");
  function Ye(t, e = {}) {
    var r, s, i, a;
    return ++po, ey.set(t, po), ty.push(t), ry.push((r = e.binop) != null ? r : -1), sy.push((s = e.beforeExpr) != null ? s : !1), iy.push((i =
    e.startsExpr) != null ? i : !1), ny.push((a = e.prefix) != null ? a : !1), Os.push(new Yu("name", e)), po;
  }
  n(Ye, "createKeywordLike");
  var Kle = {
    bracketL: Ae("[", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    bracketHashL: Ae("#[", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    bracketBarL: Ae("[|", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    bracketR: Ae("]"),
    bracketBarR: Ae("|]"),
    braceL: Ae("{", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    braceBarL: Ae("{|", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    braceHashL: Ae("#{", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    braceR: Ae("}"),
    braceBarR: Ae("|}"),
    parenL: Ae("(", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    parenR: Ae(")"),
    comma: Ae(",", {
      beforeExpr: Je
    }),
    semi: Ae(";", {
      beforeExpr: Je
    }),
    colon: Ae(":", {
      beforeExpr: Je
    }),
    doubleColon: Ae("::", {
      beforeExpr: Je
    }),
    dot: Ae("."),
    question: Ae("?", {
      beforeExpr: Je
    }),
    questionDot: Ae("?."),
    arrow: Ae("=>", {
      beforeExpr: Je
    }),
    template: Ae("template"),
    ellipsis: Ae("...", {
      beforeExpr: Je
    }),
    backQuote: Ae("`", {
      startsExpr: oe
    }),
    dollarBraceL: Ae("${", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    templateTail: Ae("...`", {
      startsExpr: oe
    }),
    templateNonTail: Ae("...${", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    at: Ae("@"),
    hash: Ae("#", {
      startsExpr: oe
    }),
    interpreterDirective: Ae("#!..."),
    eq: Ae("=", {
      beforeExpr: Je,
      isAssign: oo
    }),
    assign: Ae("_=", {
      beforeExpr: Je,
      isAssign: oo
    }),
    slashAssign: Ae("_=", {
      beforeExpr: Je,
      isAssign: oo
    }),
    xorAssign: Ae("_=", {
      beforeExpr: Je,
      isAssign: oo
    }),
    moduloAssign: Ae("_=", {
      beforeExpr: Je,
      isAssign: oo
    }),
    incDec: Ae("++/--", {
      prefix: li,
      postfix: Vle,
      startsExpr: oe
    }),
    bang: Ae("!", {
      beforeExpr: Je,
      prefix: li,
      startsExpr: oe
    }),
    tilde: Ae("~", {
      beforeExpr: Je,
      prefix: li,
      startsExpr: oe
    }),
    doubleCaret: Ae("^^", {
      startsExpr: oe
    }),
    doubleAt: Ae("@@", {
      startsExpr: oe
    }),
    pipeline: br("|>", 0),
    nullishCoalescing: br("??", 1),
    logicalOR: br("||", 1),
    logicalAND: br("&&", 2),
    bitwiseOR: br("|", 3),
    bitwiseXOR: br("^", 4),
    bitwiseAND: br("&", 5),
    equality: br("==/!=/===/!==", 6),
    lt: br("</>/<=/>=", 7),
    gt: br("</>/<=/>=", 7),
    relational: br("</>/<=/>=", 7),
    bitShift: br("<</>>/>>>", 8),
    bitShiftL: br("<</>>/>>>", 8),
    bitShiftR: br("<</>>/>>>", 8),
    plusMin: Ae("+/-", {
      beforeExpr: Je,
      binop: 9,
      prefix: li,
      startsExpr: oe
    }),
    modulo: Ae("%", {
      binop: 10,
      startsExpr: oe
    }),
    star: Ae("*", {
      binop: 10
    }),
    slash: br("/", 10),
    exponent: Ae("**", {
      beforeExpr: Je,
      binop: 11,
      rightAssociative: !0
    }),
    _in: et("in", {
      beforeExpr: Je,
      binop: 7
    }),
    _instanceof: et("instanceof", {
      beforeExpr: Je,
      binop: 7
    }),
    _break: et("break"),
    _case: et("case", {
      beforeExpr: Je
    }),
    _catch: et("catch"),
    _continue: et("continue"),
    _debugger: et("debugger"),
    _default: et("default", {
      beforeExpr: Je
    }),
    _else: et("else", {
      beforeExpr: Je
    }),
    _finally: et("finally"),
    _function: et("function", {
      startsExpr: oe
    }),
    _if: et("if"),
    _return: et("return", {
      beforeExpr: Je
    }),
    _switch: et("switch"),
    _throw: et("throw", {
      beforeExpr: Je,
      prefix: li,
      startsExpr: oe
    }),
    _try: et("try"),
    _var: et("var"),
    _const: et("const"),
    _with: et("with"),
    _new: et("new", {
      beforeExpr: Je,
      startsExpr: oe
    }),
    _this: et("this", {
      startsExpr: oe
    }),
    _super: et("super", {
      startsExpr: oe
    }),
    _class: et("class", {
      startsExpr: oe
    }),
    _extends: et("extends", {
      beforeExpr: Je
    }),
    _export: et("export"),
    _import: et("import", {
      startsExpr: oe
    }),
    _null: et("null", {
      startsExpr: oe
    }),
    _true: et("true", {
      startsExpr: oe
    }),
    _false: et("false", {
      startsExpr: oe
    }),
    _typeof: et("typeof", {
      beforeExpr: Je,
      prefix: li,
      startsExpr: oe
    }),
    _void: et("void", {
      beforeExpr: Je,
      prefix: li,
      startsExpr: oe
    }),
    _delete: et("delete", {
      beforeExpr: Je,
      prefix: li,
      startsExpr: oe
    }),
    _do: et("do", {
      isLoop: Nm,
      beforeExpr: Je
    }),
    _for: et("for", {
      isLoop: Nm
    }),
    _while: et("while", {
      isLoop: Nm
    }),
    _as: Ye("as", {
      startsExpr: oe
    }),
    _assert: Ye("assert", {
      startsExpr: oe
    }),
    _async: Ye("async", {
      startsExpr: oe
    }),
    _await: Ye("await", {
      startsExpr: oe
    }),
    _defer: Ye("defer", {
      startsExpr: oe
    }),
    _from: Ye("from", {
      startsExpr: oe
    }),
    _get: Ye("get", {
      startsExpr: oe
    }),
    _let: Ye("let", {
      startsExpr: oe
    }),
    _meta: Ye("meta", {
      startsExpr: oe
    }),
    _of: Ye("of", {
      startsExpr: oe
    }),
    _sent: Ye("sent", {
      startsExpr: oe
    }),
    _set: Ye("set", {
      startsExpr: oe
    }),
    _source: Ye("source", {
      startsExpr: oe
    }),
    _static: Ye("static", {
      startsExpr: oe
    }),
    _using: Ye("using", {
      startsExpr: oe
    }),
    _yield: Ye("yield", {
      startsExpr: oe
    }),
    _asserts: Ye("asserts", {
      startsExpr: oe
    }),
    _checks: Ye("checks", {
      startsExpr: oe
    }),
    _exports: Ye("exports", {
      startsExpr: oe
    }),
    _global: Ye("global", {
      startsExpr: oe
    }),
    _implements: Ye("implements", {
      startsExpr: oe
    }),
    _intrinsic: Ye("intrinsic", {
      startsExpr: oe
    }),
    _infer: Ye("infer", {
      startsExpr: oe
    }),
    _is: Ye("is", {
      startsExpr: oe
    }),
    _mixins: Ye("mixins", {
      startsExpr: oe
    }),
    _proto: Ye("proto", {
      startsExpr: oe
    }),
    _require: Ye("require", {
      startsExpr: oe
    }),
    _satisfies: Ye("satisfies", {
      startsExpr: oe
    }),
    _keyof: Ye("keyof", {
      startsExpr: oe
    }),
    _readonly: Ye("readonly", {
      startsExpr: oe
    }),
    _unique: Ye("unique", {
      startsExpr: oe
    }),
    _abstract: Ye("abstract", {
      startsExpr: oe
    }),
    _declare: Ye("declare", {
      startsExpr: oe
    }),
    _enum: Ye("enum", {
      startsExpr: oe
    }),
    _module: Ye("module", {
      startsExpr: oe
    }),
    _namespace: Ye("namespace", {
      startsExpr: oe
    }),
    _interface: Ye("interface", {
      startsExpr: oe
    }),
    _type: Ye("type", {
      startsExpr: oe
    }),
    _opaque: Ye("opaque", {
      startsExpr: oe
    }),
    name: Ae("name", {
      startsExpr: oe
    }),
    string: Ae("string", {
      startsExpr: oe
    }),
    num: Ae("num", {
      startsExpr: oe
    }),
    bigint: Ae("bigint", {
      startsExpr: oe
    }),
    decimal: Ae("decimal", {
      startsExpr: oe
    }),
    regexp: Ae("regexp", {
      startsExpr: oe
    }),
    privateName: Ae("#name", {
      startsExpr: oe
    }),
    eof: Ae("eof"),
    jsxName: Ae("jsxName"),
    jsxText: Ae("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: Ae("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: Ae("jsxTagEnd"),
    placeholder: Ae("%%", {
      startsExpr: !0
    })
  };
  function ht(t) {
    return t >= 93 && t <= 132;
  }
  n(ht, "tokenIsIdentifier");
  function Wle(t) {
    return t <= 92;
  }
  n(Wle, "tokenKeywordOrIdentifierIsKeyword");
  function zr(t) {
    return t >= 58 && t <= 132;
  }
  n(zr, "tokenIsKeywordOrIdentifier");
  function rv(t) {
    return t >= 58 && t <= 136;
  }
  n(rv, "tokenIsLiteralPropertyName");
  function Yle(t) {
    return sy[t];
  }
  n(Yle, "tokenComesBeforeExpression");
  function Lm(t) {
    return iy[t];
  }
  n(Lm, "tokenCanStartExpression");
  function Jle(t) {
    return t >= 29 && t <= 33;
  }
  n(Jle, "tokenIsAssignment");
  function W1(t) {
    return t >= 129 && t <= 131;
  }
  n(W1, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function Xle(t) {
    return t >= 90 && t <= 92;
  }
  n(Xle, "tokenIsLoop");
  function ay(t) {
    return t >= 58 && t <= 92;
  }
  n(ay, "tokenIsKeyword");
  function $le(t) {
    return t >= 39 && t <= 59;
  }
  n($le, "tokenIsOperator");
  function Hle(t) {
    return t === 34;
  }
  n(Hle, "tokenIsPostfix");
  function zle(t) {
    return ny[t];
  }
  n(zle, "tokenIsPrefix");
  function Gle(t) {
    return t >= 121 && t <= 123;
  }
  n(Gle, "tokenIsTSTypeOperator");
  function Qle(t) {
    return t >= 124 && t <= 130;
  }
  n(Qle, "tokenIsTSDeclarationStart");
  function ci(t) {
    return ty[t];
  }
  n(ci, "tokenLabelName");
  function Vu(t) {
    return ry[t];
  }
  n(Vu, "tokenOperatorPrecedence");
  function Zle(t) {
    return t === 57;
  }
  n(Zle, "tokenIsRightAssociative");
  function Ju(t) {
    return t >= 24 && t <= 25;
  }
  n(Ju, "tokenIsTemplate");
  function Ns(t) {
    return Os[t];
  }
  n(Ns, "getExportedToken");
  Os[8].updateContext = (t) => {
    t.pop();
  }, Os[5].updateContext = Os[7].updateContext = Os[23].updateContext = (t) => {
    t.push(gt.brace);
  }, Os[22].updateContext = (t) => {
    t[t.length - 1] === gt.template ? t.pop() : t.push(gt.template);
  }, Os[142].updateContext = (t) => {
    t.push(gt.j_expr, gt.j_oTag);
  };
  var oy = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  sv = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", eue = new RegExp("[" + oy + "]"), tue = new RegExp("[" + oy + sv + "\
]");
  oy = sv = null;
  var iv = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], rue = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Mm(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(Mm, "isInAstralSet");
  function ks(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && eue.test(String.fromCharCode(t)) :
    Mm(t, iv);
  }
  n(ks, "isIdentifierStart");
  function Bn(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && tue.test(
    String.fromCharCode(t)) : Mm(t, iv) || Mm(t, rue);
  }
  n(Bn, "isIdentifierChar");
  var ly = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, sue = new Set(ly.keyword), iue = new Set(ly.strict), nue = new Set(ly.strictBind);
  function nv(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(nv, "isReservedWord");
  function av(t, e) {
    return nv(t, e) || iue.has(t);
  }
  n(av, "isStrictReservedWord");
  function ov(t) {
    return nue.has(t);
  }
  n(ov, "isStrictBindOnlyReservedWord");
  function lv(t, e) {
    return av(t, e) || ov(t);
  }
  n(lv, "isStrictBindReservedWord");
  function aue(t) {
    return sue.has(t);
  }
  n(aue, "isKeyword");
  function oue(t, e, r) {
    return t === 64 && e === 64 && ks(r);
  }
  n(oue, "isIteratorStart");
  var lue = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function uue(t) {
    return lue.has(t);
  }
  n(uue, "canBeReservedWord");
  var ho = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, mo = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new ho(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(i, e, r, s);
        let a = i.names.get(e) || 0;
        r & 16 ? a = a | 4 : (i.firstLexicalName || (i.firstLexicalName = e), a = a | 2), i.names.set(e, a), r & 8 && this.maybeExportDefined(
        i, e);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (i = this.scopeStack[a], this.checkRedeclarationInScope(i, e, r, s), i.names.set(
        e, (i.names.get(e) || 0) | 1), this.maybeExportDefined(i, e), !(i.flags & 387)); --a)
          ;
      this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(e, r, s, i) {
      this.isRedeclaredInScope(e, r, s) && this.parser.raise(M.VarRedeclaration, i, {
        identifierName: r
      });
    }
    isRedeclaredInScope(e, r, s) {
      if (!(s & 1)) return !1;
      if (s & 8)
        return e.names.has(r);
      let i = e.names.get(r);
      return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (i & 1) > 0 : (i & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(e) && (i & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, Bm = class extends ho {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, Fm = class extends mo {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new Bm(e);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(e, r, s);
    }
    isRedeclaredInScope(e, r, s) {
      if (super.isRedeclaredInScope(e, r, s)) return !0;
      if (s & 2048 && !e.declareFunctions.has(r)) {
        let i = e.names.get(r);
        return (i & 4) > 0 || (i & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, jm = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [r, s] = e;
        if (!this.hasPlugin(r))
          return !1;
        let i = this.plugins.get(r);
        for (let a of Object.keys(s))
          if (i?.[a] !== s[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, r) {
      var s;
      return (s = this.plugins.get(e)) == null ? void 0 : s[r];
    }
  };
  function uv(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(uv, "setTrailingComments");
  function cue(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(cue, "setLeadingComments");
  function yo(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(yo, "setInnerComments");
  function lo(t, e, r) {
    let s = null, i = e.length;
    for (; s === null && i > 0; )
      s = e[--i];
    s === null || s.start > r.start ? yo(t, r.comments) : uv(s, r.comments);
  }
  n(lo, "adjustInnerComments");
  var Rm = class extends jm {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: r
      } = this.state, s = r.length;
      if (s === 0) return;
      let i = s - 1, a = r[i];
      a.start === e.end && (a.leadingNode = e, i--);
      let {
        start: o
      } = e;
      for (; i >= 0; i--) {
        let l = r[i], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), r.splice(i, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: r
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && uv(e.leadingNode, r), e.trailingNode !== null && cue(e.trailingNode, r);
      else {
        let {
          containingNode: s,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (s.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              lo(s, s.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              lo(s, s.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              lo(s, s.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              lo(s, s.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              lo(s, s.specifiers, e);
              break;
            default:
              yo(s, r);
          }
        else
          yo(s, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let r = e.length - 1; r >= 0; r--)
        this.finalizeComment(e[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      if (s === 0) return;
      let i = r[s - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      s !== 0 && (r[s - 1].trailingNode === e ? r[s - 1].trailingNode = null : s >= 2 && r[s - 2].trailingNode === e && (r[s - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, r, s) {
      let {
        commentStack: i
      } = this.state, a = i.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = i[o], u = l.end;
        if (l.start === s)
          l.leadingNode = e;
        else if (u === r)
          l.trailingNode = e;
        else if (u < r)
          break;
      }
    }
  }, cv = /\r\n?|[\n\u2028\u2029]/, Ru = new RegExp(cv.source, "g");
  function fo(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(fo, "isNewLine");
  var Om = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ku = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Y1 = new RegExp("(?=(" + Ku.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function pue(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(pue, "isWhitespace");
  var Um = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [gt.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: r,
      startLine: s,
      startColumn: i
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : r === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new us(
      s, i, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new us(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.startLoc, e.endLoc = this.endLoc,
      e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.slice(), e.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.slice(), e.commentsLen = this.commentsLen,
      e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value = this.value, e.start = this.start, e.end = this.
      end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.context = this.context.slice(), e.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors, e.tokensLength = this.tokensLength, e;
    }
  }, fue = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), J1 = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Uu = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function X1(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (hue(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = due(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(X1, "readStringContents");
  function hue(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(hue, "isStringEnd");
  function due(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = qm(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = fv(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(due, "readEscapedChar");
  function qm(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = pv(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(qm, "readHexChar");
  function pv(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? J1.hex : J1.decBinOct, m = i === 16 ? Uu.hex : i === 10 ? Uu.dec : i === 8 ? Uu.oct : Uu.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : fue(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(pv, "readInt");
  function fv(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = qm(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = qm(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(fv, "readCodePoint");
  function uo(t, e, r) {
    return new us(r, t - e, t);
  }
  n(uo, "buildPosition");
  var mue = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), ls = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new jn(e.startLoc, e.endLoc);
    }
  }, Vm = class extends Rm {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((s, i, a, o) => this.options.errorRecovery ? (this.raise(M.InvalidDigit, uo(s, i, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(M.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(M.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(M.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(M.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((s, i, a) => {
          this.recordStrictModeErrors(M.StrictNumericEscape, uo(s, i, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(M.UnterminatedString, uo(s - 1, i, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(M.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(M.UnterminatedTemplate, uo(s, i, a));
        }, "unterminated")
      }), this.state = new Um(), this.state.init(e), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new ls(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = e, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return Om.lastIndex = e, Om.test(this.input) ? Om.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Ku.lastIndex = e, Ku.test(this.input) ? Ku.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e);
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        let s = this.input.charCodeAt(e);
        (s & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (s & 1023));
      }
      return r;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([r, s]) => this.raise(r, s)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let s = this.state.pos, i = this.input.indexOf(e, s + 2);
      if (i === -1)
        throw this.raise(M.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = i + e.length, Ru.lastIndex = s + 2; Ru.test(this.input) && Ru.lastIndex <= i; )
        ++this.state.curLine, this.state.lineStart = Ru.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(s + 2, i),
        start: s,
        end: i + e.length,
        loc: new jn(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let r = this.state.pos, s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !fo(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + e, a),
        start: r,
        end: a,
        loc: new jn(s, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let i = this.skipBlockComment("*/");
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              case 47: {
                let i = this.skipLineComment(2);
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (pue(s))
              ++this.state.pos;
            else if (s === 45 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (s === 60 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let s = this.state.pos, i = {
          start: e,
          end: s,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s = this.state.type;
      this.state.type = e, this.state.value = r, this.isLookahead || this.updateContext(s);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, r = this.codePointAtPos(e);
      if (r >= 48 && r <= 57)
        throw this.raise(M.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? M.RecordExpressionHashIncorrectStartSyntaxType : M.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else ks(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !fo(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let s = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, s), !0;
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), r = 57), i === 61 && !this.state.inType && (s++, r = e ===
      37 ? 33 : 30), this.finishOp(r, s);
    }
    readToken_pipe_amp(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(M.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(M.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 62) {
        let s = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + s) === 61) {
          this.finishOp(30, s + 1);
          return;
        }
        this.finishOp(52, s);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(M.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(M.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (ks(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(M.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, r) {
      let s = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(e, s);
    }
    readRegexp() {
      let e = this.state.startLoc, r = this.state.start + 1, s, i, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(M.UnterminatedRegExp, xr(e, 1));
        let c = this.input.charCodeAt(a);
        if (fo(c))
          throw this.raise(M.UnterminatedRegExp, xr(e, 1));
        if (s)
          s = !1;
        else {
          if (c === 91)
            i = !0;
          else if (c === 93 && i)
            i = !1;
          else if (c === 47 && !i)
            break;
          s = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => xr(e, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (mue.has(c))
          c === 118 ? l.includes("u") && this.raise(M.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(M.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(M.DuplicateRegExpFlags, u());
        else if (Bn(c) || c === 92)
          this.raise(M.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, r, s = !1, i = !0) {
      let {
        n: a,
        pos: o
      } = pv(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, r, s, i, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let r = this.state.curPosition(), s = !1;
      this.state.pos += 2;
      let i = this.readInt(e);
      i == null && this.raise(M.InvalidDigit, xr(r, 2), {
        radix: e
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, s = !0;
      else if (a === 109)
        throw this.raise(M.InvalidDecimal, r);
      if (ks(this.codePointAtPos(this.state.pos)))
        throw this.raise(M.NumberIdentifier, this.state.curPosition());
      if (s) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, i);
    }
    readNumber(e) {
      let r = this.state.pos, s = this.state.curPosition(), i = !1, a = !1, o = !1, l = !1, u = !1;
      !e && this.readInt(10) === null && this.raise(M.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let y = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(M.StrictOctalLiteral, s), !this.state.strict) {
          let T = y.indexOf("_");
          T > 0 && this.raise(M.ZeroDigitNumericSeparator, xr(s, T));
        }
        u = c && !/[89]/.test(y);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !u && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      M.InvalidOrMissingExponent, s), i = !0, l = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((i || c) && this.raise(M.InvalidBigIntLiteral,
      s), ++this.state.pos, a = !0), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(M.InvalidDecimal,
      s), ++this.state.pos, o = !0), ks(this.codePointAtPos(this.state.pos)))
        throw this.raise(M.NumberIdentifier, this.state.curPosition());
      let f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, f);
        return;
      }
      if (o) {
        this.finishToken(136, f);
        return;
      }
      let m = u ? parseInt(f, 8) : parseFloat(f);
      this.finishToken(134, m);
    }
    readCodePoint(e) {
      let {
        code: r,
        pos: s
      } = fv(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = s, r;
    }
    readString(e) {
      let {
        str: r,
        pos: s,
        curLine: i,
        lineStart: a
      } = X1(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: s,
        pos: i,
        curLine: a,
        lineStart: o
      } = X1("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = i + 1, this.state.lineStart = o, this.state.curLine = a, s && (this.state.firstInvalidTemplateEscapePos = new us(s.curLine,
      s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : e + r + "`") : (this.state.pos++, this.
      finishToken(25, s ? null : e + r + "${"));
    }
    recordStrictModeErrors(e, r) {
      let s = r.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(e, r) : this.state.strictErrors.set(s, [e, r]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let r = "", s = this.state.pos, i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (Bn(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(i, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === s ? ks : Bn;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(M.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(M.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), i = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      let r = this.readWord1(e), s = ey.get(r);
      s !== void 0 ? this.finishToken(s, ci(s)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      ay(e) && this.state.containsEsc && this.raise(M.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: ci(e)
      });
    }
    raise(e, r, s = {}) {
      let i = r instanceof us ? r : r.loc.start, a = e(i, s);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, r, s = {}) {
      let i = r instanceof us ? r : r.loc.start, a = i.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(i, s);
        if (u.loc.index < a) break;
      }
      return this.raise(e, r, s);
    }
    updateContext(e) {
    }
    unexpected(e, r) {
      throw this.raise(M.UnexpectedToken, e ?? this.state.startLoc, {
        expected: r ? ci(r) : null
      });
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(M.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(M.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (r, s, i) => {
        this.raise(e, uo(r, s, i));
      };
    }
  }, Km = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, Wm = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Km());
    }
    exit() {
      let e = this.stack.pop(), r = this.current();
      for (let [s, i] of Array.from(e.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(s) || r.undefinedPrivateNames.set(s, i) : this.parser.raise(M.InvalidPrivateFieldResolution, i, {
          identifierName: s
        });
    }
    declarePrivateName(e, r, s) {
      let {
        privateNames: i,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = i.has(e);
      if (r & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = r & 4, f = u & 3, m = r & 3;
          l = f === m || c !== p, l || a.delete(e);
        } else l || a.set(e, r);
      }
      l && this.parser.raise(M.PrivateNameRedeclaration, s, {
        identifierName: e
      }), i.add(e), o.delete(e);
    }
    usePrivateName(e, r) {
      let s;
      for (s of this.stack)
        if (s.privateNames.has(e)) return;
      s ? s.undefinedPrivateNames.set(e, r) : this.parser.raise(M.InvalidPrivateFieldResolution, r, {
        identifierName: e
      });
    }
  }, Rn = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Xu = class extends Rn {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, r) {
      let s = r.index;
      this.declarationErrors.set(s, [e, r]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, Ym = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new Rn()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, r) {
      let s = r.loc.start, {
        stack: i
      } = this, a = i.length - 1, o = i[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, s);
        else
          return;
        o = i[--a];
      }
      this.parser.raise(e, s);
    }
    recordArrowParameterBindingError(e, r) {
      let {
        stack: s
      } = this, i = s[s.length - 1], a = r.loc.start;
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: r
      } = this, s = r.length - 1, i = r[s];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === 2 && i.recordDeclarationError(M.AwaitBindingIdentifier, e), i = r[--s];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, r = e[e.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([s, i]) => {
        this.parser.raise(s, i);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(i.index), o = e[--a];
      });
    }
  };
  function yue() {
    return new Rn(3);
  }
  n(yue, "newParameterDeclarationScope");
  function Tue() {
    return new Xu(1);
  }
  n(Tue, "newArrowHeadScope");
  function bue() {
    return new Xu(2);
  }
  n(bue, "newAsyncArrowScope");
  function hv() {
    return new Rn();
  }
  n(hv, "newExpressionScope");
  var Jm = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Wu(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(Wu, "functionFlags");
  var Xm = class extends Vm {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, r, s, i = !0) {
      if (!e) return;
      let a = e.extra = e.extra || {};
      i ? a[r] = s : Object.defineProperty(a, r, {
        enumerable: i,
        value: s
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, r) {
      let s = e + r.length;
      if (this.input.slice(e, s) === r) {
        let i = this.input.charCodeAt(s);
        return !(Bn(i) || (i & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return cv.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return Y1.lastIndex = this.state.end, Y1.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(M.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e);
    }
    tryParse(e, r = this.state.clone()) {
      let s = {
        node: null
      };
      try {
        let i = e((a = null) => {
          throw s.node = a, s;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: i,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: i,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (i) {
        let a = this.state;
        if (this.state = r, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (i === s)
          return {
            node: s.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw i;
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: s,
        doubleProtoLoc: i,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!s || !!i || !!o || !!a;
      if (!r)
        return l;
      s != null && this.raise(M.InvalidCoverInitializedName, s), i != null && this.raise(M.DuplicateProto, i), a != null && this.raise(M.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return rv(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let s = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let i = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new Jm();
      let u = this.classScope;
      this.classScope = new Wm(this);
      let c = this.expressionScope;
      return this.expressionScope = new Ym(this), () => {
        this.state.labels = r, this.exportedIdentifiers = s, this.inModule = i, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: r
      } = e;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, Fn = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Un = class {
    static {
      n(this, "Node");
    }
    constructor(e, r, s) {
      this.type = "", this.start = r, this.end = 0, this.loc = new jn(s), e != null && e.options.ranges && (this.range = [r, 0]), e != null &&
      e.filename && (this.loc.filename = e.filename);
    }
  }, uy = Un.prototype;
  uy.__clone = function() {
    let t = new Un(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let r = 0, s = e.length; r < s; r++) {
      let i = e[r];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
    }
    return t;
  };
  function xue(t) {
    return _s(t);
  }
  n(xue, "clonePlaceholder");
  function _s(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(uy);
    return u.type = e, u.start = r, u.end = s, u.loc = i, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(_s, "cloneIdentifier");
  function Sue(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return xue(t);
    let l = Object.create(uy);
    return l.type = e, l.start = r, l.end = s, l.loc = i, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n(Sue, "cloneStringLiteral");
  var $m = class extends Xm {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new Un(this, e.index, e);
    }
    startNodeAt(e) {
      return new Un(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, r, s) {
      return e.type = r, e.end = s.index, e.loc.end = s, this.options.ranges && (e.range[1] = s.index), this.options.attachComment && this.processComment(
      e), e;
    }
    resetStartLocation(e, r) {
      e.start = r.index, e.loc.start = r, this.options.ranges && (e.range[0] = r.index);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index);
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.loc.start);
    }
  }, gue = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), Oe = Ds`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: r
    }) => `Enum \`${t}\` has type \`${r}\`, so the initializer of \`${e}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${r}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function Pue(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(Pue, "isEsModuleType");
  function $1(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n($1, "hasTypeImportKind");
  var Eue = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function Aue(t, e) {
    let r = [], s = [];
    for (let i = 0; i < t.length; i++)
      (e(t[i], i, t) ? r : s).push(t[i]);
    return [r, s];
  }
  n(Aue, "partition");
  var vue = /\*?\s*@((?:no)?flow)\b/, Cue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Fm;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, s) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, s);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let s = vue.exec(r.value);
        if (s) if (s[1] === "flow")
          this.flowPragma = "flow";
        else if (s[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let i = this.flowParseType();
      return this.state.inType = s, i;
    }
    flowParsePredicate() {
      let r = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(Oe.UnexpectedSpaceBetweenModuloChecks,
      s), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let s = null, i = null;
      return this.match(54) ? (this.state.inType = r, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = r, this.
      match(54) && (i = this.flowParsePredicate())), [s, i];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let s = r.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
      this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return i.params = o.params, i.rest = o.rest, i.this = o._this, this.expect(11), [i.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      s), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (s && this.raise(Oe.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, s);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let s = r.body = this.startNode(), i = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Oe.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, Oe.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), i.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, o = !1;
      return i.forEach((l) => {
        Pue(l) ? (a === "CommonJS" && this.raise(Oe.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(Oe.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(Oe.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
        let i = this.state.value;
        throw this.raise(Oe.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: i,
          suggestion: Eue[i]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let s = this.flowParseTypeAlias(r);
      return s.type = "DeclareTypeAlias", s;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let s = this.flowParseOpaqueType(r, !0);
      return s.type = "DeclareOpaqueType", s;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, s) {
      if (r.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(r.id.name, s ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: s,
        allowExact: !1,
        allowSpread: !1,
        allowProto: s,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(Oe.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, s, i) {
      gue.has(r) && this.raise(i ? Oe.AssignReservedType : Oe.UnexpectedReservedType, s, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, s) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, s || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return i.name = o.name, i.variance = a, i.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) :
      r && this.raise(Oe.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = !1;
      do {
        let a = this.flowParseTypeParameter(i);
        s.params.push(a), a.default && (i = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), s = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), s = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, s, i) {
      return r.static = s, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = i, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, s) {
      return r.static = s, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, s) {
      let i = this.startNode();
      return r.static = s, r.value = this.flowParseObjectTypeMethodish(i), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: s,
      allowSpread: i,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, f = !1;
      for (s && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let y = !1, T = null, L = null, q = this.startNode();
        if (a && this.isContextual(118)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), T = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), y = !0);
        }
        let _ = this.flowParseVariance();
        if (this.eat(0))
          T != null && this.unexpected(T), this.eat(0) ? (_ && this.unexpected(_.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          q, y))) : u.indexers.push(this.flowParseObjectTypeIndexer(q, y, _));
        else if (this.match(10) || this.match(47))
          T != null && this.unexpected(T), _ && this.unexpected(_.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(q, y));
        else {
          let U = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let ie = this.lookahead();
            rv(ie.type) && (U = this.state.value, this.next());
          }
          let J = this.flowParseObjectTypeProperty(q, y, T, _, U, i, o ?? !p);
          J === null ? (f = !0, L = this.state.lastTokStartLoc) : u.properties.push(J);
        }
        this.flowObjectTypeSemicolon(), L && !this.match(8) && !this.match(9) && this.raise(Oe.UnexpectedExplicitInexactInObject, L);
      }
      this.expect(c), i && (u.inexact = f);
      let m = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, m;
    }
    flowParseObjectTypeProperty(r, s, i, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(Oe.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(Oe.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(Oe.InexactVariance, a), null) : (l || this.raise(
        Oe.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), a && this.raise(Oe.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = s, r.proto = i != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(Oe.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let s = r.kind === "get" ? 0 : 1, i = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? Oe.GetterMayNotHaveThisParam : Oe.SetterMayNotHaveThisParam, r.value.this), i !== s && this.
      raise(r.kind === "get" ? M.BadGetterArity : M.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(M.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, s) {
      var i;
      (i = r) != null || (r = this.state.startLoc);
      let a = s || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, s) {
      let i = this.startNodeAt(r);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(r, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let s = null, i = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(Oe.ThisParamMustBeFirst, o), s = this.parseIdentifier(u), this.eat(17) &&
      (i = !0, u && this.raise(Oe.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = s,
      o.optional = i, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let s = this.startNodeAt(r.loc.start);
      return s.name = null, s.optional = !1, s.typeAnnotation = r, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let s = null, i = null;
      for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: s,
        _this: i
      };
    }
    flowIdentToTypeAnnotation(r, s, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(r, i);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, s = this.startNode(), i, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), u.params =
          i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (ht(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(),
          u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(Oe.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (ay(this.state.type)) {
            let u = ci(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (ht(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, s = this.flowParsePrimaryType(), i = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        i = i || o, this.expect(0), !o && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = o, s = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(r.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(r)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.
        typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [s]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? s : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (r.types = [s]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? s : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let s = this.flowParseUnionType();
      return this.state.inType = r, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(r, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let s = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, s, i = !1) {
      if (s) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, i));
        return;
      }
      super.parseFunctionBody(r, !1, i);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, s, i);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let i = this.lookahead();
        if (zr(i.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      let s = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(r, s, i) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || ht(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ht(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(r);
          if (s.name === "type")
            return this.flowParseTypeAlias(r);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return W1(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return W1(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, s, i) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let m = this.lookaheadCharCode();
        if (m === 44 || m === 61 || m === 58 || m === 41)
          return this.setOptionalParametersError(i), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(s), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, f] = this.getArrowLikeExpressions(u);
      if (c || f.length > 0) {
        let m = [...o];
        if (f.length > 0) {
          this.state = a, this.state.noArrowAt = m;
          for (let y = 0; y < f.length; y++)
            m.push(f[y].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, f] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(Oe.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, m.push(p[0].start),
        this.state.noArrowAt = m, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: s
      };
    }
    getArrowLikeExpressions(r, s) {
      let i = [r], a = [];
      for (; i.length !== 0; ) {
        let o = i.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), i.push(o.body)) : o.type === "ConditionalExpression" && (i.push(o.consequent), i.push(o.alternate));
      }
      return s ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : Aue(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var s;
      this.toAssignableList(r.params, (s = r.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, s) {
      let i;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i =
      s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
    }
    parseParenItem(r, s) {
      let i = super.parseParenItem(r, s);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = i, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return i;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        s);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: s
      } = this.state, i = super.maybeParseExportNamespaceSpecifier(r);
      return i && r.exportKind === "type" && this.unexpected(s), i;
    }
    parseClassId(r, s, i) {
      super.parseClassId(r, s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, s, i) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, s))
          return;
        s.declare = !0;
      }
      super.parseClassMember(r, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "Property\
Definition" ? this.raise(Oe.DeclareClassElement, a) : s.value && this.raise(Oe.DeclareClassFieldInitializer, s.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), s = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(M.InvalidIdentifier, this.state.curPosition(), {
        identifierName: s
      }), this.finishToken(132, s);
    }
    getTokenFromCode(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : oue(r, s, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, s) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      !s && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, s);
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    toReferencedList(r, s) {
      for (let a = 0; a < r.length; a++) {
        var i;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((i = o.extra) != null && i.parenthesized) && (r.length > 1 || !s) && this.raise(Oe.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return s && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, s, i) {
      return r === "TypeCastExpression" || super.isValidLVal(r, s, i);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, s, i, a, o, l), s.params && o) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Oe.ThisParamBannedInConstructor, s);
      } else if (s.type === "MethodDefinition" && o && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(Oe.ThisParamBannedInConstructor, s);
      }
    }
    pushClassPrivateMethod(r, s, i, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, s, i, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let s = r.implements = [];
        do {
          let i = this.startNode();
          i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.
          typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let s = this.getObjectOrClassMethodParams(r);
      if (s.length > 0) {
        let i = s[0];
        this.isThisParam(i) && r.kind === "get" ? this.raise(Oe.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(Oe.SetterMayNotHaveThisParam,
        i);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, s, i, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(Oe.PatternIsOptional, r), this.isThisParam(r) && this.raise(Oe.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(Oe.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(Oe.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Oe.TypeBeforeInitializer,
      i.typeAnnotation), i;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Oe.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, s, i) {
      s.local = $1(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(s,
      i));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let s = this.lookaheadCharCode();
        return s === 123 || s === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      if (super.applyImportPhase(r, s, i, a), s) {
        if (!i && this.match(65))
          return;
        r.exportKind = i === "type" ? i : "value";
      } else
        i === "type" && this.match(55) && this.unexpected(), r.importKind = i === "type" || i === "typeof" ? i : "value";
    }
    parseImportSpecifier(r, s, i, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let f = this.parseIdentifier(!0);
        u !== null && !zr(this.state.type) ? (r.imported = f, r.importKind = u, r.local = _s(f)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && zr(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (s)
            throw this.raise(M.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = _s(r.imported));
      }
      let p = $1(r);
      return i && p && this.raise(Oe.ImportTypeShorthandOnlyInPureImport, r), (i || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !i && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, s) {
      let i = r.kind;
      i !== "get" && i !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      if (this.match(14)) {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
      }
      return super.parseAsyncArrowFromCallExpression(r, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, s) {
      var i;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, s), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === gt.j_oTag || p === gt.j_expr) && c.pop();
      }
      if ((i = o) != null && i.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((m) => {
          var y;
          c = this.flowParseTypeParameterDeclaration();
          let T = this.forwardNoArrowParamsConversionAt(c, () => {
            let q = super.parseMaybeAssign(r, s);
            return this.resetStartLocationFromNode(q, c), q;
          });
          (y = T.extra) != null && y.parenthesized && m();
          let L = this.maybeUnwrapTypeCastExpression(T);
          return L.type !== "ArrowFunctionExpression" && m(), L.typeParameters = c, this.resetStartLocationFromNode(L, c), T;
        }, a), f = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(Oe.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          f = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (f)
          return this.state = p.failState, f;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(Oe.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let i = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown) return null;
        s.error && (this.state = s.failState), r.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, s) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = s : super.setArrowFunctionParameters(r, s);
    }
    checkParams(r, s, i, a = !0) {
      if (!(i && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(Oe.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, s, i, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, s, i) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, s, i), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, s, i);
    }
    parseSubscript(r, s, i, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, i)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(s);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(s);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      s;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let s = this.startNodeAt(r);
      if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, s) {
      let i = super.parseTopLevel(r, s);
      return this.state.hasFlowComment && this.raise(Oe.UnterminatedFlowComment, this.state.curPosition()), i;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(Oe.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + s)); )
        s++;
      let i = this.input.charCodeAt(s + r), a = this.input.charCodeAt(s + r + 1);
      return i === 58 && a === 58 ? s + 2 : this.input.slice(s + r, s + r + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(M.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: s,
      memberName: i
    }) {
      this.raise(Oe.EnumBooleanMemberNotInitialized, r, {
        memberName: i,
        enumName: s
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? Oe.EnumInvalidMemberInitializerSymbolType : Oe.EnumInvalidMemberInitializerPrimaryType :
      Oe.EnumInvalidMemberInitializerUnknownType, r, s);
    }
    flowEnumErrorNumberMemberNotInitialized(r, s) {
      this.raise(Oe.EnumNumberMemberNotInitialized, r, s);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, s) {
      this.raise(Oe.EnumStringMemberInconsistentlyInitialized, r, s);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, s = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let i = this.parseNumericLiteral(this.state.value);
          return s() ? {
            type: "number",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let i = this.parseStringLiteral(this.state.value);
          return s() ? {
            type: "string",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let i = this.parseBooleanLiteral(this.match(85));
          return s() ? {
            type: "boolean",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, s = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: s,
        init: i
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, s, i) {
      let {
        explicitType: a
      } = s;
      a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(r, s);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: s
    }) {
      let i = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(Oe.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), i.has(p) && this.raise(Oe.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), i.add(p);
        let f = {
          enumName: r,
          explicitType: s,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, f);
          case "none":
            switch (s) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, f);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, f);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, s, {
      enumName: i
    }) {
      if (r.length === 0)
        return s;
      if (s.length === 0)
        return r;
      if (s.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return s;
      } else {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ht(this.state.type))
        throw this.raise(Oe.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: s
      } = this.state;
      return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(Oe.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: s
      }), s;
    }
    flowEnumBody(r, s) {
      let i = s.name, a = s.loc.start, o = this.flowEnumParseExplicitType({
        enumName: i
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: i,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, f = l.numberMembers.length, m = l.stringMembers.length, y = l.defaultedMembers.length;
          if (!p && !f && !m && !y)
            return c();
          if (!p && !f)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: i
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!f && !m && p >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !m && f >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(Oe.EnumInconsistentMemberValues, a, {
              enumName: i
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let s = this.parseIdentifier();
      return r.id = s, r.body = this.flowEnumBody(this.startNode(), s), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let s = this.input.charCodeAt(r + 1);
        return s !== 60 && s !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), Iue = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, Yi = Ds`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function ui(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(ui, "isFragment");
  function Mn(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Mn(t.object) + "." + Mn(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(Mn, "getQualifiedJSXName");
  var wue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Yi.UnterminatedJsxContent, this.state.startLoc);
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
              return;
            }
            r += this.input.slice(s, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(s, this.state.pos), r += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            fo(i) ? (r += this.input.slice(s, this.state.pos), r += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let s = this.input.charCodeAt(this.state.pos), i;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = r ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
    }
    jsxReadString(r) {
      let s = "", i = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(M.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : fo(a) ? (s += this.input.slice(
        i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let i = this.readInt(s, void 0, !1, "bail");
        if (i !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(i);
      } else {
        let s = 0, i = !1;
        for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (i) {
          let a = this.input.slice(r, this.state.pos), o = Iue[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, s = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (Bn(r) || r === 45);
      this.finishToken(140, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : ay(this.state.type) ? r.name = ci(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14)) return s;
      let i = this.startNodeAt(r);
      return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let i = this.startNodeAt(r);
        i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(gt.brace), this.next(), r = this.jsxParseExpressionContainer(r, gt.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(Yi.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Yi.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(gt.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, s) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let i = this.parseExpression();
        r.expression = i;
      }
      return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(gt.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      gt.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      s));
    }
    jsxParseOpeningElementAfterName(r) {
      let s = [];
      for (; !this.match(56) && !this.match(143); )
        s.push(this.jsxParseAttribute());
      return r.attributes = s, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      s, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let s = this.startNodeAt(r), i = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              i.push(this.jsxParseElementAt(r));
              break;
            case 141:
              i.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(gt.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(l)) : i.push(this.jsxParseExpressionContainer(
              l, gt.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        ui(a) && !ui(o) && o !== null ? this.raise(Yi.MissingClosingTagFragment, o) : !ui(a) && ui(o) ? this.raise(Yi.MissingClosingTagElement,
        o, {
          openingTagName: Mn(a.name)
        }) : !ui(a) && !ui(o) && Mn(o.name) !== Mn(a.name) && this.raise(Yi.MissingClosingTagElement, o, {
          openingTagName: Mn(a.name)
        });
      }
      if (ui(a) ? (s.openingFragment = a, s.closingFragment = o) : (s.openingElement = a, s.closingElement = o), s.children = i, this.match(
      47))
        throw this.raise(Yi.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return ui(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: s
      } = this.state;
      s[s.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let s = this.curContext();
      if (s === gt.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === gt.j_oTag || s === gt.j_cTag) {
        if (ks(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && s === gt.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: s,
        type: i
      } = this.state;
      if (i === 56 && r === 142)
        s.splice(-2, 2, gt.j_cTag), this.state.canStartJSXElement = !1;
      else if (i === 142)
        s.push(gt.j_oTag);
      else if (i === 143) {
        let a = s[s.length - 1];
        a === gt.j_oTag && r === 56 || a === gt.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === gt.j_expr) : (this.setContext(
        gt.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = Yle(i);
    }
  }, "jsx"), Hm = class extends ho {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, zm = class extends mo {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new Hm(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, r) {
      let s = this.importsStack.length;
      if (this.importsStack[s - 1].has(e))
        return !0;
      if (!r && s > 1) {
        for (let i = 0; i < s - 1; i++)
          if (this.importsStack[i].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, r, s) {
      if (r & 4096) {
        this.hasImport(e, !0) && this.parser.raise(M.VarRedeclaration, s, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let i = this.currentScope(), a = i.tsNames.get(e) || 0;
      if (r & 1024) {
        this.maybeExportDefined(i, e), i.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, r, s), r & 2 && (r & 1 || (this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && i.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, r, s) {
      let i = e.tsNames.get(r);
      if ((i & 2) > 0) {
        if (s & 256) {
          let a = !!(s & 512), o = (i & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return s & 128 && (i & 8) > 0 ? e.names.get(r) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(e, r, s);
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      if (this.hasImport(r)) return;
      let s = this.scopeStack.length;
      for (let i = s - 1; i >= 0; i--) {
        let o = this.scopeStack[i].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, Nue = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn$1"), dv = /* @__PURE__ */ n((t) => t.type === "Parenthesiz\
edExpression" ? dv(t.expression) : t, "unwrapParenthesizedExpression"), Gm = class extends $m {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, r = !1) {
      var s, i;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (s = e.extra) != null && s.parenthesized) && (a = dv(e), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(M.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(M.InvalidParenthesizedAssignment, e) : this.raise(M.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], f = l === c;
            this.toAssignableObjectExpressionProp(p, f, r), f && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(M.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(M.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, r, s) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? M.PatternHasAccessor : M.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let i = e.argument;
        this.checkToRestConversion(i, !1), this.toAssignable(i, s), r || this.raise(M.RestTrailingComma, e);
      } else
        this.toAssignable(e, s);
    }
    toAssignableList(e, r, s) {
      let i = e.length - 1;
      for (let a = 0; a <= i; a++) {
        let o = e[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, s);
          } else
            this.toAssignable(o, s);
          o.type === "RestElement" && (a < i ? this.raise(M.RestTrailingComma, o) : r && this.raise(M.RestTrailingComma, r));
        }
      }
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let s = e.properties.length - 1;
          return e.properties.every((i, a) => i.type !== "ObjectMethod" && (a === s || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((s) => s === null || this.isAssignable(s));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(e, r) {
      return e;
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r);
      for (let s of e)
        s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
    }
    parseSpread(e) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, r, s) {
      let i = s & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), i && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(r)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(M.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(s, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: r
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let s = this.startNode();
      return e === 138 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), s.key = this.parsePrivateName()) :
      this.parsePropertyName(s), s.method = !1, this.parseObjPropValue(s, r, !1, !1, !0, !1);
    }
    parseAssignableListItem(e, r) {
      let s = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s, e);
      let i = this.parseMaybeDefault(s.loc.start, s);
      return r.length && (s.decorators = r), i;
    }
    parseAssignableListItemTypes(e, r) {
      return e;
    }
    parseMaybeDefault(e, r) {
      var s, i;
      if ((s = e) != null || (e = this.state.startLoc), r = (i = r) != null ? i : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(e);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(e, r, s) {
      return Nue({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, {
      in: r,
      binding: s = 64,
      checkClashes: i = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), r.type !== "AssignmentExpression" && this.raise(M.InvalidLhsOptionalChaining,
        e, {
          ancestor: r
        })), s !== 64 && this.raise(M.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, s, a);
        let {
          name: T
        } = e;
        i && (i.has(T) ? this.raise(M.ParamDupe, e) : i.add(T));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", s);
      if (p === !0) return;
      if (p === !1) {
        let T = s === 64 ? M.InvalidLhs : M.InvalidLhsBinding;
        this.raise(T, e, {
          ancestor: r
        });
        return;
      }
      let [f, m] = Array.isArray(p) ? p : [p, u === "ParenthesizedExpression"], y = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let T of [].concat(e[f]))
        T && this.checkLVal(T, {
          in: y,
          binding: s,
          checkClashes: i,
          strictModeChanged: a,
          hasParenthesizedAncestor: m
        });
    }
    checkIdentifier(e, r, s = !1) {
      this.state.strict && (s ? lv(e.name, this.inModule) : ov(e.name)) && (r === 64 ? this.raise(M.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(M.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), r & 8192 && e.name === "let" && this.raise(M.LetInLexicalBinding, e), r & 64 || this.declareNameFromIdentifier(e, r);
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start);
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(M.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? M.RestTrailingComma : M.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, Oue = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn");
  function kue(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(kue, "nonNull");
  function H1(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(H1, "assert");
  var ye = Ds`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function Due(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(Due, "keywordTypeFromName");
  function z1(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(z1, "tsIsAccessModifier");
  function _ue(t) {
    return t === "in" || t === "out";
  }
  n(_ue, "tsIsVarianceAnnotations");
  var Lue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ye.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ye.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ye.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return zm;
    }
    tsIsIdentifier() {
      return ht(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, s) {
      if (!ht(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let i = this.state.value;
      if (r.indexOf(i) !== -1) {
        if (s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return i;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: s,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: a = ye.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, f, m) => {
        p === f && o[m] && this.raise(ye.InvalidModifiersOrder, c, {
          orderedModifiers: [f, m]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, f, m) => {
        (o[f] && p === m || o[m] && p === f) && this.raise(ye.IncompatibleModifiers, c, {
          modifiers: [f, m]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(s ?? []), i);
        if (!p) break;
        z1(p) ? o.accessibility ? this.raise(ye.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : _ue(p) ? (o[p] && this.raise(ye.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(ye.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), s != null && s.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, s) {
      let i = [];
      for (; !this.tsIsListTerminator(r); )
        i.push(s());
      return i;
    }
    tsParseDelimitedList(r, s, i) {
      return kue(this.tsParseDelimitedListWorker(r, s, !0, i));
    }
    tsParseDelimitedListWorker(r, s, i, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = s();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        i && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, s, i, a, o) {
      a || (i ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, s, o);
      return i ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(ye.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let s = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let i = this.startNodeAtNode(s);
        i.left = s, i.right = this.parseIdentifier(r), s = this.finishNode(i, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let s = this.startNodeAtNode(r);
      return s.parameterName = r, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let s = this.startNode();
      return r(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(
      29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let s = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = {
        value: -1
      };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, i), s.params.
      length === 0 && this.raise(ye.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, s) {
      let i = r === 19, a = "parameters", o = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(),
      i ? s[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (s[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let s of r) {
        let {
          type: i
        } = s;
        (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(ye.UnsupportedSignatureParameterKind, s, {
          type: i
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ht(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), r.parameters = [s];
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, s) {
      this.eat(17) && (r.optional = !0);
      let i = r;
      if (this.match(10) || this.match(47)) {
        s && this.raise(ye.ReadonlyForMethodSignature, r);
        let a = i;
        a.kind && this.match(47) && this.raise(ye.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(M.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(ye.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(M.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(ye.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(ye.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            ye.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(ye.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = i;
        s && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let i = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let s = this.tsTryParseIndexSignature(r);
      return s || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let s = !1;
      return r.elementTypes.forEach((i) => {
        let {
          type: a
        } = i;
        s && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && i.optional) && this.raise(ye.OptionalTypeBeforeRequired,
        i), s || (s = a === "TSNamedTupleMember" && i.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, s = this.eat(21), i, a, o, l, c = zr(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        i = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let p = this.state.startLoc, f = this.state.value, m = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (i = !0, a = this.createIdentifier(this.startNodeAt(p), f), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (i = !1, l = m, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), i = this.eat(14);
      if (i) {
        let p;
        a ? (p = this.startNodeAtNode(a), p.optional = o, p.label = a, p.elementType = l, this.eat(17) && (p.optional = !0, this.raise(ye.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (p = this.startNodeAtNode(l), p.optional = o, this.raise(ye.InvalidTupleMemberLabel, l), p.label = l,
        p.elementType = this.tsParseType()), l = this.finishNode(p, "TSNamedTupleMember");
      } else if (o) {
        let p = this.startNodeAtNode(l);
        p.typeAnnotation = l, l = this.finishNode(p, "TSOptionalType");
      }
      if (s) {
        let p = this.startNodeAt(r);
        p.typeAnnotation = l, l = this.finishNode(p, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, s) {
      let i = this.startNode();
      return r === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, i)), this.finishNode(i, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), s = this.lookahead();
            return s.type !== 134 && s.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ht(r) || r === 88 || r === 84) {
            let s = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : Due(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let i = this.startNode();
              return this.next(), this.finishNode(i, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAtNode(r);
          s.elementType = r, this.expect(3), r = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAtNode(r);
          s.objectType = r, s.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(s, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), s = this.state.value;
      return this.next(), r.operator = s, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ye.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(s, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Gle(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, s, i) {
      let a = this.startNode(), o = this.eat(i), l = [];
      do
        l.push(s());
      while (this.eat(i));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ht(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === s;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === s;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(r);
        let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i,
          "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
        let l = this.tsParseTypeAnnotation(!1);
        return i.parameterName = o, i.typeAnnotation = l, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(
        s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ht(this.state.type) && !this.match(78) ? !1 : (r && this.raise(M.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, s = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      H1(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let s = this.startNodeAtNode(r);
      return s.checkType = r, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ye.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return i.length || this.raise(ye.EmptyHeritageClauseType, s, {
        token: r
      }), i;
    }
    tsParseInterfaceDeclaration(r, s = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), s.declare && (r.declare = !0), ht(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(ye.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let i = this.startNode();
      return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return r();
      } finally {
        this.state.context = s;
      }
    }
    tsInType(r) {
      let s = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, s = {}) {
      return s.const && (r.const = !0), s.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, s = !1) {
      if (r.id = this.parseIdentifier(), s || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let i = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(i, !0), r.body = i;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, s, i) {
      r.isExport = i || !1, r.id = s || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(ye.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let s = this.state.clone(), i = r();
      return this.state = s, i;
    }
    tsTryParseAndCatch(r) {
      let s = this.tryParse((i) => r() || i());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(r) {
      let s = this.state.clone(), i = r();
      if (i !== void 0 && i !== !1)
        return i;
      this.state = s;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type, i;
      return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
        switch (s) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, i || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (ht(s))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, s, i) {
      switch (s.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, s.name, !1, i);
      }
    }
    tsParseDeclaration(r, s, i, a) {
      switch (s) {
        case "abstract":
          if (this.tsCheckLineTerminator(i) && (this.match(80) || ht(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(i)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ht(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(i) && ht(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(i) && ht(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let i = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!i)
        return super.parseArrowExpression(i, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(ye.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      gt.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Qle(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, s) {
      let i = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(ye.UnexpectedParameterModifier, i);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let f = this.startNodeAt(i);
        return s.length && (f.decorators = s), o && (f.accessibility = o), u && (f.readonly = u), l && (f.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(ye.UnsupportedParameterPropertyKind, f), f.parameter = p, this.finishNode(f, "TSParamet\
erProperty");
      }
      return s.length && (c.decorators = s), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let s of r.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(ye.PatternIsOptional, s);
    }
    setArrowFunctionParameters(r, s, i) {
      super.setArrowFunctionParameters(r, s, i), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(ye.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, i) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, s, i));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((s) => {
        s?.type === "TSTypeCastExpression" && this.raise(ye.UnexpectedTypeAnnotation, s.typeAnnotation);
      });
    }
    toReferencedList(r, s) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, s, i, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(s);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(r)) {
            let m = this.tsTryParseGenericAsyncArrowFunction(s);
            if (m)
              return m;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (Ju(this.state.type)) {
            let m = super.parseTaggedTemplateExpression(r, s, a);
            return m.typeParameters = c, m;
          }
          if (!i && this.eat(10)) {
            let m = this.startNodeAt(s);
            return m.callee = r, m.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(m.arguments), m.typeParameters =
            c, a.optionalChainMember && (m.optional = o), this.finishCallExpression(m, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && Lm(p) && !this.hasPrecedingLineBreak())
            return;
          let f = this.startNodeAt(s);
          return f.expression = r, f.typeParameters = c, this.finishNode(f, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          ye.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      var s;
      super.parseNewCallee(r);
      let {
        callee: i
      } = r;
      i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (r.typeParameters = i.typeParameters, r.callee =
      i.expression);
    }
    parseExprOp(r, s, i) {
      let a;
      if (Vu(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(s);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(M.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, s, i);
      }
      return super.parseExprOp(r, s, i);
    }
    checkReservedWord(r, s, i, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, s, i, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ye.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let s = this.lookaheadCharCode();
        return r ? s === 123 || s === 42 : s !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      super.applyImportPhase(r, s, i, a), s ? r.exportKind = i === "type" ? "type" : "value" : r.importKind = i === "type" || i === "typeof" ?
      i : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let s;
      if (ht(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let i = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, i);
        s = super.parseImportSpecifiersAndAfter(r, i);
      } else
        s = super.parseImport(r);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ye.TypeImportCannotSpecifyDefaultAndNamed,
      s), s;
    }
    parseExport(r, s) {
      if (this.match(83)) {
        this.next();
        let i = r, a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(i, !1) : i.importKind = "value", this.
        tsParseImportEqualsDeclaration(i, a, !0);
      } else if (this.eat(29)) {
        let i = r;
        return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let i = r;
        return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, s);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, s, i = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, s, i || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (s !== "const" || l.typeAnnotation ? this.raise(ye.InitializerNotAllowedInAmbientContext, u) : Bue(u, this.hasPlugin("estree")) ||
        this.raise(ye.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, s) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let i = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(i, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i) return i;
      }
      return super.parseStatementContent(r, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, s) {
      return s.some((i) => z1(i) ? r.accessibility === i : !!r[i]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, s, i) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: ye.InvalidModifierOnTypeParameterPositions
      }, s);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(ye.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, s)) : this.parseClassMemberWithIsStatic(r, s, i, !!s.static);
      }, "callParseClassMemberWithIsStatic");
      s.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, s, i, a) {
      let o = this.tsTryParseIndexSignature(s);
      if (o) {
        r.body.push(o), s.abstract && this.raise(ye.IndexSignatureHasAbstract, s), s.accessibility && this.raise(ye.IndexSignatureHasAccessibility,
        s, {
          modifier: s.accessibility
        }), s.declare && this.raise(ye.IndexSignatureHasDeclare, s), s.override && this.raise(ye.IndexSignatureHasOverride, s);
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(ye.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.
      raise(ye.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(r, s, i, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(ye.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(ye.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, s, i) {
      return (s.type === "Identifier" ? this.tsParseExpressionStatement(r, s, i) : void 0) || super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, s, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, s, i);
      let a = this.tryParse(() => super.parseConditional(r, s));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), r);
    }
    parseParenItem(r, s) {
      let i = super.parseParenItem(r, s);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let s = this.state.startLoc, i = this.eatContextual(125);
      if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(ye.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ht(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || i) && (r.exportKind = "type"), i && (this.resetStartLocation(
      o, s), o.declare = !0), o) : null;
    }
    parseClassId(r, s, i, a) {
      if ((!s || i) && this.isContextual(113))
        return;
      super.parseClassId(r, s, i, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let s = this.tsTryParseTypeAnnotation();
      s && (r.typeAnnotation = s);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(ye.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: s
        } = r;
        this.raise(ye.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: s.type === "Identifier" && !r.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(ye.PrivateElementHasAbstract, r), r.accessibility && this.raise(ye.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(ye.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(ye.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = s;
      c && (p === "get" || p === "set") && this.raise(ye.DeclareAccessor, s, {
        kind: p
      }), u && (s.typeParameters = u), super.pushClassMethod(r, s, i, a, o, l);
    }
    pushClassPrivateMethod(r, s, i, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (s.typeParameters = o), super.pushClassPrivateMethod(r, s, i, a);
    }
    declareClassPrivateMethodInScope(r, s) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(
      r, s));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, s, i, a, o, l, u);
    }
    parseFunctionParams(r, s) {
      let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      i && (r.typeParameters = i), super.parseFunctionParams(r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let i = this.tsTryParseTypeAnnotation();
      i && (r.id.typeAnnotation = i, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, s);
    }
    parseMaybeAssign(r, s) {
      var i, a, o, l, u;
      let c, p, f;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, s), c), !p.error) return p.node;
        let {
          context: T
        } = this.state, L = T[T.length - 1];
        (L === gt.j_oTag || L === gt.j_expr) && T.pop();
      }
      if (!((i = p) != null && i.error) && !this.match(47))
        return super.parseMaybeAssign(r, s);
      (!c || c === this.state) && (c = this.state.clone());
      let m, y = this.tryParse((T) => {
        var L, q;
        m = this.tsParseTypeParameters(this.tsParseConstModifier);
        let _ = super.parseMaybeAssign(r, s);
        return (_.type !== "ArrowFunctionExpression" || (L = _.extra) != null && L.parenthesized) && T(), ((q = m) == null ? void 0 : q.params.
        length) !== 0 && this.resetStartLocationFromNode(_, m), _.typeParameters = m, _;
      }, c);
      if (!y.error && !y.aborted)
        return m && this.reportReservedArrowTypeParam(m), y.node;
      if (!p && (H1(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, s), c), !f.error))
        return f.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (y.node)
        return this.state = y.failState, m && this.reportReservedArrowTypeParam(m), y.node;
      if ((o = f) != null && o.node)
        return this.state = f.failState, f.node;
      throw ((l = p) == null ? void 0 : l.error) || y.error || ((u = f) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var s;
      r.params.length === 1 && !r.params[0].constraint && !((s = r.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(ye.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse((i) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
        });
        if (s.aborted) return;
        s.thrown || (s.error && (this.state = s.failState), r.returnType = s.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, s) {
      if (!(s & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, s) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, s);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, s);
      }
    }
    toAssignable(r, s = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(ye.UnexpectedTypeCastInParameter, r) : this.raise(ye.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, s);
          break;
        case "AssignmentExpression":
          !s && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, s);
      }
    }
    toAssignableParenthesizedExpression(r, s) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, s);
          break;
        default:
          super.toAssignable(r, s);
      }
    }
    checkToRestConversion(r, s) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, s);
      }
    }
    isValidLVal(r, s, i) {
      return Oue({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSInstantiationExpression: "expression",
        TSAsExpression: (i !== 64 || !s) && ["expression", !0],
        TSSatisfiesExpression: (i !== 64 || !s) && ["expression", !0],
        TSTypeAssertion: (i !== 64 || !s) && ["expression", !0]
      }, r) || super.isValidLVal(r, s, i);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let i = super.parseMaybeDecoratorArguments(r);
          return i.typeParameters = s, i;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(ye.TypeAnnotationAfterAssign,
      i.typeAnnotation), i;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (r.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let s = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let s = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = s;
      }
    }
    parseClass(r, s, i) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, s, i);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, s) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(ye.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, s, i, a, o, l, u) {
      let c = super.parseMethod(r, s, i, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: f
        } = c;
        this.raise(ye.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, s, i, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, i), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, s, i, a));
    }
    parseImportSpecifier(r, s, i, a, o) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, i), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, s, i, a, i ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, s, i) {
      let a = s ? "imported" : "local", o = s ? "local" : "exported", l = r[a], u, c = !1, p = !0, f = l.loc.start;
      if (this.isContextual(93)) {
        let y = this.parseIdentifier();
        if (this.isContextual(93)) {
          let T = this.parseIdentifier();
          zr(this.state.type) ? (c = !0, l = y, u = s ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = T, p = !1);
        } else zr(this.state.type) ? (p = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = y);
      } else zr(this.state.type) && (c = !0, s ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && i && this.raise(s ? ye.TypeModifierIsUsedInTypeImports : ye.TypeModifierIsUsedInTypeExports, f), r[a] = l, r[o] = u;
      let m = s ? "importKind" : "exportKind";
      r[m] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = s ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = _s(r[a])), s && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function Mue(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: r
    } = t;
    return e && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : yv(t.object);
  }
  n(Mue, "isPossiblyLiteralEnum");
  function Bue(t, e) {
    var r;
    let {
      type: s
    } = t;
    if ((r = t.extra) != null && r.parenthesized)
      return !1;
    if (e) {
      if (s === "Literal") {
        let {
          value: i
        } = t;
        if (typeof i == "string" || typeof i == "boolean")
          return !0;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return !0;
    return !!(mv(t, e) || Fue(t, e) || s === "TemplateLiteral" && t.expressions.length === 0 || Mue(t));
  }
  n(Bue, "isValidAmbientConstInitializer");
  function mv(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(mv, "isNumber");
  function Fue(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: r,
        argument: s
      } = t;
      if (r === "-" && mv(s, e))
        return !0;
    }
    return !1;
  }
  n(Fue, "isNegativeNumber");
  function yv(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : yv(t.object);
  }
  n(yv, "isUncomputedMemberExpressionChain");
  var G1 = Ds`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), jue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        s, r);
      }
    }
    finishPlaceholder(r, s) {
      let i = r;
      return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, s, i, a) {
      r !== void 0 && super.checkReservedWord(r, s, i, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, s, i) {
      return r === "Placeholder" || super.isValidLVal(r, s, i);
    }
    toAssignable(r, s) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, s);
    }
    chStartsBindingIdentifier(r, s) {
      return !!(super.chStartsBindingIdentifier(r, s) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, s) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, s);
    }
    parseExpressionStatement(r, s) {
      var i;
      if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized)
        return super.parseExpressionStatement(r, s);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(s, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = s.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, s, i) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, s, i);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, s, i) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (i || !s)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(G1.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, s, i);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseExport(r, s);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = i, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(ci(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, s) {
      var i;
      return (i = r.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(r, s);
    }
    checkExport(r) {
      let {
        specifiers: s
      } = r;
      s != null && s.length && (r.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = s;
    }
    parseImport(r) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let i = this.startNodeAtNode(s);
      return i.local = s, r.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(G1.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), Rue = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, s = this.startNode();
        if (this.next(), ht(this.state.type)) {
          let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Kt(t, e) {
    let [r, s] = typeof e == "string" ? [e, {}] : e, i = Object.keys(s), a = i.length === 0;
    return t.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of i)
          if (u[c] !== s[c])
            return !1;
        return !0;
      }
    });
  }
  n(Kt, "hasPlugin");
  function Ji(t, e, r) {
    let s = t.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return s && Array.isArray(s) && s.length > 1 ? s[1][r] : null;
  }
  n(Ji, "getPluginOption");
  var Q1 = ["minimal", "fsharp", "hack", "smart"], Z1 = ["^^", "@@", "^", "%", "#"];
  function Uue(t) {
    if (Kt(t, "decorators")) {
      if (Kt(t, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let e = Ji(t, "decorators", "decoratorsBeforeExport");
      if (e != null && typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = Ji(t, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Kt(t, "flow") && Kt(t, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Kt(t, "placeholders") && Kt(t, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Kt(t, "pipelineOperator")) {
      let e = Ji(t, "pipelineOperator", "proposal");
      if (!Q1.includes(e)) {
        let i = Q1.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
      }
      let r = ["recordAndTuple", {
        syntaxType: "hash"
      }], s = Kt(t, r);
      if (e === "hack") {
        if (Kt(t, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Kt(t, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let i = Ji(t, "pipelineOperator", "topicToken");
        if (!Z1.includes(i)) {
          let a = Z1.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (i === "#" && s)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(r)}\
\`.`);
      } else if (e === "smart" && s)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(r)}\`.`);
    }
    if (Kt(t, "moduleAttributes")) {
      if (Kt(t, "importAssertions") || Kt(t, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (Ji(t, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Kt(t, "importAssertions") && Kt(t, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Kt(t, "recordAndTuple")) {
      let e = Ji(t, "recordAndTuple", "syntaxType");
      if (e != null) {
        let r = ["hash", "bar"];
        if (!r.includes(e))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + r.map((s) => `'${s}'`).join(", "));
      }
    }
    if (Kt(t, "asyncDoExpressions") && !Kt(t, "doExpressions")) {
      let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
    if (Kt(t, "optionalChainingAssign") && Ji(t, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(Uue, "validatePlugins");
  var Tv = {
    estree: qle,
    jsx: wue,
    flow: Cue,
    typescript: Lue,
    v8intrinsic: Rue,
    placeholders: jue
  }, que = Object.keys(Tv), km = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function Vue(t) {
    if (t == null)
      return Object.assign({}, km);
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let e = {};
    for (let s of Object.keys(km)) {
      var r;
      e[s] = (r = t[s]) != null ? r : km[s];
    }
    return e;
  }
  n(Vue, "getOptions");
  var Qm = class extends Gm {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, r, s, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      let a = e.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(M.RecordNoProto, a);
          return;
        }
        s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = a.loc.start) : this.raise(M.DuplicateProto, a)), s.used = !0;
      }
    }
    shouldExitDescending(e, r) {
      return e.type === "ArrowFunctionExpression" && e.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, r) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(e) {
      let r = this.state.startLoc, s = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let i = this.startNodeAt(r);
        for (i.expressions = [s]; this.eat(12); )
          i.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
      }
      return s;
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r));
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r));
    }
    setOptionalParametersError(e, r) {
      var s;
      e.optionalParametersLoc = (s = r?.loc) != null ? s : this.state.startLoc;
    }
    parseMaybeAssign(e, r) {
      let s = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, s)), l;
      }
      let i;
      e ? i = !1 : (e = new Fn(), i = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || ht(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(e);
      if (r && (o = r.call(this, o, s)), Jle(this.state.type)) {
        let l = this.startNodeAt(s), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = s.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= c && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= c && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else i && this.checkExpressionErrors(e, !0);
      return o;
    }
    parseMaybeConditional(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(e);
      return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, r, e);
    }
    parseConditional(e, r, s) {
      if (this.eat(17)) {
        let i = this.startNodeAt(r);
        return i.test = e, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(
        i, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, r, -1);
    }
    parseExprOp(e, r, s) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (s >= Vu(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(M.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let i = this.state.type;
      if ($le(i) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Vu(i);
        if (a > s) {
          if (i === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          let o = this.startNodeAt(r);
          o.left = e, o.operator = this.state.value;
          let l = i === 41 || i === 42, u = i === 40;
          if (u && (a = Vu(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(M.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(i, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(M.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, s);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, r) {
      let s = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(M.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), s);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, r);
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      let s = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, Zle(e) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: r
      } = this.state, s = this.parseMaybeAssign();
      return Mle.has(s.type) && !((e = s.extra) != null && e.parenthesized) && this.raise(M.PipeUnparenthesizedBody, r, {
        type: s.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(M.PipeTopicUnused, r), s;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(M.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, r) {
      let s = this.state.startLoc, i = this.isContextual(96);
      if (i && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(s);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (zle(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(M.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(M.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (i) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Lm(u) : Lm(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(M.AwaitNotInAsyncContext, s), this.parseAwait(s);
      }
      return l;
    }
    parseUpdate(e, r, s) {
      if (r) {
        let o = e;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), e;
      }
      let i = this.state.startLoc, a = this.parseExprSubscripts(s);
      if (this.checkExpressionErrors(s, !1)) return a;
      for (; Hle(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(i);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(e);
      return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, r);
    }
    parseSubscripts(e, r, s) {
      let i = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, r, s, i), i.maybeAsyncArrow = !1;
      while (!i.stop);
      return e;
    }
    parseSubscript(e, r, s, i) {
      let {
        type: a
      } = this.state;
      if (!s && a === 15)
        return this.parseBind(e, r, s, i);
      if (Ju(a))
        return this.parseTaggedTemplateExpression(e, r, i);
      let o = !1;
      if (a === 18) {
        if (s && (this.raise(M.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return i.stop = !0, e;
        i.optionalChainMember = o = !0, this.next();
      }
      if (!s && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, r, i, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, r, i, l, o) : (i.stop = !0, e);
      }
    }
    parseMember(e, r, s, i, a) {
      let o = this.startNodeAt(r);
      return o.object = e, o.computed = i, i ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (e.type === "Super" &&
      this.raise(M.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), s.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, r, s, i) {
      let a = this.startNodeAt(r);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, s);
    }
    parseCoverCallAndAsyncArrowHead(e, r, s, i) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = s;
      u && (this.expressionScope.enter(bue()), o = new Fn()), c && (l.optional = i), i ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r);
    }
    parseTaggedTemplateExpression(e, r, s) {
      let i = this.startNodeAt(r);
      return i.tag = e, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(M.OptionalChainingNoTemplate, r), this.finishNode(
      i, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(e, r) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), e.arguments.length === 0 ||
        e.arguments.length > 2)
          this.raise(M.ImportCallArity, e, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let s of e.arguments)
            s.type === "SpreadElement" && this.raise(M.ImportCallSpreadArgument, s);
      return this.finishNode(e, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, r, s, i, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          M.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, s));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var s;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(e, r.arguments, !0, (s = r.extra) == null ?
      void 0 : s.trailingCommaLoc), r.innerComments && yo(e, r.innerComments), r.callee.trailingComments && yo(e, r.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let r, s = null, {
        type: i
      } = this.state;
      switch (i) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(M.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          s = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(M.UnsupportedBind, a);
        }
        case 138:
          return this.raise(M.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          ks(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (ht(i)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ht(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      let s = this.getPluginOption("pipelineOperator", "proposal");
      if (s)
        return this.state.type = e, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = xr(this.state.endLoc, -1),
        this.parseTopicReference(s);
      this.unexpected();
    }
    parseTopicReference(e) {
      let r = this.startNode(), s = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(r, s, e, i);
    }
    finishTopicReference(e, r, s, i) {
      if (this.testTopicReferenceConfiguration(s, r, i)) {
        let a = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? M.PrimaryTopicNotAllowed : M.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(e, a);
      } else
        throw this.raise(M.PipeTopicUnconfiguredToken, r, {
          token: ci(i)
        });
    }
    testTopicReferenceConfiguration(e, r, s) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: ci(s)
          }]);
        case "smart":
          return s === 27;
        default:
          throw this.raise(M.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(Wu(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(M.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, r, !0);
    }
    parseDo(e, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), e.async = r, this.next();
      let s = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = s, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(M.SuperNotAllowed,
      e) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(M.UnexpectedSuper, e), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(M.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), r = this.startNodeAt(xr(this.state.startLoc, 1)), s = this.state.value;
      return this.next(), e.id = this.createIdentifier(r, s), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, r, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, r, s) {
      e.meta = r;
      let i = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== s || i) && this.raise(M.UnsupportedMetaProperty, e.property, {
        target: r.name,
        onlyValidPropertyName: s
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let r = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(M.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let s = this.isContextual(105);
        if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(M.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = s ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, r, "meta");
    }
    parseLiteralAtNode(e, r, s) {
      return this.addExtra(s, "rawValue", e), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = e, this.next(), this.
      finishNode(s, r);
    }
    parseLiteral(e, r) {
      let s = this.startNode();
      return this.parseLiteralAtNode(e, r, s);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let r = this.parseLiteral(e.value, "RegExpLiteral");
      return r.pattern = e.pattern, r.flags = e.flags, r;
    }
    parseBooleanLiteral(e) {
      let r = this.startNode();
      return r.value = e, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let r = this.state.startLoc, s;
      this.next(), this.expressionScope.enter(Tue());
      let i = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new Fn(), c = !0, p, f;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          f = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let T = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), T)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let m = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = a;
      let y = this.startNodeAt(r);
      return e && this.shouldParseArrow(l) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(y, l, !1), y) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), f && this.unexpected(f), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (s = this.startNodeAt(o), s.expressions = l, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s,
      m)) : s = l[0], this.wrapParenthesis(r, s));
    }
    wrapParenthesis(e, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", e.index), this.takeSurroundingComments(r, e.index, this.
        state.lastTokEndLoc.index), r;
      let s = this.startNodeAt(e);
      return s.expression = r, this.finishNode(s, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, r) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let s = this.parseMetaProperty(e, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(M.UnexpectedNewTarget,
        s), s;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), e.arguments = r;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let r = this.match(83), s = this.parseNoCallExpr();
      e.callee = s, r && (s.type === "Import" || s.type === "ImportExpression") && this.raise(M.ImportCallNotNewExpression, s);
    }
    parseTemplateElement(e) {
      let {
        start: r,
        startLoc: s,
        end: i,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(xr(s, 1));
      a === null && (e || this.raise(M.InvalidEscapeSequenceTemplate, xr(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = i + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let f = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(f, xr(this.state.lastTokEndLoc, c)), f;
    }
    parseTemplate(e) {
      let r = this.startNode(), s = this.parseTemplateElement(e), i = [s], a = [];
      for (; !s.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(e));
      return r.expressions = a, r.quasis = i, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(i), this.checkProto(p, s, o, i)), s && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(M.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(M.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let s = this.startNode(), i = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (s.decorators = r, r = []), s.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(s, e), !l && !u && this.maybeAsyncOrAccessorProp(s)) {
        let {
          key: c
        } = s, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        s)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), s.kind = p, this.match(55) && (l = !0, this.
        raise(M.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(s));
      }
      return this.parseObjPropValue(s, o, l, i, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var r;
      let s = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== s && this.raise(e.kind === "get" ? M.BadGetterArity : M.BadSetterArity, e), e.kind === "set" && ((r = i[i.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(M.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, r, s, i, a) {
      if (a) {
        let o = this.parseMethod(e, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (s || r || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, r, s, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, r, s, i) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), s)
          e.value = this.parseMaybeDefault(r, _s(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = a) : this.raise(M.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(r, _s(e.key));
        } else
          e.value = _s(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, r, s, i, a, o, l) {
      let u = this.parseObjectMethod(e, s, i, a, o) || this.parseObjectProperty(e, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, r) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: s,
          value: i
        } = this.state, a;
        if (zr(s))
          a = this.parseIdentifier(!0);
        else
          switch (s) {
            case 134:
              a = this.parseNumericLiteral(i);
              break;
            case 133:
              a = this.parseStringLiteral(i);
              break;
            case 135:
              a = this.parseBigIntLiteral(i);
              break;
            case 136:
              a = this.parseDecimalLiteral(i);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(M.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        e.key = a, s !== 138 && (e.computed = !1);
      }
    }
    initFunction(e, r) {
      e.id = null, e.generator = !1, e.async = r;
    }
    parseMethod(e, r, s, i, a, o, l = !1) {
      this.initFunction(e, s), e.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(Wu(s, e.generator)),
      this.parseFunctionParams(e, i);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !s, i, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, s ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, r, s, i) {
      this.scope.enter(6);
      let a = Wu(s, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, s);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, r, i)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, r, s) {
      this.toAssignableList(r, s, !1), e.params = r;
    }
    parseFunctionBodyAndFinish(e, r, s = !1) {
      return this.parseFunctionBody(e, !1, s), this.finishNode(e, r);
    }
    parseFunctionBody(e, r, s = !1) {
      let i = r && !this.match(5);
      if (this.expressionScope.enter(hv()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(M.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !r && !s && !u, r, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let r = 0, s = e.length; r < s; r++)
        if (!this.isSimpleParameter(e[r])) return !1;
      return !0;
    }
    checkParams(e, r, s, i = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: i
        });
    }
    parseExprList(e, r, s, i) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, s));
      }
      return a;
    }
    parseExprListItem(e, r, s) {
      let i;
      if (this.match(12))
        e || this.raise(M.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s || this.raise(M.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), i = this.finishNode(a, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      let r = this.startNode(), s = this.parseIdentifierName(e);
      return this.createIdentifier(r, s);
    }
    createIdentifier(e, r) {
      return e.name = r, e.loc.identifierName = r, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let r, {
        startLoc: s,
        type: i
      } = this.state;
      zr(i) ? r = this.state.value : this.unexpected();
      let a = Wle(i);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(r, s, a, !1), this.next(), r;
    }
    checkReservedWord(e, r, s, i) {
      if (e.length > 10 || !uue(e))
        return;
      if (s && aue(e)) {
        this.raise(M.UnexpectedKeyword, r, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? i ? lv : av : nv)(e, this.inModule)) {
        this.raise(M.UnexpectedReservedWord, r, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(M.YieldBindingIdentifier, r);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(M.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(M.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(M.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e) {
      let r = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(M.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(M.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || Ju(e) || e === 102 && !this.state.containsEsc || e === 137 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield() {
      let e = this.startNode();
      this.expressionScope.recordParameterInitializerError(M.YieldInParameter, e), this.next();
      let r = !1, s = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            s = this.parseMaybeAssign();
        }
      return e.delegate = r, e.argument = s, this.finishNode(e, "YieldExpression");
    }
    parseImportCall(e) {
      return this.next(), e.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(M.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(e, r) {
      if (this.isSimpleReference(e)) {
        let s = this.startNodeAt(r);
        return s.callee = e, this.finishNode(s, "PipelineBareFunction");
      } else {
        let s = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), s.expression = e, this.finishNode(s, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(M.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(M.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, e);
      return this.state.inFSharpPipelineDirectBody = s, i;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let s = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        s();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, Dm = {
    kind: 1
  }, Kue = {
    kind: 2
  }, Wue = /[\uD800-\uDFFF]/u, _m = /in(?:stanceof)?/y;
  function Yue(t, e) {
    for (let r = 0; r < t.length; r++) {
      let s = t[r], {
        type: i
      } = s;
      if (typeof i == "number") {
        {
          if (i === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = xr(a.start, 1);
            t.splice(r, 1, new ls({
              type: Ns(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }), new ls({
              type: Ns(132),
              value: l,
              start: c,
              end: u,
              startLoc: p,
              endLoc: a.end
            })), r++;
            continue;
          }
          if (Ju(i)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = xr(a.start, 1), f;
            e.charCodeAt(o) === 96 ? f = new ls({
              type: Ns(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }) : f = new ls({
              type: Ns(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            });
            let m, y, T, L;
            i === 24 ? (y = u - 1, T = xr(a.end, -1), m = l === null ? null : l.slice(1, -1), L = new ls({
              type: Ns(22),
              value: "`",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })) : (y = u - 2, T = xr(a.end, -2), m = l === null ? null : l.slice(1, -2), L = new ls({
              type: Ns(23),
              value: "${",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })), t.splice(r, 1, f, new ls({
              type: Ns(20),
              value: m,
              start: c,
              end: y,
              startLoc: p,
              endLoc: T
            }), L), r += 2;
            continue;
          }
        }
        s.type = Ns(i);
      }
    }
    return t;
  }
  n(Yue, "babel7CompatTokens");
  var Zm = class extends Qm {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, r) {
      return e.program = this.parseProgram(r), e.comments = this.comments, this.options.tokens && (e.tokens = Yue(this.tokens, this.input)),
      this.finishNode(e, "File");
    }
    parseProgram(e, r = 139, s = this.options.sourceType) {
      if (e.sourceType = s, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(M.ModuleExportUndefined, o, {
            localName: a
          });
      let i;
      return r === 139 ? i = this.finishNode(e, "Program") : i = this.finishNodeAt(e, "Program", xr(this.state.startLoc, -1)), i;
    }
    stmtToDirective(e) {
      let r = e;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let s = r.value, i = s.value, a = this.input.slice(s.start, s.end), o = s.value = a.slice(1, -1);
      return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", o), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, r) {
      if (ks(e)) {
        if (_m.lastIndex = r, _m.test(this.input)) {
          let s = this.codePointAtPos(_m.lastIndex);
          if (!Bn(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, e);
    }
    hasInLineFollowingBindingIdentifier() {
      let e = this.nextTokenInLineStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingIdentifier(r, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: r
      } = this.lookahead();
      if (e === 102 && !r)
        return !1;
      if (ht(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let r = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(r, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, e && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(e, r);
    }
    parseStatementContent(e, r) {
      let s = this.state.type, i = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (s) {
        case 60:
          return this.parseBreakContinueStatement(i, !0);
        case 63:
          return this.parseBreakContinueStatement(i, !1);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoWhileStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? M.StrictFunction : this.options.annexB ? M.SloppyFunctionAnnexB : M.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(i, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, i), !0);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(M.UnexpectedLexicalDeclaration, i) : this.raise(M.AwaitUsingNotInAsyncContext, i),
            this.next(), this.parseVarStatement(i, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(M.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(M.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), f = this.codePointAtPos(p);
          if (f !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, p) && f !== 123))
            break;
        }
        case 75:
          a || this.raise(M.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(i, p);
        }
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(M.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return s === 83 ? (p = this.parseImport(i), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (p = this.parseExport(i, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind ===
          "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(M.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return ht(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, c, e) : this.parseExpressionStatement(i, c,
      r);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(M.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, r, s) {
      return e && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(M.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...e)) : r.decorators = e, this.resetStartLocationFromNode(
      r, e[0]), s && this.resetStartLocationFromNode(s, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(M.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(M.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, s;
        if (this.match(10)) {
          let i = this.state.startLoc;
          this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          s && this.raise(M.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (s = this.parseIdentifier(!1); this.eat(16); ) {
            let i = this.startNodeAt(r);
            i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) :
            i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(e);
        return r.callee = e, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, r) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, r), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, r) {
      let s;
      for (s = 0; s < this.state.labels.length; ++s) {
        let i = this.state.labels[s];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (r || i.kind === 1) || e.label && r))
          break;
      }
      if (s === this.state.labels.length) {
        let i = r ? "BreakStatement" : "ContinueStatement";
        this.raise(M.IllegalBreakContinue, e, {
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(Dm), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(Dm);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(e, null);
      let s = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = s && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let f = this.startNode(), m;
          u ? (m = "await using", this.isAwaitAllowed() || this.raise(M.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : m =
          this.state.value, this.next(), this.parseVar(f, !0, m);
          let y = this.finishNode(f, "VariableDeclaration"), T = this.match(58);
          return T && c && this.raise(M.ForInUsing, y), (T || this.isContextual(102)) && y.declarations.length === 1 ? this.parseForIn(e, y,
          r) : (r !== null && this.unexpected(r), this.parseFor(e, y));
        }
      }
      let i = this.isContextual(95), a = new Fn(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (s && this.raise(M.ForOfLet, o), r === null && i && o.type === "Identifier" && this.raise(M.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(e, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(e, o);
    }
    parseFunctionStatement(e, r, s) {
      return this.next(), this.parseFunction(e, 1 | (s ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(M.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "Ret\
urnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let r = e.cases = [];
      this.expect(5), this.state.labels.push(Kue), this.scope.enter(0);
      let s;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          s && this.finishNode(s, "SwitchCase"), r.push(s = this.startNode()), s.consequent = [], this.next(), a ? s.test = this.parseExpression() :
          (i && this.raise(M.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
        } else
          s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(M.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        r, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(M.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, r, s = !1) {
      return this.next(), this.parseVar(e, !1, r, s), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(Dm), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(M.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, r, s, i) {
      for (let o of this.state.labels)
        o.name === r && this.raise(M.LabelRedeclaration, s, {
          labelName: r
        });
      let a = Xle(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), e.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      s, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, r, s) {
      return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, r = !0, s) {
      let i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(i, e, !1, 8, s), r && this.
      scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, r, s, i, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, s, i, a);
    }
    parseBlockOrModuleBlockBody(e, r, s, i, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(i); ) {
        let c = s ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, r) {
      return e.init = r, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, r, s) {
      let i = this.match(58);
      return this.next(), i ? s !== null && this.unexpected(s) : e.await = s !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!i || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(M.ForInOfLoopInitializer, r, {
        type: i ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(M.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = r, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, r, s, i = !1) {
      let a = e.declarations = [];
      for (e.kind = s; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, s), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !i && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(M.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(M.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: s
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, r) {
      let s = this.parseBindingAtom();
      this.checkLVal(s, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), e.id = s;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, r = 0) {
      let s = r & 2, i = !!(r & 1), a = i && !(r & 4), o = !!(r & 8);
      this.initFunction(e, o), this.match(55) && (s && this.raise(M.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), i && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Wu(o, e.generator)), i || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || ht(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, r) {
      this.expect(10), this.expressionScope.enter(yue()), e.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, r, s) {
      this.next();
      let i = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, r, s), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.
      finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, r) {
      this.classScope.enter();
      let s = {
        hadConstructor: !1,
        hadSuperClass: e
      }, i = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(M.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          i.length && (o.decorators = i, this.resetStartLocationFromNode(o, i[0]), i = []), this.parseClassMember(a, o, s), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(M.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), i.length)
        throw this.raise(M.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, r) {
      let s = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let i = r;
        return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(e, i, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let i = r;
        return i.computed = !1, i.key = s, i.static = !1, e.body.push(this.parseClassProperty(i)), !0;
      }
      return this.resetPreviousNodeTrailingComments(s), !1;
    }
    parseClassMember(e, r, s) {
      let i = this.isContextual(106);
      if (i) {
        if (this.parseClassMemberFromModifier(e, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, r, s, i);
    }
    parseClassMemberWithIsStatic(e, r, s, i) {
      let a = r, o = r, l = r, u = r, c = r, p = a, f = a;
      if (r.static = i, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let _ = this.match(138);
        if (this.parseClassElementName(p), _) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(M.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let m = !this.state.containsEsc && ht(this.state.type), y = this.parseClassElementName(r), T = m ? y.name : null, L = this.isPrivateName(
      y), q = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
        if (p.kind = "method", L) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let _ = this.isNonstaticConstructor(a), U = !1;
        _ && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(M.DuplicateConstructor, y), _ && this.
        hasPlugin("typescript") && r.override && this.raise(M.OverrideOnConstructor, y), s.hadConstructor = !0, U = s.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, _, U);
      } else if (this.isClassProperty())
        L ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (T === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(y);
        let _ = this.eat(55);
        f.optional && this.unexpected(q), p.kind = "method";
        let U = this.match(138);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(f), U ? this.pushClassPrivateMethod(e, o, _, !0) : (this.isNonstaticConstructor(
        a) && this.raise(M.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, _, !0, !1, !1));
      } else if ((T === "get" || T === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(y), p.kind = T;
        let _ = this.match(138);
        this.parseClassElementName(a), _ ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(M.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (T === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(y);
        let _ = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, _);
      } else this.isLineTerminator() ? L ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: r,
        value: s
      } = this.state;
      if ((r === 132 || r === 133) && e.static && s === "prototype" && this.raise(M.StaticPrototype, this.state.startLoc), r === 138) {
        s === "constructor" && this.raise(M.ConstructorClassPrivateField, this.state.startLoc);
        let i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, r) {
      var s;
      this.scope.enter(208);
      let i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.
      finishNode(r, "StaticBlock")), (s = r.decorators) != null && s.length && this.raise(M.DecoratorStaticBlock, r);
    }
    pushClassProperty(e, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(M.ConstructorClassField, r.key), e.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(e, r) {
      let s = this.parseClassPrivateProperty(r);
      e.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassAccessorProperty(e, r, s) {
      !s && !r.computed && this.nameIsConstructor(r.key) && this.raise(M.ConstructorClassField, r.key);
      let i = this.parseClassAccessorProperty(r);
      e.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassMethod(e, r, s, i, a, o) {
      e.body.push(this.parseMethod(r, s, i, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, r, s, i) {
      let a = this.parseMethod(r, s, i, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(hv()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, r, s, i = 8331) {
      if (ht(this.state.type))
        e.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(e.id, i);
      else if (s || !r)
        e.id = null;
      else
        throw this.raise(M.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, r) {
      let s = this.parseMaybeImportPhase(e, !0), i = this.maybeParseExportDefaultSpecifier(e, s), a = !i || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = i || o;
      if (o && !l) {
        if (i && this.unexpected(), r)
          throw this.raise(M.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      i && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let f;
      if (c || p) {
        if (f = !1, r)
          throw this.raise(M.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        f = this.maybeParseExportDeclaration(e);
      if (c || p || f) {
        var m;
        let y = e;
        if (this.checkExport(y, !0, !1, !!y.source), ((m = y.declaration) == null ? void 0 : m.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, y.declaration, y);
        else if (r)
          throw this.raise(M.UnsupportedDecoratorExport, e);
        return this.finishNode(y, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let y = e, T = this.parseExportDefaultExpression();
        if (y.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, T, y);
        else if (r)
          throw this.raise(M.UnsupportedDecoratorExport, e);
        return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let s = r || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
        return i.exported = s, e.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var r, s;
        (s = (r = e).specifiers) != null || (r.specifiers = []);
        let i = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), i.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let r = e;
        r.specifiers || (r.specifiers = []);
        let s = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(s)), r.source = null, r.declaration = null, this.hasPlugin("importAssertions") &&
        (r.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions =
      []), e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(M.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(M.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (ht(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: i
          } = this.lookahead();
          if (ht(i) && i !== 98 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), s = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ht(this.state.type) && s)
        return !0;
      if (this.match(65) && s) {
        let i = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return i === 34 || i === 39;
      }
      return !1;
    }
    parseExportFrom(e, r) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(M.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(M.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(M.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, r, s, i) {
      if (r) {
        var a;
        if (s) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            M.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !i && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(M.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let r of e.properties)
          this.checkDeclaration(r);
      else if (e.type === "ArrayPattern")
        for (let r of e.elements)
          r && this.checkDeclaration(r);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(M.DuplicateDefaultExport, e) : this.raise(M.DuplicateExport, e, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(e) {
      let r = [], s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else if (this.expect(12), this.eat(8)) break;
        let i = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, e, i));
      }
      return r;
    }
    parseExportSpecifier(e, r, s, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : r ? e.exported = Sue(e.local) : e.exported || (e.exported =
      _s(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let e = this.parseStringLiteral(this.state.value), r = e.value.match(Wue);
        return r && this.raise(M.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: r,
        value: s
      }) => s.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: r
      } = e, s = r.length === 1 ? r[0].type : null;
      if (e.phase === "source")
        s !== "ImportDefaultSpecifier" && this.raise(M.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (e.phase === "defer")
        s !== "ImportNamespaceSpecifier" && this.raise(M.DeferImportRequiresNamespace, r[0].loc.start);
      else if (e.module) {
        var i;
        s !== "ImportDefaultSpecifier" && this.raise(M.ImportReflectionNotBinding, r[0].loc.start), ((i = e.assertions) == null ? void 0 : i.
        length) > 0 && this.raise(M.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = e;
        if (r != null) {
          let s = r.find((i) => {
            let a;
            if (i.type === "ExportSpecifier" ? a = i.local : i.type === "ImportSpecifier" && (a = i.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          s !== void 0 && this.raise(M.ImportJSONBindingNotDefault, s.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, r, s, i) {
      r || (s === "module" ? (this.expectPlugin("importReflection", i), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      s === "source" ? (this.expectPlugin("sourcePhaseImports", i), e.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", i), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(e, r, null), null;
      let s = this.parseIdentifier(!0), {
        type: i
      } = this.state;
      return (zr(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(
      e, r, s.name, s.loc.start), null) : (this.applyImportPhase(e, r, null), s);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: r
      } = this.state;
      return ht(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(e) {
      return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, r) {
      e.specifiers = [];
      let i = !this.maybeParseDefaultImportSpecifier(e, r) || this.eat(12), a = i && this.maybeParseStarImportSpecifier(e);
      return i && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var r;
      return (r = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, r, s) {
      r.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, s));
    }
    finishImportSpecifier(e, r, s = 8201) {
      return this.checkLVal(e.local, {
        in: {
          type: r
        },
        binding: s
      }), this.finishNode(e, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s = this.startNode(), i = this.state.value;
        if (r.has(i) && this.raise(M.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: i
        }), r.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(M.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        let s = this.startNode();
        if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(M.ModuleAttributeDifferentFromType, s.key), r.has(s.key.name) &&
        this.raise(M.ModuleAttributesWithDuplicateKeys, s.key, {
          key: s.key.name
        }), r.add(s.key.name), this.expect(14), !this.match(133))
          throw this.raise(M.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let r, s = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), s = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(M.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !s && this.hasPlugin("importAssertions") ? e.assertions = r : e.attributes = r;
    }
    maybeParseDefaultImportSpecifier(e, r) {
      if (r) {
        let s = this.startNodeAtNode(r);
        return s.local = r, e.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
      } else if (zr(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(M.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let s = this.startNode(), i = this.match(133), a = this.isContextual(130);
        s.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(s, i, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, r, s, i, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (r)
          throw this.raise(M.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = _s(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, $u = class extends Zm {
    static {
      n(this, "Parser");
    }
    constructor(e, r) {
      e = Vue(e), super(e, r), this.options = e, this.initializeScopes(), this.plugins = Jue(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return mo;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), r = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, r), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function Jue(t) {
    let e = /* @__PURE__ */ new Map();
    for (let r of t) {
      let [s, i] = Array.isArray(r) ? r : [r, {}];
      e.has(s) || e.set(s, i || {});
    }
    return e;
  }
  n(Jue, "pluginsMap");
  function Xue(t, e) {
    var r;
    if (((r = e) == null ? void 0 : r.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let s = co(e, t), i = s.parse();
        if (s.sawUnambiguousESM)
          return i;
        if (s.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", co(e, t).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (s) {
        try {
          return e.sourceType = "script", co(e, t).parse();
        } catch {
        }
        throw s;
      }
    } else
      return co(e, t).parse();
  }
  n(Xue, "parse");
  function $ue(t, e) {
    let r = co(e, t);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  n($ue, "parseExpression");
  function Hue(t) {
    let e = {};
    for (let r of Object.keys(t))
      e[r] = Ns(t[r]);
    return e;
  }
  n(Hue, "generateExportedTokenTypes");
  var zue = Hue(Kle);
  function co(t, e) {
    let r = $u;
    return t != null && t.plugins && (Uue(t.plugins), r = Gue(t.plugins)), new r(t, e);
  }
  n(co, "getParser");
  var ev = {};
  function Gue(t) {
    let e = que.filter((i) => Kt(t, i)), r = e.join("/"), s = ev[r];
    if (!s) {
      s = $u;
      for (let i of e)
        s = Tv[i](s);
      ev[r] = s;
    }
    return s;
  }
  n(Gue, "getParserClass");
  To.parse = Xue;
  To.parseExpression = $ue;
  To.tokTypes = zue;
});

// ../node_modules/@babel/highlight/node_modules/color-name/index.js
var Sv = w((d8e, xv) => {
  "use strict";
  xv.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var cy = w((m8e, Av) => {
  var $i = Sv(), Ev = {};
  for (Hu in $i)
    $i.hasOwnProperty(Hu) && (Ev[$i[Hu]] = Hu);
  var Hu, ge = Av.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (Sr in ge)
    if (ge.hasOwnProperty(Sr)) {
      if (!("channels" in ge[Sr]))
        throw new Error("missing channels property: " + Sr);
      if (!("labels" in ge[Sr]))
        throw new Error("missing channel labels property: " + Sr);
      if (ge[Sr].labels.length !== ge[Sr].channels)
        throw new Error("channel and label counts mismatch: " + Sr);
      gv = ge[Sr].channels, Pv = ge[Sr].labels, delete ge[Sr].channels, delete ge[Sr].labels, Object.defineProperty(ge[Sr], "channels", { value: gv }),
      Object.defineProperty(ge[Sr], "labels", { value: Pv });
    }
  var gv, Pv, Sr;
  ge.rgb.hsl = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i = Math.min(e, r, s), a = Math.max(e, r, s), o = a - i, l, u, c;
    return a === i ? l = 0 : e === a ? l = (r - s) / o : r === a ? l = 2 + (s - e) / o : s === a && (l = 4 + (e - r) / o), l = Math.min(l * 60,
    360), l < 0 && (l += 360), c = (i + a) / 2, a === i ? u = 0 : c <= 0.5 ? u = o / (a + i) : u = o / (2 - a - i), [l, u * 100, c * 100];
  };
  ge.rgb.hsv = function(t) {
    var e, r, s, i, a, o = t[0] / 255, l = t[1] / 255, u = t[2] / 255, c = Math.max(o, l, u), p = c - Math.min(o, l, u), f = /* @__PURE__ */ n(
    function(m) {
      return (c - m) / 6 / p + 1 / 2;
    }, "diffc");
    return p === 0 ? i = a = 0 : (a = p / c, e = f(o), r = f(l), s = f(u), o === c ? i = s - r : l === c ? i = 1 / 3 + e - s : u === c && (i =
    2 / 3 + r - e), i < 0 ? i += 1 : i > 1 && (i -= 1)), [
      i * 360,
      a * 100,
      c * 100
    ];
  };
  ge.rgb.hwb = function(t) {
    var e = t[0], r = t[1], s = t[2], i = ge.rgb.hsl(t)[0], a = 1 / 255 * Math.min(e, Math.min(r, s));
    return s = 1 - 1 / 255 * Math.max(e, Math.max(r, s)), [i, a * 100, s * 100];
  };
  ge.rgb.cmyk = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i, a, o, l;
    return l = Math.min(1 - e, 1 - r, 1 - s), i = (1 - e - l) / (1 - l) || 0, a = (1 - r - l) / (1 - l) || 0, o = (1 - s - l) / (1 - l) || 0,
    [i * 100, a * 100, o * 100, l * 100];
  };
  function Que(t, e) {
    return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2);
  }
  n(Que, "comparativeDistance");
  ge.rgb.keyword = function(t) {
    var e = Ev[t];
    if (e)
      return e;
    var r = 1 / 0, s;
    for (var i in $i)
      if ($i.hasOwnProperty(i)) {
        var a = $i[i], o = Que(t, a);
        o < r && (r = o, s = i);
      }
    return s;
  };
  ge.keyword.rgb = function(t) {
    return $i[t];
  };
  ge.rgb.xyz = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255;
    e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, s = s >
    0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
    var i = e * 0.4124 + r * 0.3576 + s * 0.1805, a = e * 0.2126 + r * 0.7152 + s * 0.0722, o = e * 0.0193 + r * 0.1192 + s * 0.9505;
    return [i * 100, a * 100, o * 100];
  };
  ge.rgb.lab = function(t) {
    var e = ge.rgb.xyz(t), r = e[0], s = e[1], i = e[2], a, o, l;
    return r /= 95.047, s /= 100, i /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 /
    3) : 7.787 * s + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, a = 116 * s - 16, o = 500 * (r - s), l = 200 * (s -
    i), [a, o, l];
  };
  ge.hsl.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100, i, a, o, l, u;
    if (r === 0)
      return u = s * 255, [u, u, u];
    s < 0.5 ? a = s * (1 + r) : a = s + r - s * r, i = 2 * s - a, l = [0, 0, 0];
    for (var c = 0; c < 3; c++)
      o = e + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? u = i + (a - i) * 6 * o : 2 * o < 1 ? u = a : 3 * o < 2 ? u = i + (a -
      i) * (2 / 3 - o) * 6 : u = i, l[c] = u * 255;
    return l;
  };
  ge.hsl.hsv = function(t) {
    var e = t[0], r = t[1] / 100, s = t[2] / 100, i = r, a = Math.max(s, 0.01), o, l;
    return s *= 2, r *= s <= 1 ? s : 2 - s, i *= a <= 1 ? a : 2 - a, l = (s + r) / 2, o = s === 0 ? 2 * i / (a + i) : 2 * r / (s + r), [e, o *
    100, l * 100];
  };
  ge.hsv.rgb = function(t) {
    var e = t[0] / 60, r = t[1] / 100, s = t[2] / 100, i = Math.floor(e) % 6, a = e - Math.floor(e), o = 255 * s * (1 - r), l = 255 * s * (1 -
    r * a), u = 255 * s * (1 - r * (1 - a));
    switch (s *= 255, i) {
      case 0:
        return [s, u, o];
      case 1:
        return [l, s, o];
      case 2:
        return [o, s, u];
      case 3:
        return [o, l, s];
      case 4:
        return [u, o, s];
      case 5:
        return [s, o, l];
    }
  };
  ge.hsv.hsl = function(t) {
    var e = t[0], r = t[1] / 100, s = t[2] / 100, i = Math.max(s, 0.01), a, o, l;
    return l = (2 - r) * s, a = (2 - r) * i, o = r * i, o /= a <= 1 ? a : 2 - a, o = o || 0, l /= 2, [e, o * 100, l * 100];
  };
  ge.hwb.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100, i = r + s, a, o, l, u;
    i > 1 && (r /= i, s /= i), a = Math.floor(6 * e), o = 1 - s, l = 6 * e - a, a & 1 && (l = 1 - l), u = r + l * (o - r);
    var c, p, f;
    switch (a) {
      default:
      case 6:
      case 0:
        c = o, p = u, f = r;
        break;
      case 1:
        c = u, p = o, f = r;
        break;
      case 2:
        c = r, p = o, f = u;
        break;
      case 3:
        c = r, p = u, f = o;
        break;
      case 4:
        c = u, p = r, f = o;
        break;
      case 5:
        c = o, p = r, f = u;
        break;
    }
    return [c * 255, p * 255, f * 255];
  };
  ge.cmyk.rgb = function(t) {
    var e = t[0] / 100, r = t[1] / 100, s = t[2] / 100, i = t[3] / 100, a, o, l;
    return a = 1 - Math.min(1, e * (1 - i) + i), o = 1 - Math.min(1, r * (1 - i) + i), l = 1 - Math.min(1, s * (1 - i) + i), [a * 255, o * 255,
    l * 255];
  };
  ge.xyz.rgb = function(t) {
    var e = t[0] / 100, r = t[1] / 100, s = t[2] / 100, i, a, o;
    return i = e * 3.2406 + r * -1.5372 + s * -0.4986, a = e * -0.9689 + r * 1.8758 + s * 0.0415, o = e * 0.0557 + r * -0.204 + s * 1.057, i =
    i > 31308e-7 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, o =
    o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, i = Math.min(Math.max(0, i), 1), a = Math.min(Math.max(0, a), 1), o = Math.
    min(Math.max(0, o), 1), [i * 255, a * 255, o * 255];
  };
  ge.xyz.lab = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return e /= 95.047, r /= 100, s /= 108.883, e = e > 8856e-6 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 /
    3) : 7.787 * r + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, i = 116 * r - 16, a = 500 * (e - r), o = 200 * (r -
    s), [i, a, o];
  };
  ge.lab.xyz = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    a = (e + 16) / 116, i = r / 500 + a, o = a - s / 200;
    var l = Math.pow(a, 3), u = Math.pow(i, 3), c = Math.pow(o, 3);
    return a = l > 8856e-6 ? l : (a - 16 / 116) / 7.787, i = u > 8856e-6 ? u : (i - 16 / 116) / 7.787, o = c > 8856e-6 ? c : (o - 16 / 116) /
    7.787, i *= 95.047, a *= 100, o *= 108.883, [i, a, o];
  };
  ge.lab.lch = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return i = Math.atan2(s, r), a = i * 360 / 2 / Math.PI, a < 0 && (a += 360), o = Math.sqrt(r * r + s * s), [e, o, a];
  };
  ge.lch.lab = function(t) {
    var e = t[0], r = t[1], s = t[2], i, a, o;
    return o = s / 360 * 2 * Math.PI, i = r * Math.cos(o), a = r * Math.sin(o), [e, i, a];
  };
  ge.rgb.ansi16 = function(t) {
    var e = t[0], r = t[1], s = t[2], i = 1 in arguments ? arguments[1] : ge.rgb.hsv(t)[2];
    if (i = Math.round(i / 50), i === 0)
      return 30;
    var a = 30 + (Math.round(s / 255) << 2 | Math.round(r / 255) << 1 | Math.round(e / 255));
    return i === 2 && (a += 60), a;
  };
  ge.hsv.ansi16 = function(t) {
    return ge.rgb.ansi16(ge.hsv.rgb(t), t[2]);
  };
  ge.rgb.ansi256 = function(t) {
    var e = t[0], r = t[1], s = t[2];
    if (e === r && r === s)
      return e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232;
    var i = 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(s / 255 * 5);
    return i;
  };
  ge.ansi16.rgb = function(t) {
    var e = t % 10;
    if (e === 0 || e === 7)
      return t > 50 && (e += 3.5), e = e / 10.5 * 255, [e, e, e];
    var r = (~~(t > 50) + 1) * 0.5, s = (e & 1) * r * 255, i = (e >> 1 & 1) * r * 255, a = (e >> 2 & 1) * r * 255;
    return [s, i, a];
  };
  ge.ansi256.rgb = function(t) {
    if (t >= 232) {
      var e = (t - 232) * 10 + 8;
      return [e, e, e];
    }
    t -= 16;
    var r, s = Math.floor(t / 36) / 5 * 255, i = Math.floor((r = t % 36) / 6) / 5 * 255, a = r % 6 / 5 * 255;
    return [s, i, a];
  };
  ge.rgb.hex = function(t) {
    var e = ((Math.round(t[0]) & 255) << 16) + ((Math.round(t[1]) & 255) << 8) + (Math.round(t[2]) & 255), r = e.toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  };
  ge.hex.rgb = function(t) {
    var e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!e)
      return [0, 0, 0];
    var r = e[0];
    e[0].length === 3 && (r = r.split("").map(function(l) {
      return l + l;
    }).join(""));
    var s = parseInt(r, 16), i = s >> 16 & 255, a = s >> 8 & 255, o = s & 255;
    return [i, a, o];
  };
  ge.rgb.hcg = function(t) {
    var e = t[0] / 255, r = t[1] / 255, s = t[2] / 255, i = Math.max(Math.max(e, r), s), a = Math.min(Math.min(e, r), s), o = i - a, l, u;
    return o < 1 ? l = a / (1 - o) : l = 0, o <= 0 ? u = 0 : i === e ? u = (r - s) / o % 6 : i === r ? u = 2 + (s - e) / o : u = 4 + (e - r) /
    o + 4, u /= 6, u %= 1, [u * 360, o * 100, l * 100];
  };
  ge.hsl.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = 1, i = 0;
    return r < 0.5 ? s = 2 * e * r : s = 2 * e * (1 - r), s < 1 && (i = (r - 0.5 * s) / (1 - s)), [t[0], s * 100, i * 100];
  };
  ge.hsv.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e * r, i = 0;
    return s < 1 && (i = (r - s) / (1 - s)), [t[0], s * 100, i * 100];
  };
  ge.hcg.rgb = function(t) {
    var e = t[0] / 360, r = t[1] / 100, s = t[2] / 100;
    if (r === 0)
      return [s * 255, s * 255, s * 255];
    var i = [0, 0, 0], a = e % 1 * 6, o = a % 1, l = 1 - o, u = 0;
    switch (Math.floor(a)) {
      case 0:
        i[0] = 1, i[1] = o, i[2] = 0;
        break;
      case 1:
        i[0] = l, i[1] = 1, i[2] = 0;
        break;
      case 2:
        i[0] = 0, i[1] = 1, i[2] = o;
        break;
      case 3:
        i[0] = 0, i[1] = l, i[2] = 1;
        break;
      case 4:
        i[0] = o, i[1] = 0, i[2] = 1;
        break;
      default:
        i[0] = 1, i[1] = 0, i[2] = l;
    }
    return u = (1 - r) * s, [
      (r * i[0] + u) * 255,
      (r * i[1] + u) * 255,
      (r * i[2] + u) * 255
    ];
  };
  ge.hcg.hsv = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e + r * (1 - e), i = 0;
    return s > 0 && (i = e / s), [t[0], i * 100, s * 100];
  };
  ge.hcg.hsl = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = r * (1 - e) + 0.5 * e, i = 0;
    return s > 0 && s < 0.5 ? i = e / (2 * s) : s >= 0.5 && s < 1 && (i = e / (2 * (1 - s))), [t[0], i * 100, s * 100];
  };
  ge.hcg.hwb = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = e + r * (1 - e);
    return [t[0], (s - e) * 100, (1 - s) * 100];
  };
  ge.hwb.hcg = function(t) {
    var e = t[1] / 100, r = t[2] / 100, s = 1 - r, i = s - e, a = 0;
    return i < 1 && (a = (s - i) / (1 - i)), [t[0], i * 100, a * 100];
  };
  ge.apple.rgb = function(t) {
    return [t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255];
  };
  ge.rgb.apple = function(t) {
    return [t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535];
  };
  ge.gray.rgb = function(t) {
    return [t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255];
  };
  ge.gray.hsl = ge.gray.hsv = function(t) {
    return [0, 0, t[0]];
  };
  ge.gray.hwb = function(t) {
    return [0, 100, t[0]];
  };
  ge.gray.cmyk = function(t) {
    return [0, 0, 0, t[0]];
  };
  ge.gray.lab = function(t) {
    return [t[0], 0, 0];
  };
  ge.gray.hex = function(t) {
    var e = Math.round(t[0] / 100 * 255) & 255, r = (e << 16) + (e << 8) + e, s = r.toString(16).toUpperCase();
    return "000000".substring(s.length) + s;
  };
  ge.rgb.gray = function(t) {
    var e = (t[0] + t[1] + t[2]) / 3;
    return [e / 255 * 100];
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/route.js
var Cv = w((T8e, vv) => {
  var zu = cy();
  function Zue() {
    for (var t = {}, e = Object.keys(zu), r = e.length, s = 0; s < r; s++)
      t[e[s]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return t;
  }
  n(Zue, "buildGraph");
  function ece(t) {
    var e = Zue(), r = [t];
    for (e[t].distance = 0; r.length; )
      for (var s = r.pop(), i = Object.keys(zu[s]), a = i.length, o = 0; o < a; o++) {
        var l = i[o], u = e[l];
        u.distance === -1 && (u.distance = e[s].distance + 1, u.parent = s, r.unshift(l));
      }
    return e;
  }
  n(ece, "deriveBFS");
  function tce(t, e) {
    return function(r) {
      return e(t(r));
    };
  }
  n(tce, "link");
  function rce(t, e) {
    for (var r = [e[t].parent, t], s = zu[e[t].parent][t], i = e[t].parent; e[i].parent; )
      r.unshift(e[i].parent), s = tce(zu[e[i].parent][i], s), i = e[i].parent;
    return s.conversion = r, s;
  }
  n(rce, "wrapConversion");
  vv.exports = function(t) {
    for (var e = ece(t), r = {}, s = Object.keys(e), i = s.length, a = 0; a < i; a++) {
      var o = s[a], l = e[o];
      l.parent !== null && (r[o] = rce(o, e));
    }
    return r;
  };
});

// ../node_modules/@babel/highlight/node_modules/color-convert/index.js
var wv = w((x8e, Iv) => {
  var py = cy(), sce = Cv(), qn = {}, ice = Object.keys(py);
  function nce(t) {
    var e = /* @__PURE__ */ n(function(r) {
      return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), t(r));
    }, "wrappedFn");
    return "conversion" in t && (e.conversion = t.conversion), e;
  }
  n(nce, "wrapRaw");
  function ace(t) {
    var e = /* @__PURE__ */ n(function(r) {
      if (r == null)
        return r;
      arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
      var s = t(r);
      if (typeof s == "object")
        for (var i = s.length, a = 0; a < i; a++)
          s[a] = Math.round(s[a]);
      return s;
    }, "wrappedFn");
    return "conversion" in t && (e.conversion = t.conversion), e;
  }
  n(ace, "wrapRounded");
  ice.forEach(function(t) {
    qn[t] = {}, Object.defineProperty(qn[t], "channels", { value: py[t].channels }), Object.defineProperty(qn[t], "labels", { value: py[t].labels });
    var e = sce(t), r = Object.keys(e);
    r.forEach(function(s) {
      var i = e[s];
      qn[t][s] = ace(i), qn[t][s].raw = nce(i);
    });
  });
  Iv.exports = qn;
});

// ../node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var Ov = w((g8e, Nv) => {
  "use strict";
  var Vn = wv(), Gu = /* @__PURE__ */ n((t, e) => function() {
    return `\x1B[${t.apply(Vn, arguments) + e}m`;
  }, "wrapAnsi16"), Qu = /* @__PURE__ */ n((t, e) => function() {
    let r = t.apply(Vn, arguments);
    return `\x1B[${38 + e};5;${r}m`;
  }, "wrapAnsi256"), Zu = /* @__PURE__ */ n((t, e) => function() {
    let r = t.apply(Vn, arguments);
    return `\x1B[${38 + e};2;${r[0]};${r[1]};${r[2]}m`;
  }, "wrapAnsi16m");
  function oce() {
    let t = /* @__PURE__ */ new Map(), e = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    e.color.grey = e.color.gray;
    for (let i of Object.keys(e)) {
      let a = e[i];
      for (let o of Object.keys(a)) {
        let l = a[o];
        e[o] = {
          open: `\x1B[${l[0]}m`,
          close: `\x1B[${l[1]}m`
        }, a[o] = e[o], t.set(l[0], l[1]);
      }
      Object.defineProperty(e, i, {
        value: a,
        enumerable: !1
      }), Object.defineProperty(e, "codes", {
        value: t,
        enumerable: !1
      });
    }
    let r = /* @__PURE__ */ n((i) => i, "ansi2ansi"), s = /* @__PURE__ */ n((i, a, o) => [i, a, o], "rgb2rgb");
    e.color.close = "\x1B[39m", e.bgColor.close = "\x1B[49m", e.color.ansi = {
      ansi: Gu(r, 0)
    }, e.color.ansi256 = {
      ansi256: Qu(r, 0)
    }, e.color.ansi16m = {
      rgb: Zu(s, 0)
    }, e.bgColor.ansi = {
      ansi: Gu(r, 10)
    }, e.bgColor.ansi256 = {
      ansi256: Qu(r, 10)
    }, e.bgColor.ansi16m = {
      rgb: Zu(s, 10)
    };
    for (let i of Object.keys(Vn)) {
      if (typeof Vn[i] != "object")
        continue;
      let a = Vn[i];
      i === "ansi16" && (i = "ansi"), "ansi16" in a && (e.color.ansi[i] = Gu(a.ansi16, 0), e.bgColor.ansi[i] = Gu(a.ansi16, 10)), "ansi256" in
      a && (e.color.ansi256[i] = Qu(a.ansi256, 0), e.bgColor.ansi256[i] = Qu(a.ansi256, 10)), "rgb" in a && (e.color.ansi16m[i] = Zu(a.rgb, 0),
      e.bgColor.ansi16m[i] = Zu(a.rgb, 10));
    }
    return e;
  }
  n(oce, "assembleStyles");
  Object.defineProperty(Nv, "exports", {
    enumerable: !0,
    get: oce
  });
});

// ../node_modules/@babel/highlight/node_modules/has-flag/index.js
var Dv = w((E8e, kv) => {
  "use strict";
  kv.exports = (t, e) => {
    e = e || process.argv;
    let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", s = e.indexOf(r + t), i = e.indexOf("--");
    return s !== -1 && (i === -1 ? !0 : s < i);
  };
});

// ../node_modules/@babel/highlight/node_modules/supports-color/index.js
var Lv = w((A8e, _v) => {
  "use strict";
  var lce = ds("os"), Gr = Dv(), ir = process.env, Kn;
  Gr("no-color") || Gr("no-colors") || Gr("color=false") ? Kn = !1 : (Gr("color") || Gr("colors") || Gr("color=true") || Gr("color=always")) &&
  (Kn = !0);
  "FORCE_COLOR" in ir && (Kn = ir.FORCE_COLOR.length === 0 || parseInt(ir.FORCE_COLOR, 10) !== 0);
  function uce(t) {
    return t === 0 ? !1 : {
      level: t,
      hasBasic: !0,
      has256: t >= 2,
      has16m: t >= 3
    };
  }
  n(uce, "translateLevel");
  function cce(t) {
    if (Kn === !1)
      return 0;
    if (Gr("color=16m") || Gr("color=full") || Gr("color=truecolor"))
      return 3;
    if (Gr("color=256"))
      return 2;
    if (t && !t.isTTY && Kn !== !0)
      return 0;
    let e = Kn ? 1 : 0;
    if (process.platform === "win32") {
      let r = lce.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in ir)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in ir) || ir.CI_NAME === "codeship" ? 1 : e;
    if ("TEAMCITY_VERSION" in ir)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(ir.TEAMCITY_VERSION) ? 1 : 0;
    if (ir.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in ir) {
      let r = parseInt((ir.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (ir.TERM_PROGRAM) {
        case "iTerm.app":
          return r >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(ir.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(ir.TERM) || "COLORTERM" in
    ir ? 1 : (ir.TERM === "dumb", e);
  }
  n(cce, "supportsColor");
  function fy(t) {
    let e = cce(t);
    return uce(e);
  }
  n(fy, "getSupportLevel");
  _v.exports = {
    supportsColor: fy,
    stdout: fy(process.stdout),
    stderr: fy(process.stderr)
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/templates.js
var Rv = w((C8e, jv) => {
  "use strict";
  var pce = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  Mv = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, fce = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, hce = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, dce = /* @__PURE__ */ new Map(
  [
    ["n", `
`],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function Fv(t) {
    return t[0] === "u" && t.length === 5 || t[0] === "x" && t.length === 3 ? String.fromCharCode(parseInt(t.slice(1), 16)) : dce.get(t) || t;
  }
  n(Fv, "unescape");
  function mce(t, e) {
    let r = [], s = e.trim().split(/\s*,\s*/g), i;
    for (let a of s)
      if (!isNaN(a))
        r.push(Number(a));
      else if (i = a.match(fce))
        r.push(i[2].replace(hce, (o, l, u) => l ? Fv(l) : u));
      else
        throw new Error(`Invalid Chalk template style argument: ${a} (in style '${t}')`);
    return r;
  }
  n(mce, "parseArguments");
  function yce(t) {
    Mv.lastIndex = 0;
    let e = [], r;
    for (; (r = Mv.exec(t)) !== null; ) {
      let s = r[1];
      if (r[2]) {
        let i = mce(s, r[2]);
        e.push([s].concat(i));
      } else
        e.push([s]);
    }
    return e;
  }
  n(yce, "parseStyle");
  function Bv(t, e) {
    let r = {};
    for (let i of e)
      for (let a of i.styles)
        r[a[0]] = i.inverse ? null : a.slice(1);
    let s = t;
    for (let i of Object.keys(r))
      if (Array.isArray(r[i])) {
        if (!(i in s))
          throw new Error(`Unknown Chalk style: ${i}`);
        r[i].length > 0 ? s = s[i].apply(s, r[i]) : s = s[i];
      }
    return s;
  }
  n(Bv, "buildStyle");
  jv.exports = (t, e) => {
    let r = [], s = [], i = [];
    if (e.replace(pce, (a, o, l, u, c, p) => {
      if (o)
        i.push(Fv(o));
      else if (u) {
        let f = i.join("");
        i = [], s.push(r.length === 0 ? f : Bv(t, r)(f)), r.push({ inverse: l, styles: yce(u) });
      } else if (c) {
        if (r.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        s.push(Bv(t, r)(i.join(""))), i = [], r.pop();
      } else
        i.push(p);
    }), s.push(i.join("")), r.length > 0) {
      let a = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(a);
    }
    return s.join("");
  };
});

// ../node_modules/@babel/highlight/node_modules/chalk/index.js
var Wv = w((w8e, xo) => {
  "use strict";
  var dy = _d(), Wt = Ov(), hy = Lv().stdout, Tce = Rv(), qv = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith(
  "xterm"), Vv = ["ansi", "ansi", "ansi256", "ansi16m"], Kv = /* @__PURE__ */ new Set(["gray"]), Wn = /* @__PURE__ */ Object.create(null);
  function Uv(t, e) {
    e = e || {};
    let r = hy ? hy.level : 0;
    t.level = e.level === void 0 ? r : e.level, t.enabled = "enabled" in e ? e.enabled : t.level > 0;
  }
  n(Uv, "applyOptions");
  function bo(t) {
    if (!this || !(this instanceof bo) || this.template) {
      let e = {};
      return Uv(e, t), e.template = function() {
        let r = [].slice.call(arguments);
        return Sce.apply(null, [e.template].concat(r));
      }, Object.setPrototypeOf(e, bo.prototype), Object.setPrototypeOf(e.template, e), e.template.constructor = bo, e.template;
    }
    Uv(this, t);
  }
  n(bo, "Chalk");
  qv && (Wt.blue.open = "\x1B[94m");
  for (let t of Object.keys(Wt))
    Wt[t].closeRe = new RegExp(dy(Wt[t].close), "g"), Wn[t] = {
      get() {
        let e = Wt[t];
        return ec.call(this, this._styles ? this._styles.concat(e) : [e], this._empty, t);
      }
    };
  Wn.visible = {
    get() {
      return ec.call(this, this._styles || [], !0, "visible");
    }
  };
  Wt.color.closeRe = new RegExp(dy(Wt.color.close), "g");
  for (let t of Object.keys(Wt.color.ansi))
    Kv.has(t) || (Wn[t] = {
      get() {
        let e = this.level;
        return function() {
          let s = {
            open: Wt.color[Vv[e]][t].apply(null, arguments),
            close: Wt.color.close,
            closeRe: Wt.color.closeRe
          };
          return ec.call(this, this._styles ? this._styles.concat(s) : [s], this._empty, t);
        };
      }
    });
  Wt.bgColor.closeRe = new RegExp(dy(Wt.bgColor.close), "g");
  for (let t of Object.keys(Wt.bgColor.ansi)) {
    if (Kv.has(t))
      continue;
    let e = "bg" + t[0].toUpperCase() + t.slice(1);
    Wn[e] = {
      get() {
        let r = this.level;
        return function() {
          let i = {
            open: Wt.bgColor[Vv[r]][t].apply(null, arguments),
            close: Wt.bgColor.close,
            closeRe: Wt.bgColor.closeRe
          };
          return ec.call(this, this._styles ? this._styles.concat(i) : [i], this._empty, t);
        };
      }
    };
  }
  var bce = Object.defineProperties(() => {
  }, Wn);
  function ec(t, e, r) {
    let s = /* @__PURE__ */ n(function() {
      return xce.apply(s, arguments);
    }, "builder");
    s._styles = t, s._empty = e;
    let i = this;
    return Object.defineProperty(s, "level", {
      enumerable: !0,
      get() {
        return i.level;
      },
      set(a) {
        i.level = a;
      }
    }), Object.defineProperty(s, "enabled", {
      enumerable: !0,
      get() {
        return i.enabled;
      },
      set(a) {
        i.enabled = a;
      }
    }), s.hasGrey = this.hasGrey || r === "gray" || r === "grey", s.__proto__ = bce, s;
  }
  n(ec, "build");
  function xce() {
    let t = arguments, e = t.length, r = String(arguments[0]);
    if (e === 0)
      return "";
    if (e > 1)
      for (let i = 1; i < e; i++)
        r += " " + t[i];
    if (!this.enabled || this.level <= 0 || !r)
      return this._empty ? "" : r;
    let s = Wt.dim.open;
    qv && this.hasGrey && (Wt.dim.open = "");
    for (let i of this._styles.slice().reverse())
      r = i.open + r.replace(i.closeRe, i.open) + i.close, r = r.replace(/\r?\n/g, `${i.close}$&${i.open}`);
    return Wt.dim.open = s, r;
  }
  n(xce, "applyStyle");
  function Sce(t, e) {
    if (!Array.isArray(e))
      return [].slice.call(arguments, 1).join(" ");
    let r = [].slice.call(arguments, 2), s = [e.raw[0]];
    for (let i = 1; i < e.length; i++)
      s.push(String(r[i - 1]).replace(/[{}\\]/g, "\\$&")), s.push(String(e.raw[i]));
    return Tce(t, s.join(""));
  }
  n(Sce, "chalkTag");
  Object.defineProperties(bo.prototype, Wn);
  xo.exports = bo();
  xo.exports.supportsColor = hy;
  xo.exports.default = xo.exports;
});

// ../node_modules/@babel/highlight/lib/index.js
var Qv = w((So) => {
  "use strict";
  Object.defineProperty(So, "__esModule", {
    value: !0
  });
  So.default = wce;
  So.shouldHighlight = Gv;
  var Yv = Id(), Jv = ya(), yy = gce(Wa(), !0);
  function $v(t) {
    if (typeof WeakMap != "function") return null;
    var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return ($v = /* @__PURE__ */ n(function(s) {
      return s ? r : e;
    }, "_getRequireWildcardCache"))(t);
  }
  n($v, "_getRequireWildcardCache");
  function gce(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
    var r = $v(e);
    if (r && r.has(t)) return r.get(t);
    var s = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t) if (a !== "default" && {}.hasOwnProperty.call(t, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(t, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = t[a];
    }
    return s.default = t, r && r.set(t, s), s;
  }
  n(gce, "_interopRequireWildcard");
  var Hv = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, yy.createColors)(!1) :
  yy.default, Xv = /* @__PURE__ */ n((t, e) => (r) => t(e(r)), "compose"), Pce = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of",
  "set"]);
  function Ece(t) {
    return {
      keyword: t.cyan,
      capitalized: t.yellow,
      jsxIdentifier: t.yellow,
      punctuator: t.yellow,
      number: t.magenta,
      string: t.green,
      regex: t.magenta,
      comment: t.gray,
      invalid: Xv(Xv(t.white, t.bgRed), t.bold)
    };
  }
  n(Ece, "getDefs");
  var Ace = /\r\n|[\n\r\u2028\u2029]/, vce = /^[()[\]{}]$/, zv;
  {
    let t = /^[a-z][\w-]*$/i, e = /* @__PURE__ */ n(function(r, s, i) {
      if (r.type === "name") {
        if ((0, Jv.isKeyword)(r.value) || (0, Jv.isStrictReservedWord)(r.value, !0) || Pce.has(r.value))
          return "keyword";
        if (t.test(r.value) && (i[s - 1] === "<" || i.slice(s - 2, s) === "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && vce.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punc\
tuator" : r.type;
    }, "getTokenType");
    zv = /* @__PURE__ */ n(function* (r) {
      let s;
      for (; s = Yv.default.exec(r); ) {
        let i = Yv.matchToToken(s);
        yield {
          type: e(i, s.index, r),
          value: i.value
        };
      }
    }, "tokenize");
  }
  function Cce(t, e) {
    let r = "";
    for (let {
      type: s,
      value: i
    } of zv(e)) {
      let a = t[s];
      a ? r += i.split(Ace).map((o) => a(o)).join(`
`) : r += i;
    }
    return r;
  }
  n(Cce, "highlightTokens");
  function Gv(t) {
    return Hv.isColorSupported || t.forceColor;
  }
  n(Gv, "shouldHighlight");
  var my;
  function Ice(t) {
    if (t) {
      var e;
      return (e = my) != null || (my = (0, yy.createColors)(!0)), my;
    }
    return Hv;
  }
  n(Ice, "getColors");
  function wce(t, e = {}) {
    if (t !== "" && Gv(e)) {
      let r = Ece(Ice(e.forceColor));
      return Cce(r, t);
    } else
      return t;
  }
  n(wce, "highlight");
  {
    let t, e;
    So.getChalk = ({
      forceColor: r
    }) => {
      var s;
      if ((s = t) != null || (t = Wv()), r) {
        var i;
        return (i = e) != null || (e = new t.constructor({
          enabled: !0,
          level: 1
        })), e;
      }
      return t;
    };
  }
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/node_modules/@babel/code-frame/lib/index.js
var nC = w((tc) => {
  "use strict";
  Object.defineProperty(tc, "__esModule", {
    value: !0
  });
  tc.codeFrameColumns = iC;
  tc.default = Lce;
  var Zv = Qv(), by = Nce(Wa(), !0);
  function sC(t) {
    if (typeof WeakMap != "function") return null;
    var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (sC = /* @__PURE__ */ n(function(s) {
      return s ? r : e;
    }, "_getRequireWildcardCache"))(t);
  }
  n(sC, "_getRequireWildcardCache");
  function Nce(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
    var r = sC(e);
    if (r && r.has(t)) return r.get(t);
    var s = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t) if (a !== "default" && {}.hasOwnProperty.call(t, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(t, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(s, a, o) : s[a] = t[a];
    }
    return s.default = t, r && r.set(t, s), s;
  }
  n(Nce, "_interopRequireWildcard");
  var Oce = typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, by.createColors)(!1) :
  by.default, eC = /* @__PURE__ */ n((t, e) => (r) => t(e(r)), "compose"), Ty;
  function kce(t) {
    if (t) {
      var e;
      return (e = Ty) != null || (Ty = (0, by.createColors)(!0)), Ty;
    }
    return Oce;
  }
  n(kce, "getColors");
  var tC = !1;
  function Dce(t) {
    return {
      gutter: t.gray,
      marker: eC(t.red, t.bold),
      message: eC(t.red, t.bold)
    };
  }
  n(Dce, "getDefs");
  var rC = /\r\n|[\n\r\u2028\u2029]/;
  function _ce(t, e, r) {
    let s = Object.assign({
      column: 0,
      line: -1
    }, t.start), i = Object.assign({}, s, t.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = s.line, u = s.column, c = i.line, p = i.column, f = Math.max(l - (a + 1), 0), m = Math.min(e.length, c + o);
    l === -1 && (f = 0), c === -1 && (m = e.length);
    let y = c - l, T = {};
    if (y)
      for (let L = 0; L <= y; L++) {
        let q = L + l;
        if (!u)
          T[q] = !0;
        else if (L === 0) {
          let _ = e[q - 1].length;
          T[q] = [u, _ - u + 1];
        } else if (L === y)
          T[q] = [0, p];
        else {
          let _ = e[q - L].length;
          T[q] = [0, _];
        }
      }
    else
      u === p ? u ? T[l] = [u, 0] : T[l] = !0 : T[l] = [u, p - u];
    return {
      start: f,
      end: m,
      markerLines: T
    };
  }
  n(_ce, "getMarkerLines");
  function iC(t, e, r = {}) {
    let s = (r.highlightCode || r.forceColor) && (0, Zv.shouldHighlight)(r), i = kce(r.forceColor), a = Dce(i), o = /* @__PURE__ */ n((L, q) => s ?
    L(q) : q, "maybeHighlight"), l = t.split(rC), {
      start: u,
      end: c,
      markerLines: p
    } = _ce(e, l, r), f = e.start && typeof e.start.column == "number", m = String(c).length, T = (s ? (0, Zv.default)(t, r) : t).split(rC, c).
    slice(u, c).map((L, q) => {
      let _ = u + 1 + q, J = ` ${` ${_}`.slice(-m)} |`, ie = p[_], de = !p[_ + 1];
      if (ie) {
        let ne = "";
        if (Array.isArray(ie)) {
          let Be = L.slice(0, Math.max(ie[0] - 1, 0)).replace(/[^\t]/g, " "), bt = ie[1] || 1;
          ne = [`
 `, o(a.gutter, J.replace(/\d/g, " ")), " ", Be, o(a.marker, "^").repeat(bt)].join(""), de && r.message && (ne += " " + o(a.message, r.message));
        }
        return [o(a.marker, ">"), o(a.gutter, J), L.length > 0 ? ` ${L}` : "", ne].join("");
      } else
        return ` ${o(a.gutter, J)}${L.length > 0 ? ` ${L}` : ""}`;
    }).join(`
`);
    return r.message && !f && (T = `${" ".repeat(m + 1)}${r.message}
${T}`), s ? i.reset(T) : T;
  }
  n(iC, "codeFrameColumns");
  function Lce(t, e, r, s = {}) {
    if (!tC) {
      tC = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), iC(t, {
      start: {
        column: r,
        line: e
      }
    }, s);
  }
  n(Lce, "_default");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/parse.js
var Sy = w((xy) => {
  "use strict";
  Object.defineProperty(xy, "__esModule", {
    value: !0
  });
  xy.default = $ce;
  var Mce = Ce(), Bce = bv(), Fce = nC(), {
    isCallExpression: jce,
    isExpressionStatement: Rce,
    isFunction: Uce,
    isIdentifier: qce,
    isJSXIdentifier: Vce,
    isNewExpression: Kce,
    isPlaceholder: rc,
    isStatement: Wce,
    isStringLiteral: aC,
    removePropertiesDeep: Yce,
    traverse: Jce
  } = Mce, Xce = /^[_$A-Z0-9]+$/;
  function $ce(t, e, r) {
    let {
      placeholderWhitelist: s,
      placeholderPattern: i,
      preserveComments: a,
      syntacticPlaceholders: o
    } = r, l = Gce(e, r.parser, o);
    Yce(l, {
      preserveComments: a
    }), t.validate(l);
    let u = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: s,
      placeholderPattern: i,
      syntacticPlaceholders: o
    };
    return Jce(l, Hce, u), Object.assign({
      ast: l
    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
  }
  n($ce, "parseAndBuildMetadata");
  function Hce(t, e, r) {
    var s;
    let i, a = r.syntactic.placeholders.length > 0;
    if (rc(t)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      i = t.name.name, a = !0;
    } else {
      if (a || r.syntacticPlaceholders)
        return;
      if (qce(t) || Vce(t))
        i = t.name;
      else if (aC(t))
        i = t.value;
      else
        return;
    }
    if (a && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (r.placeholderPattern === !1 || !(r.placeholderPattern || Xce).test(i)) && !((s = r.placeholderWhitelist) != null && s.has(i)))
      return;
    e = e.slice();
    let {
      node: o,
      key: l
    } = e[e.length - 1], u;
    aC(t) || rc(t, {
      expectedNode: "StringLiteral"
    }) ? u = "string" : Kce(o) && l === "arguments" || jce(o) && l === "arguments" || Uce(o) && l === "params" ? u = "param" : Rce(o) && !rc(
    t) ? (u = "statement", e = e.slice(0, -1)) : Wce(t) && rc(t) ? u = "statement" : u = "other";
    let {
      placeholders: c,
      placeholderNames: p
    } = a ? r.syntactic : r.legacy;
    c.push({
      name: i,
      type: u,
      resolve: /* @__PURE__ */ n((f) => zce(f, e), "resolve"),
      isDuplicate: p.has(i)
    }), p.add(i);
  }
  n(Hce, "placeholderVisitorHandler");
  function zce(t, e) {
    let r = t;
    for (let a = 0; a < e.length - 1; a++) {
      let {
        key: o,
        index: l
      } = e[a];
      l === void 0 ? r = r[o] : r = r[o][l];
    }
    let {
      key: s,
      index: i
    } = e[e.length - 1];
    return {
      parent: r,
      key: s,
      index: i
    };
  }
  n(zce, "resolveAncestors");
  function Gce(t, e, r) {
    let s = (e.plugins || []).slice();
    r !== !1 && s.push("placeholders"), e = Object.assign({
      allowReturnOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      sourceType: "module"
    }, e, {
      plugins: s
    });
    try {
      return (0, Bce.parse)(t, e);
    } catch (i) {
      let a = i.loc;
      throw a && (i.message += `
` + (0, Fce.codeFrameColumns)(t, {
        start: a
      }), i.code = "BABEL_TEMPLATE_PARSE_ERROR"), i;
    }
  }
  n(Gce, "parseWithCodeFrame");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/populate.js
var Ay = w((Ey) => {
  "use strict";
  Object.defineProperty(Ey, "__esModule", {
    value: !0
  });
  Ey.default = spe;
  var Qce = Ce(), {
    blockStatement: Zce,
    cloneNode: Py,
    emptyStatement: epe,
    expressionStatement: gy,
    identifier: sc,
    isStatement: oC,
    isStringLiteral: tpe,
    stringLiteral: rpe,
    validate: lC
  } = Qce;
  function spe(t, e) {
    let r = Py(t.ast);
    return e && (t.placeholders.forEach((s) => {
      if (!hasOwnProperty.call(e, s.name)) {
        let i = s.name;
        throw new Error(`Error: No substitution given for "${i}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${i}'])}
            - { placeholderPattern: /^${i}$/ }`);
      }
    }), Object.keys(e).forEach((s) => {
      if (!t.placeholderNames.has(s))
        throw new Error(`Unknown substitution "${s}" given`);
    })), t.placeholders.slice().reverse().forEach((s) => {
      try {
        ipe(s, r, e && e[s.name] || null);
      } catch (i) {
        throw i.message = `@babel/template placeholder "${s.name}": ${i.message}`, i;
      }
    }), r;
  }
  n(spe, "populatePlaceholders");
  function ipe(t, e, r) {
    t.isDuplicate && (Array.isArray(r) ? r = r.map((o) => Py(o)) : typeof r == "object" && (r = Py(r)));
    let {
      parent: s,
      key: i,
      index: a
    } = t.resolve(e);
    if (t.type === "string") {
      if (typeof r == "string" && (r = rpe(r)), !r || !tpe(r))
        throw new Error("Expected string substitution");
    } else if (t.type === "statement")
      a === void 0 ? r ? Array.isArray(r) ? r = Zce(r) : typeof r == "string" ? r = gy(sc(r)) : oC(r) || (r = gy(r)) : r = epe() : r && !Array.
      isArray(r) && (typeof r == "string" && (r = sc(r)), oC(r) || (r = gy(r)));
    else if (t.type === "param") {
      if (typeof r == "string" && (r = sc(r)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof r == "string" && (r = sc(r)), Array.isArray(r))
      throw new Error("Cannot replace single expression with an array.");
    if (a === void 0)
      lC(s, i, r), s[i] = r;
    else {
      let o = s[i].slice();
      t.type === "statement" || t.type === "param" ? r == null ? o.splice(a, 1) : Array.isArray(r) ? o.splice(a, 1, ...r) : o[a] = r : o[a] =
      r, lC(s, i, o), s[i] = o;
    }
  }
  n(ipe, "applyReplacement");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/string.js
var uC = w((vy) => {
  "use strict";
  Object.defineProperty(vy, "__esModule", {
    value: !0
  });
  vy.default = lpe;
  var npe = ju(), ape = Sy(), ope = Ay();
  function lpe(t, e, r) {
    e = t.code(e);
    let s;
    return (i) => {
      let a = (0, npe.normalizeReplacements)(i);
      return s || (s = (0, ape.default)(t, e, r)), t.unwrap((0, ope.default)(s, a));
    };
  }
  n(lpe, "stringTemplate");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/literal.js
var cC = w((Cy) => {
  "use strict";
  Object.defineProperty(Cy, "__esModule", {
    value: !0
  });
  Cy.default = fpe;
  var upe = ju(), cpe = Sy(), ppe = Ay();
  function fpe(t, e, r) {
    let {
      metadata: s,
      names: i
    } = hpe(t, e, r);
    return (a) => {
      let o = {};
      return a.forEach((l, u) => {
        o[i[u]] = l;
      }), (l) => {
        let u = (0, upe.normalizeReplacements)(l);
        return u && Object.keys(u).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), t.unwrap((0, ppe.default)(s, u ? Object.assign(u, o) : o));
      };
    };
  }
  n(fpe, "literalTemplate");
  function hpe(t, e, r) {
    let s = "BABEL_TPL$", i = e.join("");
    do
      s = "$$" + s;
    while (i.includes(s));
    let {
      names: a,
      code: o
    } = dpe(e, s);
    return {
      metadata: (0, cpe.default)(t, t.code(o), {
        parser: r.parser,
        placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
        placeholderPattern: r.placeholderPattern,
        preserveComments: r.preserveComments,
        syntacticPlaceholders: r.syntacticPlaceholders
      }),
      names: a
    };
  }
  n(hpe, "buildLiteralData");
  function dpe(t, e) {
    let r = [], s = t[0];
    for (let i = 1; i < t.length; i++) {
      let a = `${e}${i - 1}`;
      r.push(a), s += a + t[i];
    }
    return {
      names: r,
      code: s
    };
  }
  n(dpe, "buildTemplateCode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/builder.js
var yC = w((Iy) => {
  "use strict";
  Object.defineProperty(Iy, "__esModule", {
    value: !0
  });
  Iy.default = mC;
  var cs = ju(), pC = uC(), fC = cC(), hC = (0, cs.validate)({
    placeholderPattern: !1
  });
  function mC(t, e) {
    let r = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), i = e || (0, cs.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return dC((0, pC.default)(t, a, (0, cs.merge)(i, (0, cs.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let l = r.get(a);
        return l || (l = (0, fC.default)(t, a, i), r.set(a, l)), dC(l(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return mC(t, (0, cs.merge)(i, (0, cs.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ n((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, pC.default)(t, a, (0, cs.merge)((0, cs.merge)(i, (0, cs.validate)(o[0])), hC))();
        } else if (Array.isArray(a)) {
          let l = s.get(a);
          return l || (l = (0, fC.default)(t, a, (0, cs.merge)(i, hC)), s.set(a, l)), l(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  n(mC, "createTemplateBuilder");
  function dC(t) {
    let e = "";
    try {
      throw new Error();
    } catch (r) {
      r.stack && (e = r.stack.split(`
`).slice(3).join(`
`));
    }
    return (r) => {
      try {
        return t(r);
      } catch (s) {
        throw s.stack += `
    =============
${e}`, s;
      }
    };
  }
  n(dC, "extendedTrace");
});

// ../node_modules/@babel/traverse/node_modules/@babel/template/lib/index.js
var TC = w((Or) => {
  "use strict";
  Object.defineProperty(Or, "__esModule", {
    value: !0
  });
  Or.statements = Or.statement = Or.smart = Or.program = Or.expression = Or.default = void 0;
  var go = R1(), Po = yC(), wy = Or.smart = (0, Po.default)(go.smart), mpe = Or.statement = (0, Po.default)(go.statement), ype = Or.statements =
  (0, Po.default)(go.statements), Tpe = Or.expression = (0, Po.default)(go.expression), bpe = Or.program = (0, Po.default)(go.program), W8e = Or.
  default = Object.assign(wy.bind(void 0), {
    smart: wy,
    statement: mpe,
    statements: ype,
    expression: Tpe,
    program: bpe,
    ast: wy.ast
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/utils/shallowEqual.js
var ic = w((Ny) => {
  "use strict";
  Object.defineProperty(Ny, "__esModule", {
    value: !0
  });
  Ny.default = xpe;
  function xpe(t, e) {
    let r = Object.keys(e);
    for (let s of r)
      if (t[s] !== e[s])
        return !1;
    return !0;
  }
  n(xpe, "shallowEqual");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/utils/deprecationWarning.js
var Eo = w((Oy) => {
  "use strict";
  Object.defineProperty(Oy, "__esModule", {
    value: !0
  });
  Oy.default = Spe;
  var bC = /* @__PURE__ */ new Set();
  function Spe(t, e, r = "") {
    if (bC.has(t)) return;
    bC.add(t);
    let {
      internal: s,
      trace: i
    } = gpe(1, 2);
    s || console.warn(`${r}\`${t}\` has been deprecated, please migrate to \`${e}\`
${i}`);
  }
  n(Spe, "deprecationWarning");
  function gpe(t, e) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: s
    } = Error, i;
    if (Error.stackTraceLimit = 1 + t + e, Error.prepareStackTrace = function(o, l) {
      i = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = s, !i) return {
      internal: !1,
      trace: ""
    };
    let a = i.slice(1 + t, 1 + t + e);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  n(gpe, "captureShortStackTrace");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/generated/index.js
var Rt = w((P) => {
  "use strict";
  Object.defineProperty(P, "__esModule", {
    value: !0
  });
  P.isAccessor = Mye;
  P.isAnyTypeAnnotation = rhe;
  P.isArgumentPlaceholder = kde;
  P.isArrayExpression = Ppe;
  P.isArrayPattern = Sfe;
  P.isArrayTypeAnnotation = she;
  P.isArrowFunctionExpression = gfe;
  P.isAssignmentExpression = Epe;
  P.isAssignmentPattern = xfe;
  P.isAwaitExpression = Wfe;
  P.isBigIntLiteral = Jfe;
  P.isBinary = iye;
  P.isBinaryExpression = Ape;
  P.isBindExpression = Dde;
  P.isBlock = oye;
  P.isBlockParent = aye;
  P.isBlockStatement = wpe;
  P.isBooleanLiteral = Hpe;
  P.isBooleanLiteralTypeAnnotation = nhe;
  P.isBooleanTypeAnnotation = ihe;
  P.isBreakStatement = Npe;
  P.isCallExpression = Ope;
  P.isCatchClause = kpe;
  P.isClass = Dye;
  P.isClassAccessorProperty = Gfe;
  P.isClassBody = Pfe;
  P.isClassDeclaration = Afe;
  P.isClassExpression = Efe;
  P.isClassImplements = ohe;
  P.isClassMethod = Bfe;
  P.isClassPrivateMethod = Zfe;
  P.isClassPrivateProperty = Qfe;
  P.isClassProperty = zfe;
  P.isCompletionStatement = cye;
  P.isConditional = pye;
  P.isConditionalExpression = Dpe;
  P.isContinueStatement = _pe;
  P.isDebuggerStatement = Lpe;
  P.isDecimalLiteral = Rde;
  P.isDeclaration = Sye;
  P.isDeclareClass = lhe;
  P.isDeclareExportAllDeclaration = The;
  P.isDeclareExportDeclaration = yhe;
  P.isDeclareFunction = uhe;
  P.isDeclareInterface = che;
  P.isDeclareModule = phe;
  P.isDeclareModuleExports = fhe;
  P.isDeclareOpaqueType = dhe;
  P.isDeclareTypeAlias = hhe;
  P.isDeclareVariable = mhe;
  P.isDeclaredPredicate = bhe;
  P.isDecorator = Lde;
  P.isDirective = Cpe;
  P.isDirectiveLiteral = Ipe;
  P.isDoExpression = Mde;
  P.isDoWhileStatement = Mpe;
  P.isEmptyStatement = Bpe;
  P.isEmptyTypeAnnotation = Nhe;
  P.isEnumBody = Vye;
  P.isEnumBooleanBody = sde;
  P.isEnumBooleanMember = ode;
  P.isEnumDeclaration = rde;
  P.isEnumDefaultedMember = cde;
  P.isEnumMember = Kye;
  P.isEnumNumberBody = ide;
  P.isEnumNumberMember = lde;
  P.isEnumStringBody = nde;
  P.isEnumStringMember = ude;
  P.isEnumSymbolBody = ade;
  P.isExistsTypeAnnotation = xhe;
  P.isExportAllDeclaration = vfe;
  P.isExportDeclaration = _ye;
  P.isExportDefaultDeclaration = Cfe;
  P.isExportDefaultSpecifier = Bde;
  P.isExportNamedDeclaration = Ife;
  P.isExportNamespaceSpecifier = Xfe;
  P.isExportSpecifier = wfe;
  P.isExpression = sye;
  P.isExpressionStatement = Fpe;
  P.isExpressionWrapper = dye;
  P.isFile = jpe;
  P.isFlow = Fye;
  P.isFlowBaseAnnotation = Rye;
  P.isFlowDeclaration = Uye;
  P.isFlowPredicate = qye;
  P.isFlowType = jye;
  P.isFor = mye;
  P.isForInStatement = Rpe;
  P.isForOfStatement = Nfe;
  P.isForStatement = Upe;
  P.isForXStatement = yye;
  P.isFunction = Tye;
  P.isFunctionDeclaration = qpe;
  P.isFunctionExpression = Vpe;
  P.isFunctionParent = bye;
  P.isFunctionTypeAnnotation = She;
  P.isFunctionTypeParam = ghe;
  P.isGenericTypeAnnotation = Phe;
  P.isIdentifier = Kpe;
  P.isIfStatement = Wpe;
  P.isImmutable = vye;
  P.isImport = Yfe;
  P.isImportAttribute = _de;
  P.isImportDeclaration = Ofe;
  P.isImportDefaultSpecifier = kfe;
  P.isImportExpression = Lfe;
  P.isImportNamespaceSpecifier = Dfe;
  P.isImportOrExportDeclaration = xC;
  P.isImportSpecifier = _fe;
  P.isIndexedAccessType = pde;
  P.isInferredPredicate = Ehe;
  P.isInterfaceDeclaration = vhe;
  P.isInterfaceExtends = Ahe;
  P.isInterfaceTypeAnnotation = Che;
  P.isInterpreterDirective = vpe;
  P.isIntersectionTypeAnnotation = Ihe;
  P.isJSX = Wye;
  P.isJSXAttribute = hde;
  P.isJSXClosingElement = dde;
  P.isJSXClosingFragment = Ide;
  P.isJSXElement = mde;
  P.isJSXEmptyExpression = yde;
  P.isJSXExpressionContainer = Tde;
  P.isJSXFragment = vde;
  P.isJSXIdentifier = xde;
  P.isJSXMemberExpression = Sde;
  P.isJSXNamespacedName = gde;
  P.isJSXOpeningElement = Pde;
  P.isJSXOpeningFragment = Cde;
  P.isJSXSpreadAttribute = Ede;
  P.isJSXSpreadChild = bde;
  P.isJSXText = Ade;
  P.isLVal = Pye;
  P.isLabeledStatement = Ype;
  P.isLiteral = Aye;
  P.isLogicalExpression = Gpe;
  P.isLoop = fye;
  P.isMemberExpression = Qpe;
  P.isMetaProperty = Mfe;
  P.isMethod = Iye;
  P.isMiscellaneous = Yye;
  P.isMixedTypeAnnotation = whe;
  P.isModuleDeclaration = eTe;
  P.isModuleExpression = Ude;
  P.isModuleSpecifier = Lye;
  P.isNewExpression = Zpe;
  P.isNoop = wde;
  P.isNullLiteral = $pe;
  P.isNullLiteralTypeAnnotation = ahe;
  P.isNullableTypeAnnotation = Ohe;
  P.isNumberLiteral = zye;
  P.isNumberLiteralTypeAnnotation = khe;
  P.isNumberTypeAnnotation = Dhe;
  P.isNumericLiteral = Xpe;
  P.isObjectExpression = tfe;
  P.isObjectMember = wye;
  P.isObjectMethod = rfe;
  P.isObjectPattern = Ffe;
  P.isObjectProperty = sfe;
  P.isObjectTypeAnnotation = _he;
  P.isObjectTypeCallProperty = Mhe;
  P.isObjectTypeIndexer = Bhe;
  P.isObjectTypeInternalSlot = Lhe;
  P.isObjectTypeProperty = Fhe;
  P.isObjectTypeSpreadProperty = jhe;
  P.isOpaqueType = Rhe;
  P.isOptionalCallExpression = Hfe;
  P.isOptionalIndexedAccessType = fde;
  P.isOptionalMemberExpression = $fe;
  P.isParenthesizedExpression = ofe;
  P.isPattern = kye;
  P.isPatternLike = gye;
  P.isPipelineBareFunction = Kde;
  P.isPipelinePrimaryTopicReference = Wde;
  P.isPipelineTopicExpression = Vde;
  P.isPlaceholder = Nde;
  P.isPrivate = Bye;
  P.isPrivateName = ehe;
  P.isProgram = efe;
  P.isProperty = Nye;
  P.isPureish = xye;
  P.isQualifiedTypeIdentifier = Uhe;
  P.isRecordExpression = Fde;
  P.isRegExpLiteral = zpe;
  P.isRegexLiteral = Gye;
  P.isRestElement = ife;
  P.isRestProperty = Qye;
  P.isReturnStatement = nfe;
  P.isScopable = nye;
  P.isSequenceExpression = afe;
  P.isSpreadElement = jfe;
  P.isSpreadProperty = Zye;
  P.isStandardized = rye;
  P.isStatement = lye;
  P.isStaticBlock = the;
  P.isStringLiteral = Jpe;
  P.isStringLiteralTypeAnnotation = qhe;
  P.isStringTypeAnnotation = Vhe;
  P.isSuper = Rfe;
  P.isSwitchCase = lfe;
  P.isSwitchStatement = ufe;
  P.isSymbolTypeAnnotation = Khe;
  P.isTSAnyKeyword = eme;
  P.isTSArrayType = Sme;
  P.isTSAsExpression = Rme;
  P.isTSBaseType = Hye;
  P.isTSBigIntKeyword = rme;
  P.isTSBooleanKeyword = tme;
  P.isTSCallSignatureDeclaration = Hde;
  P.isTSConditionalType = Ime;
  P.isTSConstructSignatureDeclaration = zde;
  P.isTSConstructorType = mme;
  P.isTSDeclareFunction = Jde;
  P.isTSDeclareMethod = Xde;
  P.isTSEntityName = Eye;
  P.isTSEnumDeclaration = Vme;
  P.isTSEnumMember = Kme;
  P.isTSExportAssignment = zme;
  P.isTSExpressionWithTypeArguments = Lme;
  P.isTSExternalModuleReference = $me;
  P.isTSFunctionType = dme;
  P.isTSImportEqualsDeclaration = Xme;
  P.isTSImportType = Jme;
  P.isTSIndexSignature = Zde;
  P.isTSIndexedAccessType = kme;
  P.isTSInferType = wme;
  P.isTSInstantiationExpression = jme;
  P.isTSInterfaceBody = Bme;
  P.isTSInterfaceDeclaration = Mme;
  P.isTSIntersectionType = Cme;
  P.isTSIntrinsicKeyword = sme;
  P.isTSLiteralType = _me;
  P.isTSMappedType = Dme;
  P.isTSMethodSignature = Qde;
  P.isTSModuleBlock = Yme;
  P.isTSModuleDeclaration = Wme;
  P.isTSNamedTupleMember = Ame;
  P.isTSNamespaceExportDeclaration = Gme;
  P.isTSNeverKeyword = ime;
  P.isTSNonNullExpression = Hme;
  P.isTSNullKeyword = nme;
  P.isTSNumberKeyword = ame;
  P.isTSObjectKeyword = ome;
  P.isTSOptionalType = Pme;
  P.isTSParameterProperty = Yde;
  P.isTSParenthesizedType = Nme;
  P.isTSPropertySignature = Gde;
  P.isTSQualifiedName = $de;
  P.isTSRestType = Eme;
  P.isTSSatisfiesExpression = Ume;
  P.isTSStringKeyword = lme;
  P.isTSSymbolKeyword = ume;
  P.isTSThisType = hme;
  P.isTSTupleType = gme;
  P.isTSType = $ye;
  P.isTSTypeAliasDeclaration = Fme;
  P.isTSTypeAnnotation = Qme;
  P.isTSTypeAssertion = qme;
  P.isTSTypeElement = Xye;
  P.isTSTypeLiteral = xme;
  P.isTSTypeOperator = Ome;
  P.isTSTypeParameter = tye;
  P.isTSTypeParameterDeclaration = eye;
  P.isTSTypeParameterInstantiation = Zme;
  P.isTSTypePredicate = Tme;
  P.isTSTypeQuery = bme;
  P.isTSTypeReference = yme;
  P.isTSUndefinedKeyword = cme;
  P.isTSUnionType = vme;
  P.isTSUnknownKeyword = pme;
  P.isTSVoidKeyword = fme;
  P.isTaggedTemplateExpression = Ufe;
  P.isTemplateElement = qfe;
  P.isTemplateLiteral = Vfe;
  P.isTerminatorless = uye;
  P.isThisExpression = cfe;
  P.isThisTypeAnnotation = Whe;
  P.isThrowStatement = pfe;
  P.isTopicReference = qde;
  P.isTryStatement = ffe;
  P.isTupleExpression = jde;
  P.isTupleTypeAnnotation = Yhe;
  P.isTypeAlias = Xhe;
  P.isTypeAnnotation = $he;
  P.isTypeCastExpression = Hhe;
  P.isTypeParameter = zhe;
  P.isTypeParameterDeclaration = Ghe;
  P.isTypeParameterInstantiation = Qhe;
  P.isTypeScript = Jye;
  P.isTypeofTypeAnnotation = Jhe;
  P.isUnaryExpression = hfe;
  P.isUnaryLike = Oye;
  P.isUnionTypeAnnotation = Zhe;
  P.isUpdateExpression = dfe;
  P.isUserWhitespacable = Cye;
  P.isV8IntrinsicIdentifier = Ode;
  P.isVariableDeclaration = mfe;
  P.isVariableDeclarator = yfe;
  P.isVariance = ede;
  P.isVoidTypeAnnotation = tde;
  P.isWhile = hye;
  P.isWhileStatement = Tfe;
  P.isWithStatement = bfe;
  P.isYieldExpression = Kfe;
  var I = ic(), Ao = Eo();
  function Ppe(t, e) {
    return !t || t.type !== "ArrayExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ppe, "isArrayExpression");
  function Epe(t, e) {
    return !t || t.type !== "AssignmentExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Epe, "isAssignmentExpression");
  function Ape(t, e) {
    return !t || t.type !== "BinaryExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ape, "isBinaryExpression");
  function vpe(t, e) {
    return !t || t.type !== "InterpreterDirective" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vpe, "isInterpreterDirective");
  function Cpe(t, e) {
    return !t || t.type !== "Directive" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Cpe, "isDirective");
  function Ipe(t, e) {
    return !t || t.type !== "DirectiveLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ipe, "isDirectiveLiteral");
  function wpe(t, e) {
    return !t || t.type !== "BlockStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(wpe, "isBlockStatement");
  function Npe(t, e) {
    return !t || t.type !== "BreakStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Npe, "isBreakStatement");
  function Ope(t, e) {
    return !t || t.type !== "CallExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ope, "isCallExpression");
  function kpe(t, e) {
    return !t || t.type !== "CatchClause" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(kpe, "isCatchClause");
  function Dpe(t, e) {
    return !t || t.type !== "ConditionalExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dpe, "isConditionalExpression");
  function _pe(t, e) {
    return !t || t.type !== "ContinueStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_pe, "isContinueStatement");
  function Lpe(t, e) {
    return !t || t.type !== "DebuggerStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lpe, "isDebuggerStatement");
  function Mpe(t, e) {
    return !t || t.type !== "DoWhileStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mpe, "isDoWhileStatement");
  function Bpe(t, e) {
    return !t || t.type !== "EmptyStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bpe, "isEmptyStatement");
  function Fpe(t, e) {
    return !t || t.type !== "ExpressionStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Fpe, "isExpressionStatement");
  function jpe(t, e) {
    return !t || t.type !== "File" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jpe, "isFile");
  function Rpe(t, e) {
    return !t || t.type !== "ForInStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rpe, "isForInStatement");
  function Upe(t, e) {
    return !t || t.type !== "ForStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Upe, "isForStatement");
  function qpe(t, e) {
    return !t || t.type !== "FunctionDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qpe, "isFunctionDeclaration");
  function Vpe(t, e) {
    return !t || t.type !== "FunctionExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vpe, "isFunctionExpression");
  function Kpe(t, e) {
    return !t || t.type !== "Identifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Kpe, "isIdentifier");
  function Wpe(t, e) {
    return !t || t.type !== "IfStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Wpe, "isIfStatement");
  function Ype(t, e) {
    return !t || t.type !== "LabeledStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ype, "isLabeledStatement");
  function Jpe(t, e) {
    return !t || t.type !== "StringLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jpe, "isStringLiteral");
  function Xpe(t, e) {
    return !t || t.type !== "NumericLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xpe, "isNumericLiteral");
  function $pe(t, e) {
    return !t || t.type !== "NullLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($pe, "isNullLiteral");
  function Hpe(t, e) {
    return !t || t.type !== "BooleanLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hpe, "isBooleanLiteral");
  function zpe(t, e) {
    return !t || t.type !== "RegExpLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zpe, "isRegExpLiteral");
  function Gpe(t, e) {
    return !t || t.type !== "LogicalExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gpe, "isLogicalExpression");
  function Qpe(t, e) {
    return !t || t.type !== "MemberExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qpe, "isMemberExpression");
  function Zpe(t, e) {
    return !t || t.type !== "NewExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zpe, "isNewExpression");
  function efe(t, e) {
    return !t || t.type !== "Program" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(efe, "isProgram");
  function tfe(t, e) {
    return !t || t.type !== "ObjectExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(tfe, "isObjectExpression");
  function rfe(t, e) {
    return !t || t.type !== "ObjectMethod" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rfe, "isObjectMethod");
  function sfe(t, e) {
    return !t || t.type !== "ObjectProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(sfe, "isObjectProperty");
  function ife(t, e) {
    return !t || t.type !== "RestElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ife, "isRestElement");
  function nfe(t, e) {
    return !t || t.type !== "ReturnStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nfe, "isReturnStatement");
  function afe(t, e) {
    return !t || t.type !== "SequenceExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(afe, "isSequenceExpression");
  function ofe(t, e) {
    return !t || t.type !== "ParenthesizedExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ofe, "isParenthesizedExpression");
  function lfe(t, e) {
    return !t || t.type !== "SwitchCase" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lfe, "isSwitchCase");
  function ufe(t, e) {
    return !t || t.type !== "SwitchStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ufe, "isSwitchStatement");
  function cfe(t, e) {
    return !t || t.type !== "ThisExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(cfe, "isThisExpression");
  function pfe(t, e) {
    return !t || t.type !== "ThrowStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(pfe, "isThrowStatement");
  function ffe(t, e) {
    return !t || t.type !== "TryStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ffe, "isTryStatement");
  function hfe(t, e) {
    return !t || t.type !== "UnaryExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(hfe, "isUnaryExpression");
  function dfe(t, e) {
    return !t || t.type !== "UpdateExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(dfe, "isUpdateExpression");
  function mfe(t, e) {
    return !t || t.type !== "VariableDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(mfe, "isVariableDeclaration");
  function yfe(t, e) {
    return !t || t.type !== "VariableDeclarator" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(yfe, "isVariableDeclarator");
  function Tfe(t, e) {
    return !t || t.type !== "WhileStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Tfe, "isWhileStatement");
  function bfe(t, e) {
    return !t || t.type !== "WithStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(bfe, "isWithStatement");
  function xfe(t, e) {
    return !t || t.type !== "AssignmentPattern" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(xfe, "isAssignmentPattern");
  function Sfe(t, e) {
    return !t || t.type !== "ArrayPattern" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Sfe, "isArrayPattern");
  function gfe(t, e) {
    return !t || t.type !== "ArrowFunctionExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(gfe, "isArrowFunctionExpression");
  function Pfe(t, e) {
    return !t || t.type !== "ClassBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Pfe, "isClassBody");
  function Efe(t, e) {
    return !t || t.type !== "ClassExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Efe, "isClassExpression");
  function Afe(t, e) {
    return !t || t.type !== "ClassDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Afe, "isClassDeclaration");
  function vfe(t, e) {
    return !t || t.type !== "ExportAllDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vfe, "isExportAllDeclaration");
  function Cfe(t, e) {
    return !t || t.type !== "ExportDefaultDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Cfe, "isExportDefaultDeclaration");
  function Ife(t, e) {
    return !t || t.type !== "ExportNamedDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ife, "isExportNamedDeclaration");
  function wfe(t, e) {
    return !t || t.type !== "ExportSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(wfe, "isExportSpecifier");
  function Nfe(t, e) {
    return !t || t.type !== "ForOfStatement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Nfe, "isForOfStatement");
  function Ofe(t, e) {
    return !t || t.type !== "ImportDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ofe, "isImportDeclaration");
  function kfe(t, e) {
    return !t || t.type !== "ImportDefaultSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(kfe, "isImportDefaultSpecifier");
  function Dfe(t, e) {
    return !t || t.type !== "ImportNamespaceSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dfe, "isImportNamespaceSpecifier");
  function _fe(t, e) {
    return !t || t.type !== "ImportSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_fe, "isImportSpecifier");
  function Lfe(t, e) {
    return !t || t.type !== "ImportExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lfe, "isImportExpression");
  function Mfe(t, e) {
    return !t || t.type !== "MetaProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mfe, "isMetaProperty");
  function Bfe(t, e) {
    return !t || t.type !== "ClassMethod" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bfe, "isClassMethod");
  function Ffe(t, e) {
    return !t || t.type !== "ObjectPattern" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ffe, "isObjectPattern");
  function jfe(t, e) {
    return !t || t.type !== "SpreadElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jfe, "isSpreadElement");
  function Rfe(t, e) {
    return !t || t.type !== "Super" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rfe, "isSuper");
  function Ufe(t, e) {
    return !t || t.type !== "TaggedTemplateExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ufe, "isTaggedTemplateExpression");
  function qfe(t, e) {
    return !t || t.type !== "TemplateElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qfe, "isTemplateElement");
  function Vfe(t, e) {
    return !t || t.type !== "TemplateLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vfe, "isTemplateLiteral");
  function Kfe(t, e) {
    return !t || t.type !== "YieldExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Kfe, "isYieldExpression");
  function Wfe(t, e) {
    return !t || t.type !== "AwaitExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Wfe, "isAwaitExpression");
  function Yfe(t, e) {
    return !t || t.type !== "Import" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Yfe, "isImport");
  function Jfe(t, e) {
    return !t || t.type !== "BigIntLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jfe, "isBigIntLiteral");
  function Xfe(t, e) {
    return !t || t.type !== "ExportNamespaceSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xfe, "isExportNamespaceSpecifier");
  function $fe(t, e) {
    return !t || t.type !== "OptionalMemberExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($fe, "isOptionalMemberExpression");
  function Hfe(t, e) {
    return !t || t.type !== "OptionalCallExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hfe, "isOptionalCallExpression");
  function zfe(t, e) {
    return !t || t.type !== "ClassProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zfe, "isClassProperty");
  function Gfe(t, e) {
    return !t || t.type !== "ClassAccessorProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gfe, "isClassAccessorProperty");
  function Qfe(t, e) {
    return !t || t.type !== "ClassPrivateProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qfe, "isClassPrivateProperty");
  function Zfe(t, e) {
    return !t || t.type !== "ClassPrivateMethod" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zfe, "isClassPrivateMethod");
  function ehe(t, e) {
    return !t || t.type !== "PrivateName" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ehe, "isPrivateName");
  function the(t, e) {
    return !t || t.type !== "StaticBlock" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(the, "isStaticBlock");
  function rhe(t, e) {
    return !t || t.type !== "AnyTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rhe, "isAnyTypeAnnotation");
  function she(t, e) {
    return !t || t.type !== "ArrayTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(she, "isArrayTypeAnnotation");
  function ihe(t, e) {
    return !t || t.type !== "BooleanTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ihe, "isBooleanTypeAnnotation");
  function nhe(t, e) {
    return !t || t.type !== "BooleanLiteralTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nhe, "isBooleanLiteralTypeAnnotation");
  function ahe(t, e) {
    return !t || t.type !== "NullLiteralTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ahe, "isNullLiteralTypeAnnotation");
  function ohe(t, e) {
    return !t || t.type !== "ClassImplements" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ohe, "isClassImplements");
  function lhe(t, e) {
    return !t || t.type !== "DeclareClass" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lhe, "isDeclareClass");
  function uhe(t, e) {
    return !t || t.type !== "DeclareFunction" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(uhe, "isDeclareFunction");
  function che(t, e) {
    return !t || t.type !== "DeclareInterface" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(che, "isDeclareInterface");
  function phe(t, e) {
    return !t || t.type !== "DeclareModule" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(phe, "isDeclareModule");
  function fhe(t, e) {
    return !t || t.type !== "DeclareModuleExports" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(fhe, "isDeclareModuleExports");
  function hhe(t, e) {
    return !t || t.type !== "DeclareTypeAlias" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(hhe, "isDeclareTypeAlias");
  function dhe(t, e) {
    return !t || t.type !== "DeclareOpaqueType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(dhe, "isDeclareOpaqueType");
  function mhe(t, e) {
    return !t || t.type !== "DeclareVariable" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(mhe, "isDeclareVariable");
  function yhe(t, e) {
    return !t || t.type !== "DeclareExportDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(yhe, "isDeclareExportDeclaration");
  function The(t, e) {
    return !t || t.type !== "DeclareExportAllDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(The, "isDeclareExportAllDeclaration");
  function bhe(t, e) {
    return !t || t.type !== "DeclaredPredicate" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(bhe, "isDeclaredPredicate");
  function xhe(t, e) {
    return !t || t.type !== "ExistsTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(xhe, "isExistsTypeAnnotation");
  function She(t, e) {
    return !t || t.type !== "FunctionTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(She, "isFunctionTypeAnnotation");
  function ghe(t, e) {
    return !t || t.type !== "FunctionTypeParam" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ghe, "isFunctionTypeParam");
  function Phe(t, e) {
    return !t || t.type !== "GenericTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Phe, "isGenericTypeAnnotation");
  function Ehe(t, e) {
    return !t || t.type !== "InferredPredicate" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ehe, "isInferredPredicate");
  function Ahe(t, e) {
    return !t || t.type !== "InterfaceExtends" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ahe, "isInterfaceExtends");
  function vhe(t, e) {
    return !t || t.type !== "InterfaceDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vhe, "isInterfaceDeclaration");
  function Che(t, e) {
    return !t || t.type !== "InterfaceTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Che, "isInterfaceTypeAnnotation");
  function Ihe(t, e) {
    return !t || t.type !== "IntersectionTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ihe, "isIntersectionTypeAnnotation");
  function whe(t, e) {
    return !t || t.type !== "MixedTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(whe, "isMixedTypeAnnotation");
  function Nhe(t, e) {
    return !t || t.type !== "EmptyTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Nhe, "isEmptyTypeAnnotation");
  function Ohe(t, e) {
    return !t || t.type !== "NullableTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ohe, "isNullableTypeAnnotation");
  function khe(t, e) {
    return !t || t.type !== "NumberLiteralTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(khe, "isNumberLiteralTypeAnnotation");
  function Dhe(t, e) {
    return !t || t.type !== "NumberTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dhe, "isNumberTypeAnnotation");
  function _he(t, e) {
    return !t || t.type !== "ObjectTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_he, "isObjectTypeAnnotation");
  function Lhe(t, e) {
    return !t || t.type !== "ObjectTypeInternalSlot" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lhe, "isObjectTypeInternalSlot");
  function Mhe(t, e) {
    return !t || t.type !== "ObjectTypeCallProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mhe, "isObjectTypeCallProperty");
  function Bhe(t, e) {
    return !t || t.type !== "ObjectTypeIndexer" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bhe, "isObjectTypeIndexer");
  function Fhe(t, e) {
    return !t || t.type !== "ObjectTypeProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Fhe, "isObjectTypeProperty");
  function jhe(t, e) {
    return !t || t.type !== "ObjectTypeSpreadProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jhe, "isObjectTypeSpreadProperty");
  function Rhe(t, e) {
    return !t || t.type !== "OpaqueType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rhe, "isOpaqueType");
  function Uhe(t, e) {
    return !t || t.type !== "QualifiedTypeIdentifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Uhe, "isQualifiedTypeIdentifier");
  function qhe(t, e) {
    return !t || t.type !== "StringLiteralTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qhe, "isStringLiteralTypeAnnotation");
  function Vhe(t, e) {
    return !t || t.type !== "StringTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vhe, "isStringTypeAnnotation");
  function Khe(t, e) {
    return !t || t.type !== "SymbolTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Khe, "isSymbolTypeAnnotation");
  function Whe(t, e) {
    return !t || t.type !== "ThisTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Whe, "isThisTypeAnnotation");
  function Yhe(t, e) {
    return !t || t.type !== "TupleTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Yhe, "isTupleTypeAnnotation");
  function Jhe(t, e) {
    return !t || t.type !== "TypeofTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jhe, "isTypeofTypeAnnotation");
  function Xhe(t, e) {
    return !t || t.type !== "TypeAlias" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xhe, "isTypeAlias");
  function $he(t, e) {
    return !t || t.type !== "TypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($he, "isTypeAnnotation");
  function Hhe(t, e) {
    return !t || t.type !== "TypeCastExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hhe, "isTypeCastExpression");
  function zhe(t, e) {
    return !t || t.type !== "TypeParameter" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zhe, "isTypeParameter");
  function Ghe(t, e) {
    return !t || t.type !== "TypeParameterDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ghe, "isTypeParameterDeclaration");
  function Qhe(t, e) {
    return !t || t.type !== "TypeParameterInstantiation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qhe, "isTypeParameterInstantiation");
  function Zhe(t, e) {
    return !t || t.type !== "UnionTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zhe, "isUnionTypeAnnotation");
  function ede(t, e) {
    return !t || t.type !== "Variance" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ede, "isVariance");
  function tde(t, e) {
    return !t || t.type !== "VoidTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(tde, "isVoidTypeAnnotation");
  function rde(t, e) {
    return !t || t.type !== "EnumDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rde, "isEnumDeclaration");
  function sde(t, e) {
    return !t || t.type !== "EnumBooleanBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(sde, "isEnumBooleanBody");
  function ide(t, e) {
    return !t || t.type !== "EnumNumberBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ide, "isEnumNumberBody");
  function nde(t, e) {
    return !t || t.type !== "EnumStringBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nde, "isEnumStringBody");
  function ade(t, e) {
    return !t || t.type !== "EnumSymbolBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ade, "isEnumSymbolBody");
  function ode(t, e) {
    return !t || t.type !== "EnumBooleanMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ode, "isEnumBooleanMember");
  function lde(t, e) {
    return !t || t.type !== "EnumNumberMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lde, "isEnumNumberMember");
  function ude(t, e) {
    return !t || t.type !== "EnumStringMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ude, "isEnumStringMember");
  function cde(t, e) {
    return !t || t.type !== "EnumDefaultedMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(cde, "isEnumDefaultedMember");
  function pde(t, e) {
    return !t || t.type !== "IndexedAccessType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(pde, "isIndexedAccessType");
  function fde(t, e) {
    return !t || t.type !== "OptionalIndexedAccessType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(fde, "isOptionalIndexedAccessType");
  function hde(t, e) {
    return !t || t.type !== "JSXAttribute" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(hde, "isJSXAttribute");
  function dde(t, e) {
    return !t || t.type !== "JSXClosingElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(dde, "isJSXClosingElement");
  function mde(t, e) {
    return !t || t.type !== "JSXElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(mde, "isJSXElement");
  function yde(t, e) {
    return !t || t.type !== "JSXEmptyExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(yde, "isJSXEmptyExpression");
  function Tde(t, e) {
    return !t || t.type !== "JSXExpressionContainer" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Tde, "isJSXExpressionContainer");
  function bde(t, e) {
    return !t || t.type !== "JSXSpreadChild" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(bde, "isJSXSpreadChild");
  function xde(t, e) {
    return !t || t.type !== "JSXIdentifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(xde, "isJSXIdentifier");
  function Sde(t, e) {
    return !t || t.type !== "JSXMemberExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Sde, "isJSXMemberExpression");
  function gde(t, e) {
    return !t || t.type !== "JSXNamespacedName" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(gde, "isJSXNamespacedName");
  function Pde(t, e) {
    return !t || t.type !== "JSXOpeningElement" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Pde, "isJSXOpeningElement");
  function Ede(t, e) {
    return !t || t.type !== "JSXSpreadAttribute" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ede, "isJSXSpreadAttribute");
  function Ade(t, e) {
    return !t || t.type !== "JSXText" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ade, "isJSXText");
  function vde(t, e) {
    return !t || t.type !== "JSXFragment" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vde, "isJSXFragment");
  function Cde(t, e) {
    return !t || t.type !== "JSXOpeningFragment" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Cde, "isJSXOpeningFragment");
  function Ide(t, e) {
    return !t || t.type !== "JSXClosingFragment" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ide, "isJSXClosingFragment");
  function wde(t, e) {
    return !t || t.type !== "Noop" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(wde, "isNoop");
  function Nde(t, e) {
    return !t || t.type !== "Placeholder" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Nde, "isPlaceholder");
  function Ode(t, e) {
    return !t || t.type !== "V8IntrinsicIdentifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ode, "isV8IntrinsicIdentifier");
  function kde(t, e) {
    return !t || t.type !== "ArgumentPlaceholder" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(kde, "isArgumentPlaceholder");
  function Dde(t, e) {
    return !t || t.type !== "BindExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dde, "isBindExpression");
  function _de(t, e) {
    return !t || t.type !== "ImportAttribute" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_de, "isImportAttribute");
  function Lde(t, e) {
    return !t || t.type !== "Decorator" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lde, "isDecorator");
  function Mde(t, e) {
    return !t || t.type !== "DoExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mde, "isDoExpression");
  function Bde(t, e) {
    return !t || t.type !== "ExportDefaultSpecifier" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bde, "isExportDefaultSpecifier");
  function Fde(t, e) {
    return !t || t.type !== "RecordExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Fde, "isRecordExpression");
  function jde(t, e) {
    return !t || t.type !== "TupleExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jde, "isTupleExpression");
  function Rde(t, e) {
    return !t || t.type !== "DecimalLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rde, "isDecimalLiteral");
  function Ude(t, e) {
    return !t || t.type !== "ModuleExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ude, "isModuleExpression");
  function qde(t, e) {
    return !t || t.type !== "TopicReference" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qde, "isTopicReference");
  function Vde(t, e) {
    return !t || t.type !== "PipelineTopicExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vde, "isPipelineTopicExpression");
  function Kde(t, e) {
    return !t || t.type !== "PipelineBareFunction" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Kde, "isPipelineBareFunction");
  function Wde(t, e) {
    return !t || t.type !== "PipelinePrimaryTopicReference" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Wde, "isPipelinePrimaryTopicReference");
  function Yde(t, e) {
    return !t || t.type !== "TSParameterProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Yde, "isTSParameterProperty");
  function Jde(t, e) {
    return !t || t.type !== "TSDeclareFunction" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jde, "isTSDeclareFunction");
  function Xde(t, e) {
    return !t || t.type !== "TSDeclareMethod" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xde, "isTSDeclareMethod");
  function $de(t, e) {
    return !t || t.type !== "TSQualifiedName" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($de, "isTSQualifiedName");
  function Hde(t, e) {
    return !t || t.type !== "TSCallSignatureDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hde, "isTSCallSignatureDeclaration");
  function zde(t, e) {
    return !t || t.type !== "TSConstructSignatureDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zde, "isTSConstructSignatureDeclaration");
  function Gde(t, e) {
    return !t || t.type !== "TSPropertySignature" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gde, "isTSPropertySignature");
  function Qde(t, e) {
    return !t || t.type !== "TSMethodSignature" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qde, "isTSMethodSignature");
  function Zde(t, e) {
    return !t || t.type !== "TSIndexSignature" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zde, "isTSIndexSignature");
  function eme(t, e) {
    return !t || t.type !== "TSAnyKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(eme, "isTSAnyKeyword");
  function tme(t, e) {
    return !t || t.type !== "TSBooleanKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(tme, "isTSBooleanKeyword");
  function rme(t, e) {
    return !t || t.type !== "TSBigIntKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(rme, "isTSBigIntKeyword");
  function sme(t, e) {
    return !t || t.type !== "TSIntrinsicKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(sme, "isTSIntrinsicKeyword");
  function ime(t, e) {
    return !t || t.type !== "TSNeverKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ime, "isTSNeverKeyword");
  function nme(t, e) {
    return !t || t.type !== "TSNullKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(nme, "isTSNullKeyword");
  function ame(t, e) {
    return !t || t.type !== "TSNumberKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ame, "isTSNumberKeyword");
  function ome(t, e) {
    return !t || t.type !== "TSObjectKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ome, "isTSObjectKeyword");
  function lme(t, e) {
    return !t || t.type !== "TSStringKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(lme, "isTSStringKeyword");
  function ume(t, e) {
    return !t || t.type !== "TSSymbolKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(ume, "isTSSymbolKeyword");
  function cme(t, e) {
    return !t || t.type !== "TSUndefinedKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(cme, "isTSUndefinedKeyword");
  function pme(t, e) {
    return !t || t.type !== "TSUnknownKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(pme, "isTSUnknownKeyword");
  function fme(t, e) {
    return !t || t.type !== "TSVoidKeyword" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(fme, "isTSVoidKeyword");
  function hme(t, e) {
    return !t || t.type !== "TSThisType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(hme, "isTSThisType");
  function dme(t, e) {
    return !t || t.type !== "TSFunctionType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(dme, "isTSFunctionType");
  function mme(t, e) {
    return !t || t.type !== "TSConstructorType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(mme, "isTSConstructorType");
  function yme(t, e) {
    return !t || t.type !== "TSTypeReference" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(yme, "isTSTypeReference");
  function Tme(t, e) {
    return !t || t.type !== "TSTypePredicate" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Tme, "isTSTypePredicate");
  function bme(t, e) {
    return !t || t.type !== "TSTypeQuery" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(bme, "isTSTypeQuery");
  function xme(t, e) {
    return !t || t.type !== "TSTypeLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(xme, "isTSTypeLiteral");
  function Sme(t, e) {
    return !t || t.type !== "TSArrayType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Sme, "isTSArrayType");
  function gme(t, e) {
    return !t || t.type !== "TSTupleType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(gme, "isTSTupleType");
  function Pme(t, e) {
    return !t || t.type !== "TSOptionalType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Pme, "isTSOptionalType");
  function Eme(t, e) {
    return !t || t.type !== "TSRestType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Eme, "isTSRestType");
  function Ame(t, e) {
    return !t || t.type !== "TSNamedTupleMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ame, "isTSNamedTupleMember");
  function vme(t, e) {
    return !t || t.type !== "TSUnionType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(vme, "isTSUnionType");
  function Cme(t, e) {
    return !t || t.type !== "TSIntersectionType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Cme, "isTSIntersectionType");
  function Ime(t, e) {
    return !t || t.type !== "TSConditionalType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ime, "isTSConditionalType");
  function wme(t, e) {
    return !t || t.type !== "TSInferType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(wme, "isTSInferType");
  function Nme(t, e) {
    return !t || t.type !== "TSParenthesizedType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Nme, "isTSParenthesizedType");
  function Ome(t, e) {
    return !t || t.type !== "TSTypeOperator" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ome, "isTSTypeOperator");
  function kme(t, e) {
    return !t || t.type !== "TSIndexedAccessType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(kme, "isTSIndexedAccessType");
  function Dme(t, e) {
    return !t || t.type !== "TSMappedType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Dme, "isTSMappedType");
  function _me(t, e) {
    return !t || t.type !== "TSLiteralType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(_me, "isTSLiteralType");
  function Lme(t, e) {
    return !t || t.type !== "TSExpressionWithTypeArguments" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Lme, "isTSExpressionWithTypeArguments");
  function Mme(t, e) {
    return !t || t.type !== "TSInterfaceDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Mme, "isTSInterfaceDeclaration");
  function Bme(t, e) {
    return !t || t.type !== "TSInterfaceBody" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Bme, "isTSInterfaceBody");
  function Fme(t, e) {
    return !t || t.type !== "TSTypeAliasDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Fme, "isTSTypeAliasDeclaration");
  function jme(t, e) {
    return !t || t.type !== "TSInstantiationExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(jme, "isTSInstantiationExpression");
  function Rme(t, e) {
    return !t || t.type !== "TSAsExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Rme, "isTSAsExpression");
  function Ume(t, e) {
    return !t || t.type !== "TSSatisfiesExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Ume, "isTSSatisfiesExpression");
  function qme(t, e) {
    return !t || t.type !== "TSTypeAssertion" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(qme, "isTSTypeAssertion");
  function Vme(t, e) {
    return !t || t.type !== "TSEnumDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Vme, "isTSEnumDeclaration");
  function Kme(t, e) {
    return !t || t.type !== "TSEnumMember" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Kme, "isTSEnumMember");
  function Wme(t, e) {
    return !t || t.type !== "TSModuleDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Wme, "isTSModuleDeclaration");
  function Yme(t, e) {
    return !t || t.type !== "TSModuleBlock" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Yme, "isTSModuleBlock");
  function Jme(t, e) {
    return !t || t.type !== "TSImportType" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Jme, "isTSImportType");
  function Xme(t, e) {
    return !t || t.type !== "TSImportEqualsDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Xme, "isTSImportEqualsDeclaration");
  function $me(t, e) {
    return !t || t.type !== "TSExternalModuleReference" ? !1 : e == null || (0, I.default)(t, e);
  }
  n($me, "isTSExternalModuleReference");
  function Hme(t, e) {
    return !t || t.type !== "TSNonNullExpression" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Hme, "isTSNonNullExpression");
  function zme(t, e) {
    return !t || t.type !== "TSExportAssignment" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zme, "isTSExportAssignment");
  function Gme(t, e) {
    return !t || t.type !== "TSNamespaceExportDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gme, "isTSNamespaceExportDeclaration");
  function Qme(t, e) {
    return !t || t.type !== "TSTypeAnnotation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qme, "isTSTypeAnnotation");
  function Zme(t, e) {
    return !t || t.type !== "TSTypeParameterInstantiation" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zme, "isTSTypeParameterInstantiation");
  function eye(t, e) {
    return !t || t.type !== "TSTypeParameterDeclaration" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(eye, "isTSTypeParameterDeclaration");
  function tye(t, e) {
    return !t || t.type !== "TSTypeParameter" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(tye, "isTSTypeParameter");
  function rye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(rye, "isStandardized");
  function sye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(sye, "isExpression");
  function iye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(iye, "isBinary");
  function nye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(nye, "isScopable");
  function aye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(aye, "isBlockParent");
  function oye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (t.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(oye, "isBlock");
  function lye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(lye, "isStatement");
  function uye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(uye, "isTerminatorless");
  function cye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(cye, "isCompletionStatement");
  function pye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(pye, "isConditional");
  function fye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(fye, "isLoop");
  function hye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(hye, "isWhile");
  function dye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(dye, "isExpressionWrapper");
  function mye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(mye, "isFor");
  function yye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(yye, "isForXStatement");
  function Tye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Tye, "isFunction");
  function bye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(bye, "isFunctionParent");
  function xye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(xye, "isPureish");
  function Sye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (t.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Sye, "isDeclaration");
  function gye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(gye, "isPatternLike");
  function Pye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (t.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Pye, "isLVal");
  function Eye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (t.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Eye, "isTSEntityName");
  function Aye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Aye, "isLiteral");
  function vye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (t.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(vye, "isImmutable");
  function Cye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Cye, "isUserWhitespacable");
  function Iye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Iye, "isMethod");
  function wye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(wye, "isObjectMember");
  function Nye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Nye, "isProperty");
  function Oye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Oye, "isUnaryLike");
  function kye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (t.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(kye, "isPattern");
  function Dye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Dye, "isClass");
  function xC(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(xC, "isImportOrExportDeclaration");
  function _ye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(_ye, "isExportDeclaration");
  function Lye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Lye, "isModuleSpecifier");
  function Mye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Mye, "isAccessor");
  function Bye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Bye, "isPrivate");
  function Fye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Fye, "isFlow");
  function jye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(jye, "isFlowType");
  function Rye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Rye, "isFlowBaseAnnotation");
  function Uye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Uye, "isFlowDeclaration");
  function qye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(qye, "isFlowPredicate");
  function Vye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Vye, "isEnumBody");
  function Kye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Kye, "isEnumMember");
  function Wye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Wye, "isJSX");
  function Yye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Yye, "isMiscellaneous");
  function Jye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Jye, "isTypeScript");
  function Xye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Xye, "isTSTypeElement");
  function $ye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n($ye, "isTSType");
  function Hye(t, e) {
    if (!t) return !1;
    switch (t.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return e == null || (0, I.default)(t, e);
  }
  n(Hye, "isTSBaseType");
  function zye(t, e) {
    return (0, Ao.default)("isNumberLiteral", "isNumericLiteral"), !t || t.type !== "NumberLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(zye, "isNumberLiteral");
  function Gye(t, e) {
    return (0, Ao.default)("isRegexLiteral", "isRegExpLiteral"), !t || t.type !== "RegexLiteral" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Gye, "isRegexLiteral");
  function Qye(t, e) {
    return (0, Ao.default)("isRestProperty", "isRestElement"), !t || t.type !== "RestProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Qye, "isRestProperty");
  function Zye(t, e) {
    return (0, Ao.default)("isSpreadProperty", "isSpreadElement"), !t || t.type !== "SpreadProperty" ? !1 : e == null || (0, I.default)(t, e);
  }
  n(Zye, "isSpreadProperty");
  function eTe(t, e) {
    return (0, Ao.default)("isModuleDeclaration", "isImportOrExportDeclaration"), xC(t, e);
  }
  n(eTe, "isModuleDeclaration");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/matchesPattern.js
var Dy = w((ky) => {
  "use strict";
  Object.defineProperty(ky, "__esModule", {
    value: !0
  });
  ky.default = tTe;
  var vo = Rt();
  function tTe(t, e, r) {
    if (!(0, vo.isMemberExpression)(t)) return !1;
    let s = Array.isArray(e) ? e : e.split("."), i = [], a;
    for (a = t; (0, vo.isMemberExpression)(a); a = a.object)
      i.push(a.property);
    if (i.push(a), i.length < s.length || !r && i.length > s.length) return !1;
    for (let o = 0, l = i.length - 1; o < s.length; o++, l--) {
      let u = i[l], c;
      if ((0, vo.isIdentifier)(u))
        c = u.name;
      else if ((0, vo.isStringLiteral)(u))
        c = u.value;
      else if ((0, vo.isThisExpression)(u))
        c = "this";
      else
        return !1;
      if (s[o] !== c) return !1;
    }
    return !0;
  }
  n(tTe, "matchesPattern");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var Ly = w((_y) => {
  "use strict";
  Object.defineProperty(_y, "__esModule", {
    value: !0
  });
  _y.default = sTe;
  var rTe = Dy();
  function sTe(t, e) {
    let r = t.split(".");
    return (s) => (0, rTe.default)(s, r, e);
  }
  n(sTe, "buildMatchMemberExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/react/isReactComponent.js
var SC = w((nc) => {
  "use strict";
  Object.defineProperty(nc, "__esModule", {
    value: !0
  });
  nc.default = void 0;
  var iTe = Ly(), nTe = (0, iTe.default)("React.Component"), r6e = nc.default = nTe;
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/react/isCompatTag.js
var gC = w((My) => {
  "use strict";
  Object.defineProperty(My, "__esModule", {
    value: !0
  });
  My.default = aTe;
  function aTe(t) {
    return !!t && /^[a-z]/.test(t);
  }
  n(aTe, "isCompatTag");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isType.js
var ac = w((By) => {
  "use strict";
  Object.defineProperty(By, "__esModule", {
    value: !0
  });
  By.default = oTe;
  var PC = Vr();
  function oTe(t, e) {
    if (t === e) return !0;
    if (t == null || PC.ALIAS_KEYS[e]) return !1;
    let r = PC.FLIPPED_ALIAS_KEYS[e];
    if (r) {
      if (r[0] === t) return !0;
      for (let s of r)
        if (t === s) return !0;
    }
    return !1;
  }
  n(oTe, "isType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isPlaceholderType.js
var jy = w((Fy) => {
  "use strict";
  Object.defineProperty(Fy, "__esModule", {
    value: !0
  });
  Fy.default = uTe;
  var lTe = Vr();
  function uTe(t, e) {
    if (t === e) return !0;
    let r = lTe.PLACEHOLDERS_ALIAS[t];
    if (r) {
      for (let s of r)
        if (e === s) return !0;
    }
    return !1;
  }
  n(uTe, "isPlaceholderType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/is.js
var Yn = w((Ry) => {
  "use strict";
  Object.defineProperty(Ry, "__esModule", {
    value: !0
  });
  Ry.default = dTe;
  var cTe = ic(), pTe = ac(), fTe = jy(), hTe = Vr();
  function dTe(t, e, r) {
    return e ? (0, pTe.default)(e.type, t) ? typeof r > "u" ? !0 : (0, cTe.default)(e, r) : !r && e.type === "Placeholder" && t in hTe.FLIPPED_ALIAS_KEYS ?
    (0, fTe.default)(e.expectedNode, t) : !1 : !1;
  }
  n(dTe, "is");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isValidIdentifier.js
var Jn = w((qy) => {
  "use strict";
  Object.defineProperty(qy, "__esModule", {
    value: !0
  });
  qy.default = mTe;
  var Uy = Ka();
  function mTe(t, e = !0) {
    return typeof t != "string" || e && ((0, Uy.isKeyword)(t) || (0, Uy.isStrictReservedWord)(t, !0)) ? !1 : (0, Uy.isIdentifierName)(t);
  }
  n(mTe, "isValidIdentifier");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-string-parser/lib/index.js
var CC = w((Co) => {
  "use strict";
  Object.defineProperty(Co, "__esModule", {
    value: !0
  });
  Co.readCodePoint = vC;
  Co.readInt = AC;
  Co.readStringContents = TTe;
  var yTe = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), EC = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, oc = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function TTe(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (bTe(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = xTe(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(TTe, "readStringContents");
  function bTe(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(bTe, "isStringEnd");
  function xTe(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = Vy(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = vC(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(xTe, "readEscapedChar");
  function Vy(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = AC(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(Vy, "readHexChar");
  function AC(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? EC.hex : EC.decBinOct, m = i === 16 ? oc.hex : i === 10 ? oc.dec : i === 8 ? oc.oct : oc.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : yTe(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(AC, "readInt");
  function vC(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = Vy(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = Vy(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(vC, "readCodePoint");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/constants/index.js
var pi = w((Ve) => {
  "use strict";
  Object.defineProperty(Ve, "__esModule", {
    value: !0
  });
  Ve.UPDATE_OPERATORS = Ve.UNARY_OPERATORS = Ve.STRING_UNARY_OPERATORS = Ve.STATEMENT_OR_BLOCK_KEYS = Ve.NUMBER_UNARY_OPERATORS = Ve.NUMBER_BINARY_OPERATORS =
  Ve.NOT_LOCAL_BINDING = Ve.LOGICAL_OPERATORS = Ve.INHERIT_KEYS = Ve.FOR_INIT_KEYS = Ve.FLATTENABLE_KEYS = Ve.EQUALITY_BINARY_OPERATORS = Ve.
  COMPARISON_BINARY_OPERATORS = Ve.COMMENT_KEYS = Ve.BOOLEAN_UNARY_OPERATORS = Ve.BOOLEAN_NUMBER_BINARY_OPERATORS = Ve.BOOLEAN_BINARY_OPERATORS =
  Ve.BLOCK_SCOPED_SYMBOL = Ve.BINARY_OPERATORS = Ve.ASSIGNMENT_OPERATORS = void 0;
  var y6e = Ve.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], T6e = Ve.FLATTENABLE_KEYS = ["body", "expressions"], b6e = Ve.
  FOR_INIT_KEYS = ["left", "init"], x6e = Ve.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], STe = Ve.LOGICAL_OPERATORS =
  ["||", "&&", "??"], S6e = Ve.UPDATE_OPERATORS = ["++", "--"], gTe = Ve.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], PTe = Ve.
  EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], ETe = Ve.COMPARISON_BINARY_OPERATORS = [...PTe, "in", "instanceof"], ATe = Ve.BOOLEAN_BINARY_OPERATORS =
  [...ETe, ...gTe], IC = Ve.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], g6e = Ve.BINARY_OPERATORS =
  ["+", ...IC, ...ATe, "|>"], P6e = Ve.ASSIGNMENT_OPERATORS = ["=", "+=", ...IC.map((t) => t + "="), ...STe.map((t) => t + "=")], vTe = Ve.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], CTe = Ve.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], ITe = Ve.STRING_UNARY_OPERATORS = ["typeof"], E6e = Ve.UNARY_OPERATORS =
  ["void", "throw", ...vTe, ...CTe, ...ITe], A6e = Ve.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  }, v6e = Ve.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), C6e = Ve.NOT_LOCAL_BINDING = Symbol.for("should not be consid\
ered a local binding");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/utils.js
var Ls = w((it) => {
  "use strict";
  Object.defineProperty(it, "__esModule", {
    value: !0
  });
  it.VISITOR_KEYS = it.NODE_PARENT_VALIDATIONS = it.NODE_FIELDS = it.FLIPPED_ALIAS_KEYS = it.DEPRECATED_KEYS = it.BUILDER_KEYS = it.ALIAS_KEYS =
  void 0;
  it.arrayOf = NC;
  it.arrayOfType = OC;
  it.assertEach = kC;
  it.assertNodeOrValueType = RTe;
  it.assertNodeType = Wy;
  it.assertOneOf = jTe;
  it.assertOptionalChainStart = qTe;
  it.assertShape = UTe;
  it.assertValueType = Xy;
  it.chain = DC;
  it.default = _C;
  it.defineAliasedType = WTe;
  it.typeIs = cc;
  it.validate = Jy;
  it.validateArrayOfType = FTe;
  it.validateOptional = MTe;
  it.validateOptionalType = BTe;
  it.validateType = LTe;
  var wC = Yn(), uc = pc(), wTe = it.VISITOR_KEYS = {}, NTe = it.ALIAS_KEYS = {}, Ky = it.FLIPPED_ALIAS_KEYS = {}, OTe = it.NODE_FIELDS = {},
  kTe = it.BUILDER_KEYS = {}, DTe = it.DEPRECATED_KEYS = {}, _Te = it.NODE_PARENT_VALIDATIONS = {};
  function lc(t) {
    return Array.isArray(t) ? "array" : t === null ? "null" : typeof t;
  }
  n(lc, "getType");
  function Jy(t) {
    return {
      validate: t
    };
  }
  n(Jy, "validate");
  function cc(t) {
    return typeof t == "string" ? Wy(t) : Wy(...t);
  }
  n(cc, "typeIs");
  function LTe(t) {
    return Jy(cc(t));
  }
  n(LTe, "validateType");
  function MTe(t) {
    return {
      validate: t,
      optional: !0
    };
  }
  n(MTe, "validateOptional");
  function BTe(t) {
    return {
      validate: cc(t),
      optional: !0
    };
  }
  n(BTe, "validateOptionalType");
  function NC(t) {
    return DC(Xy("array"), kC(t));
  }
  n(NC, "arrayOf");
  function OC(t) {
    return NC(cc(t));
  }
  n(OC, "arrayOfType");
  function FTe(t) {
    return Jy(OC(t));
  }
  n(FTe, "validateArrayOfType");
  function kC(t) {
    function e(r, s, i) {
      if (Array.isArray(i))
        for (let a = 0; a < i.length; a++) {
          let o = `${s}[${a}]`, l = i[a];
          t(r, o, l), process.env.BABEL_TYPES_8_BREAKING && (0, uc.validateChild)(r, o, l);
        }
    }
    return n(e, "validator"), e.each = t, e;
  }
  n(kC, "assertEach");
  function jTe(...t) {
    function e(r, s, i) {
      if (t.indexOf(i) < 0)
        throw new TypeError(`Property ${s} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(i)}`);
    }
    return n(e, "validate"), e.oneOf = t, e;
  }
  n(jTe, "assertOneOf");
  function Wy(...t) {
    function e(r, s, i) {
      for (let a of t)
        if ((0, wC.default)(a, i)) {
          (0, uc.validateChild)(r, s, i);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeTypes = t, e;
  }
  n(Wy, "assertNodeType");
  function RTe(...t) {
    function e(r, s, i) {
      for (let a of t)
        if (lc(i) === a || (0, wC.default)(a, i)) {
          (0, uc.validateChild)(r, s, i);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(i?.
      type)}`);
    }
    return n(e, "validate"), e.oneOfNodeOrValueTypes = t, e;
  }
  n(RTe, "assertNodeOrValueType");
  function Xy(t) {
    function e(r, s, i) {
      if (!(lc(i) === t))
        throw new TypeError(`Property ${s} expected type of ${t} but got ${lc(i)}`);
    }
    return n(e, "validate"), e.type = t, e;
  }
  n(Xy, "assertValueType");
  function UTe(t) {
    function e(r, s, i) {
      let a = [];
      for (let o of Object.keys(t))
        try {
          (0, uc.validateField)(r, o, i[o], t[o]);
        } catch (l) {
          if (l instanceof TypeError) {
            a.push(l.message);
            continue;
          }
          throw l;
        }
      if (a.length)
        throw new TypeError(`Property ${s} of ${r.type} expected to have the following:
${a.join(`
`)}`);
    }
    return n(e, "validate"), e.shapeOf = t, e;
  }
  n(UTe, "assertShape");
  function qTe() {
    function t(e) {
      var r;
      let s = e;
      for (; e; ) {
        let {
          type: i
        } = s;
        if (i === "OptionalCallExpression") {
          if (s.optional) return;
          s = s.callee;
          continue;
        }
        if (i === "OptionalMemberExpression") {
          if (s.optional) return;
          s = s.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = s) == null ? void 0 : r.type}`);
    }
    return n(t, "validate"), t;
  }
  n(qTe, "assertOptionalChainStart");
  function DC(...t) {
    function e(...r) {
      for (let s of t)
        s(...r);
    }
    if (n(e, "validate"), e.chainOf = t, t.length >= 2 && "type" in t[0] && t[0].type === "array" && !("each" in t[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return e;
  }
  n(DC, "chain");
  var VTe = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], KTe = ["default", "optional", "deprecate\
d", "validate"], Yy = {};
  function WTe(...t) {
    return (e, r = {}) => {
      let s = r.aliases;
      if (!s) {
        var i, a;
        r.inherits && (s = (i = Yy[r.inherits].aliases) == null ? void 0 : i.slice()), (a = s) != null || (s = []), r.aliases = s;
      }
      let o = t.filter((l) => !s.includes(l));
      s.unshift(...o), _C(e, r);
    };
  }
  n(WTe, "defineAliasedType");
  function _C(t, e = {}) {
    let r = e.inherits && Yy[e.inherits] || {}, s = e.fields;
    if (!s && (s = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        s[u] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let i = e.visitor || r.visitor || [], a = e.aliases || r.aliases || [], o = e.builder || r.builder || e.visitor || [];
    for (let l of Object.keys(e))
      if (VTe.indexOf(l) === -1)
        throw new Error(`Unknown type option "${l}" on ${t}`);
    e.deprecatedAlias && (DTe[e.deprecatedAlias] = t);
    for (let l of i.concat(o))
      s[l] = s[l] || {};
    for (let l of Object.keys(s)) {
      let u = s[l];
      u.default !== void 0 && o.indexOf(l) === -1 && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default !=
      null && (u.validate = Xy(lc(u.default)));
      for (let c of Object.keys(u))
        if (KTe.indexOf(c) === -1)
          throw new Error(`Unknown field key "${c}" on ${t}.${l}`);
    }
    wTe[t] = e.visitor = i, kTe[t] = e.builder = o, OTe[t] = e.fields = s, NTe[t] = e.aliases = a, a.forEach((l) => {
      Ky[l] = Ky[l] || [], Ky[l].push(t);
    }), e.validate && (_Te[t] = e.validate), Yy[t] = e;
  }
  n(_C, "defineType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/core.js
var Hy = w((kr) => {
  "use strict";
  Object.defineProperty(kr, "__esModule", {
    value: !0
  });
  kr.patternLikeCommon = kr.functionTypeAnnotationCommon = kr.functionDeclarationCommon = kr.functionCommon = kr.classMethodOrPropertyCommon =
  kr.classMethodOrDeclareMethodCommon = void 0;
  var gr = Yn(), YTe = Jn(), LC = Ka(), JTe = CC(), Io = pi(), d = Ls(), re = (0, d.defineAliasedType)("Standardized");
  re("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeOrValueType)("null", "Expression", "Spread\
Element"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  re("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, d.assertValueType)("string");
          let t = (0, d.assertOneOf)(...Io.ASSIGNMENT_OPERATORS), e = (0, d.assertOneOf)("=");
          return function(r, s, i) {
            ((0, gr.default)("Pattern", r.left) ? e : t)(r, s, i);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, d.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  re("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, d.assertOneOf)(...Io.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let t = (0, d.assertNodeType)("Expression"), e = (0, d.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(s, i, a) {
            (s.operator === "in" ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  re("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("string")
      }
    }
  });
  re("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, d.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  re("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("string")
      }
    }
  });
  re("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  re("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  re("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, d.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, d.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  re("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, d.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  re("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, d.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, d.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  re("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  re("DebuggerStatement", {
    aliases: ["Statement"]
  });
  re("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  re("EmptyStatement", {
    aliases: ["Statement"]
  });
  re("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, d.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  re("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, d.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertEach)((0, d.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, d.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  re("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, d.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, d.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  var Xn = /* @__PURE__ */ n(() => ({
    params: {
      validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  kr.functionCommon = Xn;
  var Hi = /* @__PURE__ */ n(() => ({
    returnType: {
      validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, d.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  kr.functionTypeAnnotationCommon = Hi;
  var MC = /* @__PURE__ */ n(() => Object.assign({}, Xn(), {
    declare: {
      validate: (0, d.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, d.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  kr.functionDeclarationCommon = MC;
  re("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, MC(), Hi(), {
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, d.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {
      };
      let t = (0, d.assertNodeType)("Identifier");
      return function(e, r, s) {
        (0, gr.default)("ExportDefaultDeclaration", e) || t(s, "id", s.id);
      };
    }()
  });
  re("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Xn(), Hi(), {
      id: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, d.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var $n = /* @__PURE__ */ n(() => ({
    typeAnnotation: {
      validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, d.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "patternLikeCommon");
  kr.patternLikeCommon = $n;
  re("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, $n(), {
      name: {
        validate: (0, d.chain)((0, d.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, YTe.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(t, e, r) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let s = /\.(\w+)$/.exec(e);
      if (!s) return;
      let [, i] = s, a = {
        computed: !1
      };
      if (i === "property") {
        if ((0, gr.default)("MemberExpression", t, a) || (0, gr.default)("OptionalMemberExpression", t, a)) return;
      } else if (i === "key") {
        if ((0, gr.default)("Property", t, a) || (0, gr.default)("Method", t, a)) return;
      } else if (i === "exported") {
        if ((0, gr.default)("ExportSpecifier", t)) return;
      } else if (i === "imported") {
        if ((0, gr.default)("ImportSpecifier", t, {
          imported: r
        })) return;
      } else if (i === "meta" && (0, gr.default)("MetaProperty", t, {
        meta: r
      }))
        return;
      if (((0, LC.isKeyword)(r.name) || (0, LC.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    }
  });
  re("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, d.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, d.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, d.chain)((0, d.assertValueType)("number"), Object.assign(function(t, e, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let s = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, d.assertValueType)("string")
      },
      flags: {
        validate: (0, d.chain)((0, d.assertValueType)("string"), Object.assign(function(t, e, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s = /[^gimsuy]/.exec(r);
          if (s)
            throw new TypeError(`"${s[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  re("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, d.assertOneOf)(...Io.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, d.assertNodeType)("Expression")
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, d.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let t = (0, d.assertNodeType)("Identifier", "PrivateName"), e = (0, d.assertNodeType)("Expression"), r = /* @__PURE__ */ n(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, d.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  });
  re("NewExpression", {
    inherits: "CallExpression"
  });
  re("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, d.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, d.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  re("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ObjectMethod", "ObjectProperty", "S\
preadElement")))
      }
    }
  });
  re("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, Xn(), Hi(), {
      kind: Object.assign({
        validate: (0, d.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, d.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ n(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  re("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let t = (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), e = (0, d.
          assertNodeType)("Expression");
          return Object.assign(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, d.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, d.chain)((0, d.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !(0, gr.default)("Identifier", t.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      let t = (0, d.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), e = (0, d.assertNodeType)("Expression");
      return function(r, s, i) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, gr.default)("ObjectPattern", r) ? t : e)(i, "value", i.value);
      };
    }()
  });
  re("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, $n(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, d.assertNodeType)("LVal")
      }
    }),
    validate(t, e) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      let r = /(\w+)\[(\d+)\]/.exec(e);
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, s, i] = r;
      if (t[s].length > +i + 1)
        throw new TypeError(`RestElement must be last element of ${s}`);
    }
  });
  re("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  re("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  re("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Statement")))
      }
    }
  });
  re("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, d.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("SwitchCase")))
      }
    }
  });
  re("ThisExpression", {
    aliases: ["Expression"]
  });
  re("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, d.chain)((0, d.assertNodeType)("BlockStatement"), Object.assign(function(t) {
          if (process.env.BABEL_TYPES_8_BREAKING && !t.handler && !t.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, d.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    }
  });
  re("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, d.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, d.assertOneOf)(...Io.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  re("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.assertNodeType)("Identifier", "MemberExpression") : (0, d.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, d.assertOneOf)(...Io.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  re("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, d.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(t, e, r) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, gr.default)("ForXStatement", t, {
        left: r
      }) && r.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${t.type}`);
    }
  });
  re("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, d.assertNodeType)("LVal");
          let t = (0, d.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), e = (0, d.assertNodeType)("Identifier");
          return function(r, s, i) {
            (r.init ? t : e)(r, s, i);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, d.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      }
    }
  });
  re("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $n(), {
      left: {
        validate: (0, d.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  });
  re("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $n(), {
      elements: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  re("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Xn(), Hi(), {
      expression: {
        validate: (0, d.assertValueType)("boolean")
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, d.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  re("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ClassMethod", "ClassPrivateMethod",
        "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  });
  re("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, d.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, d.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  re("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, d.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, d.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, d.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("TSExpressionWithTypeArguments", "Cl\
assImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, d.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      let t = (0, d.assertNodeType)("Identifier");
      return function(e, r, s) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, gr.default)("ExportDefaultDeclaration", e) || t(s, "id", s.id));
      };
    }()
  });
  re("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, d.assertNodeType)("StringLiteral")
      },
      exportKind: (0, d.validateOptional)((0, d.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      }
    }
  });
  re("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, d.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, d.validateOptional)((0, d.assertOneOf)("value"))
    }
  });
  re("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertNodeType)("Declaration"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && t.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)(function() {
          let t = (0, d.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), e = (0, d.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(r, s, i) {
            (r.source ? t : e)(r, s, i);
          } : t;
        }()))
      },
      source: {
        validate: (0, d.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, d.validateOptional)((0, d.assertOneOf)("type", "value"))
    }
  });
  re("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, d.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, d.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, d.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  re("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, d.assertNodeType)("VariableDeclaration", "LVal");
          let t = (0, d.assertNodeType)("VariableDeclaration"), e = (0, d.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(r, s, i) {
            (0, gr.default)("VariableDeclaration", i) ? t(r, s, i) : e(r, s, i);
          };
        }()
      },
      right: {
        validate: (0, d.assertNodeType)("Expression")
      },
      body: {
        validate: (0, d.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  re("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, d.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, d.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("ImportSpecifier", "ImportDefaultSpe\
cifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, d.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, d.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  re("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  re("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  re("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, d.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, d.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, d.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  re("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, d.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, d.assertNodeType)("Expression")
      },
      options: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  re("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, d.chain)((0, d.assertNodeType)("Identifier"), Object.assign(function(t, e, r) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let s;
          switch (r.name) {
            case "function":
              s = "sent";
              break;
            case "new":
              s = "target";
              break;
            case "import":
              s = "meta";
              break;
          }
          if (!(0, gr.default)("Identifier", t.property, {
            name: s
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  var fc = /* @__PURE__ */ n(() => ({
    abstract: {
      validate: (0, d.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, d.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, d.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, d.chain)(function() {
        let t = (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), e = (0, d.assertNodeType)("Expressi\
on");
        return function(r, s, i) {
          (r.computed ? e : t)(r, s, i);
        };
      }(), (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  kr.classMethodOrPropertyCommon = fc;
  var $y = /* @__PURE__ */ n(() => Object.assign({}, Xn(), fc(), {
    params: {
      validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Identifier", "Pattern", "RestElement",
      "TSParameterProperty")))
    },
    kind: {
      validate: (0, d.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, d.chain)((0, d.assertValueType)("string"), (0, d.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  kr.classMethodOrDeclareMethodCommon = $y;
  re("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, $y(), Hi(), {
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    })
  });
  re("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, $n(), {
      properties: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  re("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("Super", {
    aliases: ["Expression"]
  });
  re("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, d.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, d.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  re("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, d.chain)((0, d.assertShape)({
          raw: {
            validate: (0, d.assertValueType)("string")
          },
          cooked: {
            validate: (0, d.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ n(function(e) {
          let r = e.value.raw, s = !1, i = /* @__PURE__ */ n(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, JTe.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              s = !0;
            },
            strictNumericEscape: i,
            invalidEscapeSequence: i,
            numericSeparatorInEscapeSequence: i,
            unexpectedNumericSeparator: i,
            invalidDigit: i,
            invalidCodePoint: i
          });
          if (!s) throw new Error("Invalid raw");
          e.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  re("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Expression", "TSType")), function(t, e, r) {
          if (t.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${t.quasis.length}`);
        })
      }
    }
  });
  re("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, d.chain)((0, d.assertValueType)("boolean"), Object.assign(function(t, e, r) {
          if (process.env.BABEL_TYPES_8_BREAKING && r && !t.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, d.assertNodeType)("Expression")
      }
    }
  });
  re("Import", {
    aliases: ["Expression"]
  });
  re("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, d.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  re("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  re("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, d.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let t = (0, d.assertNodeType)("Identifier"), e = (0, d.assertNodeType)("Expression");
          return Object.assign(function(s, i, a) {
            (s.computed ? e : t)(s, i, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.chain)((0, d.assertValueType)("boolean"), (0, d.assertOptionalChainStart)()) : (0, d.
        assertValueType)("boolean")
      }
    }
  });
  re("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, d.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Expression", "SpreadElement", "JSXN\
amespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, d.chain)((0, d.assertValueType)("boolean"), (0, d.assertOptionalChainStart)()) : (0, d.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, d.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, d.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  re("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, fc(), {
      value: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, d.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  re("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, fc(), {
      key: {
        validate: (0, d.chain)(function() {
          let t = (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), e = (0, d.assertNodeType)(
          "Expression");
          return function(r, s, i) {
            (r.computed ? e : t)(r, s, i);
          };
        }(), (0, d.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, d.assertNodeType)("Variance"),
        optional: !0
      }
    })
  });
  re("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, d.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, d.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, d.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, d.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, d.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, d.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  re("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, $y(), Hi(), {
      kind: {
        validate: (0, d.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, d.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, d.assertNodeType)("BlockStatement")
      }
    })
  });
  re("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, d.assertNodeType)("Identifier")
      }
    }
  });
  re("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, d.chain)((0, d.assertValueType)("array"), (0, d.assertEach)((0, d.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/flow.js
var BC = w(() => {
  "use strict";
  var K = Ls(), xe = (0, K.defineAliasedType)("Flow"), zy = /* @__PURE__ */ n((t) => {
    let e = t === "DeclareClass";
    xe(t, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...e ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, K.validateType)("Identifier"),
        typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, K.validateOptional)((0, K.arrayOfType)("InterfaceExtends"))
      }, e ? {
        mixins: (0, K.validateOptional)((0, K.arrayOfType)("InterfaceExtends")),
        implements: (0, K.validateOptional)((0, K.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, K.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  xe("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, K.validateType)("FlowType")
    }
  });
  xe("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  zy("DeclareClass");
  xe("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      predicate: (0, K.validateOptionalType)("DeclaredPredicate")
    }
  });
  zy("DeclareInterface");
  xe("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)(["Identifier", "StringLiteral"]),
      body: (0, K.validateType)("BlockStatement"),
      kind: (0, K.validateOptional)((0, K.assertOneOf)("CommonJS", "ES"))
    }
  });
  xe("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, K.validateType)("TypeAnnotation")
    }
  });
  xe("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, K.validateType)("FlowType")
    }
  });
  xe("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, K.validateOptionalType)("FlowType"),
      impltype: (0, K.validateOptionalType)("FlowType")
    }
  });
  xe("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier")
    }
  });
  xe("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, K.validateOptionalType)("Flow"),
      specifiers: (0, K.validateOptional)((0, K.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, K.validateOptionalType)("StringLiteral"),
      default: (0, K.validateOptional)((0, K.assertValueType)("boolean"))
    }
  });
  xe("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, K.validateType)("StringLiteral"),
      exportKind: (0, K.validateOptional)((0, K.assertOneOf)("type", "value"))
    }
  });
  xe("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, K.validateType)("Flow")
    }
  });
  xe("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  xe("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, K.validate)((0, K.arrayOfType)("FunctionTypeParam")),
      rest: (0, K.validateOptionalType)("FunctionTypeParam"),
      this: (0, K.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, K.validateType)("FlowType")
    }
  });
  xe("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, K.validateOptionalType)("Identifier"),
      typeAnnotation: (0, K.validateType)("FlowType"),
      optional: (0, K.validateOptional)((0, K.assertValueType)("boolean"))
    }
  });
  xe("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, K.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, K.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  xe("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  xe("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, K.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, K.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  zy("InterfaceDeclaration");
  xe("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, K.validateOptional)((0, K.arrayOfType)("InterfaceExtends")),
      body: (0, K.validateType)("ObjectTypeAnnotation")
    }
  });
  xe("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, K.validate)((0, K.arrayOfType)("FlowType"))
    }
  });
  xe("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, K.validateType)("FlowType")
    }
  });
  xe("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, K.validate)((0, K.assertValueType)("number"))
    }
  });
  xe("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, K.validate)((0, K.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, K.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, K.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, K.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, K.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, K.validateOptional)((0, K.assertValueType)("boolean"))
    }
  });
  xe("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      value: (0, K.validateType)("FlowType"),
      optional: (0, K.validate)((0, K.assertValueType)("boolean")),
      static: (0, K.validate)((0, K.assertValueType)("boolean")),
      method: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, K.validateType)("FlowType"),
      static: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, K.validateOptionalType)("Identifier"),
      key: (0, K.validateType)("FlowType"),
      value: (0, K.validateType)("FlowType"),
      static: (0, K.validate)((0, K.assertValueType)("boolean")),
      variance: (0, K.validateOptionalType)("Variance")
    }
  });
  xe("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, K.validateType)(["Identifier", "StringLiteral"]),
      value: (0, K.validateType)("FlowType"),
      kind: (0, K.validate)((0, K.assertOneOf)("init", "get", "set")),
      static: (0, K.validate)((0, K.assertValueType)("boolean")),
      proto: (0, K.validate)((0, K.assertValueType)("boolean")),
      optional: (0, K.validate)((0, K.assertValueType)("boolean")),
      variance: (0, K.validateOptionalType)("Variance"),
      method: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, K.validateType)("FlowType")
    }
  });
  xe("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, K.validateOptionalType)("FlowType"),
      impltype: (0, K.validateType)("FlowType")
    }
  });
  xe("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      qualification: (0, K.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  xe("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, K.validate)((0, K.assertValueType)("string"))
    }
  });
  xe("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, K.validate)((0, K.arrayOfType)("FlowType"))
    }
  });
  xe("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, K.validateType)("FlowType")
    }
  });
  xe("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      typeParameters: (0, K.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, K.validateType)("FlowType")
    }
  });
  xe("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, K.validateType)("FlowType")
    }
  });
  xe("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, K.validateType)("Expression"),
      typeAnnotation: (0, K.validateType)("TypeAnnotation")
    }
  });
  xe("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, K.validate)((0, K.assertValueType)("string")),
      bound: (0, K.validateOptionalType)("TypeAnnotation"),
      default: (0, K.validateOptionalType)("FlowType"),
      variance: (0, K.validateOptionalType)("Variance")
    }
  });
  xe("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, K.validate)((0, K.arrayOfType)("TypeParameter"))
    }
  });
  xe("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, K.validate)((0, K.arrayOfType)("FlowType"))
    }
  });
  xe("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, K.validate)((0, K.arrayOfType)("FlowType"))
    }
  });
  xe("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, K.validate)((0, K.assertOneOf)("minus", "plus"))
    }
  });
  xe("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  xe("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      body: (0, K.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  xe("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, K.validate)((0, K.assertValueType)("boolean")),
      members: (0, K.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, K.validate)((0, K.assertValueType)("boolean")),
      members: (0, K.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, K.validate)((0, K.assertValueType)("boolean")),
      members: (0, K.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, K.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
  xe("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      init: (0, K.validateType)("BooleanLiteral")
    }
  });
  xe("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      init: (0, K.validateType)("NumericLiteral")
    }
  });
  xe("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, K.validateType)("Identifier"),
      init: (0, K.validateType)("StringLiteral")
    }
  });
  xe("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, K.validateType)("Identifier")
    }
  });
  xe("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, K.validateType)("FlowType"),
      indexType: (0, K.validateType)("FlowType")
    }
  });
  xe("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, K.validateType)("FlowType"),
      indexType: (0, K.validateType)("FlowType"),
      optional: (0, K.validate)((0, K.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/jsx.js
var FC = w(() => {
  "use strict";
  var dt = Ls(), Pr = (0, dt.defineAliasedType)("JSX");
  Pr("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, dt.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, dt.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  Pr("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, dt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  Pr("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, dt.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, dt.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, dt.chain)((0, dt.assertValueType)("array"), (0, dt.assertEach)((0, dt.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, dt.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  Pr("JSXEmptyExpression", {});
  Pr("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, dt.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  Pr("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, dt.assertNodeType)("Expression")
      }
    }
  });
  Pr("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, dt.assertValueType)("string")
      }
    }
  });
  Pr("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, dt.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, dt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  Pr("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, dt.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, dt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  Pr("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, dt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, dt.chain)((0, dt.assertValueType)("array"), (0, dt.assertEach)((0, dt.assertNodeType)("JSXAttribute", "JSXSpreadAttrib\
ute")))
      },
      typeParameters: {
        validate: (0, dt.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  Pr("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, dt.assertNodeType)("Expression")
      }
    }
  });
  Pr("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, dt.assertValueType)("string")
      }
    }
  });
  Pr("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, dt.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, dt.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, dt.chain)((0, dt.assertValueType)("array"), (0, dt.assertEach)((0, dt.assertNodeType)("JSXText", "JSXExpressionContain\
er", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  Pr("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  Pr("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/placeholders.js
var Zy = w((fi) => {
  "use strict";
  Object.defineProperty(fi, "__esModule", {
    value: !0
  });
  fi.PLACEHOLDERS_FLIPPED_ALIAS = fi.PLACEHOLDERS_ALIAS = fi.PLACEHOLDERS = void 0;
  var XTe = Ls(), $Te = fi.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "Class\
Body", "Pattern"], Qy = fi.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let t of $Te) {
    let e = XTe.ALIAS_KEYS[t];
    e != null && e.length && (Qy[t] = e);
  }
  var Gy = fi.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(Qy).forEach((t) => {
    Qy[t].forEach((e) => {
      hasOwnProperty.call(Gy, e) || (Gy[e] = []), Gy[e].push(t);
    });
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/misc.js
var jC = w(() => {
  "use strict";
  var hc = Ls(), HTe = Zy(), eT = (0, hc.defineAliasedType)("Miscellaneous");
  eT("Noop", {
    visitor: []
  });
  eT("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, hc.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, hc.assertOneOf)(...HTe.PLACEHOLDERS)
      }
    }
  });
  eT("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, hc.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/experimental.js
var RC = w(() => {
  "use strict";
  var nt = Ls();
  (0, nt.default)("ArgumentPlaceholder", {});
  (0, nt.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, nt.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, nt.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, nt.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, nt.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, nt.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, nt.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, nt.assertNodeType)("Expression")
      }
    }
  });
  (0, nt.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, nt.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, nt.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, nt.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, nt.assertNodeType)("Identifier")
      }
    }
  });
  (0, nt.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, nt.chain)((0, nt.assertValueType)("array"), (0, nt.assertEach)((0, nt.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, nt.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, nt.chain)((0, nt.assertValueType)("array"), (0, nt.assertEach)((0, nt.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, nt.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, nt.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, nt.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, nt.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, nt.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, nt.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, nt.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, nt.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, nt.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, nt.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/typescript.js
var XC = w(() => {
  "use strict";
  var $ = Ls(), UC = Hy(), zTe = Yn(), Le = (0, $.defineAliasedType)("TypeScript"), Dr = (0, $.assertValueType)("boolean"), qC = /* @__PURE__ */ n(
  () => ({
    returnType: {
      validate: (0, $.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, $.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  Le("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, $.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, $.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  });
  Le("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, UC.functionDeclarationCommon)(), qC())
  });
  Le("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, UC.classMethodOrDeclareMethodCommon)(), qC())
  });
  Le("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, $.validateType)("TSEntityName"),
      right: (0, $.validateType)("Identifier")
    }
  });
  var dc = /* @__PURE__ */ n(() => ({
    typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, $.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), VC = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: dc()
  };
  Le("TSCallSignatureDeclaration", VC);
  Le("TSConstructSignatureDeclaration", VC);
  var KC = /* @__PURE__ */ n(() => ({
    key: (0, $.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, $.validateOptional)(Dr)
  }), "namedTypeElementCommon");
  Le("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, KC(), {
      readonly: (0, $.validateOptional)(Dr),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        validate: (0, $.assertOneOf)("get", "set")
      }
    })
  });
  Le("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, dc(), KC(), {
      kind: {
        validate: (0, $.assertOneOf)("method", "get", "set")
      }
    })
  });
  Le("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, $.validateOptional)(Dr),
      static: (0, $.validateOptional)(Dr),
      parameters: (0, $.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var GTe = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeywor\
d", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let t of GTe)
    Le(t, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  Le("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var WC = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  Le("TSFunctionType", Object.assign({}, WC, {
    fields: dc()
  }));
  Le("TSConstructorType", Object.assign({}, WC, {
    fields: Object.assign({}, dc(), {
      abstract: (0, $.validateOptional)(Dr)
    })
  }));
  Le("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, $.validateType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, $.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, $.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, $.validateOptional)(Dr)
    }
  });
  Le("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, $.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, $.validateArrayOfType)("TSTypeElement")
    }
  });
  Le("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, $.validateType)("TSType")
    }
  });
  Le("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, $.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  Le("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, $.validateType)("Identifier"),
      optional: {
        validate: Dr,
        default: !1
      },
      elementType: (0, $.validateType)("TSType")
    }
  });
  var YC = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, $.validateArrayOfType)("TSType")
    }
  };
  Le("TSUnionType", YC);
  Le("TSIntersectionType", YC);
  Le("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, $.validateType)("TSType"),
      extendsType: (0, $.validateType)("TSType"),
      trueType: (0, $.validateType)("TSType"),
      falseType: (0, $.validateType)("TSType")
    }
  });
  Le("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, $.validateType)("TSTypeParameter")
    }
  });
  Le("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, $.validate)((0, $.assertValueType)("string")),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, $.validateType)("TSType"),
      indexType: (0, $.validateType)("TSType")
    }
  });
  Le("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, $.validateOptional)((0, $.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, $.validateType)("TSTypeParameter"),
      optional: (0, $.validateOptional)((0, $.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, $.validateOptionalType)("TSType"),
      nameType: (0, $.validateOptionalType)("TSType")
    }
  });
  Le("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let t = (0, $.assertNodeType)("NumericLiteral", "BigIntLiteral"), e = (0, $.assertOneOf)("-"), r = (0, $.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function s(i, a, o) {
            (0, zTe.default)("UnaryExpression", o) ? (e(o, "operator", o.operator), t(o, "argument", o.argument)) : r(i, a, o);
          }
          return n(s, "validator"), s.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiter\
al", "UnaryExpression"], s;
        }()
      }
    }
  });
  Le("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, $.validateType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Le("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, $.validateOptional)(Dr),
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, $.validateOptional)((0, $.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, $.validateType)("TSInterfaceBody")
    }
  });
  Le("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, $.validateArrayOfType)("TSTypeElement")
    }
  });
  Le("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, $.validateOptional)(Dr),
      id: (0, $.validateType)("Identifier"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  });
  Le("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, $.validateType)("Expression"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var JC = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, $.validateType)("Expression"),
      typeAnnotation: (0, $.validateType)("TSType")
    }
  };
  Le("TSAsExpression", JC);
  Le("TSSatisfiesExpression", JC);
  Le("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, $.validateType)("TSType"),
      expression: (0, $.validateType)("Expression")
    }
  });
  Le("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, $.validateOptional)(Dr),
      const: (0, $.validateOptional)(Dr),
      id: (0, $.validateType)("Identifier"),
      members: (0, $.validateArrayOfType)("TSEnumMember"),
      initializer: (0, $.validateOptionalType)("Expression")
    }
  });
  Le("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, $.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, $.validateOptionalType)("Expression")
    }
  });
  Le("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, $.validateOptional)(Dr),
      global: (0, $.validateOptional)(Dr),
      id: (0, $.validateType)(["Identifier", "StringLiteral"]),
      body: (0, $.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  Le("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, $.validateArrayOfType)("Statement")
    }
  });
  Le("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, $.validateType)("StringLiteral"),
      qualifier: (0, $.validateOptionalType)("TSEntityName"),
      typeParameters: (0, $.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, $.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  Le("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, $.validate)(Dr),
      id: (0, $.validateType)("Identifier"),
      moduleReference: (0, $.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, $.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  Le("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("StringLiteral")
    }
  });
  Le("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("Expression")
    }
  });
  Le("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, $.validateType)("Expression")
    }
  });
  Le("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, $.validateType)("Identifier")
    }
  });
  Le("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, $.assertNodeType)("TSType")
      }
    }
  });
  Le("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("TSType")))
      }
    }
  });
  Le("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, $.chain)((0, $.assertValueType)("array"), (0, $.assertEach)((0, $.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  Le("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, $.assertValueType)("string")
      },
      in: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, $.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, $.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, $.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var $C = w((mc) => {
  "use strict";
  Object.defineProperty(mc, "__esModule", {
    value: !0
  });
  mc.DEPRECATED_ALIASES = void 0;
  var Y6e = mc.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/definitions/index.js
var Vr = w((Er) => {
  "use strict";
  Object.defineProperty(Er, "__esModule", {
    value: !0
  });
  Object.defineProperty(Er, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gt.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(Er, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gt.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(Er, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return tT.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(Er, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gt.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(Er, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gt.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(Er, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gt.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(Er, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gt.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(Er, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wo.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(Er, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wo.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(Er, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wo.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  Er.TYPES = void 0;
  Object.defineProperty(Er, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gt.VISITOR_KEYS;
    }, "get")
  });
  var hi = ip();
  Hy();
  BC();
  FC();
  jC();
  RC();
  XC();
  var Gt = Ls(), wo = Zy(), tT = $C();
  Object.keys(tT.DEPRECATED_ALIASES).forEach((t) => {
    Gt.FLIPPED_ALIAS_KEYS[t] = Gt.FLIPPED_ALIAS_KEYS[tT.DEPRECATED_ALIASES[t]];
  });
  hi(Gt.VISITOR_KEYS);
  hi(Gt.ALIAS_KEYS);
  hi(Gt.FLIPPED_ALIAS_KEYS);
  hi(Gt.NODE_FIELDS);
  hi(Gt.BUILDER_KEYS);
  hi(Gt.DEPRECATED_KEYS);
  hi(wo.PLACEHOLDERS_ALIAS);
  hi(wo.PLACEHOLDERS_FLIPPED_ALIAS);
  var X6e = Er.TYPES = [].concat(Object.keys(Gt.VISITOR_KEYS), Object.keys(Gt.FLIPPED_ALIAS_KEYS), Object.keys(Gt.DEPRECATED_KEYS));
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/validate.js
var pc = w((No) => {
  "use strict";
  Object.defineProperty(No, "__esModule", {
    value: !0
  });
  No.default = QTe;
  No.validateChild = GC;
  No.validateField = zC;
  var HC = Vr();
  function QTe(t, e, r) {
    if (!t) return;
    let s = HC.NODE_FIELDS[t.type];
    if (!s) return;
    let i = s[e];
    zC(t, e, r, i), GC(t, e, r);
  }
  n(QTe, "validate");
  function zC(t, e, r, s) {
    s != null && s.validate && (s.optional && r == null || s.validate(t, e, r));
  }
  n(zC, "validateField");
  function GC(t, e, r) {
    if (r == null) return;
    let s = HC.NODE_PARENT_VALIDATIONS[r.type];
    s && s(t, e, r);
  }
  n(GC, "validateChild");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/validateNode.js
var QC = w((rT) => {
  "use strict";
  Object.defineProperty(rT, "__esModule", {
    value: !0
  });
  rT.default = t0e;
  var ZTe = pc(), e0e = Oo();
  function t0e(t) {
    let e = e0e.BUILDER_KEYS[t.type];
    for (let r of e)
      (0, ZTe.default)(t, r, t[r]);
    return t;
  }
  n(t0e, "validateNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/generated/index.js
var Ar = w((x) => {
  "use strict";
  Object.defineProperty(x, "__esModule", {
    value: !0
  });
  x.anyTypeAnnotation = Dbe;
  x.argumentPlaceholder = oSe;
  x.arrayExpression = r0e;
  x.arrayPattern = G0e;
  x.arrayTypeAnnotation = _be;
  x.arrowFunctionExpression = Q0e;
  x.assignmentExpression = s0e;
  x.assignmentPattern = z0e;
  x.awaitExpression = Sbe;
  x.bigIntLiteral = Pbe;
  x.binaryExpression = i0e;
  x.bindExpression = lSe;
  x.blockStatement = l0e;
  x.booleanLiteral = w0e;
  x.booleanLiteralTypeAnnotation = Mbe;
  x.booleanTypeAnnotation = Lbe;
  x.breakStatement = u0e;
  x.callExpression = c0e;
  x.catchClause = p0e;
  x.classAccessorProperty = Ibe;
  x.classBody = Z0e;
  x.classDeclaration = tbe;
  x.classExpression = ebe;
  x.classImplements = Fbe;
  x.classMethod = hbe;
  x.classPrivateMethod = Nbe;
  x.classPrivateProperty = wbe;
  x.classProperty = Cbe;
  x.conditionalExpression = f0e;
  x.continueStatement = h0e;
  x.debuggerStatement = d0e;
  x.decimalLiteral = mSe;
  x.declareClass = jbe;
  x.declareExportAllDeclaration = Xbe;
  x.declareExportDeclaration = Jbe;
  x.declareFunction = Rbe;
  x.declareInterface = Ube;
  x.declareModule = qbe;
  x.declareModuleExports = Vbe;
  x.declareOpaqueType = Wbe;
  x.declareTypeAlias = Kbe;
  x.declareVariable = Ybe;
  x.declaredPredicate = $be;
  x.decorator = cSe;
  x.directive = a0e;
  x.directiveLiteral = o0e;
  x.doExpression = pSe;
  x.doWhileStatement = m0e;
  x.emptyStatement = y0e;
  x.emptyTypeAnnotation = nxe;
  x.enumBooleanBody = _xe;
  x.enumBooleanMember = Fxe;
  x.enumDeclaration = Dxe;
  x.enumDefaultedMember = Uxe;
  x.enumNumberBody = Lxe;
  x.enumNumberMember = jxe;
  x.enumStringBody = Mxe;
  x.enumStringMember = Rxe;
  x.enumSymbolBody = Bxe;
  x.existsTypeAnnotation = Hbe;
  x.exportAllDeclaration = rbe;
  x.exportDefaultDeclaration = sbe;
  x.exportDefaultSpecifier = fSe;
  x.exportNamedDeclaration = ibe;
  x.exportNamespaceSpecifier = Ebe;
  x.exportSpecifier = nbe;
  x.expressionStatement = T0e;
  x.file = b0e;
  x.forInStatement = x0e;
  x.forOfStatement = abe;
  x.forStatement = S0e;
  x.functionDeclaration = g0e;
  x.functionExpression = P0e;
  x.functionTypeAnnotation = zbe;
  x.functionTypeParam = Gbe;
  x.genericTypeAnnotation = Qbe;
  x.identifier = E0e;
  x.ifStatement = A0e;
  x.import = gbe;
  x.importAttribute = uSe;
  x.importDeclaration = obe;
  x.importDefaultSpecifier = lbe;
  x.importExpression = pbe;
  x.importNamespaceSpecifier = ube;
  x.importSpecifier = cbe;
  x.indexedAccessType = qxe;
  x.inferredPredicate = Zbe;
  x.interfaceDeclaration = txe;
  x.interfaceExtends = exe;
  x.interfaceTypeAnnotation = rxe;
  x.interpreterDirective = n0e;
  x.intersectionTypeAnnotation = sxe;
  x.jSXAttribute = x.jsxAttribute = Kxe;
  x.jSXClosingElement = x.jsxClosingElement = Wxe;
  x.jSXClosingFragment = x.jsxClosingFragment = sSe;
  x.jSXElement = x.jsxElement = Yxe;
  x.jSXEmptyExpression = x.jsxEmptyExpression = Jxe;
  x.jSXExpressionContainer = x.jsxExpressionContainer = Xxe;
  x.jSXFragment = x.jsxFragment = tSe;
  x.jSXIdentifier = x.jsxIdentifier = Hxe;
  x.jSXMemberExpression = x.jsxMemberExpression = zxe;
  x.jSXNamespacedName = x.jsxNamespacedName = Gxe;
  x.jSXOpeningElement = x.jsxOpeningElement = Qxe;
  x.jSXOpeningFragment = x.jsxOpeningFragment = rSe;
  x.jSXSpreadAttribute = x.jsxSpreadAttribute = Zxe;
  x.jSXSpreadChild = x.jsxSpreadChild = $xe;
  x.jSXText = x.jsxText = eSe;
  x.labeledStatement = v0e;
  x.logicalExpression = N0e;
  x.memberExpression = O0e;
  x.metaProperty = fbe;
  x.mixedTypeAnnotation = ixe;
  x.moduleExpression = ySe;
  x.newExpression = k0e;
  x.noop = iSe;
  x.nullLiteral = I0e;
  x.nullLiteralTypeAnnotation = Bbe;
  x.nullableTypeAnnotation = axe;
  x.numberLiteral = Dge;
  x.numberLiteralTypeAnnotation = oxe;
  x.numberTypeAnnotation = lxe;
  x.numericLiteral = ZC;
  x.objectExpression = _0e;
  x.objectMethod = L0e;
  x.objectPattern = dbe;
  x.objectProperty = M0e;
  x.objectTypeAnnotation = uxe;
  x.objectTypeCallProperty = pxe;
  x.objectTypeIndexer = fxe;
  x.objectTypeInternalSlot = cxe;
  x.objectTypeProperty = hxe;
  x.objectTypeSpreadProperty = dxe;
  x.opaqueType = mxe;
  x.optionalCallExpression = vbe;
  x.optionalIndexedAccessType = Vxe;
  x.optionalMemberExpression = Abe;
  x.parenthesizedExpression = j0e;
  x.pipelineBareFunction = xSe;
  x.pipelinePrimaryTopicReference = SSe;
  x.pipelineTopicExpression = bSe;
  x.placeholder = nSe;
  x.privateName = Obe;
  x.program = D0e;
  x.qualifiedTypeIdentifier = yxe;
  x.recordExpression = hSe;
  x.regExpLiteral = eI;
  x.regexLiteral = _ge;
  x.restElement = tI;
  x.restProperty = Lge;
  x.returnStatement = B0e;
  x.sequenceExpression = F0e;
  x.spreadElement = rI;
  x.spreadProperty = Mge;
  x.staticBlock = kbe;
  x.stringLiteral = C0e;
  x.stringLiteralTypeAnnotation = Txe;
  x.stringTypeAnnotation = bxe;
  x.super = mbe;
  x.switchCase = R0e;
  x.switchStatement = U0e;
  x.symbolTypeAnnotation = xxe;
  x.taggedTemplateExpression = ybe;
  x.templateElement = Tbe;
  x.templateLiteral = bbe;
  x.thisExpression = q0e;
  x.thisTypeAnnotation = Sxe;
  x.throwStatement = V0e;
  x.topicReference = TSe;
  x.tryStatement = K0e;
  x.tSAnyKeyword = x.tsAnyKeyword = OSe;
  x.tSArrayType = x.tsArrayType = zSe;
  x.tSAsExpression = x.tsAsExpression = mge;
  x.tSBigIntKeyword = x.tsBigIntKeyword = DSe;
  x.tSBooleanKeyword = x.tsBooleanKeyword = kSe;
  x.tSCallSignatureDeclaration = x.tsCallSignatureDeclaration = vSe;
  x.tSConditionalType = x.tsConditionalType = sge;
  x.tSConstructSignatureDeclaration = x.tsConstructSignatureDeclaration = CSe;
  x.tSConstructorType = x.tsConstructorType = YSe;
  x.tSDeclareFunction = x.tsDeclareFunction = PSe;
  x.tSDeclareMethod = x.tsDeclareMethod = ESe;
  x.tSEnumDeclaration = x.tsEnumDeclaration = bge;
  x.tSEnumMember = x.tsEnumMember = xge;
  x.tSExportAssignment = x.tsExportAssignment = Cge;
  x.tSExpressionWithTypeArguments = x.tsExpressionWithTypeArguments = cge;
  x.tSExternalModuleReference = x.tsExternalModuleReference = Age;
  x.tSFunctionType = x.tsFunctionType = WSe;
  x.tSImportEqualsDeclaration = x.tsImportEqualsDeclaration = Ege;
  x.tSImportType = x.tsImportType = Pge;
  x.tSIndexSignature = x.tsIndexSignature = NSe;
  x.tSIndexedAccessType = x.tsIndexedAccessType = oge;
  x.tSInferType = x.tsInferType = ige;
  x.tSInstantiationExpression = x.tsInstantiationExpression = dge;
  x.tSInterfaceBody = x.tsInterfaceBody = fge;
  x.tSInterfaceDeclaration = x.tsInterfaceDeclaration = pge;
  x.tSIntersectionType = x.tsIntersectionType = rge;
  x.tSIntrinsicKeyword = x.tsIntrinsicKeyword = _Se;
  x.tSLiteralType = x.tsLiteralType = uge;
  x.tSMappedType = x.tsMappedType = lge;
  x.tSMethodSignature = x.tsMethodSignature = wSe;
  x.tSModuleBlock = x.tsModuleBlock = gge;
  x.tSModuleDeclaration = x.tsModuleDeclaration = Sge;
  x.tSNamedTupleMember = x.tsNamedTupleMember = ege;
  x.tSNamespaceExportDeclaration = x.tsNamespaceExportDeclaration = Ige;
  x.tSNeverKeyword = x.tsNeverKeyword = LSe;
  x.tSNonNullExpression = x.tsNonNullExpression = vge;
  x.tSNullKeyword = x.tsNullKeyword = MSe;
  x.tSNumberKeyword = x.tsNumberKeyword = BSe;
  x.tSObjectKeyword = x.tsObjectKeyword = FSe;
  x.tSOptionalType = x.tsOptionalType = QSe;
  x.tSParameterProperty = x.tsParameterProperty = gSe;
  x.tSParenthesizedType = x.tsParenthesizedType = nge;
  x.tSPropertySignature = x.tsPropertySignature = ISe;
  x.tSQualifiedName = x.tsQualifiedName = ASe;
  x.tSRestType = x.tsRestType = ZSe;
  x.tSSatisfiesExpression = x.tsSatisfiesExpression = yge;
  x.tSStringKeyword = x.tsStringKeyword = jSe;
  x.tSSymbolKeyword = x.tsSymbolKeyword = RSe;
  x.tSThisType = x.tsThisType = KSe;
  x.tSTupleType = x.tsTupleType = GSe;
  x.tSTypeAliasDeclaration = x.tsTypeAliasDeclaration = hge;
  x.tSTypeAnnotation = x.tsTypeAnnotation = wge;
  x.tSTypeAssertion = x.tsTypeAssertion = Tge;
  x.tSTypeLiteral = x.tsTypeLiteral = HSe;
  x.tSTypeOperator = x.tsTypeOperator = age;
  x.tSTypeParameter = x.tsTypeParameter = kge;
  x.tSTypeParameterDeclaration = x.tsTypeParameterDeclaration = Oge;
  x.tSTypeParameterInstantiation = x.tsTypeParameterInstantiation = Nge;
  x.tSTypePredicate = x.tsTypePredicate = XSe;
  x.tSTypeQuery = x.tsTypeQuery = $Se;
  x.tSTypeReference = x.tsTypeReference = JSe;
  x.tSUndefinedKeyword = x.tsUndefinedKeyword = USe;
  x.tSUnionType = x.tsUnionType = tge;
  x.tSUnknownKeyword = x.tsUnknownKeyword = qSe;
  x.tSVoidKeyword = x.tsVoidKeyword = VSe;
  x.tupleExpression = dSe;
  x.tupleTypeAnnotation = gxe;
  x.typeAlias = Exe;
  x.typeAnnotation = Axe;
  x.typeCastExpression = vxe;
  x.typeParameter = Cxe;
  x.typeParameterDeclaration = Ixe;
  x.typeParameterInstantiation = wxe;
  x.typeofTypeAnnotation = Pxe;
  x.unaryExpression = W0e;
  x.unionTypeAnnotation = Nxe;
  x.updateExpression = Y0e;
  x.v8IntrinsicIdentifier = aSe;
  x.variableDeclaration = J0e;
  x.variableDeclarator = X0e;
  x.variance = Oxe;
  x.voidTypeAnnotation = kxe;
  x.whileStatement = $0e;
  x.withStatement = H0e;
  x.yieldExpression = xbe;
  var R = QC(), yc = Eo();
  function r0e(t = []) {
    return (0, R.default)({
      type: "ArrayExpression",
      elements: t
    });
  }
  n(r0e, "arrayExpression");
  function s0e(t, e, r) {
    return (0, R.default)({
      type: "AssignmentExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(s0e, "assignmentExpression");
  function i0e(t, e, r) {
    return (0, R.default)({
      type: "BinaryExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(i0e, "binaryExpression");
  function n0e(t) {
    return (0, R.default)({
      type: "InterpreterDirective",
      value: t
    });
  }
  n(n0e, "interpreterDirective");
  function a0e(t) {
    return (0, R.default)({
      type: "Directive",
      value: t
    });
  }
  n(a0e, "directive");
  function o0e(t) {
    return (0, R.default)({
      type: "DirectiveLiteral",
      value: t
    });
  }
  n(o0e, "directiveLiteral");
  function l0e(t, e = []) {
    return (0, R.default)({
      type: "BlockStatement",
      body: t,
      directives: e
    });
  }
  n(l0e, "blockStatement");
  function u0e(t = null) {
    return (0, R.default)({
      type: "BreakStatement",
      label: t
    });
  }
  n(u0e, "breakStatement");
  function c0e(t, e) {
    return (0, R.default)({
      type: "CallExpression",
      callee: t,
      arguments: e
    });
  }
  n(c0e, "callExpression");
  function p0e(t = null, e) {
    return (0, R.default)({
      type: "CatchClause",
      param: t,
      body: e
    });
  }
  n(p0e, "catchClause");
  function f0e(t, e, r) {
    return (0, R.default)({
      type: "ConditionalExpression",
      test: t,
      consequent: e,
      alternate: r
    });
  }
  n(f0e, "conditionalExpression");
  function h0e(t = null) {
    return (0, R.default)({
      type: "ContinueStatement",
      label: t
    });
  }
  n(h0e, "continueStatement");
  function d0e() {
    return {
      type: "DebuggerStatement"
    };
  }
  n(d0e, "debuggerStatement");
  function m0e(t, e) {
    return (0, R.default)({
      type: "DoWhileStatement",
      test: t,
      body: e
    });
  }
  n(m0e, "doWhileStatement");
  function y0e() {
    return {
      type: "EmptyStatement"
    };
  }
  n(y0e, "emptyStatement");
  function T0e(t) {
    return (0, R.default)({
      type: "ExpressionStatement",
      expression: t
    });
  }
  n(T0e, "expressionStatement");
  function b0e(t, e = null, r = null) {
    return (0, R.default)({
      type: "File",
      program: t,
      comments: e,
      tokens: r
    });
  }
  n(b0e, "file");
  function x0e(t, e, r) {
    return (0, R.default)({
      type: "ForInStatement",
      left: t,
      right: e,
      body: r
    });
  }
  n(x0e, "forInStatement");
  function S0e(t = null, e = null, r = null, s) {
    return (0, R.default)({
      type: "ForStatement",
      init: t,
      test: e,
      update: r,
      body: s
    });
  }
  n(S0e, "forStatement");
  function g0e(t = null, e, r, s = !1, i = !1) {
    return (0, R.default)({
      type: "FunctionDeclaration",
      id: t,
      params: e,
      body: r,
      generator: s,
      async: i
    });
  }
  n(g0e, "functionDeclaration");
  function P0e(t = null, e, r, s = !1, i = !1) {
    return (0, R.default)({
      type: "FunctionExpression",
      id: t,
      params: e,
      body: r,
      generator: s,
      async: i
    });
  }
  n(P0e, "functionExpression");
  function E0e(t) {
    return (0, R.default)({
      type: "Identifier",
      name: t
    });
  }
  n(E0e, "identifier");
  function A0e(t, e, r = null) {
    return (0, R.default)({
      type: "IfStatement",
      test: t,
      consequent: e,
      alternate: r
    });
  }
  n(A0e, "ifStatement");
  function v0e(t, e) {
    return (0, R.default)({
      type: "LabeledStatement",
      label: t,
      body: e
    });
  }
  n(v0e, "labeledStatement");
  function C0e(t) {
    return (0, R.default)({
      type: "StringLiteral",
      value: t
    });
  }
  n(C0e, "stringLiteral");
  function ZC(t) {
    return (0, R.default)({
      type: "NumericLiteral",
      value: t
    });
  }
  n(ZC, "numericLiteral");
  function I0e() {
    return {
      type: "NullLiteral"
    };
  }
  n(I0e, "nullLiteral");
  function w0e(t) {
    return (0, R.default)({
      type: "BooleanLiteral",
      value: t
    });
  }
  n(w0e, "booleanLiteral");
  function eI(t, e = "") {
    return (0, R.default)({
      type: "RegExpLiteral",
      pattern: t,
      flags: e
    });
  }
  n(eI, "regExpLiteral");
  function N0e(t, e, r) {
    return (0, R.default)({
      type: "LogicalExpression",
      operator: t,
      left: e,
      right: r
    });
  }
  n(N0e, "logicalExpression");
  function O0e(t, e, r = !1, s = null) {
    return (0, R.default)({
      type: "MemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: s
    });
  }
  n(O0e, "memberExpression");
  function k0e(t, e) {
    return (0, R.default)({
      type: "NewExpression",
      callee: t,
      arguments: e
    });
  }
  n(k0e, "newExpression");
  function D0e(t, e = [], r = "script", s = null) {
    return (0, R.default)({
      type: "Program",
      body: t,
      directives: e,
      sourceType: r,
      interpreter: s
    });
  }
  n(D0e, "program");
  function _0e(t) {
    return (0, R.default)({
      type: "ObjectExpression",
      properties: t
    });
  }
  n(_0e, "objectExpression");
  function L0e(t = "method", e, r, s, i = !1, a = !1, o = !1) {
    return (0, R.default)({
      type: "ObjectMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      computed: i,
      generator: a,
      async: o
    });
  }
  n(L0e, "objectMethod");
  function M0e(t, e, r = !1, s = !1, i = null) {
    return (0, R.default)({
      type: "ObjectProperty",
      key: t,
      value: e,
      computed: r,
      shorthand: s,
      decorators: i
    });
  }
  n(M0e, "objectProperty");
  function tI(t) {
    return (0, R.default)({
      type: "RestElement",
      argument: t
    });
  }
  n(tI, "restElement");
  function B0e(t = null) {
    return (0, R.default)({
      type: "ReturnStatement",
      argument: t
    });
  }
  n(B0e, "returnStatement");
  function F0e(t) {
    return (0, R.default)({
      type: "SequenceExpression",
      expressions: t
    });
  }
  n(F0e, "sequenceExpression");
  function j0e(t) {
    return (0, R.default)({
      type: "ParenthesizedExpression",
      expression: t
    });
  }
  n(j0e, "parenthesizedExpression");
  function R0e(t = null, e) {
    return (0, R.default)({
      type: "SwitchCase",
      test: t,
      consequent: e
    });
  }
  n(R0e, "switchCase");
  function U0e(t, e) {
    return (0, R.default)({
      type: "SwitchStatement",
      discriminant: t,
      cases: e
    });
  }
  n(U0e, "switchStatement");
  function q0e() {
    return {
      type: "ThisExpression"
    };
  }
  n(q0e, "thisExpression");
  function V0e(t) {
    return (0, R.default)({
      type: "ThrowStatement",
      argument: t
    });
  }
  n(V0e, "throwStatement");
  function K0e(t, e = null, r = null) {
    return (0, R.default)({
      type: "TryStatement",
      block: t,
      handler: e,
      finalizer: r
    });
  }
  n(K0e, "tryStatement");
  function W0e(t, e, r = !0) {
    return (0, R.default)({
      type: "UnaryExpression",
      operator: t,
      argument: e,
      prefix: r
    });
  }
  n(W0e, "unaryExpression");
  function Y0e(t, e, r = !1) {
    return (0, R.default)({
      type: "UpdateExpression",
      operator: t,
      argument: e,
      prefix: r
    });
  }
  n(Y0e, "updateExpression");
  function J0e(t, e) {
    return (0, R.default)({
      type: "VariableDeclaration",
      kind: t,
      declarations: e
    });
  }
  n(J0e, "variableDeclaration");
  function X0e(t, e = null) {
    return (0, R.default)({
      type: "VariableDeclarator",
      id: t,
      init: e
    });
  }
  n(X0e, "variableDeclarator");
  function $0e(t, e) {
    return (0, R.default)({
      type: "WhileStatement",
      test: t,
      body: e
    });
  }
  n($0e, "whileStatement");
  function H0e(t, e) {
    return (0, R.default)({
      type: "WithStatement",
      object: t,
      body: e
    });
  }
  n(H0e, "withStatement");
  function z0e(t, e) {
    return (0, R.default)({
      type: "AssignmentPattern",
      left: t,
      right: e
    });
  }
  n(z0e, "assignmentPattern");
  function G0e(t) {
    return (0, R.default)({
      type: "ArrayPattern",
      elements: t
    });
  }
  n(G0e, "arrayPattern");
  function Q0e(t, e, r = !1) {
    return (0, R.default)({
      type: "ArrowFunctionExpression",
      params: t,
      body: e,
      async: r,
      expression: null
    });
  }
  n(Q0e, "arrowFunctionExpression");
  function Z0e(t) {
    return (0, R.default)({
      type: "ClassBody",
      body: t
    });
  }
  n(Z0e, "classBody");
  function ebe(t = null, e = null, r, s = null) {
    return (0, R.default)({
      type: "ClassExpression",
      id: t,
      superClass: e,
      body: r,
      decorators: s
    });
  }
  n(ebe, "classExpression");
  function tbe(t = null, e = null, r, s = null) {
    return (0, R.default)({
      type: "ClassDeclaration",
      id: t,
      superClass: e,
      body: r,
      decorators: s
    });
  }
  n(tbe, "classDeclaration");
  function rbe(t) {
    return (0, R.default)({
      type: "ExportAllDeclaration",
      source: t
    });
  }
  n(rbe, "exportAllDeclaration");
  function sbe(t) {
    return (0, R.default)({
      type: "ExportDefaultDeclaration",
      declaration: t
    });
  }
  n(sbe, "exportDefaultDeclaration");
  function ibe(t = null, e = [], r = null) {
    return (0, R.default)({
      type: "ExportNamedDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    });
  }
  n(ibe, "exportNamedDeclaration");
  function nbe(t, e) {
    return (0, R.default)({
      type: "ExportSpecifier",
      local: t,
      exported: e
    });
  }
  n(nbe, "exportSpecifier");
  function abe(t, e, r, s = !1) {
    return (0, R.default)({
      type: "ForOfStatement",
      left: t,
      right: e,
      body: r,
      await: s
    });
  }
  n(abe, "forOfStatement");
  function obe(t, e) {
    return (0, R.default)({
      type: "ImportDeclaration",
      specifiers: t,
      source: e
    });
  }
  n(obe, "importDeclaration");
  function lbe(t) {
    return (0, R.default)({
      type: "ImportDefaultSpecifier",
      local: t
    });
  }
  n(lbe, "importDefaultSpecifier");
  function ube(t) {
    return (0, R.default)({
      type: "ImportNamespaceSpecifier",
      local: t
    });
  }
  n(ube, "importNamespaceSpecifier");
  function cbe(t, e) {
    return (0, R.default)({
      type: "ImportSpecifier",
      local: t,
      imported: e
    });
  }
  n(cbe, "importSpecifier");
  function pbe(t, e = null) {
    return (0, R.default)({
      type: "ImportExpression",
      source: t,
      options: e
    });
  }
  n(pbe, "importExpression");
  function fbe(t, e) {
    return (0, R.default)({
      type: "MetaProperty",
      meta: t,
      property: e
    });
  }
  n(fbe, "metaProperty");
  function hbe(t = "method", e, r, s, i = !1, a = !1, o = !1, l = !1) {
    return (0, R.default)({
      type: "ClassMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      computed: i,
      static: a,
      generator: o,
      async: l
    });
  }
  n(hbe, "classMethod");
  function dbe(t) {
    return (0, R.default)({
      type: "ObjectPattern",
      properties: t
    });
  }
  n(dbe, "objectPattern");
  function rI(t) {
    return (0, R.default)({
      type: "SpreadElement",
      argument: t
    });
  }
  n(rI, "spreadElement");
  function mbe() {
    return {
      type: "Super"
    };
  }
  n(mbe, "_super");
  function ybe(t, e) {
    return (0, R.default)({
      type: "TaggedTemplateExpression",
      tag: t,
      quasi: e
    });
  }
  n(ybe, "taggedTemplateExpression");
  function Tbe(t, e = !1) {
    return (0, R.default)({
      type: "TemplateElement",
      value: t,
      tail: e
    });
  }
  n(Tbe, "templateElement");
  function bbe(t, e) {
    return (0, R.default)({
      type: "TemplateLiteral",
      quasis: t,
      expressions: e
    });
  }
  n(bbe, "templateLiteral");
  function xbe(t = null, e = !1) {
    return (0, R.default)({
      type: "YieldExpression",
      argument: t,
      delegate: e
    });
  }
  n(xbe, "yieldExpression");
  function Sbe(t) {
    return (0, R.default)({
      type: "AwaitExpression",
      argument: t
    });
  }
  n(Sbe, "awaitExpression");
  function gbe() {
    return {
      type: "Import"
    };
  }
  n(gbe, "_import");
  function Pbe(t) {
    return (0, R.default)({
      type: "BigIntLiteral",
      value: t
    });
  }
  n(Pbe, "bigIntLiteral");
  function Ebe(t) {
    return (0, R.default)({
      type: "ExportNamespaceSpecifier",
      exported: t
    });
  }
  n(Ebe, "exportNamespaceSpecifier");
  function Abe(t, e, r = !1, s) {
    return (0, R.default)({
      type: "OptionalMemberExpression",
      object: t,
      property: e,
      computed: r,
      optional: s
    });
  }
  n(Abe, "optionalMemberExpression");
  function vbe(t, e, r) {
    return (0, R.default)({
      type: "OptionalCallExpression",
      callee: t,
      arguments: e,
      optional: r
    });
  }
  n(vbe, "optionalCallExpression");
  function Cbe(t, e = null, r = null, s = null, i = !1, a = !1) {
    return (0, R.default)({
      type: "ClassProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: s,
      computed: i,
      static: a
    });
  }
  n(Cbe, "classProperty");
  function Ibe(t, e = null, r = null, s = null, i = !1, a = !1) {
    return (0, R.default)({
      type: "ClassAccessorProperty",
      key: t,
      value: e,
      typeAnnotation: r,
      decorators: s,
      computed: i,
      static: a
    });
  }
  n(Ibe, "classAccessorProperty");
  function wbe(t, e = null, r = null, s = !1) {
    return (0, R.default)({
      type: "ClassPrivateProperty",
      key: t,
      value: e,
      decorators: r,
      static: s
    });
  }
  n(wbe, "classPrivateProperty");
  function Nbe(t = "method", e, r, s, i = !1) {
    return (0, R.default)({
      type: "ClassPrivateMethod",
      kind: t,
      key: e,
      params: r,
      body: s,
      static: i
    });
  }
  n(Nbe, "classPrivateMethod");
  function Obe(t) {
    return (0, R.default)({
      type: "PrivateName",
      id: t
    });
  }
  n(Obe, "privateName");
  function kbe(t) {
    return (0, R.default)({
      type: "StaticBlock",
      body: t
    });
  }
  n(kbe, "staticBlock");
  function Dbe() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  n(Dbe, "anyTypeAnnotation");
  function _be(t) {
    return (0, R.default)({
      type: "ArrayTypeAnnotation",
      elementType: t
    });
  }
  n(_be, "arrayTypeAnnotation");
  function Lbe() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  n(Lbe, "booleanTypeAnnotation");
  function Mbe(t) {
    return (0, R.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: t
    });
  }
  n(Mbe, "booleanLiteralTypeAnnotation");
  function Bbe() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  n(Bbe, "nullLiteralTypeAnnotation");
  function Fbe(t, e = null) {
    return (0, R.default)({
      type: "ClassImplements",
      id: t,
      typeParameters: e
    });
  }
  n(Fbe, "classImplements");
  function jbe(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "DeclareClass",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(jbe, "declareClass");
  function Rbe(t) {
    return (0, R.default)({
      type: "DeclareFunction",
      id: t
    });
  }
  n(Rbe, "declareFunction");
  function Ube(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "DeclareInterface",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(Ube, "declareInterface");
  function qbe(t, e, r = null) {
    return (0, R.default)({
      type: "DeclareModule",
      id: t,
      body: e,
      kind: r
    });
  }
  n(qbe, "declareModule");
  function Vbe(t) {
    return (0, R.default)({
      type: "DeclareModuleExports",
      typeAnnotation: t
    });
  }
  n(Vbe, "declareModuleExports");
  function Kbe(t, e = null, r) {
    return (0, R.default)({
      type: "DeclareTypeAlias",
      id: t,
      typeParameters: e,
      right: r
    });
  }
  n(Kbe, "declareTypeAlias");
  function Wbe(t, e = null, r = null) {
    return (0, R.default)({
      type: "DeclareOpaqueType",
      id: t,
      typeParameters: e,
      supertype: r
    });
  }
  n(Wbe, "declareOpaqueType");
  function Ybe(t) {
    return (0, R.default)({
      type: "DeclareVariable",
      id: t
    });
  }
  n(Ybe, "declareVariable");
  function Jbe(t = null, e = null, r = null) {
    return (0, R.default)({
      type: "DeclareExportDeclaration",
      declaration: t,
      specifiers: e,
      source: r
    });
  }
  n(Jbe, "declareExportDeclaration");
  function Xbe(t) {
    return (0, R.default)({
      type: "DeclareExportAllDeclaration",
      source: t
    });
  }
  n(Xbe, "declareExportAllDeclaration");
  function $be(t) {
    return (0, R.default)({
      type: "DeclaredPredicate",
      value: t
    });
  }
  n($be, "declaredPredicate");
  function Hbe() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  n(Hbe, "existsTypeAnnotation");
  function zbe(t = null, e, r = null, s) {
    return (0, R.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: t,
      params: e,
      rest: r,
      returnType: s
    });
  }
  n(zbe, "functionTypeAnnotation");
  function Gbe(t = null, e) {
    return (0, R.default)({
      type: "FunctionTypeParam",
      name: t,
      typeAnnotation: e
    });
  }
  n(Gbe, "functionTypeParam");
  function Qbe(t, e = null) {
    return (0, R.default)({
      type: "GenericTypeAnnotation",
      id: t,
      typeParameters: e
    });
  }
  n(Qbe, "genericTypeAnnotation");
  function Zbe() {
    return {
      type: "InferredPredicate"
    };
  }
  n(Zbe, "inferredPredicate");
  function exe(t, e = null) {
    return (0, R.default)({
      type: "InterfaceExtends",
      id: t,
      typeParameters: e
    });
  }
  n(exe, "interfaceExtends");
  function txe(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "InterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(txe, "interfaceDeclaration");
  function rxe(t = null, e) {
    return (0, R.default)({
      type: "InterfaceTypeAnnotation",
      extends: t,
      body: e
    });
  }
  n(rxe, "interfaceTypeAnnotation");
  function sxe(t) {
    return (0, R.default)({
      type: "IntersectionTypeAnnotation",
      types: t
    });
  }
  n(sxe, "intersectionTypeAnnotation");
  function ixe() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  n(ixe, "mixedTypeAnnotation");
  function nxe() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  n(nxe, "emptyTypeAnnotation");
  function axe(t) {
    return (0, R.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: t
    });
  }
  n(axe, "nullableTypeAnnotation");
  function oxe(t) {
    return (0, R.default)({
      type: "NumberLiteralTypeAnnotation",
      value: t
    });
  }
  n(oxe, "numberLiteralTypeAnnotation");
  function lxe() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  n(lxe, "numberTypeAnnotation");
  function uxe(t, e = [], r = [], s = [], i = !1) {
    return (0, R.default)({
      type: "ObjectTypeAnnotation",
      properties: t,
      indexers: e,
      callProperties: r,
      internalSlots: s,
      exact: i
    });
  }
  n(uxe, "objectTypeAnnotation");
  function cxe(t, e, r, s, i) {
    return (0, R.default)({
      type: "ObjectTypeInternalSlot",
      id: t,
      value: e,
      optional: r,
      static: s,
      method: i
    });
  }
  n(cxe, "objectTypeInternalSlot");
  function pxe(t) {
    return (0, R.default)({
      type: "ObjectTypeCallProperty",
      value: t,
      static: null
    });
  }
  n(pxe, "objectTypeCallProperty");
  function fxe(t = null, e, r, s = null) {
    return (0, R.default)({
      type: "ObjectTypeIndexer",
      id: t,
      key: e,
      value: r,
      variance: s,
      static: null
    });
  }
  n(fxe, "objectTypeIndexer");
  function hxe(t, e, r = null) {
    return (0, R.default)({
      type: "ObjectTypeProperty",
      key: t,
      value: e,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  n(hxe, "objectTypeProperty");
  function dxe(t) {
    return (0, R.default)({
      type: "ObjectTypeSpreadProperty",
      argument: t
    });
  }
  n(dxe, "objectTypeSpreadProperty");
  function mxe(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "OpaqueType",
      id: t,
      typeParameters: e,
      supertype: r,
      impltype: s
    });
  }
  n(mxe, "opaqueType");
  function yxe(t, e) {
    return (0, R.default)({
      type: "QualifiedTypeIdentifier",
      id: t,
      qualification: e
    });
  }
  n(yxe, "qualifiedTypeIdentifier");
  function Txe(t) {
    return (0, R.default)({
      type: "StringLiteralTypeAnnotation",
      value: t
    });
  }
  n(Txe, "stringLiteralTypeAnnotation");
  function bxe() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  n(bxe, "stringTypeAnnotation");
  function xxe() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  n(xxe, "symbolTypeAnnotation");
  function Sxe() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  n(Sxe, "thisTypeAnnotation");
  function gxe(t) {
    return (0, R.default)({
      type: "TupleTypeAnnotation",
      types: t
    });
  }
  n(gxe, "tupleTypeAnnotation");
  function Pxe(t) {
    return (0, R.default)({
      type: "TypeofTypeAnnotation",
      argument: t
    });
  }
  n(Pxe, "typeofTypeAnnotation");
  function Exe(t, e = null, r) {
    return (0, R.default)({
      type: "TypeAlias",
      id: t,
      typeParameters: e,
      right: r
    });
  }
  n(Exe, "typeAlias");
  function Axe(t) {
    return (0, R.default)({
      type: "TypeAnnotation",
      typeAnnotation: t
    });
  }
  n(Axe, "typeAnnotation");
  function vxe(t, e) {
    return (0, R.default)({
      type: "TypeCastExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(vxe, "typeCastExpression");
  function Cxe(t = null, e = null, r = null) {
    return (0, R.default)({
      type: "TypeParameter",
      bound: t,
      default: e,
      variance: r,
      name: null
    });
  }
  n(Cxe, "typeParameter");
  function Ixe(t) {
    return (0, R.default)({
      type: "TypeParameterDeclaration",
      params: t
    });
  }
  n(Ixe, "typeParameterDeclaration");
  function wxe(t) {
    return (0, R.default)({
      type: "TypeParameterInstantiation",
      params: t
    });
  }
  n(wxe, "typeParameterInstantiation");
  function Nxe(t) {
    return (0, R.default)({
      type: "UnionTypeAnnotation",
      types: t
    });
  }
  n(Nxe, "unionTypeAnnotation");
  function Oxe(t) {
    return (0, R.default)({
      type: "Variance",
      kind: t
    });
  }
  n(Oxe, "variance");
  function kxe() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  n(kxe, "voidTypeAnnotation");
  function Dxe(t, e) {
    return (0, R.default)({
      type: "EnumDeclaration",
      id: t,
      body: e
    });
  }
  n(Dxe, "enumDeclaration");
  function _xe(t) {
    return (0, R.default)({
      type: "EnumBooleanBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(_xe, "enumBooleanBody");
  function Lxe(t) {
    return (0, R.default)({
      type: "EnumNumberBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(Lxe, "enumNumberBody");
  function Mxe(t) {
    return (0, R.default)({
      type: "EnumStringBody",
      members: t,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  n(Mxe, "enumStringBody");
  function Bxe(t) {
    return (0, R.default)({
      type: "EnumSymbolBody",
      members: t,
      hasUnknownMembers: null
    });
  }
  n(Bxe, "enumSymbolBody");
  function Fxe(t) {
    return (0, R.default)({
      type: "EnumBooleanMember",
      id: t,
      init: null
    });
  }
  n(Fxe, "enumBooleanMember");
  function jxe(t, e) {
    return (0, R.default)({
      type: "EnumNumberMember",
      id: t,
      init: e
    });
  }
  n(jxe, "enumNumberMember");
  function Rxe(t, e) {
    return (0, R.default)({
      type: "EnumStringMember",
      id: t,
      init: e
    });
  }
  n(Rxe, "enumStringMember");
  function Uxe(t) {
    return (0, R.default)({
      type: "EnumDefaultedMember",
      id: t
    });
  }
  n(Uxe, "enumDefaultedMember");
  function qxe(t, e) {
    return (0, R.default)({
      type: "IndexedAccessType",
      objectType: t,
      indexType: e
    });
  }
  n(qxe, "indexedAccessType");
  function Vxe(t, e) {
    return (0, R.default)({
      type: "OptionalIndexedAccessType",
      objectType: t,
      indexType: e,
      optional: null
    });
  }
  n(Vxe, "optionalIndexedAccessType");
  function Kxe(t, e = null) {
    return (0, R.default)({
      type: "JSXAttribute",
      name: t,
      value: e
    });
  }
  n(Kxe, "jsxAttribute");
  function Wxe(t) {
    return (0, R.default)({
      type: "JSXClosingElement",
      name: t
    });
  }
  n(Wxe, "jsxClosingElement");
  function Yxe(t, e = null, r, s = null) {
    return (0, R.default)({
      type: "JSXElement",
      openingElement: t,
      closingElement: e,
      children: r,
      selfClosing: s
    });
  }
  n(Yxe, "jsxElement");
  function Jxe() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  n(Jxe, "jsxEmptyExpression");
  function Xxe(t) {
    return (0, R.default)({
      type: "JSXExpressionContainer",
      expression: t
    });
  }
  n(Xxe, "jsxExpressionContainer");
  function $xe(t) {
    return (0, R.default)({
      type: "JSXSpreadChild",
      expression: t
    });
  }
  n($xe, "jsxSpreadChild");
  function Hxe(t) {
    return (0, R.default)({
      type: "JSXIdentifier",
      name: t
    });
  }
  n(Hxe, "jsxIdentifier");
  function zxe(t, e) {
    return (0, R.default)({
      type: "JSXMemberExpression",
      object: t,
      property: e
    });
  }
  n(zxe, "jsxMemberExpression");
  function Gxe(t, e) {
    return (0, R.default)({
      type: "JSXNamespacedName",
      namespace: t,
      name: e
    });
  }
  n(Gxe, "jsxNamespacedName");
  function Qxe(t, e, r = !1) {
    return (0, R.default)({
      type: "JSXOpeningElement",
      name: t,
      attributes: e,
      selfClosing: r
    });
  }
  n(Qxe, "jsxOpeningElement");
  function Zxe(t) {
    return (0, R.default)({
      type: "JSXSpreadAttribute",
      argument: t
    });
  }
  n(Zxe, "jsxSpreadAttribute");
  function eSe(t) {
    return (0, R.default)({
      type: "JSXText",
      value: t
    });
  }
  n(eSe, "jsxText");
  function tSe(t, e, r) {
    return (0, R.default)({
      type: "JSXFragment",
      openingFragment: t,
      closingFragment: e,
      children: r
    });
  }
  n(tSe, "jsxFragment");
  function rSe() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  n(rSe, "jsxOpeningFragment");
  function sSe() {
    return {
      type: "JSXClosingFragment"
    };
  }
  n(sSe, "jsxClosingFragment");
  function iSe() {
    return {
      type: "Noop"
    };
  }
  n(iSe, "noop");
  function nSe(t, e) {
    return (0, R.default)({
      type: "Placeholder",
      expectedNode: t,
      name: e
    });
  }
  n(nSe, "placeholder");
  function aSe(t) {
    return (0, R.default)({
      type: "V8IntrinsicIdentifier",
      name: t
    });
  }
  n(aSe, "v8IntrinsicIdentifier");
  function oSe() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  n(oSe, "argumentPlaceholder");
  function lSe(t, e) {
    return (0, R.default)({
      type: "BindExpression",
      object: t,
      callee: e
    });
  }
  n(lSe, "bindExpression");
  function uSe(t, e) {
    return (0, R.default)({
      type: "ImportAttribute",
      key: t,
      value: e
    });
  }
  n(uSe, "importAttribute");
  function cSe(t) {
    return (0, R.default)({
      type: "Decorator",
      expression: t
    });
  }
  n(cSe, "decorator");
  function pSe(t, e = !1) {
    return (0, R.default)({
      type: "DoExpression",
      body: t,
      async: e
    });
  }
  n(pSe, "doExpression");
  function fSe(t) {
    return (0, R.default)({
      type: "ExportDefaultSpecifier",
      exported: t
    });
  }
  n(fSe, "exportDefaultSpecifier");
  function hSe(t) {
    return (0, R.default)({
      type: "RecordExpression",
      properties: t
    });
  }
  n(hSe, "recordExpression");
  function dSe(t = []) {
    return (0, R.default)({
      type: "TupleExpression",
      elements: t
    });
  }
  n(dSe, "tupleExpression");
  function mSe(t) {
    return (0, R.default)({
      type: "DecimalLiteral",
      value: t
    });
  }
  n(mSe, "decimalLiteral");
  function ySe(t) {
    return (0, R.default)({
      type: "ModuleExpression",
      body: t
    });
  }
  n(ySe, "moduleExpression");
  function TSe() {
    return {
      type: "TopicReference"
    };
  }
  n(TSe, "topicReference");
  function bSe(t) {
    return (0, R.default)({
      type: "PipelineTopicExpression",
      expression: t
    });
  }
  n(bSe, "pipelineTopicExpression");
  function xSe(t) {
    return (0, R.default)({
      type: "PipelineBareFunction",
      callee: t
    });
  }
  n(xSe, "pipelineBareFunction");
  function SSe() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  n(SSe, "pipelinePrimaryTopicReference");
  function gSe(t) {
    return (0, R.default)({
      type: "TSParameterProperty",
      parameter: t
    });
  }
  n(gSe, "tsParameterProperty");
  function PSe(t = null, e = null, r, s = null) {
    return (0, R.default)({
      type: "TSDeclareFunction",
      id: t,
      typeParameters: e,
      params: r,
      returnType: s
    });
  }
  n(PSe, "tsDeclareFunction");
  function ESe(t = null, e, r = null, s, i = null) {
    return (0, R.default)({
      type: "TSDeclareMethod",
      decorators: t,
      key: e,
      typeParameters: r,
      params: s,
      returnType: i
    });
  }
  n(ESe, "tsDeclareMethod");
  function ASe(t, e) {
    return (0, R.default)({
      type: "TSQualifiedName",
      left: t,
      right: e
    });
  }
  n(ASe, "tsQualifiedName");
  function vSe(t = null, e, r = null) {
    return (0, R.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(vSe, "tsCallSignatureDeclaration");
  function CSe(t = null, e, r = null) {
    return (0, R.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(CSe, "tsConstructSignatureDeclaration");
  function ISe(t, e = null) {
    return (0, R.default)({
      type: "TSPropertySignature",
      key: t,
      typeAnnotation: e,
      kind: null
    });
  }
  n(ISe, "tsPropertySignature");
  function wSe(t, e = null, r, s = null) {
    return (0, R.default)({
      type: "TSMethodSignature",
      key: t,
      typeParameters: e,
      parameters: r,
      typeAnnotation: s,
      kind: null
    });
  }
  n(wSe, "tsMethodSignature");
  function NSe(t, e = null) {
    return (0, R.default)({
      type: "TSIndexSignature",
      parameters: t,
      typeAnnotation: e
    });
  }
  n(NSe, "tsIndexSignature");
  function OSe() {
    return {
      type: "TSAnyKeyword"
    };
  }
  n(OSe, "tsAnyKeyword");
  function kSe() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  n(kSe, "tsBooleanKeyword");
  function DSe() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  n(DSe, "tsBigIntKeyword");
  function _Se() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  n(_Se, "tsIntrinsicKeyword");
  function LSe() {
    return {
      type: "TSNeverKeyword"
    };
  }
  n(LSe, "tsNeverKeyword");
  function MSe() {
    return {
      type: "TSNullKeyword"
    };
  }
  n(MSe, "tsNullKeyword");
  function BSe() {
    return {
      type: "TSNumberKeyword"
    };
  }
  n(BSe, "tsNumberKeyword");
  function FSe() {
    return {
      type: "TSObjectKeyword"
    };
  }
  n(FSe, "tsObjectKeyword");
  function jSe() {
    return {
      type: "TSStringKeyword"
    };
  }
  n(jSe, "tsStringKeyword");
  function RSe() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  n(RSe, "tsSymbolKeyword");
  function USe() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  n(USe, "tsUndefinedKeyword");
  function qSe() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  n(qSe, "tsUnknownKeyword");
  function VSe() {
    return {
      type: "TSVoidKeyword"
    };
  }
  n(VSe, "tsVoidKeyword");
  function KSe() {
    return {
      type: "TSThisType"
    };
  }
  n(KSe, "tsThisType");
  function WSe(t = null, e, r = null) {
    return (0, R.default)({
      type: "TSFunctionType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(WSe, "tsFunctionType");
  function YSe(t = null, e, r = null) {
    return (0, R.default)({
      type: "TSConstructorType",
      typeParameters: t,
      parameters: e,
      typeAnnotation: r
    });
  }
  n(YSe, "tsConstructorType");
  function JSe(t, e = null) {
    return (0, R.default)({
      type: "TSTypeReference",
      typeName: t,
      typeParameters: e
    });
  }
  n(JSe, "tsTypeReference");
  function XSe(t, e = null, r = null) {
    return (0, R.default)({
      type: "TSTypePredicate",
      parameterName: t,
      typeAnnotation: e,
      asserts: r
    });
  }
  n(XSe, "tsTypePredicate");
  function $Se(t, e = null) {
    return (0, R.default)({
      type: "TSTypeQuery",
      exprName: t,
      typeParameters: e
    });
  }
  n($Se, "tsTypeQuery");
  function HSe(t) {
    return (0, R.default)({
      type: "TSTypeLiteral",
      members: t
    });
  }
  n(HSe, "tsTypeLiteral");
  function zSe(t) {
    return (0, R.default)({
      type: "TSArrayType",
      elementType: t
    });
  }
  n(zSe, "tsArrayType");
  function GSe(t) {
    return (0, R.default)({
      type: "TSTupleType",
      elementTypes: t
    });
  }
  n(GSe, "tsTupleType");
  function QSe(t) {
    return (0, R.default)({
      type: "TSOptionalType",
      typeAnnotation: t
    });
  }
  n(QSe, "tsOptionalType");
  function ZSe(t) {
    return (0, R.default)({
      type: "TSRestType",
      typeAnnotation: t
    });
  }
  n(ZSe, "tsRestType");
  function ege(t, e, r = !1) {
    return (0, R.default)({
      type: "TSNamedTupleMember",
      label: t,
      elementType: e,
      optional: r
    });
  }
  n(ege, "tsNamedTupleMember");
  function tge(t) {
    return (0, R.default)({
      type: "TSUnionType",
      types: t
    });
  }
  n(tge, "tsUnionType");
  function rge(t) {
    return (0, R.default)({
      type: "TSIntersectionType",
      types: t
    });
  }
  n(rge, "tsIntersectionType");
  function sge(t, e, r, s) {
    return (0, R.default)({
      type: "TSConditionalType",
      checkType: t,
      extendsType: e,
      trueType: r,
      falseType: s
    });
  }
  n(sge, "tsConditionalType");
  function ige(t) {
    return (0, R.default)({
      type: "TSInferType",
      typeParameter: t
    });
  }
  n(ige, "tsInferType");
  function nge(t) {
    return (0, R.default)({
      type: "TSParenthesizedType",
      typeAnnotation: t
    });
  }
  n(nge, "tsParenthesizedType");
  function age(t) {
    return (0, R.default)({
      type: "TSTypeOperator",
      typeAnnotation: t,
      operator: null
    });
  }
  n(age, "tsTypeOperator");
  function oge(t, e) {
    return (0, R.default)({
      type: "TSIndexedAccessType",
      objectType: t,
      indexType: e
    });
  }
  n(oge, "tsIndexedAccessType");
  function lge(t, e = null, r = null) {
    return (0, R.default)({
      type: "TSMappedType",
      typeParameter: t,
      typeAnnotation: e,
      nameType: r
    });
  }
  n(lge, "tsMappedType");
  function uge(t) {
    return (0, R.default)({
      type: "TSLiteralType",
      literal: t
    });
  }
  n(uge, "tsLiteralType");
  function cge(t, e = null) {
    return (0, R.default)({
      type: "TSExpressionWithTypeArguments",
      expression: t,
      typeParameters: e
    });
  }
  n(cge, "tsExpressionWithTypeArguments");
  function pge(t, e = null, r = null, s) {
    return (0, R.default)({
      type: "TSInterfaceDeclaration",
      id: t,
      typeParameters: e,
      extends: r,
      body: s
    });
  }
  n(pge, "tsInterfaceDeclaration");
  function fge(t) {
    return (0, R.default)({
      type: "TSInterfaceBody",
      body: t
    });
  }
  n(fge, "tsInterfaceBody");
  function hge(t, e = null, r) {
    return (0, R.default)({
      type: "TSTypeAliasDeclaration",
      id: t,
      typeParameters: e,
      typeAnnotation: r
    });
  }
  n(hge, "tsTypeAliasDeclaration");
  function dge(t, e = null) {
    return (0, R.default)({
      type: "TSInstantiationExpression",
      expression: t,
      typeParameters: e
    });
  }
  n(dge, "tsInstantiationExpression");
  function mge(t, e) {
    return (0, R.default)({
      type: "TSAsExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(mge, "tsAsExpression");
  function yge(t, e) {
    return (0, R.default)({
      type: "TSSatisfiesExpression",
      expression: t,
      typeAnnotation: e
    });
  }
  n(yge, "tsSatisfiesExpression");
  function Tge(t, e) {
    return (0, R.default)({
      type: "TSTypeAssertion",
      typeAnnotation: t,
      expression: e
    });
  }
  n(Tge, "tsTypeAssertion");
  function bge(t, e) {
    return (0, R.default)({
      type: "TSEnumDeclaration",
      id: t,
      members: e
    });
  }
  n(bge, "tsEnumDeclaration");
  function xge(t, e = null) {
    return (0, R.default)({
      type: "TSEnumMember",
      id: t,
      initializer: e
    });
  }
  n(xge, "tsEnumMember");
  function Sge(t, e) {
    return (0, R.default)({
      type: "TSModuleDeclaration",
      id: t,
      body: e
    });
  }
  n(Sge, "tsModuleDeclaration");
  function gge(t) {
    return (0, R.default)({
      type: "TSModuleBlock",
      body: t
    });
  }
  n(gge, "tsModuleBlock");
  function Pge(t, e = null, r = null) {
    return (0, R.default)({
      type: "TSImportType",
      argument: t,
      qualifier: e,
      typeParameters: r
    });
  }
  n(Pge, "tsImportType");
  function Ege(t, e) {
    return (0, R.default)({
      type: "TSImportEqualsDeclaration",
      id: t,
      moduleReference: e,
      isExport: null
    });
  }
  n(Ege, "tsImportEqualsDeclaration");
  function Age(t) {
    return (0, R.default)({
      type: "TSExternalModuleReference",
      expression: t
    });
  }
  n(Age, "tsExternalModuleReference");
  function vge(t) {
    return (0, R.default)({
      type: "TSNonNullExpression",
      expression: t
    });
  }
  n(vge, "tsNonNullExpression");
  function Cge(t) {
    return (0, R.default)({
      type: "TSExportAssignment",
      expression: t
    });
  }
  n(Cge, "tsExportAssignment");
  function Ige(t) {
    return (0, R.default)({
      type: "TSNamespaceExportDeclaration",
      id: t
    });
  }
  n(Ige, "tsNamespaceExportDeclaration");
  function wge(t) {
    return (0, R.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: t
    });
  }
  n(wge, "tsTypeAnnotation");
  function Nge(t) {
    return (0, R.default)({
      type: "TSTypeParameterInstantiation",
      params: t
    });
  }
  n(Nge, "tsTypeParameterInstantiation");
  function Oge(t) {
    return (0, R.default)({
      type: "TSTypeParameterDeclaration",
      params: t
    });
  }
  n(Oge, "tsTypeParameterDeclaration");
  function kge(t = null, e = null, r) {
    return (0, R.default)({
      type: "TSTypeParameter",
      constraint: t,
      default: e,
      name: r
    });
  }
  n(kge, "tsTypeParameter");
  function Dge(t) {
    return (0, yc.default)("NumberLiteral", "NumericLiteral", "The node type "), ZC(t);
  }
  n(Dge, "NumberLiteral");
  function _ge(t, e = "") {
    return (0, yc.default)("RegexLiteral", "RegExpLiteral", "The node type "), eI(t, e);
  }
  n(_ge, "RegexLiteral");
  function Lge(t) {
    return (0, yc.default)("RestProperty", "RestElement", "The node type "), tI(t);
  }
  n(Lge, "RestProperty");
  function Mge(t) {
    return (0, yc.default)("SpreadProperty", "SpreadElement", "The node type "), rI(t);
  }
  n(Mge, "SpreadProperty");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var sI = w((sT) => {
  "use strict";
  Object.defineProperty(sT, "__esModule", {
    value: !0
  });
  sT.default = jge;
  var Bge = Ar(), Fge = Oo();
  function jge(t, e) {
    let r = t.value.split(/\r\n|\n|\r/), s = 0;
    for (let a = 0; a < r.length; a++)
      r[a].match(/[^ \t]/) && (s = a);
    let i = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === s, p = o.replace(/\t/g, " ");
      l || (p = p.replace(/^[ ]+/, "")), u || (p = p.replace(/[ ]+$/, "")), p && (c || (p += " "), i += p);
    }
    i && e.push((0, Fge.inherits)((0, Bge.stringLiteral)(i), t));
  }
  n(jge, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/react/buildChildren.js
var iI = w((nT) => {
  "use strict";
  Object.defineProperty(nT, "__esModule", {
    value: !0
  });
  nT.default = Uge;
  var iT = Rt(), Rge = sI();
  function Uge(t) {
    let e = [];
    for (let r = 0; r < t.children.length; r++) {
      let s = t.children[r];
      if ((0, iT.isJSXText)(s)) {
        (0, Rge.default)(s, e);
        continue;
      }
      (0, iT.isJSXExpressionContainer)(s) && (s = s.expression), !(0, iT.isJSXEmptyExpression)(s) && e.push(s);
    }
    return e;
  }
  n(Uge, "buildChildren");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isNode.js
var oT = w((aT) => {
  "use strict";
  Object.defineProperty(aT, "__esModule", {
    value: !0
  });
  aT.default = Vge;
  var qge = Vr();
  function Vge(t) {
    return !!(t && qge.VISITOR_KEYS[t.type]);
  }
  n(Vge, "isNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/asserts/assertNode.js
var nI = w((lT) => {
  "use strict";
  Object.defineProperty(lT, "__esModule", {
    value: !0
  });
  lT.default = Wge;
  var Kge = oT();
  function Wge(t) {
    if (!(0, Kge.default)(t)) {
      var e;
      let r = (e = t?.type) != null ? e : JSON.stringify(t);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  n(Wge, "assertNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/asserts/generated/index.js
var aI = w((E) => {
  "use strict";
  Object.defineProperty(E, "__esModule", {
    value: !0
  });
  E.assertAccessor = aCe;
  E.assertAnyTypeAnnotation = CEe;
  E.assertArgumentPlaceholder = t1e;
  E.assertArrayExpression = Jge;
  E.assertArrayPattern = WPe;
  E.assertArrayTypeAnnotation = IEe;
  E.assertArrowFunctionExpression = YPe;
  E.assertAssignmentExpression = Xge;
  E.assertAssignmentPattern = KPe;
  E.assertAwaitExpression = dEe;
  E.assertBigIntLiteral = yEe;
  E.assertBinary = wve;
  E.assertBinaryExpression = $ge;
  E.assertBindExpression = r1e;
  E.assertBlock = kve;
  E.assertBlockParent = Ove;
  E.assertBlockStatement = Qge;
  E.assertBooleanLiteral = xPe;
  E.assertBooleanLiteralTypeAnnotation = NEe;
  E.assertBooleanTypeAnnotation = wEe;
  E.assertBreakStatement = Zge;
  E.assertCallExpression = ePe;
  E.assertCatchClause = tPe;
  E.assertClass = rCe;
  E.assertClassAccessorProperty = gEe;
  E.assertClassBody = JPe;
  E.assertClassDeclaration = $Pe;
  E.assertClassExpression = XPe;
  E.assertClassImplements = kEe;
  E.assertClassMethod = aEe;
  E.assertClassPrivateMethod = EEe;
  E.assertClassPrivateProperty = PEe;
  E.assertClassProperty = SEe;
  E.assertCompletionStatement = Lve;
  E.assertConditional = Mve;
  E.assertConditionalExpression = rPe;
  E.assertContinueStatement = sPe;
  E.assertDebuggerStatement = iPe;
  E.assertDecimalLiteral = u1e;
  E.assertDeclaration = Wve;
  E.assertDeclareClass = DEe;
  E.assertDeclareExportAllDeclaration = qEe;
  E.assertDeclareExportDeclaration = UEe;
  E.assertDeclareFunction = _Ee;
  E.assertDeclareInterface = LEe;
  E.assertDeclareModule = MEe;
  E.assertDeclareModuleExports = BEe;
  E.assertDeclareOpaqueType = jEe;
  E.assertDeclareTypeAlias = FEe;
  E.assertDeclareVariable = REe;
  E.assertDeclaredPredicate = VEe;
  E.assertDecorator = i1e;
  E.assertDirective = zge;
  E.assertDirectiveLiteral = Gge;
  E.assertDoExpression = n1e;
  E.assertDoWhileStatement = nPe;
  E.assertEmptyStatement = aPe;
  E.assertEmptyTypeAnnotation = ZEe;
  E.assertEnumBody = hCe;
  E.assertEnumBooleanBody = IAe;
  E.assertEnumBooleanMember = kAe;
  E.assertEnumDeclaration = CAe;
  E.assertEnumDefaultedMember = LAe;
  E.assertEnumMember = dCe;
  E.assertEnumNumberBody = wAe;
  E.assertEnumNumberMember = DAe;
  E.assertEnumStringBody = NAe;
  E.assertEnumStringMember = _Ae;
  E.assertEnumSymbolBody = OAe;
  E.assertExistsTypeAnnotation = KEe;
  E.assertExportAllDeclaration = HPe;
  E.assertExportDeclaration = iCe;
  E.assertExportDefaultDeclaration = zPe;
  E.assertExportDefaultSpecifier = a1e;
  E.assertExportNamedDeclaration = GPe;
  E.assertExportNamespaceSpecifier = TEe;
  E.assertExportSpecifier = QPe;
  E.assertExpression = Ive;
  E.assertExpressionStatement = oPe;
  E.assertExpressionWrapper = jve;
  E.assertFile = lPe;
  E.assertFlow = lCe;
  E.assertFlowBaseAnnotation = cCe;
  E.assertFlowDeclaration = pCe;
  E.assertFlowPredicate = fCe;
  E.assertFlowType = uCe;
  E.assertFor = Rve;
  E.assertForInStatement = uPe;
  E.assertForOfStatement = ZPe;
  E.assertForStatement = cPe;
  E.assertForXStatement = Uve;
  E.assertFunction = qve;
  E.assertFunctionDeclaration = pPe;
  E.assertFunctionExpression = fPe;
  E.assertFunctionParent = Vve;
  E.assertFunctionTypeAnnotation = WEe;
  E.assertFunctionTypeParam = YEe;
  E.assertGenericTypeAnnotation = JEe;
  E.assertIdentifier = hPe;
  E.assertIfStatement = dPe;
  E.assertImmutable = Hve;
  E.assertImport = mEe;
  E.assertImportAttribute = s1e;
  E.assertImportDeclaration = eEe;
  E.assertImportDefaultSpecifier = tEe;
  E.assertImportExpression = iEe;
  E.assertImportNamespaceSpecifier = rEe;
  E.assertImportOrExportDeclaration = sCe;
  E.assertImportSpecifier = sEe;
  E.assertIndexedAccessType = MAe;
  E.assertInferredPredicate = XEe;
  E.assertInterfaceDeclaration = HEe;
  E.assertInterfaceExtends = $Ee;
  E.assertInterfaceTypeAnnotation = zEe;
  E.assertInterpreterDirective = Hge;
  E.assertIntersectionTypeAnnotation = GEe;
  E.assertJSX = mCe;
  E.assertJSXAttribute = FAe;
  E.assertJSXClosingElement = jAe;
  E.assertJSXClosingFragment = GAe;
  E.assertJSXElement = RAe;
  E.assertJSXEmptyExpression = UAe;
  E.assertJSXExpressionContainer = qAe;
  E.assertJSXFragment = HAe;
  E.assertJSXIdentifier = KAe;
  E.assertJSXMemberExpression = WAe;
  E.assertJSXNamespacedName = YAe;
  E.assertJSXOpeningElement = JAe;
  E.assertJSXOpeningFragment = zAe;
  E.assertJSXSpreadAttribute = XAe;
  E.assertJSXSpreadChild = VAe;
  E.assertJSXText = $Ae;
  E.assertLVal = Jve;
  E.assertLabeledStatement = mPe;
  E.assertLiteral = $ve;
  E.assertLogicalExpression = gPe;
  E.assertLoop = Bve;
  E.assertMemberExpression = PPe;
  E.assertMetaProperty = nEe;
  E.assertMethod = Gve;
  E.assertMiscellaneous = yCe;
  E.assertMixedTypeAnnotation = QEe;
  E.assertModuleDeclaration = vCe;
  E.assertModuleExpression = c1e;
  E.assertModuleSpecifier = nCe;
  E.assertNewExpression = EPe;
  E.assertNoop = QAe;
  E.assertNullLiteral = bPe;
  E.assertNullLiteralTypeAnnotation = OEe;
  E.assertNullableTypeAnnotation = eAe;
  E.assertNumberLiteral = gCe;
  E.assertNumberLiteralTypeAnnotation = tAe;
  E.assertNumberTypeAnnotation = rAe;
  E.assertNumericLiteral = TPe;
  E.assertObjectExpression = vPe;
  E.assertObjectMember = Qve;
  E.assertObjectMethod = CPe;
  E.assertObjectPattern = oEe;
  E.assertObjectProperty = IPe;
  E.assertObjectTypeAnnotation = sAe;
  E.assertObjectTypeCallProperty = nAe;
  E.assertObjectTypeIndexer = aAe;
  E.assertObjectTypeInternalSlot = iAe;
  E.assertObjectTypeProperty = oAe;
  E.assertObjectTypeSpreadProperty = lAe;
  E.assertOpaqueType = uAe;
  E.assertOptionalCallExpression = xEe;
  E.assertOptionalIndexedAccessType = BAe;
  E.assertOptionalMemberExpression = bEe;
  E.assertParenthesizedExpression = kPe;
  E.assertPattern = tCe;
  E.assertPatternLike = Yve;
  E.assertPipelineBareFunction = h1e;
  E.assertPipelinePrimaryTopicReference = d1e;
  E.assertPipelineTopicExpression = f1e;
  E.assertPlaceholder = ZAe;
  E.assertPrivate = oCe;
  E.assertPrivateName = AEe;
  E.assertProgram = APe;
  E.assertProperty = Zve;
  E.assertPureish = Kve;
  E.assertQualifiedTypeIdentifier = cAe;
  E.assertRecordExpression = o1e;
  E.assertRegExpLiteral = SPe;
  E.assertRegexLiteral = PCe;
  E.assertRestElement = wPe;
  E.assertRestProperty = ECe;
  E.assertReturnStatement = NPe;
  E.assertScopable = Nve;
  E.assertSequenceExpression = OPe;
  E.assertSpreadElement = lEe;
  E.assertSpreadProperty = ACe;
  E.assertStandardized = Cve;
  E.assertStatement = Dve;
  E.assertStaticBlock = vEe;
  E.assertStringLiteral = yPe;
  E.assertStringLiteralTypeAnnotation = pAe;
  E.assertStringTypeAnnotation = fAe;
  E.assertSuper = uEe;
  E.assertSwitchCase = DPe;
  E.assertSwitchStatement = _Pe;
  E.assertSymbolTypeAnnotation = hAe;
  E.assertTSAnyKeyword = A1e;
  E.assertTSArrayType = W1e;
  E.assertTSAsExpression = uve;
  E.assertTSBaseType = SCe;
  E.assertTSBigIntKeyword = C1e;
  E.assertTSBooleanKeyword = v1e;
  E.assertTSCallSignatureDeclaration = x1e;
  E.assertTSConditionalType = G1e;
  E.assertTSConstructSignatureDeclaration = S1e;
  E.assertTSConstructorType = R1e;
  E.assertTSDeclareFunction = y1e;
  E.assertTSDeclareMethod = T1e;
  E.assertTSEntityName = Xve;
  E.assertTSEnumDeclaration = fve;
  E.assertTSEnumMember = hve;
  E.assertTSExportAssignment = Sve;
  E.assertTSExpressionWithTypeArguments = ive;
  E.assertTSExternalModuleReference = bve;
  E.assertTSFunctionType = j1e;
  E.assertTSImportEqualsDeclaration = Tve;
  E.assertTSImportType = yve;
  E.assertTSIndexSignature = E1e;
  E.assertTSIndexedAccessType = tve;
  E.assertTSInferType = Q1e;
  E.assertTSInstantiationExpression = lve;
  E.assertTSInterfaceBody = ave;
  E.assertTSInterfaceDeclaration = nve;
  E.assertTSIntersectionType = z1e;
  E.assertTSIntrinsicKeyword = I1e;
  E.assertTSLiteralType = sve;
  E.assertTSMappedType = rve;
  E.assertTSMethodSignature = P1e;
  E.assertTSModuleBlock = mve;
  E.assertTSModuleDeclaration = dve;
  E.assertTSNamedTupleMember = $1e;
  E.assertTSNamespaceExportDeclaration = gve;
  E.assertTSNeverKeyword = w1e;
  E.assertTSNonNullExpression = xve;
  E.assertTSNullKeyword = N1e;
  E.assertTSNumberKeyword = O1e;
  E.assertTSObjectKeyword = k1e;
  E.assertTSOptionalType = J1e;
  E.assertTSParameterProperty = m1e;
  E.assertTSParenthesizedType = Z1e;
  E.assertTSPropertySignature = g1e;
  E.assertTSQualifiedName = b1e;
  E.assertTSRestType = X1e;
  E.assertTSSatisfiesExpression = cve;
  E.assertTSStringKeyword = D1e;
  E.assertTSSymbolKeyword = _1e;
  E.assertTSThisType = F1e;
  E.assertTSTupleType = Y1e;
  E.assertTSType = xCe;
  E.assertTSTypeAliasDeclaration = ove;
  E.assertTSTypeAnnotation = Pve;
  E.assertTSTypeAssertion = pve;
  E.assertTSTypeElement = bCe;
  E.assertTSTypeLiteral = K1e;
  E.assertTSTypeOperator = eve;
  E.assertTSTypeParameter = vve;
  E.assertTSTypeParameterDeclaration = Ave;
  E.assertTSTypeParameterInstantiation = Eve;
  E.assertTSTypePredicate = q1e;
  E.assertTSTypeQuery = V1e;
  E.assertTSTypeReference = U1e;
  E.assertTSUndefinedKeyword = L1e;
  E.assertTSUnionType = H1e;
  E.assertTSUnknownKeyword = M1e;
  E.assertTSVoidKeyword = B1e;
  E.assertTaggedTemplateExpression = cEe;
  E.assertTemplateElement = pEe;
  E.assertTemplateLiteral = fEe;
  E.assertTerminatorless = _ve;
  E.assertThisExpression = LPe;
  E.assertThisTypeAnnotation = dAe;
  E.assertThrowStatement = MPe;
  E.assertTopicReference = p1e;
  E.assertTryStatement = BPe;
  E.assertTupleExpression = l1e;
  E.assertTupleTypeAnnotation = mAe;
  E.assertTypeAlias = TAe;
  E.assertTypeAnnotation = bAe;
  E.assertTypeCastExpression = xAe;
  E.assertTypeParameter = SAe;
  E.assertTypeParameterDeclaration = gAe;
  E.assertTypeParameterInstantiation = PAe;
  E.assertTypeScript = TCe;
  E.assertTypeofTypeAnnotation = yAe;
  E.assertUnaryExpression = FPe;
  E.assertUnaryLike = eCe;
  E.assertUnionTypeAnnotation = EAe;
  E.assertUpdateExpression = jPe;
  E.assertUserWhitespacable = zve;
  E.assertV8IntrinsicIdentifier = e1e;
  E.assertVariableDeclaration = RPe;
  E.assertVariableDeclarator = UPe;
  E.assertVariance = AAe;
  E.assertVoidTypeAnnotation = vAe;
  E.assertWhile = Fve;
  E.assertWhileStatement = qPe;
  E.assertWithStatement = VPe;
  E.assertYieldExpression = hEe;
  var Yge = Yn(), ko = Eo();
  function v(t, e, r) {
    if (!(0, Yge.default)(t, e, r))
      throw new Error(`Expected type "${t}" with option ${JSON.stringify(r)}, but instead got "${e.type}".`);
  }
  n(v, "assert");
  function Jge(t, e) {
    v("ArrayExpression", t, e);
  }
  n(Jge, "assertArrayExpression");
  function Xge(t, e) {
    v("AssignmentExpression", t, e);
  }
  n(Xge, "assertAssignmentExpression");
  function $ge(t, e) {
    v("BinaryExpression", t, e);
  }
  n($ge, "assertBinaryExpression");
  function Hge(t, e) {
    v("InterpreterDirective", t, e);
  }
  n(Hge, "assertInterpreterDirective");
  function zge(t, e) {
    v("Directive", t, e);
  }
  n(zge, "assertDirective");
  function Gge(t, e) {
    v("DirectiveLiteral", t, e);
  }
  n(Gge, "assertDirectiveLiteral");
  function Qge(t, e) {
    v("BlockStatement", t, e);
  }
  n(Qge, "assertBlockStatement");
  function Zge(t, e) {
    v("BreakStatement", t, e);
  }
  n(Zge, "assertBreakStatement");
  function ePe(t, e) {
    v("CallExpression", t, e);
  }
  n(ePe, "assertCallExpression");
  function tPe(t, e) {
    v("CatchClause", t, e);
  }
  n(tPe, "assertCatchClause");
  function rPe(t, e) {
    v("ConditionalExpression", t, e);
  }
  n(rPe, "assertConditionalExpression");
  function sPe(t, e) {
    v("ContinueStatement", t, e);
  }
  n(sPe, "assertContinueStatement");
  function iPe(t, e) {
    v("DebuggerStatement", t, e);
  }
  n(iPe, "assertDebuggerStatement");
  function nPe(t, e) {
    v("DoWhileStatement", t, e);
  }
  n(nPe, "assertDoWhileStatement");
  function aPe(t, e) {
    v("EmptyStatement", t, e);
  }
  n(aPe, "assertEmptyStatement");
  function oPe(t, e) {
    v("ExpressionStatement", t, e);
  }
  n(oPe, "assertExpressionStatement");
  function lPe(t, e) {
    v("File", t, e);
  }
  n(lPe, "assertFile");
  function uPe(t, e) {
    v("ForInStatement", t, e);
  }
  n(uPe, "assertForInStatement");
  function cPe(t, e) {
    v("ForStatement", t, e);
  }
  n(cPe, "assertForStatement");
  function pPe(t, e) {
    v("FunctionDeclaration", t, e);
  }
  n(pPe, "assertFunctionDeclaration");
  function fPe(t, e) {
    v("FunctionExpression", t, e);
  }
  n(fPe, "assertFunctionExpression");
  function hPe(t, e) {
    v("Identifier", t, e);
  }
  n(hPe, "assertIdentifier");
  function dPe(t, e) {
    v("IfStatement", t, e);
  }
  n(dPe, "assertIfStatement");
  function mPe(t, e) {
    v("LabeledStatement", t, e);
  }
  n(mPe, "assertLabeledStatement");
  function yPe(t, e) {
    v("StringLiteral", t, e);
  }
  n(yPe, "assertStringLiteral");
  function TPe(t, e) {
    v("NumericLiteral", t, e);
  }
  n(TPe, "assertNumericLiteral");
  function bPe(t, e) {
    v("NullLiteral", t, e);
  }
  n(bPe, "assertNullLiteral");
  function xPe(t, e) {
    v("BooleanLiteral", t, e);
  }
  n(xPe, "assertBooleanLiteral");
  function SPe(t, e) {
    v("RegExpLiteral", t, e);
  }
  n(SPe, "assertRegExpLiteral");
  function gPe(t, e) {
    v("LogicalExpression", t, e);
  }
  n(gPe, "assertLogicalExpression");
  function PPe(t, e) {
    v("MemberExpression", t, e);
  }
  n(PPe, "assertMemberExpression");
  function EPe(t, e) {
    v("NewExpression", t, e);
  }
  n(EPe, "assertNewExpression");
  function APe(t, e) {
    v("Program", t, e);
  }
  n(APe, "assertProgram");
  function vPe(t, e) {
    v("ObjectExpression", t, e);
  }
  n(vPe, "assertObjectExpression");
  function CPe(t, e) {
    v("ObjectMethod", t, e);
  }
  n(CPe, "assertObjectMethod");
  function IPe(t, e) {
    v("ObjectProperty", t, e);
  }
  n(IPe, "assertObjectProperty");
  function wPe(t, e) {
    v("RestElement", t, e);
  }
  n(wPe, "assertRestElement");
  function NPe(t, e) {
    v("ReturnStatement", t, e);
  }
  n(NPe, "assertReturnStatement");
  function OPe(t, e) {
    v("SequenceExpression", t, e);
  }
  n(OPe, "assertSequenceExpression");
  function kPe(t, e) {
    v("ParenthesizedExpression", t, e);
  }
  n(kPe, "assertParenthesizedExpression");
  function DPe(t, e) {
    v("SwitchCase", t, e);
  }
  n(DPe, "assertSwitchCase");
  function _Pe(t, e) {
    v("SwitchStatement", t, e);
  }
  n(_Pe, "assertSwitchStatement");
  function LPe(t, e) {
    v("ThisExpression", t, e);
  }
  n(LPe, "assertThisExpression");
  function MPe(t, e) {
    v("ThrowStatement", t, e);
  }
  n(MPe, "assertThrowStatement");
  function BPe(t, e) {
    v("TryStatement", t, e);
  }
  n(BPe, "assertTryStatement");
  function FPe(t, e) {
    v("UnaryExpression", t, e);
  }
  n(FPe, "assertUnaryExpression");
  function jPe(t, e) {
    v("UpdateExpression", t, e);
  }
  n(jPe, "assertUpdateExpression");
  function RPe(t, e) {
    v("VariableDeclaration", t, e);
  }
  n(RPe, "assertVariableDeclaration");
  function UPe(t, e) {
    v("VariableDeclarator", t, e);
  }
  n(UPe, "assertVariableDeclarator");
  function qPe(t, e) {
    v("WhileStatement", t, e);
  }
  n(qPe, "assertWhileStatement");
  function VPe(t, e) {
    v("WithStatement", t, e);
  }
  n(VPe, "assertWithStatement");
  function KPe(t, e) {
    v("AssignmentPattern", t, e);
  }
  n(KPe, "assertAssignmentPattern");
  function WPe(t, e) {
    v("ArrayPattern", t, e);
  }
  n(WPe, "assertArrayPattern");
  function YPe(t, e) {
    v("ArrowFunctionExpression", t, e);
  }
  n(YPe, "assertArrowFunctionExpression");
  function JPe(t, e) {
    v("ClassBody", t, e);
  }
  n(JPe, "assertClassBody");
  function XPe(t, e) {
    v("ClassExpression", t, e);
  }
  n(XPe, "assertClassExpression");
  function $Pe(t, e) {
    v("ClassDeclaration", t, e);
  }
  n($Pe, "assertClassDeclaration");
  function HPe(t, e) {
    v("ExportAllDeclaration", t, e);
  }
  n(HPe, "assertExportAllDeclaration");
  function zPe(t, e) {
    v("ExportDefaultDeclaration", t, e);
  }
  n(zPe, "assertExportDefaultDeclaration");
  function GPe(t, e) {
    v("ExportNamedDeclaration", t, e);
  }
  n(GPe, "assertExportNamedDeclaration");
  function QPe(t, e) {
    v("ExportSpecifier", t, e);
  }
  n(QPe, "assertExportSpecifier");
  function ZPe(t, e) {
    v("ForOfStatement", t, e);
  }
  n(ZPe, "assertForOfStatement");
  function eEe(t, e) {
    v("ImportDeclaration", t, e);
  }
  n(eEe, "assertImportDeclaration");
  function tEe(t, e) {
    v("ImportDefaultSpecifier", t, e);
  }
  n(tEe, "assertImportDefaultSpecifier");
  function rEe(t, e) {
    v("ImportNamespaceSpecifier", t, e);
  }
  n(rEe, "assertImportNamespaceSpecifier");
  function sEe(t, e) {
    v("ImportSpecifier", t, e);
  }
  n(sEe, "assertImportSpecifier");
  function iEe(t, e) {
    v("ImportExpression", t, e);
  }
  n(iEe, "assertImportExpression");
  function nEe(t, e) {
    v("MetaProperty", t, e);
  }
  n(nEe, "assertMetaProperty");
  function aEe(t, e) {
    v("ClassMethod", t, e);
  }
  n(aEe, "assertClassMethod");
  function oEe(t, e) {
    v("ObjectPattern", t, e);
  }
  n(oEe, "assertObjectPattern");
  function lEe(t, e) {
    v("SpreadElement", t, e);
  }
  n(lEe, "assertSpreadElement");
  function uEe(t, e) {
    v("Super", t, e);
  }
  n(uEe, "assertSuper");
  function cEe(t, e) {
    v("TaggedTemplateExpression", t, e);
  }
  n(cEe, "assertTaggedTemplateExpression");
  function pEe(t, e) {
    v("TemplateElement", t, e);
  }
  n(pEe, "assertTemplateElement");
  function fEe(t, e) {
    v("TemplateLiteral", t, e);
  }
  n(fEe, "assertTemplateLiteral");
  function hEe(t, e) {
    v("YieldExpression", t, e);
  }
  n(hEe, "assertYieldExpression");
  function dEe(t, e) {
    v("AwaitExpression", t, e);
  }
  n(dEe, "assertAwaitExpression");
  function mEe(t, e) {
    v("Import", t, e);
  }
  n(mEe, "assertImport");
  function yEe(t, e) {
    v("BigIntLiteral", t, e);
  }
  n(yEe, "assertBigIntLiteral");
  function TEe(t, e) {
    v("ExportNamespaceSpecifier", t, e);
  }
  n(TEe, "assertExportNamespaceSpecifier");
  function bEe(t, e) {
    v("OptionalMemberExpression", t, e);
  }
  n(bEe, "assertOptionalMemberExpression");
  function xEe(t, e) {
    v("OptionalCallExpression", t, e);
  }
  n(xEe, "assertOptionalCallExpression");
  function SEe(t, e) {
    v("ClassProperty", t, e);
  }
  n(SEe, "assertClassProperty");
  function gEe(t, e) {
    v("ClassAccessorProperty", t, e);
  }
  n(gEe, "assertClassAccessorProperty");
  function PEe(t, e) {
    v("ClassPrivateProperty", t, e);
  }
  n(PEe, "assertClassPrivateProperty");
  function EEe(t, e) {
    v("ClassPrivateMethod", t, e);
  }
  n(EEe, "assertClassPrivateMethod");
  function AEe(t, e) {
    v("PrivateName", t, e);
  }
  n(AEe, "assertPrivateName");
  function vEe(t, e) {
    v("StaticBlock", t, e);
  }
  n(vEe, "assertStaticBlock");
  function CEe(t, e) {
    v("AnyTypeAnnotation", t, e);
  }
  n(CEe, "assertAnyTypeAnnotation");
  function IEe(t, e) {
    v("ArrayTypeAnnotation", t, e);
  }
  n(IEe, "assertArrayTypeAnnotation");
  function wEe(t, e) {
    v("BooleanTypeAnnotation", t, e);
  }
  n(wEe, "assertBooleanTypeAnnotation");
  function NEe(t, e) {
    v("BooleanLiteralTypeAnnotation", t, e);
  }
  n(NEe, "assertBooleanLiteralTypeAnnotation");
  function OEe(t, e) {
    v("NullLiteralTypeAnnotation", t, e);
  }
  n(OEe, "assertNullLiteralTypeAnnotation");
  function kEe(t, e) {
    v("ClassImplements", t, e);
  }
  n(kEe, "assertClassImplements");
  function DEe(t, e) {
    v("DeclareClass", t, e);
  }
  n(DEe, "assertDeclareClass");
  function _Ee(t, e) {
    v("DeclareFunction", t, e);
  }
  n(_Ee, "assertDeclareFunction");
  function LEe(t, e) {
    v("DeclareInterface", t, e);
  }
  n(LEe, "assertDeclareInterface");
  function MEe(t, e) {
    v("DeclareModule", t, e);
  }
  n(MEe, "assertDeclareModule");
  function BEe(t, e) {
    v("DeclareModuleExports", t, e);
  }
  n(BEe, "assertDeclareModuleExports");
  function FEe(t, e) {
    v("DeclareTypeAlias", t, e);
  }
  n(FEe, "assertDeclareTypeAlias");
  function jEe(t, e) {
    v("DeclareOpaqueType", t, e);
  }
  n(jEe, "assertDeclareOpaqueType");
  function REe(t, e) {
    v("DeclareVariable", t, e);
  }
  n(REe, "assertDeclareVariable");
  function UEe(t, e) {
    v("DeclareExportDeclaration", t, e);
  }
  n(UEe, "assertDeclareExportDeclaration");
  function qEe(t, e) {
    v("DeclareExportAllDeclaration", t, e);
  }
  n(qEe, "assertDeclareExportAllDeclaration");
  function VEe(t, e) {
    v("DeclaredPredicate", t, e);
  }
  n(VEe, "assertDeclaredPredicate");
  function KEe(t, e) {
    v("ExistsTypeAnnotation", t, e);
  }
  n(KEe, "assertExistsTypeAnnotation");
  function WEe(t, e) {
    v("FunctionTypeAnnotation", t, e);
  }
  n(WEe, "assertFunctionTypeAnnotation");
  function YEe(t, e) {
    v("FunctionTypeParam", t, e);
  }
  n(YEe, "assertFunctionTypeParam");
  function JEe(t, e) {
    v("GenericTypeAnnotation", t, e);
  }
  n(JEe, "assertGenericTypeAnnotation");
  function XEe(t, e) {
    v("InferredPredicate", t, e);
  }
  n(XEe, "assertInferredPredicate");
  function $Ee(t, e) {
    v("InterfaceExtends", t, e);
  }
  n($Ee, "assertInterfaceExtends");
  function HEe(t, e) {
    v("InterfaceDeclaration", t, e);
  }
  n(HEe, "assertInterfaceDeclaration");
  function zEe(t, e) {
    v("InterfaceTypeAnnotation", t, e);
  }
  n(zEe, "assertInterfaceTypeAnnotation");
  function GEe(t, e) {
    v("IntersectionTypeAnnotation", t, e);
  }
  n(GEe, "assertIntersectionTypeAnnotation");
  function QEe(t, e) {
    v("MixedTypeAnnotation", t, e);
  }
  n(QEe, "assertMixedTypeAnnotation");
  function ZEe(t, e) {
    v("EmptyTypeAnnotation", t, e);
  }
  n(ZEe, "assertEmptyTypeAnnotation");
  function eAe(t, e) {
    v("NullableTypeAnnotation", t, e);
  }
  n(eAe, "assertNullableTypeAnnotation");
  function tAe(t, e) {
    v("NumberLiteralTypeAnnotation", t, e);
  }
  n(tAe, "assertNumberLiteralTypeAnnotation");
  function rAe(t, e) {
    v("NumberTypeAnnotation", t, e);
  }
  n(rAe, "assertNumberTypeAnnotation");
  function sAe(t, e) {
    v("ObjectTypeAnnotation", t, e);
  }
  n(sAe, "assertObjectTypeAnnotation");
  function iAe(t, e) {
    v("ObjectTypeInternalSlot", t, e);
  }
  n(iAe, "assertObjectTypeInternalSlot");
  function nAe(t, e) {
    v("ObjectTypeCallProperty", t, e);
  }
  n(nAe, "assertObjectTypeCallProperty");
  function aAe(t, e) {
    v("ObjectTypeIndexer", t, e);
  }
  n(aAe, "assertObjectTypeIndexer");
  function oAe(t, e) {
    v("ObjectTypeProperty", t, e);
  }
  n(oAe, "assertObjectTypeProperty");
  function lAe(t, e) {
    v("ObjectTypeSpreadProperty", t, e);
  }
  n(lAe, "assertObjectTypeSpreadProperty");
  function uAe(t, e) {
    v("OpaqueType", t, e);
  }
  n(uAe, "assertOpaqueType");
  function cAe(t, e) {
    v("QualifiedTypeIdentifier", t, e);
  }
  n(cAe, "assertQualifiedTypeIdentifier");
  function pAe(t, e) {
    v("StringLiteralTypeAnnotation", t, e);
  }
  n(pAe, "assertStringLiteralTypeAnnotation");
  function fAe(t, e) {
    v("StringTypeAnnotation", t, e);
  }
  n(fAe, "assertStringTypeAnnotation");
  function hAe(t, e) {
    v("SymbolTypeAnnotation", t, e);
  }
  n(hAe, "assertSymbolTypeAnnotation");
  function dAe(t, e) {
    v("ThisTypeAnnotation", t, e);
  }
  n(dAe, "assertThisTypeAnnotation");
  function mAe(t, e) {
    v("TupleTypeAnnotation", t, e);
  }
  n(mAe, "assertTupleTypeAnnotation");
  function yAe(t, e) {
    v("TypeofTypeAnnotation", t, e);
  }
  n(yAe, "assertTypeofTypeAnnotation");
  function TAe(t, e) {
    v("TypeAlias", t, e);
  }
  n(TAe, "assertTypeAlias");
  function bAe(t, e) {
    v("TypeAnnotation", t, e);
  }
  n(bAe, "assertTypeAnnotation");
  function xAe(t, e) {
    v("TypeCastExpression", t, e);
  }
  n(xAe, "assertTypeCastExpression");
  function SAe(t, e) {
    v("TypeParameter", t, e);
  }
  n(SAe, "assertTypeParameter");
  function gAe(t, e) {
    v("TypeParameterDeclaration", t, e);
  }
  n(gAe, "assertTypeParameterDeclaration");
  function PAe(t, e) {
    v("TypeParameterInstantiation", t, e);
  }
  n(PAe, "assertTypeParameterInstantiation");
  function EAe(t, e) {
    v("UnionTypeAnnotation", t, e);
  }
  n(EAe, "assertUnionTypeAnnotation");
  function AAe(t, e) {
    v("Variance", t, e);
  }
  n(AAe, "assertVariance");
  function vAe(t, e) {
    v("VoidTypeAnnotation", t, e);
  }
  n(vAe, "assertVoidTypeAnnotation");
  function CAe(t, e) {
    v("EnumDeclaration", t, e);
  }
  n(CAe, "assertEnumDeclaration");
  function IAe(t, e) {
    v("EnumBooleanBody", t, e);
  }
  n(IAe, "assertEnumBooleanBody");
  function wAe(t, e) {
    v("EnumNumberBody", t, e);
  }
  n(wAe, "assertEnumNumberBody");
  function NAe(t, e) {
    v("EnumStringBody", t, e);
  }
  n(NAe, "assertEnumStringBody");
  function OAe(t, e) {
    v("EnumSymbolBody", t, e);
  }
  n(OAe, "assertEnumSymbolBody");
  function kAe(t, e) {
    v("EnumBooleanMember", t, e);
  }
  n(kAe, "assertEnumBooleanMember");
  function DAe(t, e) {
    v("EnumNumberMember", t, e);
  }
  n(DAe, "assertEnumNumberMember");
  function _Ae(t, e) {
    v("EnumStringMember", t, e);
  }
  n(_Ae, "assertEnumStringMember");
  function LAe(t, e) {
    v("EnumDefaultedMember", t, e);
  }
  n(LAe, "assertEnumDefaultedMember");
  function MAe(t, e) {
    v("IndexedAccessType", t, e);
  }
  n(MAe, "assertIndexedAccessType");
  function BAe(t, e) {
    v("OptionalIndexedAccessType", t, e);
  }
  n(BAe, "assertOptionalIndexedAccessType");
  function FAe(t, e) {
    v("JSXAttribute", t, e);
  }
  n(FAe, "assertJSXAttribute");
  function jAe(t, e) {
    v("JSXClosingElement", t, e);
  }
  n(jAe, "assertJSXClosingElement");
  function RAe(t, e) {
    v("JSXElement", t, e);
  }
  n(RAe, "assertJSXElement");
  function UAe(t, e) {
    v("JSXEmptyExpression", t, e);
  }
  n(UAe, "assertJSXEmptyExpression");
  function qAe(t, e) {
    v("JSXExpressionContainer", t, e);
  }
  n(qAe, "assertJSXExpressionContainer");
  function VAe(t, e) {
    v("JSXSpreadChild", t, e);
  }
  n(VAe, "assertJSXSpreadChild");
  function KAe(t, e) {
    v("JSXIdentifier", t, e);
  }
  n(KAe, "assertJSXIdentifier");
  function WAe(t, e) {
    v("JSXMemberExpression", t, e);
  }
  n(WAe, "assertJSXMemberExpression");
  function YAe(t, e) {
    v("JSXNamespacedName", t, e);
  }
  n(YAe, "assertJSXNamespacedName");
  function JAe(t, e) {
    v("JSXOpeningElement", t, e);
  }
  n(JAe, "assertJSXOpeningElement");
  function XAe(t, e) {
    v("JSXSpreadAttribute", t, e);
  }
  n(XAe, "assertJSXSpreadAttribute");
  function $Ae(t, e) {
    v("JSXText", t, e);
  }
  n($Ae, "assertJSXText");
  function HAe(t, e) {
    v("JSXFragment", t, e);
  }
  n(HAe, "assertJSXFragment");
  function zAe(t, e) {
    v("JSXOpeningFragment", t, e);
  }
  n(zAe, "assertJSXOpeningFragment");
  function GAe(t, e) {
    v("JSXClosingFragment", t, e);
  }
  n(GAe, "assertJSXClosingFragment");
  function QAe(t, e) {
    v("Noop", t, e);
  }
  n(QAe, "assertNoop");
  function ZAe(t, e) {
    v("Placeholder", t, e);
  }
  n(ZAe, "assertPlaceholder");
  function e1e(t, e) {
    v("V8IntrinsicIdentifier", t, e);
  }
  n(e1e, "assertV8IntrinsicIdentifier");
  function t1e(t, e) {
    v("ArgumentPlaceholder", t, e);
  }
  n(t1e, "assertArgumentPlaceholder");
  function r1e(t, e) {
    v("BindExpression", t, e);
  }
  n(r1e, "assertBindExpression");
  function s1e(t, e) {
    v("ImportAttribute", t, e);
  }
  n(s1e, "assertImportAttribute");
  function i1e(t, e) {
    v("Decorator", t, e);
  }
  n(i1e, "assertDecorator");
  function n1e(t, e) {
    v("DoExpression", t, e);
  }
  n(n1e, "assertDoExpression");
  function a1e(t, e) {
    v("ExportDefaultSpecifier", t, e);
  }
  n(a1e, "assertExportDefaultSpecifier");
  function o1e(t, e) {
    v("RecordExpression", t, e);
  }
  n(o1e, "assertRecordExpression");
  function l1e(t, e) {
    v("TupleExpression", t, e);
  }
  n(l1e, "assertTupleExpression");
  function u1e(t, e) {
    v("DecimalLiteral", t, e);
  }
  n(u1e, "assertDecimalLiteral");
  function c1e(t, e) {
    v("ModuleExpression", t, e);
  }
  n(c1e, "assertModuleExpression");
  function p1e(t, e) {
    v("TopicReference", t, e);
  }
  n(p1e, "assertTopicReference");
  function f1e(t, e) {
    v("PipelineTopicExpression", t, e);
  }
  n(f1e, "assertPipelineTopicExpression");
  function h1e(t, e) {
    v("PipelineBareFunction", t, e);
  }
  n(h1e, "assertPipelineBareFunction");
  function d1e(t, e) {
    v("PipelinePrimaryTopicReference", t, e);
  }
  n(d1e, "assertPipelinePrimaryTopicReference");
  function m1e(t, e) {
    v("TSParameterProperty", t, e);
  }
  n(m1e, "assertTSParameterProperty");
  function y1e(t, e) {
    v("TSDeclareFunction", t, e);
  }
  n(y1e, "assertTSDeclareFunction");
  function T1e(t, e) {
    v("TSDeclareMethod", t, e);
  }
  n(T1e, "assertTSDeclareMethod");
  function b1e(t, e) {
    v("TSQualifiedName", t, e);
  }
  n(b1e, "assertTSQualifiedName");
  function x1e(t, e) {
    v("TSCallSignatureDeclaration", t, e);
  }
  n(x1e, "assertTSCallSignatureDeclaration");
  function S1e(t, e) {
    v("TSConstructSignatureDeclaration", t, e);
  }
  n(S1e, "assertTSConstructSignatureDeclaration");
  function g1e(t, e) {
    v("TSPropertySignature", t, e);
  }
  n(g1e, "assertTSPropertySignature");
  function P1e(t, e) {
    v("TSMethodSignature", t, e);
  }
  n(P1e, "assertTSMethodSignature");
  function E1e(t, e) {
    v("TSIndexSignature", t, e);
  }
  n(E1e, "assertTSIndexSignature");
  function A1e(t, e) {
    v("TSAnyKeyword", t, e);
  }
  n(A1e, "assertTSAnyKeyword");
  function v1e(t, e) {
    v("TSBooleanKeyword", t, e);
  }
  n(v1e, "assertTSBooleanKeyword");
  function C1e(t, e) {
    v("TSBigIntKeyword", t, e);
  }
  n(C1e, "assertTSBigIntKeyword");
  function I1e(t, e) {
    v("TSIntrinsicKeyword", t, e);
  }
  n(I1e, "assertTSIntrinsicKeyword");
  function w1e(t, e) {
    v("TSNeverKeyword", t, e);
  }
  n(w1e, "assertTSNeverKeyword");
  function N1e(t, e) {
    v("TSNullKeyword", t, e);
  }
  n(N1e, "assertTSNullKeyword");
  function O1e(t, e) {
    v("TSNumberKeyword", t, e);
  }
  n(O1e, "assertTSNumberKeyword");
  function k1e(t, e) {
    v("TSObjectKeyword", t, e);
  }
  n(k1e, "assertTSObjectKeyword");
  function D1e(t, e) {
    v("TSStringKeyword", t, e);
  }
  n(D1e, "assertTSStringKeyword");
  function _1e(t, e) {
    v("TSSymbolKeyword", t, e);
  }
  n(_1e, "assertTSSymbolKeyword");
  function L1e(t, e) {
    v("TSUndefinedKeyword", t, e);
  }
  n(L1e, "assertTSUndefinedKeyword");
  function M1e(t, e) {
    v("TSUnknownKeyword", t, e);
  }
  n(M1e, "assertTSUnknownKeyword");
  function B1e(t, e) {
    v("TSVoidKeyword", t, e);
  }
  n(B1e, "assertTSVoidKeyword");
  function F1e(t, e) {
    v("TSThisType", t, e);
  }
  n(F1e, "assertTSThisType");
  function j1e(t, e) {
    v("TSFunctionType", t, e);
  }
  n(j1e, "assertTSFunctionType");
  function R1e(t, e) {
    v("TSConstructorType", t, e);
  }
  n(R1e, "assertTSConstructorType");
  function U1e(t, e) {
    v("TSTypeReference", t, e);
  }
  n(U1e, "assertTSTypeReference");
  function q1e(t, e) {
    v("TSTypePredicate", t, e);
  }
  n(q1e, "assertTSTypePredicate");
  function V1e(t, e) {
    v("TSTypeQuery", t, e);
  }
  n(V1e, "assertTSTypeQuery");
  function K1e(t, e) {
    v("TSTypeLiteral", t, e);
  }
  n(K1e, "assertTSTypeLiteral");
  function W1e(t, e) {
    v("TSArrayType", t, e);
  }
  n(W1e, "assertTSArrayType");
  function Y1e(t, e) {
    v("TSTupleType", t, e);
  }
  n(Y1e, "assertTSTupleType");
  function J1e(t, e) {
    v("TSOptionalType", t, e);
  }
  n(J1e, "assertTSOptionalType");
  function X1e(t, e) {
    v("TSRestType", t, e);
  }
  n(X1e, "assertTSRestType");
  function $1e(t, e) {
    v("TSNamedTupleMember", t, e);
  }
  n($1e, "assertTSNamedTupleMember");
  function H1e(t, e) {
    v("TSUnionType", t, e);
  }
  n(H1e, "assertTSUnionType");
  function z1e(t, e) {
    v("TSIntersectionType", t, e);
  }
  n(z1e, "assertTSIntersectionType");
  function G1e(t, e) {
    v("TSConditionalType", t, e);
  }
  n(G1e, "assertTSConditionalType");
  function Q1e(t, e) {
    v("TSInferType", t, e);
  }
  n(Q1e, "assertTSInferType");
  function Z1e(t, e) {
    v("TSParenthesizedType", t, e);
  }
  n(Z1e, "assertTSParenthesizedType");
  function eve(t, e) {
    v("TSTypeOperator", t, e);
  }
  n(eve, "assertTSTypeOperator");
  function tve(t, e) {
    v("TSIndexedAccessType", t, e);
  }
  n(tve, "assertTSIndexedAccessType");
  function rve(t, e) {
    v("TSMappedType", t, e);
  }
  n(rve, "assertTSMappedType");
  function sve(t, e) {
    v("TSLiteralType", t, e);
  }
  n(sve, "assertTSLiteralType");
  function ive(t, e) {
    v("TSExpressionWithTypeArguments", t, e);
  }
  n(ive, "assertTSExpressionWithTypeArguments");
  function nve(t, e) {
    v("TSInterfaceDeclaration", t, e);
  }
  n(nve, "assertTSInterfaceDeclaration");
  function ave(t, e) {
    v("TSInterfaceBody", t, e);
  }
  n(ave, "assertTSInterfaceBody");
  function ove(t, e) {
    v("TSTypeAliasDeclaration", t, e);
  }
  n(ove, "assertTSTypeAliasDeclaration");
  function lve(t, e) {
    v("TSInstantiationExpression", t, e);
  }
  n(lve, "assertTSInstantiationExpression");
  function uve(t, e) {
    v("TSAsExpression", t, e);
  }
  n(uve, "assertTSAsExpression");
  function cve(t, e) {
    v("TSSatisfiesExpression", t, e);
  }
  n(cve, "assertTSSatisfiesExpression");
  function pve(t, e) {
    v("TSTypeAssertion", t, e);
  }
  n(pve, "assertTSTypeAssertion");
  function fve(t, e) {
    v("TSEnumDeclaration", t, e);
  }
  n(fve, "assertTSEnumDeclaration");
  function hve(t, e) {
    v("TSEnumMember", t, e);
  }
  n(hve, "assertTSEnumMember");
  function dve(t, e) {
    v("TSModuleDeclaration", t, e);
  }
  n(dve, "assertTSModuleDeclaration");
  function mve(t, e) {
    v("TSModuleBlock", t, e);
  }
  n(mve, "assertTSModuleBlock");
  function yve(t, e) {
    v("TSImportType", t, e);
  }
  n(yve, "assertTSImportType");
  function Tve(t, e) {
    v("TSImportEqualsDeclaration", t, e);
  }
  n(Tve, "assertTSImportEqualsDeclaration");
  function bve(t, e) {
    v("TSExternalModuleReference", t, e);
  }
  n(bve, "assertTSExternalModuleReference");
  function xve(t, e) {
    v("TSNonNullExpression", t, e);
  }
  n(xve, "assertTSNonNullExpression");
  function Sve(t, e) {
    v("TSExportAssignment", t, e);
  }
  n(Sve, "assertTSExportAssignment");
  function gve(t, e) {
    v("TSNamespaceExportDeclaration", t, e);
  }
  n(gve, "assertTSNamespaceExportDeclaration");
  function Pve(t, e) {
    v("TSTypeAnnotation", t, e);
  }
  n(Pve, "assertTSTypeAnnotation");
  function Eve(t, e) {
    v("TSTypeParameterInstantiation", t, e);
  }
  n(Eve, "assertTSTypeParameterInstantiation");
  function Ave(t, e) {
    v("TSTypeParameterDeclaration", t, e);
  }
  n(Ave, "assertTSTypeParameterDeclaration");
  function vve(t, e) {
    v("TSTypeParameter", t, e);
  }
  n(vve, "assertTSTypeParameter");
  function Cve(t, e) {
    v("Standardized", t, e);
  }
  n(Cve, "assertStandardized");
  function Ive(t, e) {
    v("Expression", t, e);
  }
  n(Ive, "assertExpression");
  function wve(t, e) {
    v("Binary", t, e);
  }
  n(wve, "assertBinary");
  function Nve(t, e) {
    v("Scopable", t, e);
  }
  n(Nve, "assertScopable");
  function Ove(t, e) {
    v("BlockParent", t, e);
  }
  n(Ove, "assertBlockParent");
  function kve(t, e) {
    v("Block", t, e);
  }
  n(kve, "assertBlock");
  function Dve(t, e) {
    v("Statement", t, e);
  }
  n(Dve, "assertStatement");
  function _ve(t, e) {
    v("Terminatorless", t, e);
  }
  n(_ve, "assertTerminatorless");
  function Lve(t, e) {
    v("CompletionStatement", t, e);
  }
  n(Lve, "assertCompletionStatement");
  function Mve(t, e) {
    v("Conditional", t, e);
  }
  n(Mve, "assertConditional");
  function Bve(t, e) {
    v("Loop", t, e);
  }
  n(Bve, "assertLoop");
  function Fve(t, e) {
    v("While", t, e);
  }
  n(Fve, "assertWhile");
  function jve(t, e) {
    v("ExpressionWrapper", t, e);
  }
  n(jve, "assertExpressionWrapper");
  function Rve(t, e) {
    v("For", t, e);
  }
  n(Rve, "assertFor");
  function Uve(t, e) {
    v("ForXStatement", t, e);
  }
  n(Uve, "assertForXStatement");
  function qve(t, e) {
    v("Function", t, e);
  }
  n(qve, "assertFunction");
  function Vve(t, e) {
    v("FunctionParent", t, e);
  }
  n(Vve, "assertFunctionParent");
  function Kve(t, e) {
    v("Pureish", t, e);
  }
  n(Kve, "assertPureish");
  function Wve(t, e) {
    v("Declaration", t, e);
  }
  n(Wve, "assertDeclaration");
  function Yve(t, e) {
    v("PatternLike", t, e);
  }
  n(Yve, "assertPatternLike");
  function Jve(t, e) {
    v("LVal", t, e);
  }
  n(Jve, "assertLVal");
  function Xve(t, e) {
    v("TSEntityName", t, e);
  }
  n(Xve, "assertTSEntityName");
  function $ve(t, e) {
    v("Literal", t, e);
  }
  n($ve, "assertLiteral");
  function Hve(t, e) {
    v("Immutable", t, e);
  }
  n(Hve, "assertImmutable");
  function zve(t, e) {
    v("UserWhitespacable", t, e);
  }
  n(zve, "assertUserWhitespacable");
  function Gve(t, e) {
    v("Method", t, e);
  }
  n(Gve, "assertMethod");
  function Qve(t, e) {
    v("ObjectMember", t, e);
  }
  n(Qve, "assertObjectMember");
  function Zve(t, e) {
    v("Property", t, e);
  }
  n(Zve, "assertProperty");
  function eCe(t, e) {
    v("UnaryLike", t, e);
  }
  n(eCe, "assertUnaryLike");
  function tCe(t, e) {
    v("Pattern", t, e);
  }
  n(tCe, "assertPattern");
  function rCe(t, e) {
    v("Class", t, e);
  }
  n(rCe, "assertClass");
  function sCe(t, e) {
    v("ImportOrExportDeclaration", t, e);
  }
  n(sCe, "assertImportOrExportDeclaration");
  function iCe(t, e) {
    v("ExportDeclaration", t, e);
  }
  n(iCe, "assertExportDeclaration");
  function nCe(t, e) {
    v("ModuleSpecifier", t, e);
  }
  n(nCe, "assertModuleSpecifier");
  function aCe(t, e) {
    v("Accessor", t, e);
  }
  n(aCe, "assertAccessor");
  function oCe(t, e) {
    v("Private", t, e);
  }
  n(oCe, "assertPrivate");
  function lCe(t, e) {
    v("Flow", t, e);
  }
  n(lCe, "assertFlow");
  function uCe(t, e) {
    v("FlowType", t, e);
  }
  n(uCe, "assertFlowType");
  function cCe(t, e) {
    v("FlowBaseAnnotation", t, e);
  }
  n(cCe, "assertFlowBaseAnnotation");
  function pCe(t, e) {
    v("FlowDeclaration", t, e);
  }
  n(pCe, "assertFlowDeclaration");
  function fCe(t, e) {
    v("FlowPredicate", t, e);
  }
  n(fCe, "assertFlowPredicate");
  function hCe(t, e) {
    v("EnumBody", t, e);
  }
  n(hCe, "assertEnumBody");
  function dCe(t, e) {
    v("EnumMember", t, e);
  }
  n(dCe, "assertEnumMember");
  function mCe(t, e) {
    v("JSX", t, e);
  }
  n(mCe, "assertJSX");
  function yCe(t, e) {
    v("Miscellaneous", t, e);
  }
  n(yCe, "assertMiscellaneous");
  function TCe(t, e) {
    v("TypeScript", t, e);
  }
  n(TCe, "assertTypeScript");
  function bCe(t, e) {
    v("TSTypeElement", t, e);
  }
  n(bCe, "assertTSTypeElement");
  function xCe(t, e) {
    v("TSType", t, e);
  }
  n(xCe, "assertTSType");
  function SCe(t, e) {
    v("TSBaseType", t, e);
  }
  n(SCe, "assertTSBaseType");
  function gCe(t, e) {
    (0, ko.default)("assertNumberLiteral", "assertNumericLiteral"), v("NumberLiteral", t, e);
  }
  n(gCe, "assertNumberLiteral");
  function PCe(t, e) {
    (0, ko.default)("assertRegexLiteral", "assertRegExpLiteral"), v("RegexLiteral", t, e);
  }
  n(PCe, "assertRegexLiteral");
  function ECe(t, e) {
    (0, ko.default)("assertRestProperty", "assertRestElement"), v("RestProperty", t, e);
  }
  n(ECe, "assertRestProperty");
  function ACe(t, e) {
    (0, ko.default)("assertSpreadProperty", "assertSpreadElement"), v("SpreadProperty", t, e);
  }
  n(ACe, "assertSpreadProperty");
  function vCe(t, e) {
    (0, ko.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), v("ModuleDeclaration", t, e);
  }
  n(vCe, "assertModuleDeclaration");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var oI = w((Tc) => {
  "use strict";
  Object.defineProperty(Tc, "__esModule", {
    value: !0
  });
  Tc.default = void 0;
  var Qr = Ar(), fRe = Tc.default = CCe;
  function CCe(t) {
    switch (t) {
      case "string":
        return (0, Qr.stringTypeAnnotation)();
      case "number":
        return (0, Qr.numberTypeAnnotation)();
      case "undefined":
        return (0, Qr.voidTypeAnnotation)();
      case "boolean":
        return (0, Qr.booleanTypeAnnotation)();
      case "function":
        return (0, Qr.genericTypeAnnotation)((0, Qr.identifier)("Function"));
      case "object":
        return (0, Qr.genericTypeAnnotation)((0, Qr.identifier)("Object"));
      case "symbol":
        return (0, Qr.genericTypeAnnotation)((0, Qr.identifier)("Symbol"));
      case "bigint":
        return (0, Qr.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + t);
  }
  n(CCe, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var cT = w((uT) => {
  "use strict";
  Object.defineProperty(uT, "__esModule", {
    value: !0
  });
  uT.default = uI;
  var Do = Rt();
  function lI(t) {
    return (0, Do.isIdentifier)(t) ? t.name : `${t.id.name}.${lI(t.qualification)}`;
  }
  n(lI, "getQualifiedName");
  function uI(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, Do.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, Do.isFlowBaseAnnotation)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, Do.isUnionTypeAnnotation)(l)) {
          i.has(l.types) || (e.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, Do.isGenericTypeAnnotation)(l)) {
          let u = lI(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = uI(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(uI, "removeTypeDuplicates");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var cI = w((pT) => {
  "use strict";
  Object.defineProperty(pT, "__esModule", {
    value: !0
  });
  pT.default = NCe;
  var ICe = Ar(), wCe = cT();
  function NCe(t) {
    let e = (0, wCe.default)(t);
    return e.length === 1 ? e[0] : (0, ICe.unionTypeAnnotation)(e);
  }
  n(NCe, "createFlowUnionType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var hI = w((fT) => {
  "use strict";
  Object.defineProperty(fT, "__esModule", {
    value: !0
  });
  fT.default = fI;
  var _o = Rt();
  function pI(t) {
    return (0, _o.isIdentifier)(t) ? t.name : `${t.right.name}.${pI(t.left)}`;
  }
  n(pI, "getQualifiedName");
  function fI(t) {
    let e = Array.from(t), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l && !(a.indexOf(l) >= 0)) {
        if ((0, _o.isTSAnyKeyword)(l))
          return [l];
        if ((0, _o.isTSBaseType)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, _o.isTSUnionType)(l)) {
          i.has(l.types) || (e.push(...l.types), i.add(l.types));
          continue;
        }
        if ((0, _o.isTSTypeReference)(l) && l.typeParameters) {
          let u = pI(l.typeName);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = fI(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(fI, "removeTypeDuplicates");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var dI = w((hT) => {
  "use strict";
  Object.defineProperty(hT, "__esModule", {
    value: !0
  });
  hT.default = _Ce;
  var OCe = Ar(), kCe = hI(), DCe = Rt();
  function _Ce(t) {
    let e = t.map((s) => (0, DCe.isTSTypeAnnotation)(s) ? s.typeAnnotation : s), r = (0, kCe.default)(e);
    return r.length === 1 ? r[0] : (0, OCe.tsUnionType)(r);
  }
  n(_Ce, "createTSUnionType");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/generated/uppercase.js
var mI = w((O) => {
  "use strict";
  Object.defineProperty(O, "__esModule", {
    value: !0
  });
  Object.defineProperty(O, "AnyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.anyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ArgumentPlaceholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.argumentPlaceholder;
    }, "get")
  });
  Object.defineProperty(O, "ArrayExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.arrayExpression;
    }, "get")
  });
  Object.defineProperty(O, "ArrayPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.arrayPattern;
    }, "get")
  });
  Object.defineProperty(O, "ArrayTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.arrayTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ArrowFunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.arrowFunctionExpression;
    }, "get")
  });
  Object.defineProperty(O, "AssignmentExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.assignmentExpression;
    }, "get")
  });
  Object.defineProperty(O, "AssignmentPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.assignmentPattern;
    }, "get")
  });
  Object.defineProperty(O, "AwaitExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.awaitExpression;
    }, "get")
  });
  Object.defineProperty(O, "BigIntLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.bigIntLiteral;
    }, "get")
  });
  Object.defineProperty(O, "BinaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.binaryExpression;
    }, "get")
  });
  Object.defineProperty(O, "BindExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.bindExpression;
    }, "get")
  });
  Object.defineProperty(O, "BlockStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.blockStatement;
    }, "get")
  });
  Object.defineProperty(O, "BooleanLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.booleanLiteral;
    }, "get")
  });
  Object.defineProperty(O, "BooleanLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.booleanLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "BooleanTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.booleanTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "BreakStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.breakStatement;
    }, "get")
  });
  Object.defineProperty(O, "CallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.callExpression;
    }, "get")
  });
  Object.defineProperty(O, "CatchClause", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.catchClause;
    }, "get")
  });
  Object.defineProperty(O, "ClassAccessorProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classAccessorProperty;
    }, "get")
  });
  Object.defineProperty(O, "ClassBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classBody;
    }, "get")
  });
  Object.defineProperty(O, "ClassDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ClassExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classExpression;
    }, "get")
  });
  Object.defineProperty(O, "ClassImplements", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classImplements;
    }, "get")
  });
  Object.defineProperty(O, "ClassMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classMethod;
    }, "get")
  });
  Object.defineProperty(O, "ClassPrivateMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classPrivateMethod;
    }, "get")
  });
  Object.defineProperty(O, "ClassPrivateProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classPrivateProperty;
    }, "get")
  });
  Object.defineProperty(O, "ClassProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.classProperty;
    }, "get")
  });
  Object.defineProperty(O, "ConditionalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.conditionalExpression;
    }, "get")
  });
  Object.defineProperty(O, "ContinueStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.continueStatement;
    }, "get")
  });
  Object.defineProperty(O, "DebuggerStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.debuggerStatement;
    }, "get")
  });
  Object.defineProperty(O, "DecimalLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.decimalLiteral;
    }, "get")
  });
  Object.defineProperty(O, "DeclareClass", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareClass;
    }, "get")
  });
  Object.defineProperty(O, "DeclareExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareExportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "DeclareExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareExportDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "DeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareFunction;
    }, "get")
  });
  Object.defineProperty(O, "DeclareInterface", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareInterface;
    }, "get")
  });
  Object.defineProperty(O, "DeclareModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareModule;
    }, "get")
  });
  Object.defineProperty(O, "DeclareModuleExports", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareModuleExports;
    }, "get")
  });
  Object.defineProperty(O, "DeclareOpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareOpaqueType;
    }, "get")
  });
  Object.defineProperty(O, "DeclareTypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareTypeAlias;
    }, "get")
  });
  Object.defineProperty(O, "DeclareVariable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declareVariable;
    }, "get")
  });
  Object.defineProperty(O, "DeclaredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.declaredPredicate;
    }, "get")
  });
  Object.defineProperty(O, "Decorator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.decorator;
    }, "get")
  });
  Object.defineProperty(O, "Directive", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.directive;
    }, "get")
  });
  Object.defineProperty(O, "DirectiveLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.directiveLiteral;
    }, "get")
  });
  Object.defineProperty(O, "DoExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.doExpression;
    }, "get")
  });
  Object.defineProperty(O, "DoWhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.doWhileStatement;
    }, "get")
  });
  Object.defineProperty(O, "EmptyStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.emptyStatement;
    }, "get")
  });
  Object.defineProperty(O, "EmptyTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.emptyTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "EnumBooleanBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumBooleanBody;
    }, "get")
  });
  Object.defineProperty(O, "EnumBooleanMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumBooleanMember;
    }, "get")
  });
  Object.defineProperty(O, "EnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "EnumDefaultedMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumDefaultedMember;
    }, "get")
  });
  Object.defineProperty(O, "EnumNumberBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumNumberBody;
    }, "get")
  });
  Object.defineProperty(O, "EnumNumberMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumNumberMember;
    }, "get")
  });
  Object.defineProperty(O, "EnumStringBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumStringBody;
    }, "get")
  });
  Object.defineProperty(O, "EnumStringMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumStringMember;
    }, "get")
  });
  Object.defineProperty(O, "EnumSymbolBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.enumSymbolBody;
    }, "get")
  });
  Object.defineProperty(O, "ExistsTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.existsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ExportAllDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportAllDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ExportDefaultDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportDefaultDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ExportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ExportNamedDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportNamedDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ExportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ExportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.exportSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ExpressionStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.expressionStatement;
    }, "get")
  });
  Object.defineProperty(O, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.file;
    }, "get")
  });
  Object.defineProperty(O, "ForInStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.forInStatement;
    }, "get")
  });
  Object.defineProperty(O, "ForOfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.forOfStatement;
    }, "get")
  });
  Object.defineProperty(O, "ForStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.forStatement;
    }, "get")
  });
  Object.defineProperty(O, "FunctionDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.functionDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "FunctionExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.functionExpression;
    }, "get")
  });
  Object.defineProperty(O, "FunctionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.functionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "FunctionTypeParam", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.functionTypeParam;
    }, "get")
  });
  Object.defineProperty(O, "GenericTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.genericTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.identifier;
    }, "get")
  });
  Object.defineProperty(O, "IfStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.ifStatement;
    }, "get")
  });
  Object.defineProperty(O, "Import", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.import;
    }, "get")
  });
  Object.defineProperty(O, "ImportAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importAttribute;
    }, "get")
  });
  Object.defineProperty(O, "ImportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "ImportDefaultSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importDefaultSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ImportExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importExpression;
    }, "get")
  });
  Object.defineProperty(O, "ImportNamespaceSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importNamespaceSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "ImportSpecifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.importSpecifier;
    }, "get")
  });
  Object.defineProperty(O, "IndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.indexedAccessType;
    }, "get")
  });
  Object.defineProperty(O, "InferredPredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.inferredPredicate;
    }, "get")
  });
  Object.defineProperty(O, "InterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.interfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "InterfaceExtends", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.interfaceExtends;
    }, "get")
  });
  Object.defineProperty(O, "InterfaceTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.interfaceTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "InterpreterDirective", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.interpreterDirective;
    }, "get")
  });
  Object.defineProperty(O, "IntersectionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.intersectionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "JSXAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxAttribute;
    }, "get")
  });
  Object.defineProperty(O, "JSXClosingElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxClosingElement;
    }, "get")
  });
  Object.defineProperty(O, "JSXClosingFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxClosingFragment;
    }, "get")
  });
  Object.defineProperty(O, "JSXElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxElement;
    }, "get")
  });
  Object.defineProperty(O, "JSXEmptyExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxEmptyExpression;
    }, "get")
  });
  Object.defineProperty(O, "JSXExpressionContainer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxExpressionContainer;
    }, "get")
  });
  Object.defineProperty(O, "JSXFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxFragment;
    }, "get")
  });
  Object.defineProperty(O, "JSXIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxIdentifier;
    }, "get")
  });
  Object.defineProperty(O, "JSXMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxMemberExpression;
    }, "get")
  });
  Object.defineProperty(O, "JSXNamespacedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxNamespacedName;
    }, "get")
  });
  Object.defineProperty(O, "JSXOpeningElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxOpeningElement;
    }, "get")
  });
  Object.defineProperty(O, "JSXOpeningFragment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxOpeningFragment;
    }, "get")
  });
  Object.defineProperty(O, "JSXSpreadAttribute", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxSpreadAttribute;
    }, "get")
  });
  Object.defineProperty(O, "JSXSpreadChild", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxSpreadChild;
    }, "get")
  });
  Object.defineProperty(O, "JSXText", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.jsxText;
    }, "get")
  });
  Object.defineProperty(O, "LabeledStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.labeledStatement;
    }, "get")
  });
  Object.defineProperty(O, "LogicalExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.logicalExpression;
    }, "get")
  });
  Object.defineProperty(O, "MemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.memberExpression;
    }, "get")
  });
  Object.defineProperty(O, "MetaProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.metaProperty;
    }, "get")
  });
  Object.defineProperty(O, "MixedTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.mixedTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ModuleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.moduleExpression;
    }, "get")
  });
  Object.defineProperty(O, "NewExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.newExpression;
    }, "get")
  });
  Object.defineProperty(O, "Noop", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.noop;
    }, "get")
  });
  Object.defineProperty(O, "NullLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.nullLiteral;
    }, "get")
  });
  Object.defineProperty(O, "NullLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.nullLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "NullableTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.nullableTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "NumberLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.numberLiteral;
    }, "get")
  });
  Object.defineProperty(O, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.numberLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "NumberTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.numberTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "NumericLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.numericLiteral;
    }, "get")
  });
  Object.defineProperty(O, "ObjectExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectExpression;
    }, "get")
  });
  Object.defineProperty(O, "ObjectMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectMethod;
    }, "get")
  });
  Object.defineProperty(O, "ObjectPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectPattern;
    }, "get")
  });
  Object.defineProperty(O, "ObjectProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectProperty;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeCallProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeCallProperty;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeIndexer", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeIndexer;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeInternalSlot", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeInternalSlot;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeProperty;
    }, "get")
  });
  Object.defineProperty(O, "ObjectTypeSpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.objectTypeSpreadProperty;
    }, "get")
  });
  Object.defineProperty(O, "OpaqueType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.opaqueType;
    }, "get")
  });
  Object.defineProperty(O, "OptionalCallExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.optionalCallExpression;
    }, "get")
  });
  Object.defineProperty(O, "OptionalIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.optionalIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(O, "OptionalMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.optionalMemberExpression;
    }, "get")
  });
  Object.defineProperty(O, "ParenthesizedExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.parenthesizedExpression;
    }, "get")
  });
  Object.defineProperty(O, "PipelineBareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.pipelineBareFunction;
    }, "get")
  });
  Object.defineProperty(O, "PipelinePrimaryTopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.pipelinePrimaryTopicReference;
    }, "get")
  });
  Object.defineProperty(O, "PipelineTopicExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.pipelineTopicExpression;
    }, "get")
  });
  Object.defineProperty(O, "Placeholder", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.placeholder;
    }, "get")
  });
  Object.defineProperty(O, "PrivateName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.privateName;
    }, "get")
  });
  Object.defineProperty(O, "Program", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.program;
    }, "get")
  });
  Object.defineProperty(O, "QualifiedTypeIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.qualifiedTypeIdentifier;
    }, "get")
  });
  Object.defineProperty(O, "RecordExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.recordExpression;
    }, "get")
  });
  Object.defineProperty(O, "RegExpLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.regExpLiteral;
    }, "get")
  });
  Object.defineProperty(O, "RegexLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.regexLiteral;
    }, "get")
  });
  Object.defineProperty(O, "RestElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.restElement;
    }, "get")
  });
  Object.defineProperty(O, "RestProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.restProperty;
    }, "get")
  });
  Object.defineProperty(O, "ReturnStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.returnStatement;
    }, "get")
  });
  Object.defineProperty(O, "SequenceExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.sequenceExpression;
    }, "get")
  });
  Object.defineProperty(O, "SpreadElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.spreadElement;
    }, "get")
  });
  Object.defineProperty(O, "SpreadProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.spreadProperty;
    }, "get")
  });
  Object.defineProperty(O, "StaticBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.staticBlock;
    }, "get")
  });
  Object.defineProperty(O, "StringLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.stringLiteral;
    }, "get")
  });
  Object.defineProperty(O, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.stringLiteralTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "StringTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.stringTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "Super", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.super;
    }, "get")
  });
  Object.defineProperty(O, "SwitchCase", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.switchCase;
    }, "get")
  });
  Object.defineProperty(O, "SwitchStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.switchStatement;
    }, "get")
  });
  Object.defineProperty(O, "SymbolTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.symbolTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "TSAnyKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsAnyKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSArrayType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsArrayType;
    }, "get")
  });
  Object.defineProperty(O, "TSAsExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsAsExpression;
    }, "get")
  });
  Object.defineProperty(O, "TSBigIntKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsBigIntKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSBooleanKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsBooleanKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSCallSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsCallSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSConditionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsConditionalType;
    }, "get")
  });
  Object.defineProperty(O, "TSConstructSignatureDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsConstructSignatureDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSConstructorType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsConstructorType;
    }, "get")
  });
  Object.defineProperty(O, "TSDeclareFunction", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsDeclareFunction;
    }, "get")
  });
  Object.defineProperty(O, "TSDeclareMethod", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsDeclareMethod;
    }, "get")
  });
  Object.defineProperty(O, "TSEnumDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsEnumDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSEnumMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsEnumMember;
    }, "get")
  });
  Object.defineProperty(O, "TSExportAssignment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsExportAssignment;
    }, "get")
  });
  Object.defineProperty(O, "TSExpressionWithTypeArguments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsExpressionWithTypeArguments;
    }, "get")
  });
  Object.defineProperty(O, "TSExternalModuleReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsExternalModuleReference;
    }, "get")
  });
  Object.defineProperty(O, "TSFunctionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsFunctionType;
    }, "get")
  });
  Object.defineProperty(O, "TSImportEqualsDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsImportEqualsDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSImportType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsImportType;
    }, "get")
  });
  Object.defineProperty(O, "TSIndexSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsIndexSignature;
    }, "get")
  });
  Object.defineProperty(O, "TSIndexedAccessType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsIndexedAccessType;
    }, "get")
  });
  Object.defineProperty(O, "TSInferType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsInferType;
    }, "get")
  });
  Object.defineProperty(O, "TSInstantiationExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsInstantiationExpression;
    }, "get")
  });
  Object.defineProperty(O, "TSInterfaceBody", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsInterfaceBody;
    }, "get")
  });
  Object.defineProperty(O, "TSInterfaceDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsInterfaceDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSIntersectionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsIntersectionType;
    }, "get")
  });
  Object.defineProperty(O, "TSIntrinsicKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsIntrinsicKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSLiteralType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsLiteralType;
    }, "get")
  });
  Object.defineProperty(O, "TSMappedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsMappedType;
    }, "get")
  });
  Object.defineProperty(O, "TSMethodSignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsMethodSignature;
    }, "get")
  });
  Object.defineProperty(O, "TSModuleBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsModuleBlock;
    }, "get")
  });
  Object.defineProperty(O, "TSModuleDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsModuleDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSNamedTupleMember", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNamedTupleMember;
    }, "get")
  });
  Object.defineProperty(O, "TSNamespaceExportDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNamespaceExportDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSNeverKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNeverKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSNonNullExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNonNullExpression;
    }, "get")
  });
  Object.defineProperty(O, "TSNullKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNullKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSNumberKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsNumberKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSObjectKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsObjectKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSOptionalType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsOptionalType;
    }, "get")
  });
  Object.defineProperty(O, "TSParameterProperty", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsParameterProperty;
    }, "get")
  });
  Object.defineProperty(O, "TSParenthesizedType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsParenthesizedType;
    }, "get")
  });
  Object.defineProperty(O, "TSPropertySignature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsPropertySignature;
    }, "get")
  });
  Object.defineProperty(O, "TSQualifiedName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsQualifiedName;
    }, "get")
  });
  Object.defineProperty(O, "TSRestType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsRestType;
    }, "get")
  });
  Object.defineProperty(O, "TSSatisfiesExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsSatisfiesExpression;
    }, "get")
  });
  Object.defineProperty(O, "TSStringKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsStringKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSSymbolKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsSymbolKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSThisType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsThisType;
    }, "get")
  });
  Object.defineProperty(O, "TSTupleType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTupleType;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeAliasDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeAliasDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeAssertion", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeAssertion;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeLiteral;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeOperator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeOperator;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeParameter;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(O, "TSTypePredicate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypePredicate;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeQuery", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeQuery;
    }, "get")
  });
  Object.defineProperty(O, "TSTypeReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsTypeReference;
    }, "get")
  });
  Object.defineProperty(O, "TSUndefinedKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsUndefinedKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsUnionType;
    }, "get")
  });
  Object.defineProperty(O, "TSUnknownKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsUnknownKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TSVoidKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tsVoidKeyword;
    }, "get")
  });
  Object.defineProperty(O, "TaggedTemplateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.taggedTemplateExpression;
    }, "get")
  });
  Object.defineProperty(O, "TemplateElement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.templateElement;
    }, "get")
  });
  Object.defineProperty(O, "TemplateLiteral", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.templateLiteral;
    }, "get")
  });
  Object.defineProperty(O, "ThisExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.thisExpression;
    }, "get")
  });
  Object.defineProperty(O, "ThisTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.thisTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "ThrowStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.throwStatement;
    }, "get")
  });
  Object.defineProperty(O, "TopicReference", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.topicReference;
    }, "get")
  });
  Object.defineProperty(O, "TryStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tryStatement;
    }, "get")
  });
  Object.defineProperty(O, "TupleExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tupleExpression;
    }, "get")
  });
  Object.defineProperty(O, "TupleTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.tupleTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "TypeAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeAlias;
    }, "get")
  });
  Object.defineProperty(O, "TypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "TypeCastExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeCastExpression;
    }, "get")
  });
  Object.defineProperty(O, "TypeParameter", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeParameter;
    }, "get")
  });
  Object.defineProperty(O, "TypeParameterDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeParameterDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "TypeParameterInstantiation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeParameterInstantiation;
    }, "get")
  });
  Object.defineProperty(O, "TypeofTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.typeofTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "UnaryExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.unaryExpression;
    }, "get")
  });
  Object.defineProperty(O, "UnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.unionTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "UpdateExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.updateExpression;
    }, "get")
  });
  Object.defineProperty(O, "V8IntrinsicIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.v8IntrinsicIdentifier;
    }, "get")
  });
  Object.defineProperty(O, "VariableDeclaration", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.variableDeclaration;
    }, "get")
  });
  Object.defineProperty(O, "VariableDeclarator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.variableDeclarator;
    }, "get")
  });
  Object.defineProperty(O, "Variance", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.variance;
    }, "get")
  });
  Object.defineProperty(O, "VoidTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.voidTypeAnnotation;
    }, "get")
  });
  Object.defineProperty(O, "WhileStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.whileStatement;
    }, "get")
  });
  Object.defineProperty(O, "WithStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.withStatement;
    }, "get")
  });
  Object.defineProperty(O, "YieldExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D.yieldExpression;
    }, "get")
  });
  var D = Ar();
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/builders/productions.js
var TI = w((dT) => {
  "use strict";
  Object.defineProperty(dT, "__esModule", {
    value: !0
  });
  dT.buildUndefinedNode = LCe;
  var yI = Ar();
  function LCe() {
    return (0, yI.unaryExpression)("void", (0, yI.numericLiteral)(0), !0);
  }
  n(LCe, "buildUndefinedNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/cloneNode.js
var di = w((mT) => {
  "use strict";
  Object.defineProperty(mT, "__esModule", {
    value: !0
  });
  mT.default = MCe;
  var bI = Vr(), xI = Rt(), {
    hasOwn: Ms
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function SI(t, e, r, s) {
    return t && typeof t.type == "string" ? PI(t, e, r, s) : t;
  }
  n(SI, "cloneIfNode");
  function gI(t, e, r, s) {
    return Array.isArray(t) ? t.map((i) => SI(i, e, r, s)) : SI(t, e, r, s);
  }
  n(gI, "cloneIfNodeOrArray");
  function MCe(t, e = !0, r = !1) {
    return PI(t, e, r, /* @__PURE__ */ new Map());
  }
  n(MCe, "cloneNode");
  function PI(t, e = !0, r = !1, s) {
    if (!t) return t;
    let {
      type: i
    } = t, a = {
      type: t.type
    };
    if ((0, xI.isIdentifier)(t))
      a.name = t.name, Ms(t, "optional") && typeof t.optional == "boolean" && (a.optional = t.optional), Ms(t, "typeAnnotation") && (a.typeAnnotation =
      e ? gI(t.typeAnnotation, !0, r, s) : t.typeAnnotation);
    else if (Ms(bI.NODE_FIELDS, i))
      for (let o of Object.keys(bI.NODE_FIELDS[i]))
        Ms(t, o) && (e ? a[o] = (0, xI.isFile)(t) && o === "comments" ? bc(t.comments, e, r, s) : gI(t[o], !0, r, s) : a[o] = t[o]);
    else
      throw new Error(`Unknown node type: "${i}"`);
    return Ms(t, "loc") && (r ? a.loc = null : a.loc = t.loc), Ms(t, "leadingComments") && (a.leadingComments = bc(t.leadingComments, e, r, s)),
    Ms(t, "innerComments") && (a.innerComments = bc(t.innerComments, e, r, s)), Ms(t, "trailingComments") && (a.trailingComments = bc(t.trailingComments,
    e, r, s)), Ms(t, "extra") && (a.extra = Object.assign({}, t.extra)), a;
  }
  n(PI, "cloneNodeInternal");
  function bc(t, e, r, s) {
    return !t || !e ? t : t.map((i) => {
      let a = s.get(i);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = i, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), s.set(i, c), c;
    });
  }
  n(bc, "maybeCloneComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/clone.js
var EI = w((yT) => {
  "use strict";
  Object.defineProperty(yT, "__esModule", {
    value: !0
  });
  yT.default = FCe;
  var BCe = di();
  function FCe(t) {
    return (0, BCe.default)(t, !1);
  }
  n(FCe, "clone");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/cloneDeep.js
var AI = w((TT) => {
  "use strict";
  Object.defineProperty(TT, "__esModule", {
    value: !0
  });
  TT.default = RCe;
  var jCe = di();
  function RCe(t) {
    return (0, jCe.default)(t);
  }
  n(RCe, "cloneDeep");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var vI = w((bT) => {
  "use strict";
  Object.defineProperty(bT, "__esModule", {
    value: !0
  });
  bT.default = qCe;
  var UCe = di();
  function qCe(t) {
    return (0, UCe.default)(t, !0, !0);
  }
  n(qCe, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var CI = w((xT) => {
  "use strict";
  Object.defineProperty(xT, "__esModule", {
    value: !0
  });
  xT.default = KCe;
  var VCe = di();
  function KCe(t) {
    return (0, VCe.default)(t, !1, !0);
  }
  n(KCe, "cloneWithoutLoc");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/addComments.js
var gT = w((ST) => {
  "use strict";
  Object.defineProperty(ST, "__esModule", {
    value: !0
  });
  ST.default = WCe;
  function WCe(t, e, r) {
    if (!r || !t) return t;
    let s = `${e}Comments`;
    return t[s] ? e === "leading" ? t[s] = r.concat(t[s]) : t[s].push(...r) : t[s] = r, t;
  }
  n(WCe, "addComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/addComment.js
var II = w((PT) => {
  "use strict";
  Object.defineProperty(PT, "__esModule", {
    value: !0
  });
  PT.default = JCe;
  var YCe = gT();
  function JCe(t, e, r, s) {
    return (0, YCe.default)(t, e, [{
      type: s ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  n(JCe, "addComment");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/utils/inherit.js
var xc = w((ET) => {
  "use strict";
  Object.defineProperty(ET, "__esModule", {
    value: !0
  });
  ET.default = XCe;
  function XCe(t, e, r) {
    e && r && (e[t] = Array.from(new Set([].concat(e[t], r[t]).filter(Boolean))));
  }
  n(XCe, "inherit");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/inheritInnerComments.js
var vT = w((AT) => {
  "use strict";
  Object.defineProperty(AT, "__esModule", {
    value: !0
  });
  AT.default = HCe;
  var $Ce = xc();
  function HCe(t, e) {
    (0, $Ce.default)("innerComments", t, e);
  }
  n(HCe, "inheritInnerComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var IT = w((CT) => {
  "use strict";
  Object.defineProperty(CT, "__esModule", {
    value: !0
  });
  CT.default = GCe;
  var zCe = xc();
  function GCe(t, e) {
    (0, zCe.default)("leadingComments", t, e);
  }
  n(GCe, "inheritLeadingComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var NT = w((wT) => {
  "use strict";
  Object.defineProperty(wT, "__esModule", {
    value: !0
  });
  wT.default = ZCe;
  var QCe = xc();
  function ZCe(t, e) {
    (0, QCe.default)("trailingComments", t, e);
  }
  n(ZCe, "inheritTrailingComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/inheritsComments.js
var kT = w((OT) => {
  "use strict";
  Object.defineProperty(OT, "__esModule", {
    value: !0
  });
  OT.default = sIe;
  var eIe = NT(), tIe = IT(), rIe = vT();
  function sIe(t, e) {
    return (0, eIe.default)(t, e), (0, tIe.default)(t, e), (0, rIe.default)(t, e), t;
  }
  n(sIe, "inheritsComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/comments/removeComments.js
var wI = w((DT) => {
  "use strict";
  Object.defineProperty(DT, "__esModule", {
    value: !0
  });
  DT.default = nIe;
  var iIe = pi();
  function nIe(t) {
    return iIe.COMMENT_KEYS.forEach((e) => {
      t[e] = null;
    }), t;
  }
  n(nIe, "removeComments");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/constants/generated/index.js
var NI = w((z) => {
  "use strict";
  Object.defineProperty(z, "__esModule", {
    value: !0
  });
  z.WHILE_TYPES = z.USERWHITESPACABLE_TYPES = z.UNARYLIKE_TYPES = z.TYPESCRIPT_TYPES = z.TSTYPE_TYPES = z.TSTYPEELEMENT_TYPES = z.TSENTITYNAME_TYPES =
  z.TSBASETYPE_TYPES = z.TERMINATORLESS_TYPES = z.STATEMENT_TYPES = z.STANDARDIZED_TYPES = z.SCOPABLE_TYPES = z.PUREISH_TYPES = z.PROPERTY_TYPES =
  z.PRIVATE_TYPES = z.PATTERN_TYPES = z.PATTERNLIKE_TYPES = z.OBJECTMEMBER_TYPES = z.MODULESPECIFIER_TYPES = z.MODULEDECLARATION_TYPES = z.MISCELLANEOUS_TYPES =
  z.METHOD_TYPES = z.LVAL_TYPES = z.LOOP_TYPES = z.LITERAL_TYPES = z.JSX_TYPES = z.IMPORTOREXPORTDECLARATION_TYPES = z.IMMUTABLE_TYPES = z.FUNCTION_TYPES =
  z.FUNCTIONPARENT_TYPES = z.FOR_TYPES = z.FORXSTATEMENT_TYPES = z.FLOW_TYPES = z.FLOWTYPE_TYPES = z.FLOWPREDICATE_TYPES = z.FLOWDECLARATION_TYPES =
  z.FLOWBASEANNOTATION_TYPES = z.EXPRESSION_TYPES = z.EXPRESSIONWRAPPER_TYPES = z.EXPORTDECLARATION_TYPES = z.ENUMMEMBER_TYPES = z.ENUMBODY_TYPES =
  z.DECLARATION_TYPES = z.CONDITIONAL_TYPES = z.COMPLETIONSTATEMENT_TYPES = z.CLASS_TYPES = z.BLOCK_TYPES = z.BLOCKPARENT_TYPES = z.BINARY_TYPES =
  z.ACCESSOR_TYPES = void 0;
  var je = Vr(), ZRe = z.STANDARDIZED_TYPES = je.FLIPPED_ALIAS_KEYS.Standardized, e9e = z.EXPRESSION_TYPES = je.FLIPPED_ALIAS_KEYS.Expression,
  t9e = z.BINARY_TYPES = je.FLIPPED_ALIAS_KEYS.Binary, r9e = z.SCOPABLE_TYPES = je.FLIPPED_ALIAS_KEYS.Scopable, s9e = z.BLOCKPARENT_TYPES = je.
  FLIPPED_ALIAS_KEYS.BlockParent, i9e = z.BLOCK_TYPES = je.FLIPPED_ALIAS_KEYS.Block, n9e = z.STATEMENT_TYPES = je.FLIPPED_ALIAS_KEYS.Statement,
  a9e = z.TERMINATORLESS_TYPES = je.FLIPPED_ALIAS_KEYS.Terminatorless, o9e = z.COMPLETIONSTATEMENT_TYPES = je.FLIPPED_ALIAS_KEYS.CompletionStatement,
  l9e = z.CONDITIONAL_TYPES = je.FLIPPED_ALIAS_KEYS.Conditional, u9e = z.LOOP_TYPES = je.FLIPPED_ALIAS_KEYS.Loop, c9e = z.WHILE_TYPES = je.FLIPPED_ALIAS_KEYS.
  While, p9e = z.EXPRESSIONWRAPPER_TYPES = je.FLIPPED_ALIAS_KEYS.ExpressionWrapper, f9e = z.FOR_TYPES = je.FLIPPED_ALIAS_KEYS.For, h9e = z.FORXSTATEMENT_TYPES =
  je.FLIPPED_ALIAS_KEYS.ForXStatement, d9e = z.FUNCTION_TYPES = je.FLIPPED_ALIAS_KEYS.Function, m9e = z.FUNCTIONPARENT_TYPES = je.FLIPPED_ALIAS_KEYS.
  FunctionParent, y9e = z.PUREISH_TYPES = je.FLIPPED_ALIAS_KEYS.Pureish, T9e = z.DECLARATION_TYPES = je.FLIPPED_ALIAS_KEYS.Declaration, b9e = z.
  PATTERNLIKE_TYPES = je.FLIPPED_ALIAS_KEYS.PatternLike, x9e = z.LVAL_TYPES = je.FLIPPED_ALIAS_KEYS.LVal, S9e = z.TSENTITYNAME_TYPES = je.FLIPPED_ALIAS_KEYS.
  TSEntityName, g9e = z.LITERAL_TYPES = je.FLIPPED_ALIAS_KEYS.Literal, P9e = z.IMMUTABLE_TYPES = je.FLIPPED_ALIAS_KEYS.Immutable, E9e = z.USERWHITESPACABLE_TYPES =
  je.FLIPPED_ALIAS_KEYS.UserWhitespacable, A9e = z.METHOD_TYPES = je.FLIPPED_ALIAS_KEYS.Method, v9e = z.OBJECTMEMBER_TYPES = je.FLIPPED_ALIAS_KEYS.
  ObjectMember, C9e = z.PROPERTY_TYPES = je.FLIPPED_ALIAS_KEYS.Property, I9e = z.UNARYLIKE_TYPES = je.FLIPPED_ALIAS_KEYS.UnaryLike, w9e = z.
  PATTERN_TYPES = je.FLIPPED_ALIAS_KEYS.Pattern, N9e = z.CLASS_TYPES = je.FLIPPED_ALIAS_KEYS.Class, aIe = z.IMPORTOREXPORTDECLARATION_TYPES =
  je.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, O9e = z.EXPORTDECLARATION_TYPES = je.FLIPPED_ALIAS_KEYS.ExportDeclaration, k9e = z.MODULESPECIFIER_TYPES =
  je.FLIPPED_ALIAS_KEYS.ModuleSpecifier, D9e = z.ACCESSOR_TYPES = je.FLIPPED_ALIAS_KEYS.Accessor, _9e = z.PRIVATE_TYPES = je.FLIPPED_ALIAS_KEYS.
  Private, L9e = z.FLOW_TYPES = je.FLIPPED_ALIAS_KEYS.Flow, M9e = z.FLOWTYPE_TYPES = je.FLIPPED_ALIAS_KEYS.FlowType, B9e = z.FLOWBASEANNOTATION_TYPES =
  je.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, F9e = z.FLOWDECLARATION_TYPES = je.FLIPPED_ALIAS_KEYS.FlowDeclaration, j9e = z.FLOWPREDICATE_TYPES =
  je.FLIPPED_ALIAS_KEYS.FlowPredicate, R9e = z.ENUMBODY_TYPES = je.FLIPPED_ALIAS_KEYS.EnumBody, U9e = z.ENUMMEMBER_TYPES = je.FLIPPED_ALIAS_KEYS.
  EnumMember, q9e = z.JSX_TYPES = je.FLIPPED_ALIAS_KEYS.JSX, V9e = z.MISCELLANEOUS_TYPES = je.FLIPPED_ALIAS_KEYS.Miscellaneous, K9e = z.TYPESCRIPT_TYPES =
  je.FLIPPED_ALIAS_KEYS.TypeScript, W9e = z.TSTYPEELEMENT_TYPES = je.FLIPPED_ALIAS_KEYS.TSTypeElement, Y9e = z.TSTYPE_TYPES = je.FLIPPED_ALIAS_KEYS.
  TSType, J9e = z.TSBASETYPE_TYPES = je.FLIPPED_ALIAS_KEYS.TSBaseType, X9e = z.MODULEDECLARATION_TYPES = aIe;
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toBlock.js
var MT = w((LT) => {
  "use strict";
  Object.defineProperty(LT, "__esModule", {
    value: !0
  });
  LT.default = oIe;
  var Sc = Rt(), _T = Ar();
  function oIe(t, e) {
    if ((0, Sc.isBlockStatement)(t))
      return t;
    let r = [];
    return (0, Sc.isEmptyStatement)(t) ? r = [] : ((0, Sc.isStatement)(t) || ((0, Sc.isFunction)(e) ? t = (0, _T.returnStatement)(t) : t = (0, _T.
    expressionStatement)(t)), r = [t]), (0, _T.blockStatement)(r);
  }
  n(oIe, "toBlock");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/ensureBlock.js
var OI = w((BT) => {
  "use strict";
  Object.defineProperty(BT, "__esModule", {
    value: !0
  });
  BT.default = uIe;
  var lIe = MT();
  function uIe(t, e = "body") {
    let r = (0, lIe.default)(t[e], t);
    return t[e] = r, r;
  }
  n(uIe, "ensureBlock");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toIdentifier.js
var jT = w((FT) => {
  "use strict";
  Object.defineProperty(FT, "__esModule", {
    value: !0
  });
  FT.default = fIe;
  var cIe = Jn(), pIe = Ka();
  function fIe(t) {
    t = t + "";
    let e = "";
    for (let r of t)
      e += (0, pIe.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return e = e.replace(/^[-0-9]+/, ""), e = e.replace(/[-\s]+(.)?/g, function(r, s) {
      return s ? s.toUpperCase() : "";
    }), (0, cIe.default)(e) || (e = `_${e}`), e || "_";
  }
  n(fIe, "toIdentifier");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var kI = w((RT) => {
  "use strict";
  Object.defineProperty(RT, "__esModule", {
    value: !0
  });
  RT.default = dIe;
  var hIe = jT();
  function dIe(t) {
    return t = (0, hIe.default)(t), (t === "eval" || t === "arguments") && (t = "_" + t), t;
  }
  n(dIe, "toBindingIdentifierName");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toComputedKey.js
var DI = w((UT) => {
  "use strict";
  Object.defineProperty(UT, "__esModule", {
    value: !0
  });
  UT.default = TIe;
  var mIe = Rt(), yIe = Ar();
  function TIe(t, e = t.key || t.property) {
    return !t.computed && (0, mIe.isIdentifier)(e) && (e = (0, yIe.stringLiteral)(e.name)), e;
  }
  n(TIe, "toComputedKey");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toExpression.js
var _I = w((gc) => {
  "use strict";
  Object.defineProperty(gc, "__esModule", {
    value: !0
  });
  gc.default = void 0;
  var Lo = Rt(), n7e = gc.default = bIe;
  function bIe(t) {
    if ((0, Lo.isExpressionStatement)(t) && (t = t.expression), (0, Lo.isExpression)(t))
      return t;
    if ((0, Lo.isClass)(t) ? t.type = "ClassExpression" : (0, Lo.isFunction)(t) && (t.type = "FunctionExpression"), !(0, Lo.isExpression)(t))
      throw new Error(`cannot turn ${t.type} to an expression`);
    return t;
  }
  n(bIe, "toExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/traverse/traverseFast.js
var KT = w((VT) => {
  "use strict";
  Object.defineProperty(VT, "__esModule", {
    value: !0
  });
  VT.default = qT;
  var xIe = Vr();
  function qT(t, e, r) {
    if (!t) return;
    let s = xIe.VISITOR_KEYS[t.type];
    if (s) {
      r = r || {}, e(t, r);
      for (let i of s) {
        let a = t[i];
        if (Array.isArray(a))
          for (let o of a)
            qT(o, e, r);
        else
          qT(a, e, r);
      }
    }
  }
  n(qT, "traverseFast");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/removeProperties.js
var YT = w((WT) => {
  "use strict";
  Object.defineProperty(WT, "__esModule", {
    value: !0
  });
  WT.default = PIe;
  var SIe = pi(), LI = ["tokens", "start", "end", "loc", "raw", "rawValue"], gIe = [...SIe.COMMENT_KEYS, "comments", ...LI];
  function PIe(t, e = {}) {
    let r = e.preserveComments ? LI : gIe;
    for (let i of r)
      t[i] != null && (t[i] = void 0);
    for (let i of Object.keys(t))
      i[0] === "_" && t[i] != null && (t[i] = void 0);
    let s = Object.getOwnPropertySymbols(t);
    for (let i of s)
      t[i] = null;
  }
  n(PIe, "removeProperties");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var XT = w((JT) => {
  "use strict";
  Object.defineProperty(JT, "__esModule", {
    value: !0
  });
  JT.default = vIe;
  var EIe = KT(), AIe = YT();
  function vIe(t, e) {
    return (0, EIe.default)(t, AIe.default, e), t;
  }
  n(vIe, "removePropertiesDeep");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toKeyAlias.js
var BI = w(($T) => {
  "use strict";
  Object.defineProperty($T, "__esModule", {
    value: !0
  });
  $T.default = zi;
  var MI = Rt(), CIe = di(), IIe = XT();
  function zi(t, e = t.key) {
    let r;
    return t.kind === "method" ? zi.increment() + "" : ((0, MI.isIdentifier)(e) ? r = e.name : (0, MI.isStringLiteral)(e) ? r = JSON.stringify(
    e.value) : r = JSON.stringify((0, IIe.default)((0, CIe.default)(e))), t.computed && (r = `[${r}]`), t.static && (r = `static:${r}`), r);
  }
  n(zi, "toKeyAlias");
  zi.uid = 0;
  zi.increment = function() {
    return zi.uid >= Number.MAX_SAFE_INTEGER ? zi.uid = 0 : zi.uid++;
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toStatement.js
var FI = w((Ec) => {
  "use strict";
  Object.defineProperty(Ec, "__esModule", {
    value: !0
  });
  Ec.default = void 0;
  var Pc = Rt(), wIe = Ar(), y7e = Ec.default = NIe;
  function NIe(t, e) {
    if ((0, Pc.isStatement)(t))
      return t;
    let r = !1, s;
    if ((0, Pc.isClass)(t))
      r = !0, s = "ClassDeclaration";
    else if ((0, Pc.isFunction)(t))
      r = !0, s = "FunctionDeclaration";
    else if ((0, Pc.isAssignmentExpression)(t))
      return (0, wIe.expressionStatement)(t);
    if (r && !t.id && (s = !1), !s) {
      if (e)
        return !1;
      throw new Error(`cannot turn ${t.type} to a statement`);
    }
    return t.type = s, t;
  }
  n(NIe, "toStatement");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/valueToNode.js
var jI = w((Ac) => {
  "use strict";
  Object.defineProperty(Ac, "__esModule", {
    value: !0
  });
  Ac.default = void 0;
  var OIe = Jn(), nr = Ar(), x7e = Ac.default = HT, kIe = Function.call.bind(Object.prototype.toString);
  function DIe(t) {
    return kIe(t) === "[object RegExp]";
  }
  n(DIe, "isRegExp");
  function _Ie(t) {
    if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
      return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null;
  }
  n(_Ie, "isPlainObject");
  function HT(t) {
    if (t === void 0)
      return (0, nr.identifier)("undefined");
    if (t === !0 || t === !1)
      return (0, nr.booleanLiteral)(t);
    if (t === null)
      return (0, nr.nullLiteral)();
    if (typeof t == "string")
      return (0, nr.stringLiteral)(t);
    if (typeof t == "number") {
      let e;
      if (Number.isFinite(t))
        e = (0, nr.numericLiteral)(Math.abs(t));
      else {
        let r;
        Number.isNaN(t) ? r = (0, nr.numericLiteral)(0) : r = (0, nr.numericLiteral)(1), e = (0, nr.binaryExpression)("/", r, (0, nr.numericLiteral)(
        0));
      }
      return (t < 0 || Object.is(t, -0)) && (e = (0, nr.unaryExpression)("-", e)), e;
    }
    if (DIe(t)) {
      let e = t.source, r = t.toString().match(/\/([a-z]+|)$/)[1];
      return (0, nr.regExpLiteral)(e, r);
    }
    if (Array.isArray(t))
      return (0, nr.arrayExpression)(t.map(HT));
    if (_Ie(t)) {
      let e = [];
      for (let r of Object.keys(t)) {
        let s;
        (0, OIe.default)(r) ? s = (0, nr.identifier)(r) : s = (0, nr.stringLiteral)(r), e.push((0, nr.objectProperty)(s, HT(t[r])));
      }
      return (0, nr.objectExpression)(e);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  n(HT, "valueToNode");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var RI = w((zT) => {
  "use strict";
  Object.defineProperty(zT, "__esModule", {
    value: !0
  });
  zT.default = MIe;
  var LIe = Ar();
  function MIe(t, e, r = !1) {
    return t.object = (0, LIe.memberExpression)(t.object, t.property, t.computed), t.property = e, t.computed = !!r, t;
  }
  n(MIe, "appendToMemberExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/inherits.js
var qI = w((GT) => {
  "use strict";
  Object.defineProperty(GT, "__esModule", {
    value: !0
  });
  GT.default = FIe;
  var UI = pi(), BIe = kT();
  function FIe(t, e) {
    if (!t || !e) return t;
    for (let r of UI.INHERIT_KEYS.optional)
      t[r] == null && (t[r] = e[r]);
    for (let r of Object.keys(e))
      r[0] === "_" && r !== "__clone" && (t[r] = e[r]);
    for (let r of UI.INHERIT_KEYS.force)
      t[r] = e[r];
    return (0, BIe.default)(t, e), t;
  }
  n(FIe, "inherits");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var VI = w((QT) => {
  "use strict";
  Object.defineProperty(QT, "__esModule", {
    value: !0
  });
  QT.default = UIe;
  var jIe = Ar(), RIe = Oo();
  function UIe(t, e) {
    if ((0, RIe.isSuper)(t.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return t.object = (0, jIe.memberExpression)(e, t.object), t;
  }
  n(UIe, "prependToMemberExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Mo = w((e0) => {
  "use strict";
  Object.defineProperty(e0, "__esModule", {
    value: !0
  });
  e0.default = ZT;
  var mi = Rt();
  function ZT(t, e, r, s) {
    let i = [].concat(t), a = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let o = i.shift();
      if (!o || s && ((0, mi.isAssignmentExpression)(o) || (0, mi.isUnaryExpression)(o)))
        continue;
      let l = ZT.keys[o.type];
      if ((0, mi.isIdentifier)(o)) {
        e ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, mi.isExportDeclaration)(o) && !(0, mi.isExportAllDeclaration)(o)) {
        (0, mi.isDeclaration)(o.declaration) && i.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, mi.isFunctionDeclaration)(o)) {
          i.push(o.id);
          continue;
        }
        if ((0, mi.isFunctionExpression)(o))
          continue;
      }
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], p = o[c];
          p && (Array.isArray(p) ? i.push(...p) : i.push(p));
        }
    }
    return a;
  }
  n(ZT, "getBindingIdentifiers");
  ZT.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var KI = w((vc) => {
  "use strict";
  Object.defineProperty(vc, "__esModule", {
    value: !0
  });
  vc.default = void 0;
  var qIe = Mo(), O7e = vc.default = VIe;
  function VIe(t, e) {
    return (0, qIe.default)(t, e, !0);
  }
  n(VIe, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/traverse/traverse.js
var WI = w((r0) => {
  "use strict";
  Object.defineProperty(r0, "__esModule", {
    value: !0
  });
  r0.default = WIe;
  var KIe = Vr();
  function WIe(t, e, r) {
    typeof e == "function" && (e = {
      enter: e
    });
    let {
      enter: s,
      exit: i
    } = e;
    t0(t, s, i, r, []);
  }
  n(WIe, "traverse");
  function t0(t, e, r, s, i) {
    let a = KIe.VISITOR_KEYS[t.type];
    if (a) {
      e && e(t, i, s);
      for (let o of a) {
        let l = t[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (i.push({
              node: t,
              key: o,
              index: u
            }), t0(c, e, r, s, i), i.pop());
          }
        else l && (i.push({
          node: t,
          key: o
        }), t0(l, e, r, s, i), i.pop());
      }
      r && r(t, i, s);
    }
  }
  n(t0, "traverseSimpleImpl");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isBinding.js
var YI = w((s0) => {
  "use strict";
  Object.defineProperty(s0, "__esModule", {
    value: !0
  });
  s0.default = JIe;
  var YIe = Mo();
  function JIe(t, e, r) {
    if (r && t.type === "Identifier" && e.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let s = YIe.default.keys[e.type];
    if (s)
      for (let i = 0; i < s.length; i++) {
        let a = s[i], o = e[a];
        if (Array.isArray(o)) {
          if (o.indexOf(t) >= 0) return !0;
        } else if (o === t) return !0;
      }
    return !1;
  }
  n(JIe, "isBinding");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isLet.js
var n0 = w((i0) => {
  "use strict";
  Object.defineProperty(i0, "__esModule", {
    value: !0
  });
  i0.default = HIe;
  var XIe = Rt(), $Ie = pi();
  function HIe(t) {
    return (0, XIe.isVariableDeclaration)(t) && (t.kind !== "var" || t[$Ie.BLOCK_SCOPED_SYMBOL]);
  }
  n(HIe, "isLet");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isBlockScoped.js
var XI = w((a0) => {
  "use strict";
  Object.defineProperty(a0, "__esModule", {
    value: !0
  });
  a0.default = GIe;
  var JI = Rt(), zIe = n0();
  function GIe(t) {
    return (0, JI.isFunctionDeclaration)(t) || (0, JI.isClassDeclaration)(t) || (0, zIe.default)(t);
  }
  n(GIe, "isBlockScoped");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isImmutable.js
var $I = w((o0) => {
  "use strict";
  Object.defineProperty(o0, "__esModule", {
    value: !0
  });
  o0.default = ewe;
  var QIe = ac(), ZIe = Rt();
  function ewe(t) {
    return (0, QIe.default)(t.type, "Immutable") ? !0 : (0, ZIe.isIdentifier)(t) ? t.name === "undefined" : !1;
  }
  n(ewe, "isImmutable");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var zI = w((u0) => {
  "use strict";
  Object.defineProperty(u0, "__esModule", {
    value: !0
  });
  u0.default = l0;
  var HI = Vr();
  function l0(t, e) {
    if (typeof t != "object" || typeof e != "object" || t == null || e == null)
      return t === e;
    if (t.type !== e.type)
      return !1;
    let r = Object.keys(HI.NODE_FIELDS[t.type] || t.type), s = HI.VISITOR_KEYS[t.type];
    for (let i of r) {
      let a = t[i], o = e[i];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!l0(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(s != null && s.includes(i))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!l0(a, o))
          return !1;
      }
    }
    return !0;
  }
  n(l0, "isNodesEquivalent");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isReferenced.js
var GI = w((c0) => {
  "use strict";
  Object.defineProperty(c0, "__esModule", {
    value: !0
  });
  c0.default = twe;
  function twe(t, e, r) {
    switch (e.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return e.property === t ? !!e.computed : e.object === t;
      case "JSXMemberExpression":
        return e.object === t;
      case "VariableDeclarator":
        return e.init === t;
      case "ArrowFunctionExpression":
        return e.body === t;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return e.key === t ? !!e.computed : !1;
      case "ObjectProperty":
        return e.key === t ? !!e.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return e.key === t ? !!e.computed : !0;
      case "ClassPrivateProperty":
        return e.key !== t;
      case "ClassDeclaration":
      case "ClassExpression":
        return e.superClass === t;
      case "AssignmentExpression":
        return e.right === t;
      case "AssignmentPattern":
        return e.right === t;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : e.local === t;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return e.key !== t;
      case "TSEnumMember":
        return e.id !== t;
      case "TSPropertySignature":
        return e.key === t ? !!e.computed : !0;
    }
    return !0;
  }
  n(twe, "isReferenced");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isScope.js
var QI = w((p0) => {
  "use strict";
  Object.defineProperty(p0, "__esModule", {
    value: !0
  });
  p0.default = rwe;
  var Gi = Rt();
  function rwe(t, e) {
    return (0, Gi.isBlockStatement)(t) && ((0, Gi.isFunction)(e) || (0, Gi.isCatchClause)(e)) ? !1 : (0, Gi.isPattern)(t) && ((0, Gi.isFunction)(
    e) || (0, Gi.isCatchClause)(e)) ? !0 : (0, Gi.isScopable)(t);
  }
  n(rwe, "isScope");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var ew = w((f0) => {
  "use strict";
  Object.defineProperty(f0, "__esModule", {
    value: !0
  });
  f0.default = swe;
  var ZI = Rt();
  function swe(t) {
    return (0, ZI.isImportDefaultSpecifier)(t) || (0, ZI.isIdentifier)(t.imported || t.exported, {
      name: "default"
    });
  }
  n(swe, "isSpecifierDefault");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var tw = w((h0) => {
  "use strict";
  Object.defineProperty(h0, "__esModule", {
    value: !0
  });
  h0.default = awe;
  var iwe = Jn(), nwe = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "impleme\
nts", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "trans\
ient", "volatile"]);
  function awe(t) {
    return (0, iwe.default)(t) && !nwe.has(t);
  }
  n(awe, "isValidES3Identifier");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/validators/isVar.js
var rw = w((d0) => {
  "use strict";
  Object.defineProperty(d0, "__esModule", {
    value: !0
  });
  d0.default = uwe;
  var owe = Rt(), lwe = pi();
  function uwe(t) {
    return (0, owe.isVariableDeclaration)(t, {
      kind: "var"
    }) && !t[lwe.BLOCK_SCOPED_SYMBOL];
  }
  n(uwe, "isVar");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var sw = w((y0) => {
  "use strict";
  Object.defineProperty(y0, "__esModule", {
    value: !0
  });
  y0.default = Cc;
  var cwe = Mo(), Qi = Rt(), m0 = Ar(), pwe = di();
  function Cc(t, e, r) {
    let s = [], i = !0;
    for (let a of t)
      if ((0, Qi.isEmptyStatement)(a) || (i = !1), (0, Qi.isExpression)(a))
        s.push(a);
      else if ((0, Qi.isExpressionStatement)(a))
        s.push(a.expression);
      else if ((0, Qi.isVariableDeclaration)(a)) {
        if (a.kind !== "var") return;
        for (let o of a.declarations) {
          let l = (0, cwe.default)(o);
          for (let u of Object.keys(l))
            r.push({
              kind: a.kind,
              id: (0, pwe.default)(l[u])
            });
          o.init && s.push((0, m0.assignmentExpression)("=", o.id, o.init));
        }
        i = !0;
      } else if ((0, Qi.isIfStatement)(a)) {
        let o = a.consequent ? Cc([a.consequent], e, r) : e.buildUndefinedNode(), l = a.alternate ? Cc([a.alternate], e, r) : e.buildUndefinedNode();
        if (!o || !l) return;
        s.push((0, m0.conditionalExpression)(a.test, o, l));
      } else if ((0, Qi.isBlockStatement)(a)) {
        let o = Cc(a.body, e, r);
        if (!o) return;
        s.push(o);
      } else if ((0, Qi.isEmptyStatement)(a))
        t.indexOf(a) === 0 && (i = !0);
      else
        return;
    return i && s.push(e.buildUndefinedNode()), s.length === 1 ? s[0] : (0, m0.sequenceExpression)(s);
  }
  n(Cc, "gatherSequenceExpressions");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/converters/toSequenceExpression.js
var iw = w((T0) => {
  "use strict";
  Object.defineProperty(T0, "__esModule", {
    value: !0
  });
  T0.default = hwe;
  var fwe = sw();
  function hwe(t, e) {
    if (!(t != null && t.length)) return;
    let r = [], s = (0, fwe.default)(t, e, r);
    if (s) {
      for (let i of r)
        e.push(i);
      return s;
    }
  }
  n(hwe, "toSequenceExpression");
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/node_modules/@babel/types/lib/index.js
var Oo = w((se) => {
  "use strict";
  Object.defineProperty(se, "__esModule", {
    value: !0
  });
  var Bs = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(se, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return mNe.default;
    }, "get")
  });
  Object.defineProperty(se, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vwe.default;
    }, "get")
  });
  Object.defineProperty(se, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Cwe.default;
    }, "get")
  });
  Object.defineProperty(se, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return qwe.default;
    }, "get")
  });
  Object.defineProperty(se, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Twe.default;
    }, "get")
  });
  Object.defineProperty(se, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return dNe.default;
    }, "get")
  });
  Object.defineProperty(se, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gwe.default;
    }, "get")
  });
  Object.defineProperty(se, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Pwe.default;
    }, "get")
  });
  Object.defineProperty(se, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ewe.default;
    }, "get")
  });
  Object.defineProperty(se, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Swe.default;
    }, "get")
  });
  Object.defineProperty(se, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Awe.default;
    }, "get")
  });
  Object.defineProperty(se, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nw.default;
    }, "get")
  });
  Object.defineProperty(se, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xwe.default;
    }, "get")
  });
  Object.defineProperty(se, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bwe.default;
    }, "get")
  });
  Object.defineProperty(se, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nw.default;
    }, "get")
  });
  Object.defineProperty(se, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Dwe.default;
    }, "get")
  });
  Object.defineProperty(se, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Xwe.default;
    }, "get")
  });
  Object.defineProperty(se, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $we.default;
    }, "get")
  });
  Object.defineProperty(se, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Iwe.default;
    }, "get")
  });
  Object.defineProperty(se, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return wwe.default;
    }, "get")
  });
  Object.defineProperty(se, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Owe.default;
    }, "get")
  });
  Object.defineProperty(se, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Vwe.default;
    }, "get")
  });
  Object.defineProperty(se, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Nwe.default;
    }, "get")
  });
  Object.defineProperty(se, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Gwe.default;
    }, "get")
  });
  Object.defineProperty(se, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qwe.default;
    }, "get")
  });
  Object.defineProperty(se, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Zwe.default;
    }, "get")
  });
  Object.defineProperty(se, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return eNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return tNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return sNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return iNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return nNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return aNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return oNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return lNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return uNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return cNe.default;
    }, "get")
  });
  Object.defineProperty(se, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pNe.default;
    }, "get")
  });
  Object.defineProperty(se, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return fNe.default;
    }, "get")
  });
  Object.defineProperty(se, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Kwe.default;
    }, "get")
  });
  se.react = void 0;
  Object.defineProperty(se, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kwe.default;
    }, "get")
  });
  Object.defineProperty(se, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Wwe.default;
    }, "get")
  });
  Object.defineProperty(se, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ywe.default;
    }, "get")
  });
  Object.defineProperty(se, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Jwe.default;
    }, "get")
  });
  Object.defineProperty(se, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return zwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return _we.default;
    }, "get")
  });
  Object.defineProperty(se, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Lwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Mwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Fwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jwe.default;
    }, "get")
  });
  Object.defineProperty(se, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Rwe.default;
    }, "get")
  });
  Object.defineProperty(se, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Ic.default;
    }, "get")
  });
  Object.defineProperty(se, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Hwe.default;
    }, "get")
  });
  Object.defineProperty(se, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hNe.default;
    }, "get")
  });
  Object.defineProperty(se, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Uwe.default;
    }, "get")
  });
  var dwe = SC(), mwe = gC(), ywe = iI(), Twe = nI(), b0 = aI();
  Object.keys(b0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === b0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return b0[t];
      }, "get")
    });
  });
  var bwe = oI(), nw = cI(), xwe = dI(), x0 = Ar();
  Object.keys(x0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === x0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return x0[t];
      }, "get")
    });
  });
  var S0 = mI();
  Object.keys(S0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === S0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return S0[t];
      }, "get")
    });
  });
  var g0 = TI();
  Object.keys(g0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === g0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return g0[t];
      }, "get")
    });
  });
  var Swe = di(), gwe = EI(), Pwe = AI(), Ewe = vI(), Awe = CI(), vwe = II(), Cwe = gT(), Iwe = vT(), wwe = IT(), Nwe = kT(), Owe = NT(), kwe = wI(),
  P0 = NI();
  Object.keys(P0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === P0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return P0[t];
      }, "get")
    });
  });
  var E0 = pi();
  Object.keys(E0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === E0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return E0[t];
      }, "get")
    });
  });
  var Dwe = OI(), _we = kI(), Lwe = MT(), Mwe = DI(), Bwe = _I(), Fwe = jT(), jwe = BI(), Rwe = FI(), Uwe = jI(), A0 = Vr();
  Object.keys(A0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === A0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return A0[t];
      }, "get")
    });
  });
  var qwe = RI(), Vwe = qI(), Kwe = VI(), Wwe = YT(), Ywe = XT(), Jwe = cT(), Xwe = Mo(), $we = KI(), Ic = WI();
  Object.keys(Ic).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === Ic[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Ic[t];
      }, "get")
    });
  });
  var Hwe = KT(), zwe = ic(), Gwe = Yn(), Qwe = YI(), Zwe = XI(), eNe = $I(), tNe = n0(), rNe = oT(), sNe = zI(), iNe = jy(), nNe = GI(), aNe = QI(),
  oNe = ew(), lNe = ac(), uNe = tw(), cNe = Jn(), pNe = rw(), fNe = Dy(), hNe = pc(), dNe = Ly(), v0 = Rt();
  Object.keys(v0).forEach(function(t) {
    t === "default" || t === "__esModule" || Object.prototype.hasOwnProperty.call(Bs, t) || t in se && se[t] === v0[t] || Object.defineProperty(
    se, t, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return v0[t];
      }, "get")
    });
  });
  var mNe = Eo(), nUe = se.react = {
    isReactComponent: dwe.default,
    isCompatTag: mwe.default,
    buildChildren: ywe.default
  };
  se.toSequenceExpression = iw().default;
});

// ../node_modules/@babel/traverse/node_modules/@babel/helper-function-name/lib/index.js
var pw = w((C0) => {
  "use strict";
  Object.defineProperty(C0, "__esModule", {
    value: !0
  });
  C0.default = BNe;
  var uw = TC(), yNe = Oo(), {
    NOT_LOCAL_BINDING: aw,
    cloneNode: TNe,
    identifier: bNe,
    isAssignmentExpression: xNe,
    isAssignmentPattern: SNe,
    isFunction: cw,
    isIdentifier: ow,
    isLiteral: lw,
    isNullLiteral: gNe,
    isObjectMethod: PNe,
    isObjectProperty: ENe,
    isRegExpLiteral: ANe,
    isRestElement: vNe,
    isTemplateLiteral: CNe,
    isVariableDeclarator: INe,
    toBindingIdentifierName: wNe
  } = yNe;
  function NNe(t) {
    let e = t.params.findIndex((r) => SNe(r) || vNe(r));
    return e === -1 ? t.params.length : e;
  }
  n(NNe, "getFunctionArity");
  var ONe = uw.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), kNe = uw.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), DNe = {
    "ReferencedIdentifier|BindingIdentifier"(t, e) {
      t.node.name !== e.name || t.scope.getBindingIdentifier(e.name) !== e.outerDeclar || (e.selfReference = !0, t.stop());
    }
  };
  function _Ne(t) {
    return gNe(t) ? "null" : ANe(t) ? `_${t.pattern}_${t.flags}` : CNe(t) ? t.quasis.map((e) => e.value.raw).join("") : t.value !== void 0 ?
    t.value + "" : "";
  }
  n(_Ne, "getNameFromLiteralId");
  function LNe(t, e, r, s) {
    if (t.selfReference)
      if (s.hasBinding(r.name) && !s.hasGlobal(r.name))
        s.rename(r.name);
      else {
        if (!cw(e)) return;
        let i = ONe;
        e.generator && (i = kNe);
        let a = i({
          FUNCTION: e,
          FUNCTION_ID: r,
          FUNCTION_KEY: s.generateUidIdentifier(r.name)
        }).expression, o = a.callee.body.body[0].params;
        for (let l = 0, u = NNe(e); l < u; l++)
          o.push(s.generateUidIdentifier("x"));
        return a;
      }
    e.id = r, s.getProgramParent().references[r.name] = !0;
  }
  n(LNe, "wrap");
  function MNe(t, e, r) {
    let s = {
      selfAssignment: !1,
      selfReference: !1,
      outerDeclar: r.getBindingIdentifier(e),
      name: e
    }, i = r.getOwnBinding(e);
    return i ? i.kind === "param" && (s.selfReference = !0) : (s.outerDeclar || r.hasGlobal(e)) && r.traverse(t, DNe, s), s;
  }
  n(MNe, "visit");
  function BNe({
    node: t,
    parent: e,
    scope: r,
    id: s
  }, i = !1, a = !1) {
    if (t.id) return;
    if ((ENe(e) || PNe(e, {
      kind: "method"
    })) && (!e.computed || lw(e.key)))
      s = e.key;
    else if (INe(e)) {
      if (s = e.id, ow(s) && !i) {
        let c = r.parent.getBinding(s.name);
        if (c && c.constant && r.getBinding(s.name) === c) {
          t.id = TNe(s), t.id[aw] = !0;
          return;
        }
      }
    } else if (xNe(e, {
      operator: "="
    }))
      s = e.left;
    else if (!s)
      return;
    let o;
    if (s && lw(s) ? o = _Ne(s) : s && ow(s) && (o = s.name), o === void 0 || !a && cw(t) && /[\uD800-\uDFFF]/.test(o))
      return;
    o = wNe(o);
    let l = bNe(o);
    l[aw] = !0;
    let u = MNe(t, o, r);
    return LNe(u, t, l, r) || t;
  }
  n(BNe, "_default");
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var yw = w((en) => {
  "use strict";
  Object.defineProperty(en, "__esModule", {
    value: !0
  });
  en.arrowFunctionToExpression = i2e;
  en.ensureBlock = t2e;
  en.toComputedKey = e2e;
  en.unwrapFunctionEnvironment = r2e;
  var FNe = Ce(), N0 = Kh(), jNe = pw(), O0 = La(), {
    arrowFunctionExpression: k0,
    assignmentExpression: Zi,
    binaryExpression: I0,
    blockStatement: RNe,
    callExpression: Hn,
    conditionalExpression: UNe,
    expressionStatement: fw,
    identifier: kt,
    isIdentifier: qNe,
    jsxIdentifier: VNe,
    logicalExpression: KNe,
    LOGICAL_OPERATORS: WNe,
    memberExpression: Zr,
    metaProperty: YNe,
    numericLiteral: JNe,
    objectExpression: XNe,
    restElement: $Ne,
    returnStatement: HNe,
    sequenceExpression: zNe,
    spreadElement: GNe,
    stringLiteral: hw,
    super: w0,
    thisExpression: Bo,
    toExpression: QNe,
    unaryExpression: ZNe
  } = FNe;
  function e2e() {
    let t;
    if (this.isMemberExpression())
      t = this.node.property;
    else if (this.isProperty() || this.isMethod())
      t = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || qNe(t) && (t = hw(t.name)), t;
  }
  n(e2e, "toComputedKey");
  function t2e() {
    let t = this.get("body"), e = t.node;
    if (Array.isArray(t))
      throw new Error("Can't convert array path to a block statement");
    if (!e)
      throw new Error("Can't convert node without a body");
    if (t.isBlockStatement())
      return e;
    let r = [], s = "body", i, a;
    t.isStatement() ? (a = "body", i = 0, r.push(t.node)) : (s += ".body.0", this.isFunction() ? (i = "argument", r.push(HNe(t.node))) : (i =
    "expression", r.push(fw(t.node)))), this.node.body = RNe(r);
    let o = this.get(s);
    return t.setup(o, a ? o.node[a] : o.node, a, i), this.node;
  }
  n(t2e, "ensureBlock");
  en.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function r2e() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    dw(this);
  }
  n(r2e, "unwrapFunctionEnvironment");
  function s2e(t, e) {
    t.node.type = e;
  }
  n(s2e, "setType");
  function i2e({
    allowInsertArrow: t = !0,
    allowInsertArrowWithRest: e = t,
    noNewArrows: r = !((s) => (s = arguments[0]) == null ? void 0 : s.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let {
      thisBinding: s,
      fnPath: i
    } = dw(this, r, t, e);
    if (i.ensureBlock(), s2e(i, "FunctionExpression"), !r) {
      let a = s ? null : i.scope.generateUidIdentifier("arrowCheckId");
      return a && i.parentPath.scope.push({
        id: a,
        init: XNe([])
      }), i.get("body").unshiftContainer("body", fw(Hn(this.hub.addHelper("newArrowCheck"), [Bo(), kt(a ? a.name : s)]))), i.replaceWith(Hn(
      Zr((0, jNe.default)(this, !0) || i.node, kt("bind")), [a ? kt(a.name) : Bo()])), i.get("callee.object");
    }
    return i;
  }
  n(i2e, "arrowFunctionToExpression");
  var n2e = (0, O0.merge)([{
    CallExpression(t, {
      allSuperCalls: e
    }) {
      t.get("callee").isSuper() && e.push(t);
    }
  }, N0.default]);
  function dw(t, e = !0, r = !0, s = !0) {
    let i, a = t.findParent((y) => {
      if (y.isArrowFunctionExpression()) {
        var T;
        return (T = i) != null || (i = y), !1;
      }
      return y.isFunction() || y.isProgram() || y.isClassProperty({
        static: !1
      }) || y.isClassPrivateProperty({
        static: !1
      });
    }), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (i)
        a = i;
      else if (r)
        t.replaceWith(Hn(k0([], QNe(t.node)), [])), a = t.get("callee"), t = a.get("body");
      else
        throw t.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: p,
      superCalls: f
    } = h2e(t);
    if (o && f.length > 0) {
      if (!r)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!s)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let y = [];
      a.traverse(n2e, {
        allSuperCalls: y
      });
      let T = c2e(a);
      y.forEach((L) => {
        let q = kt(T);
        q.loc = L.node.callee.loc, L.get("callee").replaceWith(q);
      });
    }
    if (u.length > 0) {
      let y = Fo(a, "arguments", () => {
        let T = /* @__PURE__ */ n(() => kt("arguments"), "args");
        return a.scope.path.isProgram() ? UNe(I0("===", ZNe("typeof", T()), hw("undefined")), a.scope.buildUndefinedNode(), T()) : T();
      });
      u.forEach((T) => {
        let L = kt(y);
        L.loc = T.node.loc, T.replaceWith(L);
      });
    }
    if (c.length > 0) {
      let y = Fo(a, "newtarget", () => YNe(kt("new"), kt("target")));
      c.forEach((T) => {
        let L = kt(y);
        L.loc = T.node.loc, T.replaceWith(L);
      });
    }
    if (p.length > 0) {
      if (!r)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      p.reduce((T, L) => T.concat(o2e(L)), []).forEach((T) => {
        let L = T.node.computed ? "" : T.get("property").node.name, q = T.parentPath, _ = q.isAssignmentExpression({
          left: T.node
        }), U = q.isCallExpression({
          callee: T.node
        }), J = q.isTaggedTemplateExpression({
          tag: T.node
        }), ie = p2e(a, _, L), de = [];
        if (T.node.computed && de.push(T.get("property").node), _) {
          let Be = q.node.right;
          de.push(Be);
        }
        let ne = Hn(kt(ie), de);
        U ? (q.unshiftContainer("arguments", Bo()), T.replaceWith(Zr(ne, kt("call"))), l.push(q.get("arguments.0"))) : _ ? q.replaceWith(ne) :
        J ? (T.replaceWith(Hn(Zr(ne, kt("bind"), !1), [Bo()])), l.push(T.get("arguments.0"))) : T.replaceWith(ne);
      });
    }
    let m;
    return (l.length > 0 || !e) && (m = u2e(a, o), (e || o && mw(a)) && (l.forEach((y) => {
      let T = y.isJSX() ? VNe(m) : kt(m);
      T.loc = y.node.loc, y.replaceWith(T);
    }), e || (m = null))), {
      thisBinding: m,
      fnPath: t
    };
  }
  n(dw, "hoistFunctionEnvironment");
  function a2e(t) {
    return WNe.includes(t);
  }
  n(a2e, "isLogicalOp");
  function o2e(t) {
    if (t.parentPath.isAssignmentExpression() && t.parentPath.node.operator !== "=") {
      let r = t.parentPath, s = r.node.operator.slice(0, -1), i = r.node.right, a = a2e(s);
      if (t.node.computed) {
        let o = t.scope.generateDeclaredUidIdentifier("tmp"), l = t.node.object, u = t.node.property;
        r.get("left").replaceWith(Zr(l, Zi("=", o, u), !0)), r.get("right").replaceWith(e(a ? "=" : s, Zr(l, kt(o.name), !0), i));
      } else {
        let o = t.node.object, l = t.node.property;
        r.get("left").replaceWith(Zr(o, l)), r.get("right").replaceWith(e(a ? "=" : s, Zr(o, kt(l.name)), i));
      }
      return a ? r.replaceWith(KNe(s, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
    } else if (t.parentPath.isUpdateExpression()) {
      let r = t.parentPath, s = t.scope.generateDeclaredUidIdentifier("tmp"), i = t.node.computed ? t.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [Zi("=", s, Zr(t.node.object, i ? Zi("=", i, t.node.property) : t.node.property, t.node.computed)), Zi("=", Zr(t.node.object,
      i ? kt(i.name) : t.node.property, t.node.computed), I0(t.parentPath.node.operator[0], kt(s.name), JNe(1)))];
      t.parentPath.node.prefix || a.push(kt(s.name)), r.replaceWith(zNe(a));
      let o = r.get("expressions.0.right"), l = r.get("expressions.1.left");
      return [o, l];
    }
    return [t];
    function e(r, s, i) {
      return r === "=" ? Zi("=", s, i) : I0(r, s, i);
    }
  }
  n(o2e, "standardizeSuperProperty");
  function mw(t) {
    return t.isClassMethod() && !!t.parentPath.parentPath.node.superClass;
  }
  n(mw, "hasSuperClass");
  var l2e = (0, O0.merge)([{
    CallExpression(t, {
      supers: e,
      thisBinding: r
    }) {
      t.get("callee").isSuper() && (e.has(t.node) || (e.add(t.node), t.replaceWithMultiple([t.node, Zi("=", kt(r), kt("this"))])));
    }
  }, N0.default]);
  function u2e(t, e) {
    return Fo(t, "this", (r) => {
      if (!e || !mw(t)) return Bo();
      t.traverse(l2e, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: r
      });
    });
  }
  n(u2e, "getThisBinding");
  function c2e(t) {
    return Fo(t, "supercall", () => {
      let e = t.scope.generateUidIdentifier("args");
      return k0([$Ne(e)], Hn(w0(), [GNe(kt(e.name))]));
    });
  }
  n(c2e, "getSuperBinding");
  function p2e(t, e, r) {
    return Fo(t, `superprop_${e ? "set" : "get"}:${r || ""}`, () => {
      let i = [], a;
      if (r)
        a = Zr(w0(), kt(r));
      else {
        let o = t.scope.generateUidIdentifier("prop");
        i.unshift(o), a = Zr(w0(), kt(o.name), !0);
      }
      if (e) {
        let o = t.scope.generateUidIdentifier("value");
        i.push(o), a = Zi("=", a, kt(o.name));
      }
      return k0(i, a);
    });
  }
  n(p2e, "getSuperPropBinding");
  function Fo(t, e, r) {
    let s = "binding:" + e, i = t.getData(s);
    if (!i) {
      let a = t.scope.generateUidIdentifier(e);
      i = a.name, t.setData(s, i), t.scope.push({
        id: a,
        init: r(i)
      });
    }
    return i;
  }
  n(Fo, "getBinding");
  var f2e = (0, O0.merge)([{
    ThisExpression(t, {
      thisPaths: e
    }) {
      e.push(t);
    },
    JSXIdentifier(t, {
      thisPaths: e
    }) {
      t.node.name === "this" && (!t.parentPath.isJSXMemberExpression({
        object: t.node
      }) && !t.parentPath.isJSXOpeningElement({
        name: t.node
      }) || e.push(t));
    },
    CallExpression(t, {
      superCalls: e
    }) {
      t.get("callee").isSuper() && e.push(t);
    },
    MemberExpression(t, {
      superProps: e
    }) {
      t.get("object").isSuper() && e.push(t);
    },
    Identifier(t, {
      argumentsPaths: e
    }) {
      if (!t.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let r = t.scope;
      do {
        if (r.hasOwnBinding("arguments")) {
          r.rename("arguments");
          return;
        }
        if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
      } while (r = r.parent);
      e.push(t);
    },
    MetaProperty(t, {
      newTargetPaths: e
    }) {
      t.get("meta").isIdentifier({
        name: "new"
      }) && t.get("property").isIdentifier({
        name: "target"
      }) && e.push(t);
    }
  }, N0.default]);
  function h2e(t) {
    let e = [], r = [], s = [], i = [], a = [];
    return t.traverse(f2e, {
      thisPaths: e,
      argumentsPaths: r,
      newTargetPaths: s,
      superProps: i,
      superCalls: a
    }), {
      thisPaths: e,
      argumentsPaths: r,
      newTargetPaths: s,
      superProps: i,
      superCalls: a
    };
  }
  n(h2e, "getScopeInformation");
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var Pw = w((Bt) => {
  "use strict";
  Object.defineProperty(Bt, "__esModule", {
    value: !0
  });
  Bt._guessExecutionStatusRelativeTo = B2e;
  Bt._resolve = U2e;
  Bt.canHaveVariableDeclarationOrExpression = w2e;
  Bt.canSwapBetweenExpressionAndStatement = N2e;
  Bt.equals = C2e;
  Bt.getSource = _2e;
  Bt.has = gw;
  Bt.is = void 0;
  Bt.isCompletionRecord = O2e;
  Bt.isConstantExpression = q2e;
  Bt.isInStrictMode = V2e;
  Bt.isNodeType = I2e;
  Bt.isStatementOrBlock = k2e;
  Bt.isStatic = A2e;
  Bt.isnt = v2e;
  Bt.matchesPattern = E2e;
  Bt.referencesImport = D2e;
  Bt.resolve = R2e;
  Bt.willIMaybeExecuteBefore = L2e;
  var d2e = Ce(), {
    STATEMENT_OR_BLOCK_KEYS: m2e,
    VISITOR_KEYS: y2e,
    isBlockStatement: Sw,
    isExpression: T2e,
    isIdentifier: b2e,
    isLiteral: x2e,
    isStringLiteral: S2e,
    isType: g2e,
    matchesPattern: P2e
  } = d2e;
  function E2e(t, e) {
    return P2e(this.node, t, e);
  }
  n(E2e, "matchesPattern");
  function gw(t) {
    let e = this.node && this.node[t];
    return e && Array.isArray(e) ? !!e.length : !!e;
  }
  n(gw, "has");
  function A2e() {
    return this.scope.isStatic(this.node);
  }
  n(A2e, "isStatic");
  var fUe = Bt.is = gw;
  function v2e(t) {
    return !this.has(t);
  }
  n(v2e, "isnt");
  function C2e(t, e) {
    return this.node[t] === e;
  }
  n(C2e, "equals");
  function I2e(t) {
    return g2e(this.type, t);
  }
  n(I2e, "isNodeType");
  function w2e() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  n(w2e, "canHaveVariableDeclarationOrExpression");
  function N2e(t) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? Sw(t) : this.isBlockStatement() ?
    T2e(t) : !1;
  }
  n(N2e, "canSwapBetweenExpressionAndStatement");
  function O2e(t) {
    let e = this, r = !0;
    do {
      let {
        type: s,
        container: i
      } = e;
      if (!r && (e.isFunction() || s === "StaticBlock"))
        return !!t;
      if (r = !1, Array.isArray(i) && e.key !== i.length - 1)
        return !1;
    } while ((e = e.parentPath) && !e.isProgram() && !e.isDoExpression());
    return !0;
  }
  n(O2e, "isCompletionRecord");
  function k2e() {
    return this.parentPath.isLabeledStatement() || Sw(this.container) ? !1 : m2e.includes(this.key);
  }
  n(k2e, "isStatementOrBlock");
  function D2e(t, e) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === e || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? S2e(this.node.property, {
        value: e
      }) : this.node.property.name === e)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(t, "*");
      }
      return !1;
    }
    let r = this.scope.getBinding(this.node.name);
    if (!r || r.kind !== "module") return !1;
    let s = r.path, i = s.parentPath;
    if (!i.isImportDeclaration()) return !1;
    if (i.node.source.value === t) {
      if (!e) return !0;
    } else
      return !1;
    return !!(s.isImportDefaultSpecifier() && e === "default" || s.isImportNamespaceSpecifier() && e === "*" || s.isImportSpecifier() && b2e(
    s.node.imported, {
      name: e
    }));
  }
  n(D2e, "referencesImport");
  function _2e() {
    let t = this.node;
    if (t.end) {
      let e = this.hub.getCode();
      if (e) return e.slice(t.start, t.end);
    }
    return "";
  }
  n(_2e, "getSource");
  function L2e(t) {
    return this._guessExecutionStatusRelativeTo(t) !== "after";
  }
  n(L2e, "willIMaybeExecuteBefore");
  function Tw(t) {
    return t.isProgram() ? t : (t.parentPath.scope.getFunctionParent() || t.parentPath.scope.getProgramParent()).path;
  }
  n(Tw, "getOuterFunction");
  function M2e(t, e) {
    switch (t) {
      case "LogicalExpression":
        return e === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return e === "consequent" || e === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return e === "body";
      case "ForStatement":
        return e === "body" || e === "update";
      case "SwitchStatement":
        return e === "cases";
      case "TryStatement":
        return e === "handler";
      case "AssignmentPattern":
        return e === "right";
      case "OptionalMemberExpression":
        return e === "property";
      case "OptionalCallExpression":
        return e === "arguments";
      default:
        return !1;
    }
  }
  n(M2e, "isExecutionUncertain");
  function bw(t, e) {
    for (let r = 0; r < e; r++) {
      let s = t[r];
      if (M2e(s.parent.type, s.parentKey))
        return !0;
    }
    return !1;
  }
  n(bw, "isExecutionUncertainInList");
  var xw = Symbol();
  function B2e(t) {
    return D0(this, t, /* @__PURE__ */ new Map());
  }
  n(B2e, "_guessExecutionStatusRelativeTo");
  function D0(t, e, r) {
    let s = {
      this: Tw(t),
      target: Tw(e)
    };
    if (s.target.node !== s.this.node)
      return j2e(t, s.target, r);
    let i = {
      target: e.getAncestry(),
      this: t.getAncestry()
    };
    if (i.target.indexOf(t) >= 0) return "after";
    if (i.this.indexOf(e) >= 0) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < i.this.length; ) {
      let p = i.this[o.this];
      o.target = i.target.indexOf(p), o.target >= 0 ? a = p : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (bw(i.this, o.this - 1) || bw(i.target, o.target - 1))
      return "unknown";
    let l = {
      this: i.this[o.this - 1],
      target: i.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = y2e[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  n(D0, "_guessExecutionStatusRelativeToCached");
  function F2e(t, e, r) {
    if (e.isFunctionDeclaration()) {
      if (e.parentPath.isExportDeclaration())
        return "unknown";
    } else return D0(t, e, r) === "before" ? "before" : "unknown";
    let s = e.scope.getBinding(e.node.id.name);
    if (!s.references) return "before";
    let i = s.referencePaths, a;
    for (let o of i) {
      if (!!o.find((c) => c.node === e.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = D0(t, o, r);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  n(F2e, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function j2e(t, e, r) {
    let s = r.get(t.node), i;
    if (!s)
      r.set(t.node, s = /* @__PURE__ */ new Map());
    else if (i = s.get(e.node))
      return i === xw ? "unknown" : i;
    s.set(e.node, xw);
    let a = F2e(t, e, r);
    return s.set(e.node, a), a;
  }
  n(j2e, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function R2e(t, e) {
    return this._resolve(t, e) || this;
  }
  n(R2e, "resolve");
  function U2e(t, e) {
    if (!(e && e.indexOf(this) >= 0))
      if (e = e || [], e.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(t, e);
      } else if (this.isReferencedIdentifier()) {
        let r = this.scope.getBinding(this.node.name);
        if (!r || !r.constant || r.kind === "module") return;
        if (r.path !== this) {
          let s = r.path.resolve(t, e);
          return this.find((i) => i.node === s.node) ? void 0 : s;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(t, e);
        if (t && this.isMemberExpression()) {
          let r = this.toComputedKey();
          if (!x2e(r)) return;
          let s = r.value, i = this.get("object").resolve(t, e);
          if (i.isObjectExpression()) {
            let a = i.get("properties");
            for (let o of a) {
              if (!o.isProperty()) continue;
              let l = o.get("key"), u = o.isnt("computed") && l.isIdentifier({
                name: s
              });
              if (u = u || l.isLiteral({
                value: s
              }), u) return o.get("value").resolve(t, e);
            }
          } else if (i.isArrayExpression() && !isNaN(+s)) {
            let o = i.get("elements")[s];
            if (o) return o.resolve(t, e);
          }
        }
      }
  }
  n(U2e, "_resolve");
  function q2e() {
    if (this.isIdentifier()) {
      let t = this.scope.getBinding(this.node.name);
      return t ? t.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((t) => t.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: t
      } = this.node;
      return t !== "in" && t !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  n(q2e, "isConstantExpression");
  function V2e() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({
        sourceType: "module"
      }) || r.isClass()) return !0;
      if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
        return !1;
      let s;
      if (r.isFunction())
        s = r.node.body;
      else if (r.isProgram())
        s = r.node;
      else
        return !1;
      for (let i of s.directives)
        if (i.value.value === "use strict")
          return !0;
    });
  }
  n(V2e, "isInStrictMode");
});

// ../node_modules/@babel/traverse/lib/path/context.js
var vw = w((Lt) => {
  "use strict";
  Object.defineProperty(Lt, "__esModule", {
    value: !0
  });
  Lt._call = Y2e;
  Lt._getQueueContexts = uOe;
  Lt._resyncKey = tOe;
  Lt._resyncList = rOe;
  Lt._resyncParent = eOe;
  Lt._resyncRemoved = sOe;
  Lt.call = W2e;
  Lt.isBlacklisted = Lt.isDenylisted = J2e;
  Lt.popContext = iOe;
  Lt.pushContext = nOe;
  Lt.requeue = lOe;
  Lt.resync = Z2e;
  Lt.setContext = Q2e;
  Lt.setKey = oOe;
  Lt.setScope = G2e;
  Lt.setup = aOe;
  Lt.skip = $2e;
  Lt.skipKey = H2e;
  Lt.stop = z2e;
  Lt.visit = X2e;
  var K2e = eu(), Ew = oi();
  function W2e(t) {
    let e = this.opts;
    if (this.debug(t), this.node && this._call(e[t]))
      return !0;
    if (this.node) {
      var r;
      return this._call((r = e[this.node.type]) == null ? void 0 : r[t]);
    }
    return !1;
  }
  n(W2e, "call");
  function Y2e(t) {
    if (!t) return !1;
    for (let e of t) {
      if (!e) continue;
      let r = this.node;
      if (!r) return !0;
      let s = e.call(this.state, this, this.state);
      if (s && typeof s == "object" && typeof s.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (s)
        throw new Error(`Unexpected return value from visitor method ${e}`);
      if (this.node !== r || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  n(Y2e, "_call");
  function J2e() {
    var t;
    let e = (t = this.opts.denylist) != null ? t : this.opts.blacklist;
    return e && e.indexOf(this.node.type) > -1;
  }
  n(J2e, "isDenylisted");
  function Aw(t, e) {
    t.context !== e && (t.context = e, t.state = e.state, t.opts = e.opts);
  }
  n(Aw, "restoreContext");
  function X2e() {
    var t, e;
    if (!this.node || this.isDenylisted() || (t = (e = this.opts).shouldSkip) != null && t.call(e, this))
      return !1;
    let r = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (Aw(this, r), this.debug("Recursing into..."),
    this.shouldStop = (0, K2e.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), Aw(this, r), this.call("exit"),
    this.shouldStop);
  }
  n(X2e, "visit");
  function $2e() {
    this.shouldSkip = !0;
  }
  n($2e, "skip");
  function H2e(t) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[t] = !0;
  }
  n(H2e, "skipKey");
  function z2e() {
    this._traverseFlags |= Ew.SHOULD_SKIP | Ew.SHOULD_STOP;
  }
  n(z2e, "stop");
  function G2e() {
    var t, e;
    if ((t = this.opts) != null && t.noScope) return;
    let r = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.
    parentPath);
    let s;
    for (; r && !s; ) {
      var i;
      if ((i = r.opts) != null && i.noScope) return;
      s = r.scope, r = r.parentPath;
    }
    this.scope = this.getScope(s), (e = this.scope) == null || e.init();
  }
  n(G2e, "setScope");
  function Q2e(t) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, t && (this.context = t, this.state = t.state, this.opts =
    t.opts), this.setScope(), this;
  }
  n(Q2e, "setContext");
  function Z2e() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }
  n(Z2e, "resync");
  function eOe() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  n(eOe, "_resyncParent");
  function tOe() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let t = 0; t < this.container.length; t++)
          if (this.container[t] === this.node) {
            this.setKey(t);
            return;
          }
      } else
        for (let t of Object.keys(this.container))
          if (this.container[t] === this.node) {
            this.setKey(t);
            return;
          }
      this.key = null;
    }
  }
  n(tOe, "_resyncKey");
  function rOe() {
    if (!this.parent || !this.inList) return;
    let t = this.parent[this.listKey];
    this.container !== t && (this.container = t || null);
  }
  n(rOe, "_resyncList");
  function sOe() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved();
  }
  n(sOe, "_resyncRemoved");
  function iOe() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  n(iOe, "popContext");
  function nOe(t) {
    this.contexts.push(t), this.setContext(t);
  }
  n(nOe, "pushContext");
  function aOe(t, e, r, s) {
    this.listKey = r, this.container = e, this.parentPath = t || this.parentPath, this.setKey(s);
  }
  n(aOe, "setup");
  function oOe(t) {
    var e;
    this.key = t, this.node = this.container[this.key], this.type = (e = this.node) == null ? void 0 : e.type;
  }
  n(oOe, "setKey");
  function lOe(t = this) {
    if (t.removed) return;
    let e = this.contexts;
    for (let r of e)
      r.maybeQueue(t);
  }
  n(lOe, "requeue");
  function uOe() {
    let t = this, e = this.contexts;
    for (; !e.length && (t = t.parentPath, !!t); )
      e = t.contexts;
    return e;
  }
  n(uOe, "_getQueueContexts");
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var Cw = w((wc) => {
  "use strict";
  Object.defineProperty(wc, "__esModule", {
    value: !0
  });
  wc.hooks = void 0;
  var TUe = wc.hooks = [function(t, e) {
    if (t.key === "test" && (e.isWhile() || e.isSwitchCase()) || t.key === "declaration" && e.isExportDeclaration() || t.key === "body" && e.
    isLabeledStatement() || t.listKey === "declarations" && e.isVariableDeclaration() && e.node.declarations.length === 1 || t.key === "expr\
ession" && e.isExpressionStatement())
      return e.remove(), !0;
  }, function(t, e) {
    if (e.isSequenceExpression() && e.node.expressions.length === 1)
      return e.replaceWith(e.node.expressions[0]), !0;
  }, function(t, e) {
    if (e.isBinary())
      return t.key === "left" ? e.replaceWith(e.node.right) : e.replaceWith(e.node.left), !0;
  }, function(t, e) {
    if (e.isIfStatement() && t.key === "consequent" || t.key === "body" && (e.isLoop() || e.isArrowFunctionExpression()))
      return t.replaceWith({
        type: "BlockStatement",
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var ww = w((yi) => {
  "use strict";
  Object.defineProperty(yi, "__esModule", {
    value: !0
  });
  yi._assertUnremoved = xOe;
  yi._callRemovalHooks = yOe;
  yi._markRemoved = bOe;
  yi._remove = TOe;
  yi._removeFromScope = mOe;
  yi.remove = dOe;
  var cOe = Cw(), pOe = Li(), Iw = oi(), fOe = Ce(), {
    getBindingIdentifiers: hOe
  } = fOe;
  function dOe() {
    var t;
    if (this._assertUnremoved(), this.resync(), (t = this.opts) != null && t.noScope || this._removeFromScope(), this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }
  n(dOe, "remove");
  function mOe() {
    let t = hOe(this.node, !1, !1, !0);
    Object.keys(t).forEach((e) => this.scope.removeBinding(e));
  }
  n(mOe, "_removeFromScope");
  function yOe() {
    if (this.parentPath) {
      for (let t of cOe.hooks)
        if (t(this, this.parentPath)) return !0;
    }
  }
  n(yOe, "_callRemovalHooks");
  function TOe() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }
  n(TOe, "_remove");
  function bOe() {
    this._traverseFlags |= Iw.SHOULD_SKIP | Iw.REMOVED, this.parent && (0, pOe.getCachedPaths)(this.hub, this.parent).delete(this.node), this.
    node = null;
  }
  n(bOe, "_markRemoved");
  function xOe() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  n(xOe, "_assertUnremoved");
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var Ow = w((Nc) => {
  "use strict";
  Object.defineProperty(Nc, "__esModule", {
    value: !0
  });
  Nc.default = void 0;
  var Nw = Ce(), SOe = Nw, {
    react: gOe
  } = Nw, {
    cloneNode: POe,
    jsxExpressionContainer: EOe,
    variableDeclaration: AOe,
    variableDeclarator: vOe
  } = SOe, COe = {
    ReferencedIdentifier(t, e) {
      if (t.isJSXIdentifier() && gOe.isCompatTag(t.node.name) && !t.parentPath.isJSXMemberExpression())
        return;
      if (t.node.name === "this") {
        let s = t.scope;
        do
          if (s.path.isFunction() && !s.path.isArrowFunctionExpression())
            break;
        while (s = s.parent);
        s && e.breakOnScopePaths.push(s.path);
      }
      let r = t.scope.getBinding(t.node.name);
      if (r) {
        for (let s of r.constantViolations)
          if (s.scope !== r.path.scope) {
            e.mutableBinding = !0, t.stop();
            return;
          }
        r === e.scope.getBinding(t.node.name) && (e.bindings[t.node.name] = r);
      }
    }
  }, _0 = class {
    static {
      n(this, "PathHoister");
    }
    constructor(e, r) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = r, this.path = e, this.attachAfter = !1;
    }
    isCompatibleScope(e) {
      for (let r of Object.keys(this.bindings)) {
        let s = this.bindings[r];
        if (!e.bindingIdentifierEquals(r, s.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let e = this.path.scope;
      do {
        if (this.isCompatibleScope(e))
          this.scopes.push(e);
        else
          break;
        if (this.breakOnScopePaths.indexOf(e.path) >= 0)
          break;
      } while (e = e.parent);
    }
    getAttachmentPath() {
      let e = this._getAttachmentPath();
      if (!e) return;
      let r = e.scope;
      if (r.path === e && (r = e.scope.parent), r.path.isProgram() || r.path.isFunction())
        for (let s of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(s)) continue;
          let i = this.bindings[s];
          if (i.kind === "param" || i.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(i.path).key >= e.key) {
            this.attachAfter = !0, e = i.path;
            for (let o of i.constantViolations)
              this.getAttachmentParentForPath(o).key > e.key && (e = o);
          }
        }
      return e;
    }
    _getAttachmentPath() {
      let r = this.scopes.pop();
      if (r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return;
            let s = r.path.get("body").get("body");
            for (let i = 0; i < s.length; i++)
              if (!s[i].node._blockHoist)
                return s[i];
          } else
            return this.getNextScopeAttachmentParent();
        else if (r.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let e = this.scopes.pop();
      if (e) return this.getAttachmentParentForPath(e.path);
    }
    getAttachmentParentForPath(e) {
      do
        if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
          return e;
      while (e = e.parentPath);
    }
    hasOwnParamBindings(e) {
      for (let r of Object.keys(this.bindings)) {
        if (!e.hasOwnBinding(r)) continue;
        let s = this.bindings[r];
        if (s.kind === "param" && s.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(COe, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let e = this.getAttachmentPath();
      if (!e || e.getFunctionParent() === this.path.getFunctionParent()) return;
      let r = e.scope.generateUidIdentifier("ref"), s = vOe(r, this.path.node), i = this.attachAfter ? "insertAfter" : "insertBefore", [a] = e[i](
      [e.isVariableDeclarator() ? s : AOe("var", [s])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (r = EOe(r)), this.path.replaceWith(POe(r)), e.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  Nc.default = _0;
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var Mw = w((Kr) => {
  "use strict";
  Object.defineProperty(Kr, "__esModule", {
    value: !0
  });
  Kr._containerInsert = VOe;
  Kr._containerInsertAfter = WOe;
  Kr._containerInsertBefore = KOe;
  Kr._verifyNodeList = $Oe;
  Kr.hoist = GOe;
  Kr.insertAfter = JOe;
  Kr.insertBefore = qOe;
  Kr.pushContainer = zOe;
  Kr.unshiftContainer = HOe;
  Kr.updateSiblingKeys = XOe;
  var IOe = Li(), wOe = Ow(), B0 = oi(), NOe = Ce(), {
    arrowFunctionExpression: OOe,
    assertExpression: kOe,
    assignmentExpression: DOe,
    blockStatement: kw,
    callExpression: _Oe,
    cloneNode: L0,
    expressionStatement: M0,
    isAssignmentExpression: LOe,
    isCallExpression: MOe,
    isExportNamedDeclaration: Dw,
    isExpression: BOe,
    isIdentifier: FOe,
    isSequenceExpression: jOe,
    isSuper: ROe,
    thisExpression: UOe
  } = NOe;
  function qOe(t) {
    this._assertUnremoved();
    let e = this._verifyNodeList(t), {
      parentPath: r,
      parent: s
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || Dw(s) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertBefore(e);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init")
      return this.node && e.push(this.node), this.replaceExpressionWithStatements(e);
    if (Array.isArray(this.container))
      return this._containerInsertBefore(e);
    if (this.isStatementOrBlock()) {
      let i = this.node, a = i && (!this.isExpressionStatement() || i.expression != null);
      return this.replaceWith(kw(a ? [i] : [])), this.unshiftContainer("body", e);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  n(qOe, "insertBefore");
  function VOe(t, e) {
    this.updateSiblingKeys(t, e.length);
    let r = [];
    this.container.splice(t, 0, ...e);
    for (let a = 0; a < e.length; a++) {
      var s;
      let o = t + a, l = this.getSibling(o);
      r.push(l), (s = this.context) != null && s.queue && l.pushContext(this.context);
    }
    let i = this._getQueueContexts();
    for (let a of r) {
      a.setScope(), a.debug("Inserted.");
      for (let o of i)
        o.maybeQueue(a, !0);
    }
    return r;
  }
  n(VOe, "_containerInsert");
  function KOe(t) {
    return this._containerInsert(this.key, t);
  }
  n(KOe, "_containerInsertBefore");
  function WOe(t) {
    return this._containerInsert(this.key + 1, t);
  }
  n(WOe, "_containerInsertAfter");
  var _w = /* @__PURE__ */ n((t) => t[t.length - 1], "last");
  function Lw(t) {
    return jOe(t.parent) && (_w(t.parent.expressions) !== t.node || Lw(t.parentPath));
  }
  n(Lw, "isHiddenInSequenceExpression");
  function YOe(t, e) {
    if (!LOe(t) || !FOe(t.left))
      return !1;
    let r = e.getBlockParent();
    return r.hasOwnBinding(t.left.name) && r.getOwnBinding(t.left.name).constantViolations.length <= 1;
  }
  n(YOe, "isAlmostConstantAssignment");
  function JOe(t) {
    if (this._assertUnremoved(), this.isSequenceExpression())
      return _w(this.get("expressions")).insertAfter(t);
    let e = this._verifyNodeList(t), {
      parentPath: r,
      parent: s
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || Dw(s) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertAfter(e.map((i) => BOe(i) ? M0(i) : i));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
      if (this.node) {
        let i = this.node, {
          scope: a
        } = this;
        if (a.path.isPattern())
          return kOe(i), this.replaceWith(_Oe(OOe([], i), [])), this.get("callee.body").insertAfter(e), [this];
        if (Lw(this))
          e.unshift(i);
        else if (MOe(i) && ROe(i.callee))
          e.unshift(i), e.push(UOe());
        else if (YOe(i, a))
          e.unshift(i), e.push(L0(i.left));
        else if (a.isPure(i, !0))
          e.push(i);
        else {
          r.isMethod({
            computed: !0,
            key: i
          }) && (a = a.parent);
          let o = a.generateDeclaredUidIdentifier();
          e.unshift(M0(DOe("=", L0(o), i))), e.push(M0(L0(o)));
        }
      }
      return this.replaceExpressionWithStatements(e);
    } else {
      if (Array.isArray(this.container))
        return this._containerInsertAfter(e);
      if (this.isStatementOrBlock()) {
        let i = this.node, a = i && (!this.isExpressionStatement() || i.expression != null);
        return this.replaceWith(kw(a ? [i] : [])), this.pushContainer("body", e);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  n(JOe, "insertAfter");
  function XOe(t, e) {
    if (!this.parent) return;
    let r = (0, IOe.getCachedPaths)(this.hub, this.parent) || [];
    for (let [, s] of r)
      typeof s.key == "number" && s.key >= t && (s.key += e);
  }
  n(XOe, "updateSiblingKeys");
  function $Oe(t) {
    if (!t)
      return [];
    Array.isArray(t) || (t = [t]);
    for (let e = 0; e < t.length; e++) {
      let r = t[e], s;
      if (r ? typeof r != "object" ? s = "contains a non-object node" : r.type ? r instanceof B0.default && (s = "has a NodePath when it exp\
ected a raw object") : s = "without a type" : s = "has falsy node", s) {
        let i = Array.isArray(r) ? "array" : typeof r;
        throw new Error(`Node list ${s} with the index of ${e} and type of ${i}`);
      }
    }
    return t;
  }
  n($Oe, "_verifyNodeList");
  function HOe(t, e) {
    return this._assertUnremoved(), e = this._verifyNodeList(e), B0.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[t],
      listKey: t,
      key: 0
    }).setContext(this.context)._containerInsertBefore(e);
  }
  n(HOe, "unshiftContainer");
  function zOe(t, e) {
    this._assertUnremoved();
    let r = this._verifyNodeList(e), s = this.node[t];
    return B0.default.get({
      parentPath: this,
      parent: this.node,
      container: s,
      listKey: t,
      key: s.length
    }).setContext(this.context).replaceWithMultiple(r);
  }
  n(zOe, "pushContainer");
  function GOe(t = this.scope) {
    return new wOe.default(this, t).run();
  }
  n(GOe, "hoist");
});

// ../node_modules/@babel/traverse/lib/path/family.js
var jw = w((ar) => {
  "use strict";
  Object.defineProperty(ar, "__esModule", {
    value: !0
  });
  ar._getKey = mke;
  ar._getPattern = yke;
  ar.get = dke;
  ar.getAllNextSiblings = fke;
  ar.getAllPrevSiblings = hke;
  ar.getBindingIdentifierPaths = xke;
  ar.getBindingIdentifiers = Tke;
  ar.getCompletionRecords = lke;
  ar.getNextSibling = pke;
  ar.getOpposite = nke;
  ar.getOuterBindingIdentifierPaths = Ske;
  ar.getOuterBindingIdentifiers = bke;
  ar.getPrevSibling = cke;
  ar.getSibling = uke;
  var j0 = oi(), QOe = Ce(), {
    getBindingIdentifiers: Fw,
    getOuterBindingIdentifiers: ZOe,
    isDeclaration: eke,
    numericLiteral: tke,
    unaryExpression: rke
  } = QOe, R0 = 0, jo = 1;
  function ske(t) {
    return {
      type: R0,
      path: t
    };
  }
  n(ske, "NormalCompletion");
  function ike(t) {
    return {
      type: jo,
      path: t
    };
  }
  n(ike, "BreakCompletion");
  function nke() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  n(nke, "getOpposite");
  function zn(t, e, r) {
    return t && e.push(...Gn(t, r)), e;
  }
  n(zn, "addCompletionRecords");
  function ake(t, e, r) {
    let s = [];
    for (let i = 0; i < t.length; i++) {
      let a = t[i], o = Gn(a, r), l = [], u = [];
      for (let c of o)
        c.type === R0 && l.push(c), c.type === jo && u.push(c);
      l.length && (s = l), e.push(...u);
    }
    return e.push(...s), e;
  }
  n(ake, "completionRecordForSwitch");
  function oke(t) {
    t.forEach((e) => {
      e.type = jo;
    });
  }
  n(oke, "normalCompletionToBreak");
  function F0(t, e) {
    t.forEach((r) => {
      r.path.isBreakStatement({
        label: null
      }) && (e ? r.path.replaceWith(rke("void", tke(0))) : r.path.remove());
    });
  }
  n(F0, "replaceBreakStatementInBreakCompletion");
  function Bw(t, e) {
    let r = [];
    if (e.canHaveBreak) {
      let s = [];
      for (let i = 0; i < t.length; i++) {
        let a = t[i], o = Object.assign({}, e, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (e.inCaseClause || e.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = Gn(a, o);
        if (l.length > 0 && l.every((u) => u.type === jo)) {
          s.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (oke(s), r.push(...s), s.some((u) => u.path.isDeclaration()) && (r.push(...l), F0(l, !0)), F0(l, !1)) : (r.push(...l), e.shouldPopulateBreak ||
          F0(l, !0));
          break;
        }
        if (i === t.length - 1)
          r.push(...l);
        else {
          s = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === jo && r.push(c), c.type === R0 && s.push(c);
          }
        }
      }
    } else if (t.length)
      for (let s = t.length - 1; s >= 0; s--) {
        let i = Gn(t[s], e);
        if (i.length > 1 || i.length === 1 && !i[0].path.isVariableDeclaration()) {
          r.push(...i);
          break;
        }
      }
    return r;
  }
  n(Bw, "getStatementListCompletion");
  function Gn(t, e) {
    let r = [];
    if (t.isIfStatement())
      r = zn(t.get("consequent"), r, e), r = zn(t.get("alternate"), r, e);
    else {
      if (t.isDoExpression() || t.isFor() || t.isWhile() || t.isLabeledStatement())
        return zn(t.get("body"), r, e);
      if (t.isProgram() || t.isBlockStatement())
        return Bw(t.get("body"), e);
      if (t.isFunction())
        return Gn(t.get("body"), e);
      if (t.isTryStatement())
        r = zn(t.get("block"), r, e), r = zn(t.get("handler"), r, e);
      else {
        if (t.isCatchClause())
          return zn(t.get("body"), r, e);
        if (t.isSwitchStatement())
          return ake(t.get("cases"), r, e);
        if (t.isSwitchCase())
          return Bw(t.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        t.isBreakStatement() ? r.push(ike(t)) : r.push(ske(t));
      }
    }
    return r;
  }
  n(Gn, "_getCompletionRecords");
  function lke() {
    return Gn(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((e) => e.path);
  }
  n(lke, "getCompletionRecords");
  function uke(t) {
    return j0.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: t
    }).setContext(this.context);
  }
  n(uke, "getSibling");
  function cke() {
    return this.getSibling(this.key - 1);
  }
  n(cke, "getPrevSibling");
  function pke() {
    return this.getSibling(this.key + 1);
  }
  n(pke, "getNextSibling");
  function fke() {
    let t = this.key, e = this.getSibling(++t), r = [];
    for (; e.node; )
      r.push(e), e = this.getSibling(++t);
    return r;
  }
  n(fke, "getAllNextSiblings");
  function hke() {
    let t = this.key, e = this.getSibling(--t), r = [];
    for (; e.node; )
      r.push(e), e = this.getSibling(--t);
    return r;
  }
  n(hke, "getAllPrevSiblings");
  function dke(t, e = !0) {
    e === !0 && (e = this.context);
    let r = t.split(".");
    return r.length === 1 ? this._getKey(t, e) : this._getPattern(r, e);
  }
  n(dke, "get");
  function mke(t, e) {
    let r = this.node, s = r[t];
    return Array.isArray(s) ? s.map((i, a) => j0.default.get({
      listKey: t,
      parentPath: this,
      parent: r,
      container: s,
      key: a
    }).setContext(e)) : j0.default.get({
      parentPath: this,
      parent: r,
      container: r,
      key: t
    }).setContext(e);
  }
  n(mke, "_getKey");
  function yke(t, e) {
    let r = this;
    for (let s of t)
      s === "." ? r = r.parentPath : Array.isArray(r) ? r = r[s] : r = r.get(s, e);
    return r;
  }
  n(yke, "_getPattern");
  function Tke(t) {
    return Fw(this.node, t);
  }
  n(Tke, "getBindingIdentifiers");
  function bke(t) {
    return ZOe(this.node, t);
  }
  n(bke, "getOuterBindingIdentifiers");
  function xke(t = !1, e = !1) {
    let s = [this], i = /* @__PURE__ */ Object.create(null);
    for (; s.length; ) {
      let a = s.shift();
      if (!a || !a.node) continue;
      let o = Fw.keys[a.node.type];
      if (a.isIdentifier()) {
        t ? (i[a.node.name] = i[a.node.name] || []).push(a) : i[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        eke(l) && s.push(l);
        continue;
      }
      if (e) {
        if (a.isFunctionDeclaration()) {
          s.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? s.push(...c) : c.node && s.push(c);
        }
    }
    return i;
  }
  n(xke, "getBindingIdentifierPaths");
  function Ske(t = !1) {
    return this.getBindingIdentifierPaths(t, !0);
  }
  n(Ske, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var Uw = w((Ro) => {
  "use strict";
  Object.defineProperty(Ro, "__esModule", {
    value: !0
  });
  Ro.addComment = vke;
  Ro.addComments = Cke;
  Ro.shareCommentsWithSiblings = Ake;
  var gke = Ce(), {
    addComment: Pke,
    addComments: Eke
  } = gke;
  function Ake() {
    if (typeof this.key == "string") return;
    let t = this.node;
    if (!t) return;
    let e = t.trailingComments, r = t.leadingComments;
    if (!e && !r) return;
    let s = this.getSibling(this.key - 1), i = this.getSibling(this.key + 1), a = !!s.node, o = !!i.node;
    a && (r && s.addComments("trailing", Rw(r, s.node.trailingComments)), e && !o && s.addComments("trailing", e)), o && (e && i.addComments(
    "leading", Rw(e, i.node.leadingComments)), r && !a && i.addComments("leading", r));
  }
  n(Ake, "shareCommentsWithSiblings");
  function Rw(t, e) {
    if (!(e != null && e.length)) return t;
    let r = new Set(e);
    return t.filter((s) => !r.has(s));
  }
  n(Rw, "removeIfExisting");
  function vke(t, e, r) {
    Pke(this.node, t, e, r);
  }
  n(vke, "addComment");
  function Cke(t, e) {
    Eke(this.node, t, e);
  }
  n(Cke, "addComments");
});

// ../node_modules/@babel/traverse/lib/path/index.js
var oi = w((ps) => {
  "use strict";
  Object.defineProperty(ps, "__esModule", {
    value: !0
  });
  ps.default = ps.SHOULD_STOP = ps.SHOULD_SKIP = ps.REMOVED = void 0;
  var Ike = kh(), wke = TP(), Nke = Fi(), Oke = Hh(), Vw = Ce(), Oc = Vw, kke = Li(), Dke = CE(), _ke = IE(), Lke = JE(), Mke = L1(), Bke = j1(),
  Fke = yw(), Kw = Pw(), jke = vw(), Rke = ww(), Uke = Mw(), qke = jw(), Vke = Uw(), Kke = _h(), {
    validate: Wke
  } = Vw, qw = wke("babel"), U0 = ps.REMOVED = 1, q0 = ps.SHOULD_STOP = 2, V0 = ps.SHOULD_SKIP = 4, Ti = class t {
    static {
      n(this, "NodePath");
    }
    constructor(e, r) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container =
      null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = r, this.hub = e, this.data = null, this.
      context = null, this.scope = null;
    }
    static get({
      hub: e,
      parentPath: r,
      parent: s,
      container: i,
      listKey: a,
      key: o
    }) {
      if (!e && r && (e = r.hub), !s)
        throw new Error("To get a node path the parent needs to exist");
      let l = i[o], u = kke.getOrCreateCachedPaths(e, s), c = u.get(l);
      return c || (c = new t(e, s), l && u.set(l, c)), c.setup(r, i, a, o), c;
    }
    getScope(e) {
      return this.isScope() ? new Oke.default(this) : e;
    }
    setData(e, r) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[e] = r;
    }
    getData(e, r) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let s = this.data[e];
      return s === void 0 && r !== void 0 && (s = this.data[e] = r), s;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(e, r = SyntaxError) {
      return this.hub.buildError(this.node, e, r);
    }
    traverse(e, r) {
      (0, Nke.default)(this.node, e, this.scope, r, this);
    }
    set(e, r) {
      Wke(this.node, e, r), this.node[e] = r;
    }
    getPathLocation() {
      let e = [], r = this;
      do {
        let s = r.key;
        r.inList && (s = `${r.listKey}[${s}]`), e.unshift(s);
      } while (r = r.parentPath);
      return e.join(".");
    }
    debug(e) {
      qw.enabled && qw(`${this.getPathLocation()} ${this.type}: ${e}`);
    }
    toString() {
      return (0, Dke.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(e) {
      e || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & V0);
    }
    set shouldSkip(e) {
      e ? this._traverseFlags |= V0 : this._traverseFlags &= ~V0;
    }
    get shouldStop() {
      return !!(this._traverseFlags & q0);
    }
    set shouldStop(e) {
      e ? this._traverseFlags |= q0 : this._traverseFlags &= ~q0;
    }
    get removed() {
      return !!(this._traverseFlags & U0);
    }
    set removed(e) {
      e ? this._traverseFlags |= U0 : this._traverseFlags &= ~U0;
    }
  };
  Object.assign(Ti.prototype, _ke, Lke, Mke, Bke, Fke, Kw, jke, Rke, Uke, qke, Vke);
  Ti.prototype._guessExecutionStatusRelativeToDifferentFunctions = Kw._guessExecutionStatusRelativeTo;
  for (let t of Oc.TYPES) {
    let e = `is${t}`, r = Oc[e];
    Ti.prototype[e] = function(s) {
      return r(this.node, s);
    }, Ti.prototype[`assert${t}`] = function(s) {
      if (!r(this.node, s))
        throw new TypeError(`Expected node path of type ${t}`);
    };
  }
  Object.assign(Ti.prototype, Kke);
  for (let t of Object.keys(Ike))
    t[0] !== "_" && (Oc.TYPES.includes(t) || Oc.TYPES.push(t));
  var NUe = ps.default = Ti;
});

// ../node_modules/@babel/traverse/lib/context.js
var Ww = w((kc) => {
  "use strict";
  Object.defineProperty(kc, "__esModule", {
    value: !0
  });
  kc.default = void 0;
  var Yke = oi(), Jke = Ce(), {
    VISITOR_KEYS: Xke
  } = Jke, K0 = class {
    static {
      n(this, "TraversalContext");
    }
    constructor(e, r, s, i) {
      this.queue = null, this.priorityQueue = null, this.parentPath = i, this.scope = e, this.state = s, this.opts = r;
    }
    shouldVisit(e) {
      let r = this.opts;
      if (r.enter || r.exit || r[e.type]) return !0;
      let s = Xke[e.type];
      if (!(s != null && s.length)) return !1;
      for (let i of s)
        if (e[i])
          return !0;
      return !1;
    }
    create(e, r, s, i) {
      return Yke.default.get({
        parentPath: this.parentPath,
        parent: e,
        container: r,
        key: s,
        listKey: i
      });
    }
    maybeQueue(e, r) {
      this.queue && (r ? this.queue.push(e) : this.priorityQueue.push(e));
    }
    visitMultiple(e, r, s) {
      if (e.length === 0) return !1;
      let i = [];
      for (let a = 0; a < e.length; a++) {
        let o = e[a];
        o && this.shouldVisit(o) && i.push(this.create(r, e, a, s));
      }
      return this.visitQueue(i);
    }
    visitSingle(e, r) {
      return this.shouldVisit(e[r]) ? this.visitQueue([this.create(e, e, r)]) : !1;
    }
    visitQueue(e) {
      this.queue = e, this.priorityQueue = [];
      let r = /* @__PURE__ */ new WeakSet(), s = !1, i = 0;
      for (; i < e.length; ) {
        let a = e[i];
        if (i++, a.resync(), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && a.pushContext(this), a.key === null)
         continue;
        let {
          node: o
        } = a;
        if (!r.has(o)) {
          if (o && r.add(o), a.visit()) {
            s = !0;
            break;
          }
          if (this.priorityQueue.length && (s = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e, s))
            break;
        }
      }
      for (let a = 0; a < i; a++)
        e[a].popContext();
      return this.queue = null, s;
    }
    visit(e, r) {
      let s = e[r];
      return s ? Array.isArray(s) ? this.visitMultiple(s, e, r) : this.visitSingle(e, r) : !1;
    }
  };
  kc.default = K0;
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var eu = w((W0) => {
  "use strict";
  Object.defineProperty(W0, "__esModule", {
    value: !0
  });
  W0.traverseNode = Gke;
  var $ke = Ww(), Hke = Ce(), {
    VISITOR_KEYS: zke
  } = Hke;
  function Gke(t, e, r, s, i, a, o) {
    let l = zke[t.type];
    if (!l) return !1;
    let u = new $ke.default(r, e, s, i);
    if (o)
      return a != null && a[i.parentKey] ? !1 : u.visitQueue([i]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(t, c))
        return !0;
    return !1;
  }
  n(Gke, "traverseNode");
});

// ../node_modules/@babel/traverse/lib/hub.js
var Yw = w((Dc) => {
  "use strict";
  Object.defineProperty(Dc, "__esModule", {
    value: !0
  });
  Dc.default = void 0;
  var Y0 = class {
    static {
      n(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(e, r, s = TypeError) {
      return new s(r);
    }
  };
  Dc.default = Y0;
});

// ../node_modules/@babel/traverse/lib/index.js
var Fi = w((Fs) => {
  "use strict";
  Object.defineProperty(Fs, "__esModule", {
    value: !0
  });
  Object.defineProperty(Fs, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rDe.default;
    }, "get")
  });
  Object.defineProperty(Fs, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return eDe.default;
    }, "get")
  });
  Object.defineProperty(Fs, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return tDe.default;
    }, "get")
  });
  Fs.visitors = Fs.default = void 0;
  var Uo = La();
  Fs.visitors = Uo;
  var Qke = Ce(), Zke = Li(), Jw = eu(), eDe = oi(), tDe = Hh(), rDe = Yw(), {
    VISITOR_KEYS: sDe,
    removeProperties: iDe,
    traverseFast: Xw
  } = Qke;
  function Wr(t, e = {}, r, s, i, a) {
    if (t) {
      if (!e.noScope && !r && t.type !== "Program" && t.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${t.
        type} node without passing scope and parentPath.`);
      if (!i && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      sDe[t.type] && (Uo.explode(e), (0, Jw.traverseNode)(t, e, r, s, i, null, a));
    }
  }
  n(Wr, "traverse");
  var jUe = Fs.default = Wr;
  Wr.visitors = Uo;
  Wr.verify = Uo.verify;
  Wr.explode = Uo.explode;
  Wr.cheap = function(t, e) {
    Xw(t, e);
  };
  Wr.node = function(t, e, r, s, i, a) {
    (0, Jw.traverseNode)(t, e, r, s, i, a);
  };
  Wr.clearNode = function(t, e) {
    iDe(t, e);
  };
  Wr.removeProperties = function(t, e) {
    return Xw(t, Wr.clearNode, e), t;
  };
  function nDe(t, e) {
    t.node.type === e.type && (e.has = !0, t.stop());
  }
  n(nDe, "hasDenylistedType");
  Wr.hasType = function(t, e, r) {
    if (r != null && r.includes(t.type)) return !1;
    if (t.type === e) return !0;
    let s = {
      has: !1,
      type: e
    };
    return Wr(t, {
      noScope: !0,
      denylist: r,
      enter: nDe
    }, null, s), s.has;
  };
  Wr.cache = Zke;
});

// ../node_modules/@babel/parser/lib/index.js
var CN = w((Go) => {
  "use strict";
  Object.defineProperty(Go, "__esModule", {
    value: !0
  });
  function uN(t, e) {
    if (t == null) return {};
    var r = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r;
  }
  n(uN, "_objectWithoutPropertiesLoose");
  var hs = class {
    static {
      n(this, "Position");
    }
    constructor(e, r, s) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e, this.column = r, this.index = s;
    }
  }, ta = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(e, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = r;
    }
  };
  function Cr(t, e) {
    let {
      line: r,
      column: s,
      index: i
    } = t;
    return new hs(r, s + e, i + e);
  }
  n(Cr, "createPositionWithColumnOffset");
  var $w = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", aDe = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: $w
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: $w
    }
  }, Hw = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Mc = /* @__PURE__ */ n((t) => t.type === "UpdateExpression" ? Hw.UpdateExpression[`${t.prefix}`] : Hw[t.type], "toNodeDescription"), oDe = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: t
    }) => `A ${t}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: t
    }) => `Missing initializer in ${t} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: t
    }) => `\`${t}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    DynamicImportPhaseRequiresImportExpressions: /* @__PURE__ */ n(({
      phase: t
    }) => `'import.${t}(...)' can only be parsed when using the 'createImportExpressions' option.`, "DynamicImportPhaseRequiresImportExpress\
ions"),
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: t,
      exportName: e
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t}' as '${e}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: t
    }) => `'${t === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: t
    }) => `Unsyntactic ${t === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: t
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: /* @__PURE__ */ n(({
      maxArgumentCount: t
    }) => `\`import()\` requires exactly ${t === 1 ? "one argument" : "one or two arguments"}.`, "ImportCallArity"),
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: t
    }) => `Expected number in radix ${t}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Escape sequence in keyword ${t}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Invalid identifier ${t}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid left-hand side in ${Mc(t)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Binding invalid left-hand side in ${Mc(t)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: t
    }) => `Invalid optional chaining in the left-hand side of ${Mc(t)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t
    }) => `Unexpected character '${t}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private name #${t} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: t
    }) => `Label '${t}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling the parser plugin: ${t.map((e) => JSON.stringify(e)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: t
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map((e) => JSON.stringify(e)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: t
    }) => `Duplicate key "${t}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: t
    }) => `An export name cannot include a lone surrogate, found '\\u${t.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: t
    }) => `Export '${t}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Private names are only allowed in property accesses (\`obj.#${t}\`) or in \`in\` expressions (\`#${t} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Duplicate private name #${t}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: t
    }) => `Unexpected keyword '${t}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: t
    }) => `Unexpected reserved word '${t}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: t,
      unexpected: e
    }) => `Unexpected token${e ? ` '${e}'.` : ""}${t ? `, expected "${t}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: t,
      onlyValidPropertyName: e
    }) => `The only valid meta property for ${t} is ${t}.${e}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: t
    }) => `Identifier '${t}' has already been declared.`, "VarRedeclaration"),
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, lDe = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: t
    }) => `Assigning to '${t}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: t
    }) => `Binding '${t}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, uDe = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), cDe = {
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: t
    }) => `Invalid topic token ${t}. In order to use ${t} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${t}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: t
    }) => `Hack-style pipe body cannot be an unparenthesized ${Mc({
      type: t
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody"),
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }, pDe = ["toMessage"], fDe = ["message"];
  function zw(t, e, r) {
    Object.defineProperty(t, e, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  n(zw, "defineHidden");
  function hDe(t) {
    let {
      toMessage: e
    } = t, r = uN(t, pDe);
    return /* @__PURE__ */ n(function s(i, a) {
      let o = new SyntaxError();
      return Object.assign(o, r, {
        loc: i,
        pos: i.index
      }), "missingPlugin" in a && Object.assign(o, {
        missingPlugin: a.missingPlugin
      }), zw(o, "clone", /* @__PURE__ */ n(function(u = {}) {
        var c;
        let {
          line: p,
          column: f,
          index: m
        } = (c = u.loc) != null ? c : i;
        return s(new hs(p, f, m), Object.assign({}, a, u.details));
      }, "clone")), zw(o, "details", a), Object.defineProperty(o, "message", {
        configurable: !0,
        get() {
          let l = `${e(a)} (${i.line}:${i.column})`;
          return this.message = l, l;
        },
        set(l) {
          Object.defineProperty(this, "message", {
            value: l,
            writable: !0
          });
        }
      }), o;
    }, "constructor");
  }
  n(hDe, "toParseErrorConstructor");
  function qs(t, e) {
    if (Array.isArray(t))
      return (s) => qs(s, t[0]);
    let r = {};
    for (let s of Object.keys(t)) {
      let i = t[s], a = typeof i == "string" ? {
        message: /* @__PURE__ */ n(() => i, "message")
      } : typeof i == "function" ? {
        message: i
      } : i, {
        message: o
      } = a, l = uN(a, fDe), u = typeof o == "string" ? () => o : o;
      r[s] = hDe(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: s,
        toMessage: u
      }, e ? {
        syntaxPlugin: e
      } : {}, l));
    }
    return r;
  }
  n(qs, "ParseErrorEnum");
  var B = Object.assign({}, qs(aDe), qs(oDe), qs(lDe), qs`pipelineOperator`(cDe)), {
    defineProperty: dDe
  } = Object, Gw = /* @__PURE__ */ n((t, e) => dDe(t, e, {
    enumerable: !1,
    value: t[e]
  }), "toUnenumerable");
  function qo(t) {
    return t.loc.start && Gw(t.loc.start, "index"), t.loc.end && Gw(t.loc.end, "index"), t;
  }
  n(qo, "toESTreeLocation");
  var mDe = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let r = qo(super.parse());
      return this.options.tokens && (r.tokens = r.tokens.map(qo)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: s
    }) {
      let i = null;
      try {
        i = new RegExp(r, s);
      } catch {
      }
      let a = this.estreeParseLiteral(i);
      return a.regex = {
        pattern: r,
        flags: s
      }, a;
    }
    parseBigIntLiteral(r) {
      let s;
      try {
        s = BigInt(r);
      } catch {
        s = null;
      }
      let i = this.estreeParseLiteral(s);
      return i.bigint = String(i.value || r), i;
    }
    parseDecimalLiteral(r) {
      let i = this.estreeParseLiteral(null);
      return i.decimal = String(i.value || r), i;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    directiveToStmt(r) {
      let s = r.value;
      delete r.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let i = r;
      return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
    }
    initFunction(r, s) {
      super.initFunction(r, s), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var s;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((s = r.expression.
      extra) != null && s.parenthesized);
    }
    parseBlockBody(r, s, i, a, o) {
      super.parseBlockBody(r, s, i, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    pushClassMethod(r, s, i, a, o, l) {
      this.parseMethod(s, i, a, o, l, "ClassMethod", !0), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters),
      r.body.push(s);
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let s = super.getPrivateNameSV(r);
      return r = r, delete r.id, r.name = s, r.type = "PrivateIdentifier", r;
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, s) {
      let i = super.parseLiteral(r, s);
      return i.raw = i.extra.raw, delete i.extra, i;
    }
    parseFunctionBody(r, s, i = !1) {
      super.parseFunctionBody(r, s, i), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, s, i, a, o, l, u = !1) {
      let c = this.startNode();
      return c.kind = r.kind, c = super.parseMethod(c, s, i, a, o, l, u), c.type = "FunctionExpression", delete c.kind, r.value = c, l === "\
ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let s = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
    }
    parseClassPrivateProperty(...r) {
      let s = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = !1), s;
    }
    parseObjectMethod(r, s, i, a, o) {
      let l = super.parseObjectMethod(r, s, i, a, o);
      return l && (l.type = "Property", l.kind === "method" && (l.kind = "init"), l.shorthand = !1), l;
    }
    parseObjectProperty(r, s, i, a) {
      let o = super.parseObjectProperty(r, s, i, a);
      return o && (o.kind = "init", o.type = "Property"), o;
    }
    isValidLVal(r, s, i) {
      return r === "Property" ? "value" : super.isValidLVal(r, s, i);
    }
    isAssignable(r, s) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: i,
          value: a
        } = r;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(r, s);
    }
    toAssignableObjectExpressionProp(r, s, i) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(B.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(B.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, s, i);
    }
    finishCallExpression(r, s) {
      let i = super.finishCallExpression(r, s);
      if (i.callee.type === "Import") {
        if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var a, o;
          i.options = (a = i.arguments[1]) != null ? a : null, i.attributes = (o = i.arguments[1]) != null ? o : null;
        }
        delete i.arguments, delete i.callee;
      }
      return i;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, s) {
      let i = this.state.lastTokStartLoc, a = super.parseExport(r, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported =
          a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, i);
          }
          break;
      }
      return a;
    }
    parseSubscript(r, s, i, a) {
      let o = super.parseSubscript(r, s, i, a);
      if (a.optionalChainMember) {
        if ((o.type === "OptionalMemberExpression" || o.type === "OptionalCallExpression") && (o.type = o.type.substring(8)), a.stop) {
          let l = this.startNodeAtNode(o);
          return l.expression = o, this.finishNode(l, "ChainExpression");
        }
      } else (o.type === "MemberExpression" || o.type === "CallExpression") && (o.optional = !1);
      return o;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    finishNodeAt(r, s, i) {
      return qo(super.finishNodeAt(r, s, i));
    }
    resetStartLocation(r, s) {
      super.resetStartLocation(r, s), qo(r);
    }
    resetEndLocation(r, s = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, s), qo(r);
    }
  }, "estree"), sn = class {
    static {
      n(this, "TokContext");
    }
    constructor(e, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e, this.preserveSpace = !!r;
    }
  }, Pt = {
    brace: new sn("{"),
    j_oTag: new sn("<tag"),
    j_cTag: new sn("</tag"),
    j_expr: new sn("<tag>...</tag>", !0)
  };
  Pt.template = new sn("`", !0);
  var $e = !0, le = !0, J0 = !0, Vo = !0, bi = !0, yDe = !0, Rc = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(e, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, Tb = /* @__PURE__ */ new Map();
  function tt(t, e = {}) {
    e.keyword = t;
    let r = ve(t, e);
    return Tb.set(t, r), r;
  }
  n(tt, "createKeyword");
  function vr(t, e) {
    return ve(t, {
      beforeExpr: $e,
      binop: e
    });
  }
  n(vr, "createBinop");
  var Jo = -1, Rs = [], bb = [], xb = [], Sb = [], gb = [], Pb = [];
  function ve(t, e = {}) {
    var r, s, i, a;
    return ++Jo, bb.push(t), xb.push((r = e.binop) != null ? r : -1), Sb.push((s = e.beforeExpr) != null ? s : !1), gb.push((i = e.startsExpr) !=
    null ? i : !1), Pb.push((a = e.prefix) != null ? a : !1), Rs.push(new Rc(t, e)), Jo;
  }
  n(ve, "createToken");
  function Xe(t, e = {}) {
    var r, s, i, a;
    return ++Jo, Tb.set(t, Jo), bb.push(t), xb.push((r = e.binop) != null ? r : -1), Sb.push((s = e.beforeExpr) != null ? s : !1), gb.push((i =
    e.startsExpr) != null ? i : !1), Pb.push((a = e.prefix) != null ? a : !1), Rs.push(new Rc("name", e)), Jo;
  }
  n(Xe, "createKeywordLike");
  var TDe = {
    bracketL: ve("[", {
      beforeExpr: $e,
      startsExpr: le
    }),
    bracketHashL: ve("#[", {
      beforeExpr: $e,
      startsExpr: le
    }),
    bracketBarL: ve("[|", {
      beforeExpr: $e,
      startsExpr: le
    }),
    bracketR: ve("]"),
    bracketBarR: ve("|]"),
    braceL: ve("{", {
      beforeExpr: $e,
      startsExpr: le
    }),
    braceBarL: ve("{|", {
      beforeExpr: $e,
      startsExpr: le
    }),
    braceHashL: ve("#{", {
      beforeExpr: $e,
      startsExpr: le
    }),
    braceR: ve("}"),
    braceBarR: ve("|}"),
    parenL: ve("(", {
      beforeExpr: $e,
      startsExpr: le
    }),
    parenR: ve(")"),
    comma: ve(",", {
      beforeExpr: $e
    }),
    semi: ve(";", {
      beforeExpr: $e
    }),
    colon: ve(":", {
      beforeExpr: $e
    }),
    doubleColon: ve("::", {
      beforeExpr: $e
    }),
    dot: ve("."),
    question: ve("?", {
      beforeExpr: $e
    }),
    questionDot: ve("?."),
    arrow: ve("=>", {
      beforeExpr: $e
    }),
    template: ve("template"),
    ellipsis: ve("...", {
      beforeExpr: $e
    }),
    backQuote: ve("`", {
      startsExpr: le
    }),
    dollarBraceL: ve("${", {
      beforeExpr: $e,
      startsExpr: le
    }),
    templateTail: ve("...`", {
      startsExpr: le
    }),
    templateNonTail: ve("...${", {
      beforeExpr: $e,
      startsExpr: le
    }),
    at: ve("@"),
    hash: ve("#", {
      startsExpr: le
    }),
    interpreterDirective: ve("#!..."),
    eq: ve("=", {
      beforeExpr: $e,
      isAssign: Vo
    }),
    assign: ve("_=", {
      beforeExpr: $e,
      isAssign: Vo
    }),
    slashAssign: ve("_=", {
      beforeExpr: $e,
      isAssign: Vo
    }),
    xorAssign: ve("_=", {
      beforeExpr: $e,
      isAssign: Vo
    }),
    moduloAssign: ve("_=", {
      beforeExpr: $e,
      isAssign: Vo
    }),
    incDec: ve("++/--", {
      prefix: bi,
      postfix: yDe,
      startsExpr: le
    }),
    bang: ve("!", {
      beforeExpr: $e,
      prefix: bi,
      startsExpr: le
    }),
    tilde: ve("~", {
      beforeExpr: $e,
      prefix: bi,
      startsExpr: le
    }),
    doubleCaret: ve("^^", {
      startsExpr: le
    }),
    doubleAt: ve("@@", {
      startsExpr: le
    }),
    pipeline: vr("|>", 0),
    nullishCoalescing: vr("??", 1),
    logicalOR: vr("||", 1),
    logicalAND: vr("&&", 2),
    bitwiseOR: vr("|", 3),
    bitwiseXOR: vr("^", 4),
    bitwiseAND: vr("&", 5),
    equality: vr("==/!=/===/!==", 6),
    lt: vr("</>/<=/>=", 7),
    gt: vr("</>/<=/>=", 7),
    relational: vr("</>/<=/>=", 7),
    bitShift: vr("<</>>/>>>", 8),
    bitShiftL: vr("<</>>/>>>", 8),
    bitShiftR: vr("<</>>/>>>", 8),
    plusMin: ve("+/-", {
      beforeExpr: $e,
      binop: 9,
      prefix: bi,
      startsExpr: le
    }),
    modulo: ve("%", {
      binop: 10,
      startsExpr: le
    }),
    star: ve("*", {
      binop: 10
    }),
    slash: vr("/", 10),
    exponent: ve("**", {
      beforeExpr: $e,
      binop: 11,
      rightAssociative: !0
    }),
    _in: tt("in", {
      beforeExpr: $e,
      binop: 7
    }),
    _instanceof: tt("instanceof", {
      beforeExpr: $e,
      binop: 7
    }),
    _break: tt("break"),
    _case: tt("case", {
      beforeExpr: $e
    }),
    _catch: tt("catch"),
    _continue: tt("continue"),
    _debugger: tt("debugger"),
    _default: tt("default", {
      beforeExpr: $e
    }),
    _else: tt("else", {
      beforeExpr: $e
    }),
    _finally: tt("finally"),
    _function: tt("function", {
      startsExpr: le
    }),
    _if: tt("if"),
    _return: tt("return", {
      beforeExpr: $e
    }),
    _switch: tt("switch"),
    _throw: tt("throw", {
      beforeExpr: $e,
      prefix: bi,
      startsExpr: le
    }),
    _try: tt("try"),
    _var: tt("var"),
    _const: tt("const"),
    _with: tt("with"),
    _new: tt("new", {
      beforeExpr: $e,
      startsExpr: le
    }),
    _this: tt("this", {
      startsExpr: le
    }),
    _super: tt("super", {
      startsExpr: le
    }),
    _class: tt("class", {
      startsExpr: le
    }),
    _extends: tt("extends", {
      beforeExpr: $e
    }),
    _export: tt("export"),
    _import: tt("import", {
      startsExpr: le
    }),
    _null: tt("null", {
      startsExpr: le
    }),
    _true: tt("true", {
      startsExpr: le
    }),
    _false: tt("false", {
      startsExpr: le
    }),
    _typeof: tt("typeof", {
      beforeExpr: $e,
      prefix: bi,
      startsExpr: le
    }),
    _void: tt("void", {
      beforeExpr: $e,
      prefix: bi,
      startsExpr: le
    }),
    _delete: tt("delete", {
      beforeExpr: $e,
      prefix: bi,
      startsExpr: le
    }),
    _do: tt("do", {
      isLoop: J0,
      beforeExpr: $e
    }),
    _for: tt("for", {
      isLoop: J0
    }),
    _while: tt("while", {
      isLoop: J0
    }),
    _as: Xe("as", {
      startsExpr: le
    }),
    _assert: Xe("assert", {
      startsExpr: le
    }),
    _async: Xe("async", {
      startsExpr: le
    }),
    _await: Xe("await", {
      startsExpr: le
    }),
    _defer: Xe("defer", {
      startsExpr: le
    }),
    _from: Xe("from", {
      startsExpr: le
    }),
    _get: Xe("get", {
      startsExpr: le
    }),
    _let: Xe("let", {
      startsExpr: le
    }),
    _meta: Xe("meta", {
      startsExpr: le
    }),
    _of: Xe("of", {
      startsExpr: le
    }),
    _sent: Xe("sent", {
      startsExpr: le
    }),
    _set: Xe("set", {
      startsExpr: le
    }),
    _source: Xe("source", {
      startsExpr: le
    }),
    _static: Xe("static", {
      startsExpr: le
    }),
    _using: Xe("using", {
      startsExpr: le
    }),
    _yield: Xe("yield", {
      startsExpr: le
    }),
    _asserts: Xe("asserts", {
      startsExpr: le
    }),
    _checks: Xe("checks", {
      startsExpr: le
    }),
    _exports: Xe("exports", {
      startsExpr: le
    }),
    _global: Xe("global", {
      startsExpr: le
    }),
    _implements: Xe("implements", {
      startsExpr: le
    }),
    _intrinsic: Xe("intrinsic", {
      startsExpr: le
    }),
    _infer: Xe("infer", {
      startsExpr: le
    }),
    _is: Xe("is", {
      startsExpr: le
    }),
    _mixins: Xe("mixins", {
      startsExpr: le
    }),
    _proto: Xe("proto", {
      startsExpr: le
    }),
    _require: Xe("require", {
      startsExpr: le
    }),
    _satisfies: Xe("satisfies", {
      startsExpr: le
    }),
    _keyof: Xe("keyof", {
      startsExpr: le
    }),
    _readonly: Xe("readonly", {
      startsExpr: le
    }),
    _unique: Xe("unique", {
      startsExpr: le
    }),
    _abstract: Xe("abstract", {
      startsExpr: le
    }),
    _declare: Xe("declare", {
      startsExpr: le
    }),
    _enum: Xe("enum", {
      startsExpr: le
    }),
    _module: Xe("module", {
      startsExpr: le
    }),
    _namespace: Xe("namespace", {
      startsExpr: le
    }),
    _interface: Xe("interface", {
      startsExpr: le
    }),
    _type: Xe("type", {
      startsExpr: le
    }),
    _opaque: Xe("opaque", {
      startsExpr: le
    }),
    name: ve("name", {
      startsExpr: le
    }),
    string: ve("string", {
      startsExpr: le
    }),
    num: ve("num", {
      startsExpr: le
    }),
    bigint: ve("bigint", {
      startsExpr: le
    }),
    decimal: ve("decimal", {
      startsExpr: le
    }),
    regexp: ve("regexp", {
      startsExpr: le
    }),
    privateName: ve("#name", {
      startsExpr: le
    }),
    eof: ve("eof"),
    jsxName: ve("jsxName"),
    jsxText: ve("jsxText", {
      beforeExpr: !0
    }),
    jsxTagStart: ve("jsxTagStart", {
      startsExpr: !0
    }),
    jsxTagEnd: ve("jsxTagEnd"),
    placeholder: ve("%%", {
      startsExpr: !0
    })
  };
  function mt(t) {
    return t >= 93 && t <= 132;
  }
  n(mt, "tokenIsIdentifier");
  function bDe(t) {
    return t <= 92;
  }
  n(bDe, "tokenKeywordOrIdentifierIsKeyword");
  function es(t) {
    return t >= 58 && t <= 132;
  }
  n(es, "tokenIsKeywordOrIdentifier");
  function cN(t) {
    return t >= 58 && t <= 136;
  }
  n(cN, "tokenIsLiteralPropertyName");
  function xDe(t) {
    return Sb[t];
  }
  n(xDe, "tokenComesBeforeExpression");
  function G0(t) {
    return gb[t];
  }
  n(G0, "tokenCanStartExpression");
  function SDe(t) {
    return t >= 29 && t <= 33;
  }
  n(SDe, "tokenIsAssignment");
  function Qw(t) {
    return t >= 129 && t <= 131;
  }
  n(Qw, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function gDe(t) {
    return t >= 90 && t <= 92;
  }
  n(gDe, "tokenIsLoop");
  function Eb(t) {
    return t >= 58 && t <= 92;
  }
  n(Eb, "tokenIsKeyword");
  function PDe(t) {
    return t >= 39 && t <= 59;
  }
  n(PDe, "tokenIsOperator");
  function EDe(t) {
    return t === 34;
  }
  n(EDe, "tokenIsPostfix");
  function ADe(t) {
    return Pb[t];
  }
  n(ADe, "tokenIsPrefix");
  function vDe(t) {
    return t >= 121 && t <= 123;
  }
  n(vDe, "tokenIsTSTypeOperator");
  function CDe(t) {
    return t >= 124 && t <= 130;
  }
  n(CDe, "tokenIsTSDeclarationStart");
  function Si(t) {
    return bb[t];
  }
  n(Si, "tokenLabelName");
  function Bc(t) {
    return xb[t];
  }
  n(Bc, "tokenOperatorPrecedence");
  function IDe(t) {
    return t === 57;
  }
  n(IDe, "tokenIsRightAssociative");
  function Uc(t) {
    return t >= 24 && t <= 25;
  }
  n(Uc, "tokenIsTemplate");
  function js(t) {
    return Rs[t];
  }
  n(js, "getExportedToken");
  Rs[8].updateContext = (t) => {
    t.pop();
  }, Rs[5].updateContext = Rs[7].updateContext = Rs[23].updateContext = (t) => {
    t.push(Pt.brace);
  }, Rs[22].updateContext = (t) => {
    t[t.length - 1] === Pt.template ? t.pop() : t.push(Pt.template);
  }, Rs[142].updateContext = (t) => {
    t.push(Pt.j_expr, Pt.j_oTag);
  };
  var Ab = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\
\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\
\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\
\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\
\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01\
-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  pN = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\
\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4\
-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\
\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\
\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", wDe = new RegExp("[" + Ab + "]"), NDe = new RegExp("[" + Ab + pN + "\
]");
  Ab = pN = null;
  var fN = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0,
  2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27,
  28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
  3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8,
  46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60,
  42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22,
  0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33,
  125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689,
  63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106,
  6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339,
  3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
  485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0,
  2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33,
  4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], ODe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41,
  2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
  6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
  10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
  13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9,
  9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
  8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14,
  1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Q0(t, e) {
    let r = 65536;
    for (let s = 0, i = e.length; s < i; s += 2) {
      if (r += e[s], r > t) return !1;
      if (r += e[s + 1], r >= t) return !0;
    }
    return !1;
  }
  n(Q0, "isInAstralSet");
  function Us(t) {
    return t < 65 ? t === 36 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && wDe.test(String.fromCharCode(t)) :
    Q0(t, fN);
  }
  n(Us, "isIdentifierStart");
  function Zn(t) {
    return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t <= 90 ? !0 : t < 97 ? t === 95 : t <= 122 ? !0 : t <= 65535 ? t >= 170 && NDe.test(
    String.fromCharCode(t)) : Q0(t, fN) || Q0(t, ODe);
  }
  n(Zn, "isIdentifierChar");
  var vb = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, kDe = new Set(vb.keyword), DDe = new Set(vb.strict), _De = new Set(vb.strictBind);
  function hN(t, e) {
    return e && t === "await" || t === "enum";
  }
  n(hN, "isReservedWord");
  function dN(t, e) {
    return hN(t, e) || DDe.has(t);
  }
  n(dN, "isStrictReservedWord");
  function mN(t) {
    return _De.has(t);
  }
  n(mN, "isStrictBindOnlyReservedWord");
  function yN(t, e) {
    return dN(t, e) || mN(t);
  }
  n(yN, "isStrictBindReservedWord");
  function LDe(t) {
    return kDe.has(t);
  }
  n(LDe, "isKeyword");
  function MDe(t, e, r) {
    return t === 64 && e === 64 && Us(r);
  }
  n(MDe, "isIteratorStart");
  var BDe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function FDe(t) {
    return BDe.has(t);
  }
  n(FDe, "canBeReservedWord");
  var $o = class {
    static {
      n(this, "Scope");
    }
    constructor(e) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e;
    }
  }, Ho = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(e, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (e & 64) > 0 && (e & 2) === 0;
    }
    get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 128)
          return !0;
        if (r & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e) {
      return new $o(e);
    }
    enter(e) {
      this.scopeStack.push(this.createScope(e));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e) {
      return !!(e.flags & 130 || !this.parser.inModule && e.flags & 1);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(i, e, r, s);
        let a = i.names.get(e) || 0;
        r & 16 ? a = a | 4 : (i.firstLexicalName || (i.firstLexicalName = e), a = a | 2), i.names.set(e, a), r & 8 && this.maybeExportDefined(
        i, e);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (i = this.scopeStack[a], this.checkRedeclarationInScope(i, e, r, s), i.names.set(
        e, (i.names.get(e) || 0) | 1), this.maybeExportDefined(i, e), !(i.flags & 387)); --a)
          ;
      this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(e);
    }
    maybeExportDefined(e, r) {
      this.parser.inModule && e.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(e, r, s, i) {
      this.isRedeclaredInScope(e, r, s) && this.parser.raise(B.VarRedeclaration, i, {
        identifierName: r
      });
    }
    isRedeclaredInScope(e, r, s) {
      if (!(s & 1)) return !1;
      if (s & 8)
        return e.names.has(r);
      let i = e.names.get(r);
      return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(e) && (i & 1) > 0 : (i & 2) > 0 && !(e.flags & 8 && e.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(e) && (i & 4) > 0;
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, e.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 387)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
        let {
          flags: r
        } = this.scopeStack[e];
        if (r & 451 && !(r & 4))
          return r;
      }
    }
  }, Z0 = class extends $o {
    static {
      n(this, "FlowScope");
    }
    constructor(...e) {
      super(...e), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, eb = class extends Ho {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(e) {
      return new Z0(e);
    }
    declareName(e, r, s) {
      let i = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e), i.declareFunctions.add(e);
        return;
      }
      super.declareName(e, r, s);
    }
    isRedeclaredInScope(e, r, s) {
      if (super.isRedeclaredInScope(e, r, s)) return !0;
      if (s & 2048 && !e.declareFunctions.has(r)) {
        let i = e.names.get(r);
        return (i & 4) > 0 || (i & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
    }
  }, tb = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(e) {
      if (typeof e == "string")
        return this.plugins.has(e);
      {
        let [r, s] = e;
        if (!this.hasPlugin(r))
          return !1;
        let i = this.plugins.get(r);
        for (let a of Object.keys(s))
          if (i?.[a] !== s[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(e, r) {
      var s;
      return (s = this.plugins.get(e)) == null ? void 0 : s[r];
    }
  };
  function TN(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  n(TN, "setTrailingComments");
  function jDe(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  n(jDe, "setLeadingComments");
  function zo(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  n(zo, "setInnerComments");
  function Ko(t, e, r) {
    let s = null, i = e.length;
    for (; s === null && i > 0; )
      s = e[--i];
    s === null || s.start > r.start ? zo(t, r.comments) : TN(s, r.comments);
  }
  n(Ko, "adjustInnerComments");
  var rb = class extends tb {
    static {
      n(this, "CommentsParser");
    }
    addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(e), this.state.commentsLen++;
    }
    processComment(e) {
      let {
        commentStack: r
      } = this.state, s = r.length;
      if (s === 0) return;
      let i = s - 1, a = r[i];
      a.start === e.end && (a.leadingNode = e, i--);
      let {
        start: o
      } = e;
      for (; i >= 0; i--) {
        let l = r[i], u = l.end;
        if (u > o)
          l.containingNode = e, this.finalizeComment(l), r.splice(i, 1);
        else {
          u === o && (l.trailingNode = e);
          break;
        }
      }
    }
    finalizeComment(e) {
      let {
        comments: r
      } = e;
      if (e.leadingNode !== null || e.trailingNode !== null)
        e.leadingNode !== null && TN(e.leadingNode, r), e.trailingNode !== null && jDe(e.trailingNode, r);
      else {
        let {
          containingNode: s,
          start: i
        } = e;
        if (this.input.charCodeAt(i - 1) === 44)
          switch (s.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Ko(s, s.properties, e);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Ko(s, s.arguments, e);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Ko(s, s.params, e);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Ko(s, s.elements, e);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Ko(s, s.specifiers, e);
              break;
            default:
              zo(s, r);
          }
        else
          zo(s, r);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: e
      } = this.state;
      for (let r = e.length - 1; r >= 0; r--)
        this.finalizeComment(e[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      if (s === 0) return;
      let i = r[s - 1];
      i.leadingNode === e && (i.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      s !== 0 && (r[s - 1].trailingNode === e ? r[s - 1].trailingNode = null : s >= 2 && r[s - 2].trailingNode === e && (r[s - 2].trailingNode =
      null));
    }
    takeSurroundingComments(e, r, s) {
      let {
        commentStack: i
      } = this.state, a = i.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = i[o], u = l.end;
        if (l.start === s)
          l.leadingNode = e;
        else if (u === r)
          l.trailingNode = e;
        else if (u < r)
          break;
      }
    }
  }, bN = /\r\n?|[\n\u2028\u2029]/, _c = new RegExp(bN.source, "g");
  function Xo(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(Xo, "isNewLine");
  var X0 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Fc = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Zw = new RegExp("(?=(" + Fc.source + "))\\\
1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function RDe(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(RDe, "isWhitespace");
  var sb = class t {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.
      potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [Pt.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(e) {
      e ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: e,
      sourceType: r,
      startLine: s,
      startColumn: i
    }) {
      this.strict = e === !1 ? !1 : e === !0 ? !0 : r === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new hs(
      s, i, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(e) {
      e ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(e) {
      e ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(e) {
      e ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(e) {
      e ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(e) {
      e ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(e) {
      e ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(e) {
      e ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(e) {
      e ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(e) {
      e ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(e) {
      e ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(e) {
      e ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new hs(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let e = new t();
      return e.flags = this.flags, e.curLine = this.curLine, e.lineStart = this.lineStart, e.startLoc = this.startLoc, e.endLoc = this.endLoc,
      e.errors = this.errors.slice(), e.potentialArrowAt = this.potentialArrowAt, e.noArrowAt = this.noArrowAt.slice(), e.noArrowParamsConversionAt =
      this.noArrowParamsConversionAt.slice(), e.topicContext = this.topicContext, e.labels = this.labels.slice(), e.commentsLen = this.commentsLen,
      e.commentStack = this.commentStack.slice(), e.pos = this.pos, e.type = this.type, e.value = this.value, e.start = this.start, e.end = this.
      end, e.lastTokEndLoc = this.lastTokEndLoc, e.lastTokStartLoc = this.lastTokStartLoc, e.context = this.context.slice(), e.firstInvalidTemplateEscapePos =
      this.firstInvalidTemplateEscapePos, e.strictErrors = this.strictErrors, e.tokensLength = this.tokensLength, e;
    }
  }, UDe = /* @__PURE__ */ n(function(e) {
    return e >= 48 && e <= 57;
  }, "isDigit"), eN = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Lc = {
    bin: /* @__PURE__ */ n((t) => t === 48 || t === 49, "bin"),
    oct: /* @__PURE__ */ n((t) => t >= 48 && t <= 55, "oct"),
    dec: /* @__PURE__ */ n((t) => t >= 48 && t <= 57, "dec"),
    hex: /* @__PURE__ */ n((t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102, "hex")
  };
  function tN(t, e, r, s, i, a) {
    let o = r, l = s, u = i, c = "", p = null, f = r, {
      length: m
    } = e;
    for (; ; ) {
      if (r >= m) {
        a.unterminated(o, l, u), c += e.slice(f, r);
        break;
      }
      let y = e.charCodeAt(r);
      if (qDe(t, y, e, r)) {
        c += e.slice(f, r);
        break;
      }
      if (y === 92) {
        c += e.slice(f, r);
        let T = VDe(e, r, s, i, t === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: i
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: i
        } = T, f = r;
      } else y === 8232 || y === 8233 ? (++r, ++i, s = r) : y === 10 || y === 13 ? t === "template" ? (c += e.slice(f, r) + `
`, ++r, y === 13 && e.charCodeAt(r) === 10 && ++r, ++i, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: i,
      containsInvalid: !!p
    };
  }
  n(tN, "readStringContents");
  function qDe(t, e, r, s) {
    return t === "template" ? e === 96 || e === 36 && r.charCodeAt(s + 1) === 123 : e === (t === "double" ? 34 : 39);
  }
  n(qDe, "isStringEnd");
  function VDe(t, e, r, s, i, a) {
    let o = !i;
    e++;
    let l = /* @__PURE__ */ n((c) => ({
      pos: e,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = t.charCodeAt(e++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: e
        } = ib(t, e, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: e
        } = SN(t, e, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        t.charCodeAt(e) === 10 && ++e;
      case 10:
        r = e, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (i)
          return l(null);
        a.strictNumericEscape(e - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = e - 1, f = t.slice(c, e + 2).match(/^[0-7]+/)[0], m = parseInt(f, 8);
          m > 255 && (f = f.slice(0, -1), m = parseInt(f, 8)), e += f.length - 1;
          let y = t.charCodeAt(e);
          if (f !== "0" || y === 56 || y === 57) {
            if (i)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(m));
        }
        return l(String.fromCharCode(u));
    }
  }
  n(VDe, "readEscapedChar");
  function ib(t, e, r, s, i, a, o, l) {
    let u = e, c;
    return {
      n: c,
      pos: e
    } = xN(t, e, r, s, 16, i, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : e = u - 1), {
      code: c,
      pos: e
    };
  }
  n(ib, "readHexChar");
  function xN(t, e, r, s, i, a, o, l, u, c) {
    let p = e, f = i === 16 ? eN.hex : eN.decBinOct, m = i === 16 ? Lc.hex : i === 10 ? Lc.dec : i === 8 ? Lc.oct : Lc.bin, y = !1, T = 0;
    for (let L = 0, q = a ?? 1 / 0; L < q; ++L) {
      let _ = t.charCodeAt(e), U;
      if (_ === 95 && l !== "bail") {
        let J = t.charCodeAt(e - 1), ie = t.charCodeAt(e + 1);
        if (l) {
          if (Number.isNaN(ie) || !m(ie) || f.has(J) || f.has(ie)) {
            if (c) return {
              n: null,
              pos: e
            };
            u.unexpectedNumericSeparator(e, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: e
          };
          u.numericSeparatorInEscapeSequence(e, r, s);
        }
        ++e;
        continue;
      }
      if (_ >= 97 ? U = _ - 97 + 10 : _ >= 65 ? U = _ - 65 + 10 : UDe(_) ? U = _ - 48 : U = 1 / 0, U >= i) {
        if (U <= 9 && c)
          return {
            n: null,
            pos: e
          };
        if (U <= 9 && u.invalidDigit(e, r, s, i))
          U = 0;
        else if (o)
          U = 0, y = !0;
        else
          break;
      }
      ++e, T = T * i + U;
    }
    return e === p || a != null && e - p !== a || y ? {
      n: null,
      pos: e
    } : {
      n: T,
      pos: e
    };
  }
  n(xN, "readInt");
  function SN(t, e, r, s, i, a) {
    let o = t.charCodeAt(e), l;
    if (o === 123) {
      if (++e, {
        code: l,
        pos: e
      } = ib(t, e, r, s, t.indexOf("}", e) - e, !0, i, a), ++e, l !== null && l > 1114111)
        if (i)
          a.invalidCodePoint(e, r, s);
        else
          return {
            code: null,
            pos: e
          };
    } else
      ({
        code: l,
        pos: e
      } = ib(t, e, r, s, 4, !1, i, a));
    return {
      code: l,
      pos: e
    };
  }
  n(SN, "readCodePoint");
  function Wo(t, e, r) {
    return new hs(r, t - e, t);
  }
  n(Wo, "buildPosition");
  var KDe = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), fs = class {
    static {
      n(this, "Token");
    }
    constructor(e) {
      this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new ta(e.startLoc, e.endLoc);
    }
  }, nb = class extends rb {
    static {
      n(this, "Tokenizer");
    }
    constructor(e, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((s, i, a, o) => this.options.errorRecovery ? (this.raise(B.InvalidDigit, Wo(s, i, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(B.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(B.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(B.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(B.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((s, i, a) => {
          this.recordStrictModeErrors(B.StrictNumericEscape, Wo(s, i, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(B.UnterminatedString, Wo(s - 1, i, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(B.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((s, i, a) => {
          throw this.raise(B.UnterminatedTemplate, Wo(s, i, a));
        }, "unterminated")
      }), this.state = new sb(), this.state.init(e), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(e) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new fs(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.
      state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e) {
      return this.match(e) ? (this.next(), !0) : !1;
    }
    match(e) {
      return this.state.type === e;
    }
    createLookaheadState(e) {
      return {
        pos: e.pos,
        value: null,
        type: e.type,
        start: e.start,
        end: e.end,
        context: [this.curContext()],
        inType: e.inType,
        startLoc: e.startLoc,
        lastTokEndLoc: e.lastTokEndLoc,
        curLine: e.curLine,
        lineStart: e.lineStart,
        curPosition: e.curPosition
      };
    }
    lookahead() {
      let e = this.state;
      this.state = this.createLookaheadState(e), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = e, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e) {
      return X0.lastIndex = e, X0.test(this.input) ? X0.lastIndex : e;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e) {
      return Fc.lastIndex = e, Fc.test(this.input) ? Fc.lastIndex : e;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e) {
      let r = this.input.charCodeAt(e);
      if ((r & 64512) === 55296 && ++e < this.input.length) {
        let s = this.input.charCodeAt(e);
        (s & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (s & 1023));
      }
      return r;
    }
    setStrict(e) {
      this.state.strict = e, e && (this.state.strictErrors.forEach(([r, s]) => this.raise(r, s)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let s = this.state.pos, i = this.input.indexOf(e, s + 2);
      if (i === -1)
        throw this.raise(B.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = i + e.length, _c.lastIndex = s + 2; _c.test(this.input) && _c.lastIndex <= i; )
        ++this.state.curLine, this.state.lineStart = _c.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(s + 2, i),
        start: s,
        end: i + e.length,
        loc: new ta(r, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(a), a;
    }
    skipLineComment(e) {
      let r = this.state.pos, s;
      this.isLookahead || (s = this.state.curPosition());
      let i = this.input.charCodeAt(this.state.pos += e);
      if (this.state.pos < this.length)
        for (; !Xo(i) && ++this.state.pos < this.length; )
          i = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + e, a),
        start: r,
        end: a,
        loc: new ta(s, this.state.curPosition())
      };
      return this.options.tokens && this.pushToken(l), l;
    }
    skipSpace() {
      let e = this.state.pos, r = [];
      e: for (; this.state.pos < this.length; ) {
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let i = this.skipBlockComment("*/");
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              case 47: {
                let i = this.skipLineComment(2);
                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (RDe(s))
              ++this.state.pos;
            else if (s === 45 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (e === 0 || this.state.lineStart > e)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else if (s === 60 && !this.inModule && this.options.annexB) {
              let i = this.state.pos;
              if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), this.options.attachComment && r.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r.length > 0) {
        let s = this.state.pos, i = {
          start: e,
          end: s,
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(i);
      }
    }
    finishToken(e, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s = this.state.type;
      this.state.type = e, this.state.value = r, this.isLookahead || this.updateContext(s);
    }
    replaceToken(e) {
      this.state.type = e, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let e = this.state.pos + 1, r = this.codePointAtPos(e);
      if (r >= 48 && r <= 57)
        throw this.raise(B.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? B.RecordExpressionHashIncorrectStartSyntaxType : B.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else Us(r) ? (++this.state.pos, this.finishToken(138, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(138, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e >= 48 && e <= 57) {
        this.readNumber(!0);
        return;
      }
      e === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !Xo(e) && ++this.state.pos < this.length; )
        e = this.input.charCodeAt(this.state.pos);
      let s = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, s), !0;
    }
    readToken_mult_modulo(e) {
      let r = e === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
      e === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), r = 57), i === 61 && !this.state.inType && (s++, r = e ===
      37 ? 33 : 30), this.finishOp(r, s);
    }
    readToken_pipe_amp(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(e === 124 ? 41 : 42, 2);
        return;
      }
      if (e === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(B.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(B.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(e === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e === 61 && !this.state.inType ? this.finishOp(32, 2) : e === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === e) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 60) {
        if (this.input.charCodeAt(e + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: e
      } = this.state, r = this.input.charCodeAt(e + 1);
      if (r === 62) {
        let s = this.input.charCodeAt(e + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(e + s) === 61) {
          this.finishOp(30, s + 1);
          return;
        }
        this.finishOp(52, s);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(e) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (e === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(e === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      e === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : e === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(e) {
      switch (e) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(B.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(B.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(e);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(e);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(e);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(e);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(e);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Us(e)) {
            this.readWord(e);
            return;
          }
      }
      throw this.raise(B.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(e)
      });
    }
    finishOp(e, r) {
      let s = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(e, s);
    }
    readRegexp() {
      let e = this.state.startLoc, r = this.state.start + 1, s, i, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(B.UnterminatedRegExp, Cr(e, 1));
        let c = this.input.charCodeAt(a);
        if (Xo(c))
          throw this.raise(B.UnterminatedRegExp, Cr(e, 1));
        if (s)
          s = !1;
        else {
          if (c === 91)
            i = !0;
          else if (c === 93 && i)
            i = !1;
          else if (c === 47 && !i)
            break;
          s = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ n(() => Cr(e, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (KDe.has(c))
          c === 118 ? l.includes("u") && this.raise(B.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(B.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(B.DuplicateRegExpFlags, u());
        else if (Zn(c) || c === 92)
          this.raise(B.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(137, {
        pattern: o,
        flags: l
      });
    }
    readInt(e, r, s = !1, i = !0) {
      let {
        n: a,
        pos: o
      } = xN(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, r, s, i, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(e) {
      let r = this.state.curPosition(), s = !1;
      this.state.pos += 2;
      let i = this.readInt(e);
      i == null && this.raise(B.InvalidDigit, Cr(r, 2), {
        radix: e
      });
      let a = this.input.charCodeAt(this.state.pos);
      if (a === 110)
        ++this.state.pos, s = !0;
      else if (a === 109)
        throw this.raise(B.InvalidDecimal, r);
      if (Us(this.codePointAtPos(this.state.pos)))
        throw this.raise(B.NumberIdentifier, this.state.curPosition());
      if (s) {
        let o = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, o);
        return;
      }
      this.finishToken(134, i);
    }
    readNumber(e) {
      let r = this.state.pos, s = this.state.curPosition(), i = !1, a = !1, o = !1, l = !1, u = !1;
      !e && this.readInt(10) === null && this.raise(B.InvalidNumber, this.state.curPosition());
      let c = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (c) {
        let y = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(B.StrictOctalLiteral, s), !this.state.strict) {
          let T = y.indexOf("_");
          T > 0 && this.raise(B.ZeroDigitNumericSeparator, Cr(s, T));
        }
        u = c && !/[89]/.test(y);
      }
      let p = this.input.charCodeAt(this.state.pos);
      if (p === 46 && !u && (++this.state.pos, this.readInt(10), i = !0, p = this.input.charCodeAt(this.state.pos)), (p === 69 || p === 101) &&
      !u && (p = this.input.charCodeAt(++this.state.pos), (p === 43 || p === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      B.InvalidOrMissingExponent, s), i = !0, l = !0, p = this.input.charCodeAt(this.state.pos)), p === 110 && ((i || c) && this.raise(B.InvalidBigIntLiteral,
      s), ++this.state.pos, a = !0), p === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (l || c) && this.raise(B.InvalidDecimal,
      s), ++this.state.pos, o = !0), Us(this.codePointAtPos(this.state.pos)))
        throw this.raise(B.NumberIdentifier, this.state.curPosition());
      let f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(135, f);
        return;
      }
      if (o) {
        this.finishToken(136, f);
        return;
      }
      let m = u ? parseInt(f, 8) : parseFloat(f);
      this.finishToken(134, m);
    }
    readCodePoint(e) {
      let {
        code: r,
        pos: s
      } = SN(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return this.state.pos = s, r;
    }
    readString(e) {
      let {
        str: r,
        pos: s,
        curLine: i,
        lineStart: a
      } = tN(e === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, this.finishToken(133, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let e = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: s,
        pos: i,
        curLine: a,
        lineStart: o
      } = tN("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = i + 1, this.state.lineStart = o, this.state.curLine = a, s && (this.state.firstInvalidTemplateEscapePos = new hs(s.curLine,
      s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : e + r + "`") : (this.state.pos++, this.
      finishToken(25, s ? null : e + r + "${"));
    }
    recordStrictModeErrors(e, r) {
      let s = r.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(e, r) : this.state.strictErrors.set(s, [e, r]);
    }
    readWord1(e) {
      this.state.containsEsc = !1;
      let r = "", s = this.state.pos, i = this.state.pos;
      for (e !== void 0 && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (Zn(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(i, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === s ? Us : Zn;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(B.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(B.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), i = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(i, this.state.pos);
    }
    readWord(e) {
      let r = this.readWord1(e), s = Tb.get(r);
      s !== void 0 ? this.finishToken(s, Si(s)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: e
      } = this.state;
      Eb(e) && this.state.containsEsc && this.raise(B.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: Si(e)
      });
    }
    raise(e, r, s = {}) {
      let i = r instanceof hs ? r : r.loc.start, a = e(i, s);
      if (!this.options.errorRecovery) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(e, r, s = {}) {
      let i = r instanceof hs ? r : r.loc.start, a = i.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = e(i, s);
        if (u.loc.index < a) break;
      }
      return this.raise(e, r, s);
    }
    updateContext(e) {
    }
    unexpected(e, r) {
      throw this.raise(B.UnexpectedToken, e ?? this.state.startLoc, {
        expected: r ? Si(r) : null
      });
    }
    expectPlugin(e, r) {
      if (this.hasPlugin(e))
        return !0;
      throw this.raise(B.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [e]
      });
    }
    expectOnePlugin(e) {
      if (!e.some((r) => this.hasPlugin(r)))
        throw this.raise(B.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: e
        });
    }
    errorBuilder(e) {
      return (r, s, i) => {
        this.raise(e, Wo(r, s, i));
      };
    }
  }, ab = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, ob = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ab());
    }
    exit() {
      let e = this.stack.pop(), r = this.current();
      for (let [s, i] of Array.from(e.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(s) || r.undefinedPrivateNames.set(s, i) : this.parser.raise(B.InvalidPrivateFieldResolution, i, {
          identifierName: s
        });
    }
    declarePrivateName(e, r, s) {
      let {
        privateNames: i,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = i.has(e);
      if (r & 3) {
        let u = l && a.get(e);
        if (u) {
          let c = u & 4, p = r & 4, f = u & 3, m = r & 3;
          l = f === m || c !== p, l || a.delete(e);
        } else l || a.set(e, r);
      }
      l && this.parser.raise(B.PrivateNameRedeclaration, s, {
        identifierName: e
      }), i.add(e), o.delete(e);
    }
    usePrivateName(e, r) {
      let s;
      for (s of this.stack)
        if (s.privateNames.has(e)) return;
      s ? s.undefinedPrivateNames.set(e, r) : this.parser.raise(B.InvalidPrivateFieldResolution, r, {
        identifierName: e
      });
    }
  }, ra = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(e = 0) {
      this.type = e;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, qc = class extends ra {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(e) {
      super(e), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e, r) {
      let s = r.index;
      this.declarationErrors.set(s, [e, r]);
    }
    clearDeclarationError(e) {
      this.declarationErrors.delete(e);
    }
    iterateErrors(e) {
      this.declarationErrors.forEach(e);
    }
  }, lb = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(e) {
      this.parser = void 0, this.stack = [new ra()], this.parser = e;
    }
    enter(e) {
      this.stack.push(e);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e, r) {
      let s = r.loc.start, {
        stack: i
      } = this, a = i.length - 1, o = i[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(e, s);
        else
          return;
        o = i[--a];
      }
      this.parser.raise(e, s);
    }
    recordArrowParameterBindingError(e, r) {
      let {
        stack: s
      } = this, i = s[s.length - 1], a = r.loc.start;
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(e, a);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(e, a);
      else
        return;
    }
    recordAsyncArrowParametersError(e) {
      let {
        stack: r
      } = this, s = r.length - 1, i = r[s];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === 2 && i.recordDeclarationError(B.AwaitBindingIdentifier, e), i = r[--s];
    }
    validateAsPattern() {
      let {
        stack: e
      } = this, r = e[e.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([s, i]) => {
        this.parser.raise(s, i);
        let a = e.length - 2, o = e[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(i.index), o = e[--a];
      });
    }
  };
  function WDe() {
    return new ra(3);
  }
  n(WDe, "newParameterDeclarationScope");
  function YDe() {
    return new qc(1);
  }
  n(YDe, "newArrowHeadScope");
  function JDe() {
    return new qc(2);
  }
  n(JDe, "newAsyncArrowScope");
  function gN() {
    return new ra();
  }
  n(gN, "newExpressionScope");
  var ub = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(e) {
      this.stacks.push(e);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function jc(t, e) {
    return (t ? 2 : 0) | (e ? 1 : 0);
  }
  n(jc, "functionFlags");
  var cb = class extends nb {
    static {
      n(this, "UtilParser");
    }
    addExtra(e, r, s, i = !0) {
      if (!e) return;
      let a = e.extra = e.extra || {};
      i ? a[r] = s : Object.defineProperty(a, r, {
        enumerable: i,
        value: s
      });
    }
    isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
    }
    isUnparsedContextual(e, r) {
      let s = e + r.length;
      if (this.input.slice(e, s) === r) {
        let i = this.input.charCodeAt(s);
        return !(Zn(i) || (i & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(e) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, e);
    }
    eatContextual(e) {
      return this.isContextual(e) ? (this.next(), !0) : !1;
    }
    expectContextual(e, r) {
      if (!this.eatContextual(e)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, e);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return bN.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return Zw.lastIndex = this.state.end, Zw.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(B.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e, r) {
      this.eat(e) || this.unexpected(r, e);
    }
    tryParse(e, r = this.state.clone()) {
      let s = {
        node: null
      };
      try {
        let i = e((a = null) => {
          throw s.node = a, s;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: i,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: i,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (i) {
        let a = this.state;
        if (this.state = r, i instanceof SyntaxError)
          return {
            node: null,
            error: i,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (i === s)
          return {
            node: s.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw i;
      }
    }
    checkExpressionErrors(e, r) {
      if (!e) return !1;
      let {
        shorthandAssignLoc: s,
        doubleProtoLoc: i,
        privateKeyLoc: a,
        optionalParametersLoc: o
      } = e, l = !!s || !!i || !!o || !!a;
      if (!r)
        return l;
      s != null && this.raise(B.InvalidCoverInitializedName, s), i != null && this.raise(B.DuplicateProto, i), a != null && this.raise(B.UnexpectedPrivateField,
      a), o != null && this.unexpected(o);
    }
    isLiteralPropertyName() {
      return cN(this.state.type);
    }
    isPrivateName(e) {
      return e.type === "PrivateName";
    }
    getPrivateNameSV(e) {
      return e.id.name;
    }
    hasPropertyAsPrivateName(e) {
      return (e.type === "MemberExpression" || e.type === "OptionalMemberExpression") && this.isPrivateName(e.property);
    }
    isObjectProperty(e) {
      return e.type === "ObjectProperty";
    }
    isObjectMethod(e) {
      return e.type === "ObjectMethod";
    }
    initializeScopes(e = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let s = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let i = this.inModule;
      this.inModule = e;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, e);
      let l = this.prodParam;
      this.prodParam = new ub();
      let u = this.classScope;
      this.classScope = new ob(this);
      let c = this.expressionScope;
      return this.expressionScope = new lb(this), () => {
        this.state.labels = r, this.exportedIdentifiers = s, this.inModule = i, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let e = 0;
      this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
    }
    checkDestructuringPrivate(e) {
      let {
        privateKeyLoc: r
      } = e;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, ea = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, sa = class {
    static {
      n(this, "Node");
    }
    constructor(e, r, s) {
      this.type = "", this.start = r, this.end = 0, this.loc = new ta(s), e != null && e.options.ranges && (this.range = [r, 0]), e != null &&
      e.filename && (this.loc.filename = e.filename);
    }
  }, Cb = sa.prototype;
  Cb.__clone = function() {
    let t = new sa(void 0, this.start, this.loc.start), e = Object.keys(this);
    for (let r = 0, s = e.length; r < s; r++) {
      let i = e[r];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
    }
    return t;
  };
  function XDe(t) {
    return Vs(t);
  }
  n(XDe, "clonePlaceholder");
  function Vs(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o,
      name: l
    } = t, u = Object.create(Cb);
    return u.type = e, u.start = r, u.end = s, u.loc = i, u.range = a, u.extra = o, u.name = l, e === "Placeholder" && (u.expectedNode = t.expectedNode),
    u;
  }
  n(Vs, "cloneIdentifier");
  function $De(t) {
    let {
      type: e,
      start: r,
      end: s,
      loc: i,
      range: a,
      extra: o
    } = t;
    if (e === "Placeholder")
      return XDe(t);
    let l = Object.create(Cb);
    return l.type = e, l.start = r, l.end = s, l.loc = i, l.range = a, t.raw !== void 0 ? l.raw = t.raw : l.extra = o, l.value = t.value, l;
  }
  n($De, "cloneStringLiteral");
  var pb = class extends cb {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let e = this.state.startLoc;
      return new sa(this, e.index, e);
    }
    startNodeAt(e) {
      return new sa(this, e.index, e);
    }
    startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
    }
    finishNode(e, r) {
      return this.finishNodeAt(e, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(e, r, s) {
      return e.type = r, e.end = s.index, e.loc.end = s, this.options.ranges && (e.range[1] = s.index), this.options.attachComment && this.processComment(
      e), e;
    }
    resetStartLocation(e, r) {
      e.start = r.index, e.loc.start = r, this.options.ranges && (e.range[0] = r.index);
    }
    resetEndLocation(e, r = this.state.lastTokEndLoc) {
      e.end = r.index, e.loc.end = r, this.options.ranges && (e.range[1] = r.index);
    }
    resetStartLocationFromNode(e, r) {
      this.resetStartLocation(e, r.loc.start);
    }
  }, HDe = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), ke = qs`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Cannot overwrite reserved type ${t}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Boolean enum members need to be initialized. Use either \`${t} = true,\` or \`${t} = false,\` in enum \`${e}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: t,
      enumName: e
    }) => `Enum member names need to be unique, but the name \`${t}\` has already been used before in enum \`${e}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: t
    }) => `Enum \`${t}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: t,
      enumName: e
    }) => `Enum type \`${t}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: t
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      explicitType: r
    }) => `Enum \`${t}\` has type \`${r}\`, so the initializer of \`${e}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${t}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${t}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${r}\`, in enum \`${t}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: t,
      memberName: e
    }) => `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${t}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: t
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: t
    }) => `Unexpected reserved type ${t}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: t,
      suggestion: e
    }) => `\`declare export ${t}\` is not supported. Use \`${e}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function zDe(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "T\
ypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  n(zDe, "isEsModuleType");
  function rN(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  n(rN, "hasTypeImportKind");
  var GDe = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function QDe(t, e) {
    let r = [], s = [];
    for (let i = 0; i < t.length; i++)
      (e(t[i], i, t) ? r : s).push(t[i]);
    return [r, s];
  }
  n(QDe, "partition");
  var ZDe = /\*?\s*@((?:no)?flow)\b/, e_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return eb;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(r, s) {
      r !== 133 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, s);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let s = ZDe.exec(r.value);
        if (s) if (s[1] === "flow")
          this.flowPragma = "flow";
        else if (s[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let i = this.flowParseType();
      return this.state.inType = s, i;
    }
    flowParsePredicate() {
      let r = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(ke.UnexpectedSpaceBetweenModuloChecks,
      s), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let s = null, i = null;
      return this.match(54) ? (this.state.inType = r, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = r, this.
      match(54) && (i = this.flowParsePredicate())), [s, i];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let s = r.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
      this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return i.params = o.params, i.rest = o.rest, i.this = o._this, this.expect(11), [i.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      s), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (s && this.raise(ke.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, s);
      this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(133) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let s = r.body = this.startNode(), i = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ke.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), super.parseImport(l)) : (this.expectContextual(125, ke.UnsupportedStatementInDeclareModule), l = this.flowParseDeclare(
        l, !0)), i.push(l);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, o = !1;
      return i.forEach((l) => {
        zDe(l) ? (a === "CommonJS" && this.raise(ke.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(ke.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(ke.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
        let i = this.state.value;
        throw this.raise(ke.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: i,
          suggestion: GDe[i]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.
        exportKind), r.type = "Declare" + r.type, r;
      this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let s = this.flowParseTypeAlias(r);
      return s.type = "DeclareTypeAlias", s;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let s = this.flowParseOpaqueType(r, !0);
      return s.type = "DeclareOpaqueType", s;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, s) {
      if (r.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(r.id.name, s ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: s,
        allowExact: !1,
        allowSpread: !1,
        allowProto: s,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(ke.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, s, i) {
      HDe.has(r) && this.raise(i ? ke.AssignReservedType : ke.UnexpectedReservedType, s, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, s) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, s || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return i.name = o.name, i.variance = a, i.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) :
      r && this.raise(ke.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = !1;
      do {
        let a = this.flowParseTypeParameter(i);
        s.params.push(a), a.default && (i = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), s = this.state.inType;
      r.params = [], this.state.inType = !0, this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let r = this.startNode(), s = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, s, i) {
      return r.static = s, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = i, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, s) {
      return r.static = s, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, s) {
      let i = this.startNode();
      return r.static = s, r.value = this.flowParseObjectTypeMethodish(i), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: s,
      allowSpread: i,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, f = !1;
      for (s && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let y = !1, T = null, L = null, q = this.startNode();
        if (a && this.isContextual(118)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), T = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let U = this.lookahead();
          U.type !== 14 && U.type !== 17 && (this.next(), y = !0);
        }
        let _ = this.flowParseVariance();
        if (this.eat(0))
          T != null && this.unexpected(T), this.eat(0) ? (_ && this.unexpected(_.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          q, y))) : u.indexers.push(this.flowParseObjectTypeIndexer(q, y, _));
        else if (this.match(10) || this.match(47))
          T != null && this.unexpected(T), _ && this.unexpected(_.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(q, y));
        else {
          let U = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let ie = this.lookahead();
            cN(ie.type) && (U = this.state.value, this.next());
          }
          let J = this.flowParseObjectTypeProperty(q, y, T, _, U, i, o ?? !p);
          J === null ? (f = !0, L = this.state.lastTokStartLoc) : u.properties.push(J);
        }
        this.flowObjectTypeSemicolon(), L && !this.match(8) && !this.match(9) && this.raise(ke.UnexpectedExplicitInexactInObject, L);
      }
      this.expect(c), i && (u.inexact = f);
      let m = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, m;
    }
    flowParseObjectTypeProperty(r, s, i, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(ke.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(ke.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(ke.InexactVariance, a), null) : (l || this.raise(
        ke.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), a && this.raise(ke.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = s, r.proto = i != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(ke.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let s = r.kind === "get" ? 0 : 1, i = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? ke.GetterMayNotHaveThisParam : ke.SetterMayNotHaveThisParam, r.value.this), i !== s && this.
      raise(r.kind === "get" ? B.BadGetterArity : B.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(B.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, s) {
      var i;
      (i = r) != null || (r = this.state.startLoc);
      let a = s || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let o = this.startNodeAt(r);
        o.qualification = a, o.id = this.flowParseRestrictedIdentifier(!0), a = this.finishNode(o, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(r, s) {
      let i = this.startNodeAt(r);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(r, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let s = null, i = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(ke.ThisParamMustBeFirst, o), s = this.parseIdentifier(u), this.eat(17) &&
      (i = !0, u && this.raise(ke.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = s,
      o.optional = i, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let s = this.startNodeAt(r.loc.start);
      return s.name = null, s.optional = !1, s.typeAnnotation = r, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let s = null, i = null;
      for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: s,
        _this: i
      };
    }
    flowIdentToTypeAnnotation(r, s, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(r, i);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, s = this.startNode(), i, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), u.params =
          i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (mt(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(),
          u.params = i.params, u.rest = i.rest, u.this = i._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(ke.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Eb(this.state.type)) {
            let u = Si(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (mt(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, s = this.flowParsePrimaryType(), i = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        i = i || o, this.expect(0), !o && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = o, s = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(r.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(r)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.
        typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [s]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? s : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (r.types = [s]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? s : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let s = this.flowParseUnionType();
      return this.state.inType = r, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(r, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let s = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, s, i = !1) {
      if (s) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, i));
        return;
      }
      super.parseFunctionBody(r, !1, i);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, s, i);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let i = this.lookahead();
        if (es(i.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      let s = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(r, s, i) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || mt(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (mt(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(r);
          if (s.name === "type")
            return this.flowParseTypeAlias(r);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return Qw(r) || this.shouldParseEnums() && r === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return Qw(r) || this.shouldParseEnums() && r === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, s, i) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let m = this.lookaheadCharCode();
        if (m === 44 || m === 61 || m === 58 || m === 41)
          return this.setOptionalParametersError(i), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(s), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, f] = this.getArrowLikeExpressions(u);
      if (c || f.length > 0) {
        let m = [...o];
        if (f.length > 0) {
          this.state = a, this.state.noArrowAt = m;
          for (let y = 0; y < f.length; y++)
            m.push(f[y].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, f] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(ke.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, m.push(p[0].start),
        this.state.noArrowAt = m, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: s
      };
    }
    getArrowLikeExpressions(r, s) {
      let i = [r], a = [];
      for (; i.length !== 0; ) {
        let o = i.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), i.push(o.body)) : o.type === "ConditionalExpression" && (i.push(o.consequent), i.push(o.alternate));
      }
      return s ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : QDe(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var s;
      this.toAssignableList(r.params, (s = r.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, s) {
      let i;
      return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i =
      s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
    }
    parseParenItem(r, s) {
      let i = super.parseParenItem(r, s);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = i, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return i;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        s);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        r.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: s
      } = this.state, i = super.maybeParseExportNamespaceSpecifier(r);
      return i && r.exportKind === "type" && this.unexpected(s), i;
    }
    parseClassId(r, s, i) {
      super.parseClassId(r, s, i), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, s, i) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, s))
          return;
        s.declare = !0;
      }
      super.parseClassMember(r, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "Property\
Definition" ? this.raise(ke.DeclareClassElement, a) : s.value && this.raise(ke.DeclareClassFieldInitializer, s.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), s = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(B.InvalidIdentifier, this.state.curPosition(), {
        identifierName: s
      }), this.finishToken(132, s);
    }
    getTokenFromCode(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : MDe(r, s, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, s) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      !s && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, s);
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    toReferencedList(r, s) {
      for (let a = 0; a < r.length; a++) {
        var i;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((i = o.extra) != null && i.parenthesized) && (r.length > 1 || !s) && this.raise(ke.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return s && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements), o;
    }
    isValidLVal(r, s, i) {
      return r === "TypeCastExpression" || super.isValidLVal(r, s, i);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, s, i, a, o, l), s.params && o) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(ke.ThisParamBannedInConstructor, s);
      } else if (s.type === "MethodDefinition" && o && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(ke.ThisParamBannedInConstructor, s);
      }
    }
    pushClassPrivateMethod(r, s, i, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, s, i, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.
      isContextual(113)) {
        this.next();
        let s = r.implements = [];
        do {
          let i = this.startNode();
          i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.
          typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let s = this.getObjectOrClassMethodParams(r);
      if (s.length > 0) {
        let i = s[0];
        this.isThisParam(i) && r.kind === "get" ? this.raise(ke.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(ke.SetterMayNotHaveThisParam,
        i);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, s, i, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseAssignableListItemTypes(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(ke.PatternIsOptional, r), this.isThisParam(r) && this.raise(ke.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(ke.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(ke.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(ke.TypeBeforeInitializer,
      i.typeAnnotation), i;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ke.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, s, i) {
      s.local = rN(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(s,
      i));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let s = this.lookaheadCharCode();
        return s === 123 || s === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      if (super.applyImportPhase(r, s, i, a), s) {
        if (!i && this.match(65))
          return;
        r.exportKind = i === "type" ? i : "value";
      } else
        i === "type" && this.match(55) && this.unexpected(), r.importKind = i === "type" || i === "typeof" ? i : "value";
    }
    parseImportSpecifier(r, s, i, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let f = this.parseIdentifier(!0);
        u !== null && !es(this.state.type) ? (r.imported = f, r.importKind = u, r.local = Vs(f)) : (r.imported = l, r.importKind = null, r.local =
        this.parseIdentifier());
      } else {
        if (u !== null && es(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (s)
            throw this.raise(B.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = Vs(r.imported));
      }
      let p = rN(r);
      return i && p && this.raise(ke.ImportTypeShorthandOnlyInPureImport, r), (i || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !i && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, s) {
      let i = r.kind;
      i !== "get" && i !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      if (this.match(14)) {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
      }
      return super.parseAsyncArrowFromCallExpression(r, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, s) {
      var i;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, s), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === Pt.j_oTag || p === Pt.j_expr) && c.pop();
      }
      if ((i = o) != null && i.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((m) => {
          var y;
          c = this.flowParseTypeParameterDeclaration();
          let T = this.forwardNoArrowParamsConversionAt(c, () => {
            let q = super.parseMaybeAssign(r, s);
            return this.resetStartLocationFromNode(q, c), q;
          });
          (y = T.extra) != null && y.parenthesized && m();
          let L = this.maybeUnwrapTypeCastExpression(T);
          return L.type !== "ArrowFunctionExpression" && m(), L.typeParameters = c, this.resetStartLocationFromNode(L, c), T;
        }, a), f = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(ke.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          f = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (f)
          return this.state = p.failState, f;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(ke.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let i = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown) return null;
        s.error && (this.state = s.failState), r.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, s) {
      this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = s : super.setArrowFunctionParameters(r, s);
    }
    checkParams(r, s, i, a = !0) {
      if (!(i && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(ke.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, s, i, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(r, s, i) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, s, i), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, s, i);
    }
    parseSubscript(r, s, i, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, i)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(s);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), o.arguments = this.parseCallExpressionArguments(
        11, !1), o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        let o = this.startNodeAt(s);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(11, !1), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      s;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let s = this.startNodeAt(r);
      if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, s) {
      let i = super.parseTopLevel(r, s);
      return this.state.hasFlowComment && this.raise(ke.UnterminatedFlowComment, this.state.curPosition()), i;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(ke.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + s)); )
        s++;
      let i = this.input.charCodeAt(s + r), a = this.input.charCodeAt(s + r + 1);
      return i === 58 && a === 58 ? s + 2 : this.input.slice(s + r, s + r + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(B.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: s,
      memberName: i
    }) {
      this.raise(ke.EnumBooleanMemberNotInitialized, r, {
        memberName: i,
        enumName: s
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? ke.EnumInvalidMemberInitializerSymbolType : ke.EnumInvalidMemberInitializerPrimaryType :
      ke.EnumInvalidMemberInitializerUnknownType, r, s);
    }
    flowEnumErrorNumberMemberNotInitialized(r, s) {
      this.raise(ke.EnumNumberMemberNotInitialized, r, s);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, s) {
      this.raise(ke.EnumStringMemberInconsistentlyInitialized, r, s);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, s = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 134: {
          let i = this.parseNumericLiteral(this.state.value);
          return s() ? {
            type: "number",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 133: {
          let i = this.parseStringLiteral(this.state.value);
          return s() ? {
            type: "string",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let i = this.parseBooleanLiteral(this.match(85));
          return s() ? {
            type: "boolean",
            loc: i.loc.start,
            value: i
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, s = this.parseIdentifier(!0), i = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: s,
        init: i
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, s, i) {
      let {
        explicitType: a
      } = s;
      a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(r, s);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: s
    }) {
      let i = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(ke.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), i.has(p) && this.raise(ke.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), i.add(p);
        let f = {
          enumName: r,
          explicitType: s,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, f);
          case "none":
            switch (s) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, f);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, f);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, s, {
      enumName: i
    }) {
      if (r.length === 0)
        return s;
      if (s.length === 0)
        return r;
      if (s.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return s;
      } else {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: i
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!mt(this.state.type))
        throw this.raise(ke.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: s
      } = this.state;
      return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(ke.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: s
      }), s;
    }
    flowEnumBody(r, s) {
      let i = s.name, a = s.loc.start, o = this.flowEnumParseExplicitType({
        enumName: i
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: i,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: i
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, f = l.numberMembers.length, m = l.stringMembers.length, y = l.defaultedMembers.length;
          if (!p && !f && !m && !y)
            return c();
          if (!p && !f)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: i
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!f && !m && p >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !m && f >= y) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(T.loc.start, {
                enumName: i,
                memberName: T.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(ke.EnumInconsistentMemberValues, a, {
              enumName: i
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let s = this.parseIdentifier();
      return r.id = s, r.body = this.flowEnumBody(this.startNode(), s), this.finishNode(r, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let s = this.input.charCodeAt(r + 1);
        return s !== 60 && s !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), t_e = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, tn = qs`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: t
    }) => `Expected corresponding JSX closing tag for <${t}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: t,
      HTMLEntity: e
    }) => `Unexpected token \`${t}\`. Did you mean \`${e}\` or \`{'${t}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function xi(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : !1;
  }
  n(xi, "isFragment");
  function Qn(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Qn(t.object) + "." + Qn(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  n(Qn, "getQualifiedJSXName");
  var r_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(tn.UnterminatedJsxContent, this.state.startLoc);
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
              return;
            }
            r += this.input.slice(s, this.state.pos), this.finishToken(141, r);
            return;
          case 38:
            r += this.input.slice(s, this.state.pos), r += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Xo(i) ? (r += this.input.slice(s, this.state.pos), r += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let s = this.input.charCodeAt(this.state.pos), i;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = r ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
    }
    jsxReadString(r) {
      let s = "", i = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(B.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : Xo(a) ? (s += this.input.slice(
        i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let i = this.readInt(s, void 0, !1, "bail");
        if (i !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(i);
      } else {
        let s = 0, i = !1;
        for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (i) {
          let a = this.input.slice(r, this.state.pos), o = t_e[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, s = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (Zn(r) || r === 45);
      this.finishToken(140, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(140) ? r.name = this.state.value : Eb(this.state.type) ? r.name = Si(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14)) return s;
      let i = this.startNodeAt(r);
      return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let i = this.startNodeAt(r);
        i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(Pt.brace), this.next(), r = this.jsxParseExpressionContainer(r, Pt.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(tn.AttributeIsEmpty, r), r;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(tn.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(Pt.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, s) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let i = this.parseExpression();
        r.expression = i;
      }
      return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(Pt.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      Pt.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      s));
    }
    jsxParseOpeningElementAfterName(r) {
      let s = [];
      for (; !this.match(56) && !this.match(143); )
        s.push(this.jsxParseAttribute());
      return r.attributes = s, r.selfClosing = this.eat(56), this.expect(143), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(
      s, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let s = this.startNodeAt(r), i = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 142:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              i.push(this.jsxParseElementAt(r));
              break;
            case 141:
              i.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(Pt.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(l)) : i.push(this.jsxParseExpressionContainer(
              l, Pt.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        xi(a) && !xi(o) && o !== null ? this.raise(tn.MissingClosingTagFragment, o) : !xi(a) && xi(o) ? this.raise(tn.MissingClosingTagElement,
        o, {
          openingTagName: Qn(a.name)
        }) : !xi(a) && !xi(o) && Qn(o.name) !== Qn(a.name) && this.raise(tn.MissingClosingTagElement, o, {
          openingTagName: Qn(a.name)
        });
      }
      if (xi(a) ? (s.openingFragment = a, s.closingFragment = o) : (s.openingElement = a, s.closingElement = o), s.children = i, this.match(
      47))
        throw this.raise(tn.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return xi(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: s
      } = this.state;
      s[s.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      142), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let s = this.curContext();
      if (s === Pt.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === Pt.j_oTag || s === Pt.j_cTag) {
        if (Us(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((r === 34 || r === 39) && s === Pt.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: s,
        type: i
      } = this.state;
      if (i === 56 && r === 142)
        s.splice(-2, 2, Pt.j_cTag), this.state.canStartJSXElement = !1;
      else if (i === 142)
        s.push(Pt.j_oTag);
      else if (i === 143) {
        let a = s[s.length - 1];
        a === Pt.j_oTag && r === 56 || a === Pt.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === Pt.j_expr) : (this.setContext(
        Pt.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = xDe(i);
    }
  }, "jsx"), fb = class extends $o {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...e) {
      super(...e), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, hb = class extends Ho {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...e) {
      super(...e), this.importsStack = [];
    }
    createScope(e) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new fb(e);
    }
    enter(e) {
      e === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e);
    }
    exit() {
      let e = super.exit();
      return e === 256 && this.importsStack.pop(), e;
    }
    hasImport(e, r) {
      let s = this.importsStack.length;
      if (this.importsStack[s - 1].has(e))
        return !0;
      if (!r && s > 1) {
        for (let i = 0; i < s - 1; i++)
          if (this.importsStack[i].has(e)) return !0;
      }
      return !1;
    }
    declareName(e, r, s) {
      if (r & 4096) {
        this.hasImport(e, !0) && this.parser.raise(B.VarRedeclaration, s, {
          identifierName: e
        }), this.importsStack[this.importsStack.length - 1].add(e);
        return;
      }
      let i = this.currentScope(), a = i.tsNames.get(e) || 0;
      if (r & 1024) {
        this.maybeExportDefined(i, e), i.tsNames.set(e, a | 16);
        return;
      }
      super.declareName(e, r, s), r & 2 && (r & 1 || (this.checkRedeclarationInScope(i, e, r, s), this.maybeExportDefined(i, e)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && i.tsNames.set(e, a);
    }
    isRedeclaredInScope(e, r, s) {
      let i = e.tsNames.get(r);
      if ((i & 2) > 0) {
        if (s & 256) {
          let a = !!(s & 512), o = (i & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return s & 128 && (i & 8) > 0 ? e.names.get(r) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(e, r, s);
    }
    checkLocalExport(e) {
      let {
        name: r
      } = e;
      if (this.hasImport(r)) return;
      let s = this.scopeStack.length;
      for (let i = s - 1; i >= 0; i--) {
        let o = this.scopeStack[i].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(e);
    }
  }, s_e = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn$1"), PN = /* @__PURE__ */ n((t) => t.type === "Parenthesiz\
edExpression" ? PN(t.expression) : t, "unwrapParenthesizedExpression"), db = class extends pb {
    static {
      n(this, "LValParser");
    }
    toAssignable(e, r = !1) {
      var s, i;
      let a;
      switch ((e.type === "ParenthesizedExpression" || (s = e.extra) != null && s.parenthesized) && (a = PN(e), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(B.InvalidParenthesizedAssignment, e) : a.type !== "MemberExpression" && !this.isOptionalMemberExpression(
      a) && this.raise(B.InvalidParenthesizedAssignment, e) : this.raise(B.InvalidParenthesizedAssignment, e)), e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern";
          for (let l = 0, u = e.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = e.properties[l], f = l === c;
            this.toAssignableObjectExpressionProp(p, f, r), f && p.type === "RestElement" && (o = e.extra) != null && o.trailingCommaLoc && this.
            raise(B.RestTrailingComma, e.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = e;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          e.type = "ArrayPattern", this.toAssignableList(e.elements, (i = e.extra) == null ? void 0 : i.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(B.MissingEqInAssignment, e.left.loc.end), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(
          e.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(e, r, s) {
      if (e.type === "ObjectMethod")
        this.raise(e.kind === "get" || e.kind === "set" ? B.PatternHasAccessor : B.PatternHasMethod, e.key);
      else if (e.type === "SpreadElement") {
        e.type = "RestElement";
        let i = e.argument;
        this.checkToRestConversion(i, !1), this.toAssignable(i, s), r || this.raise(B.RestTrailingComma, e);
      } else
        this.toAssignable(e, s);
    }
    toAssignableList(e, r, s) {
      let i = e.length - 1;
      for (let a = 0; a <= i; a++) {
        let o = e[a];
        if (o) {
          if (o.type === "SpreadElement") {
            o.type = "RestElement";
            let l = o.argument;
            this.checkToRestConversion(l, !0), this.toAssignable(l, s);
          } else
            this.toAssignable(o, s);
          o.type === "RestElement" && (a < i ? this.raise(B.RestTrailingComma, o) : r && this.raise(B.RestTrailingComma, r));
        }
      }
    }
    isAssignable(e, r) {
      switch (e.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let s = e.properties.length - 1;
          return e.properties.every((i, a) => i.type !== "ObjectMethod" && (a === s || i.type !== "SpreadElement") && this.isAssignable(i));
        }
        case "ObjectProperty":
          return this.isAssignable(e.value);
        case "SpreadElement":
          return this.isAssignable(e.argument);
        case "ArrayExpression":
          return e.elements.every((s) => s === null || this.isAssignable(s));
        case "AssignmentExpression":
          return e.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(e.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(e, r) {
      return e;
    }
    toReferencedListDeep(e, r) {
      this.toReferencedList(e, r);
      for (let s of e)
        s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
    }
    parseSpread(e) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(e, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let e = this.startNode();
      return this.next(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(3, 93, 1), this.finishNode(e, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e, r, s) {
      let i = s & 1, a = [], o = !0;
      for (; !this.eat(e); )
        if (o ? o = !1 : this.expect(12), i && this.match(12))
          a.push(null);
        else {
          if (this.eat(e))
            break;
          if (this.match(21)) {
            if (a.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(r)) {
              this.expect(e);
              break;
            }
          } else {
            let l = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(B.UnsupportedParameterDecorator, this.state.startLoc); this.match(
            26); )
              l.push(this.parseDecorator());
            a.push(this.parseAssignableListItem(s, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(e) {
      return this.next(), e.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: e,
        startLoc: r
      } = this.state;
      if (e === 21)
        return this.parseBindingRestProperty(this.startNode());
      let s = this.startNode();
      return e === 138 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), s.key = this.parsePrivateName()) :
      this.parsePropertyName(s), s.method = !1, this.parseObjPropValue(s, r, !1, !1, !0, !1);
    }
    parseAssignableListItem(e, r) {
      let s = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s, e);
      let i = this.parseMaybeDefault(s.loc.start, s);
      return r.length && (s.decorators = r), i;
    }
    parseAssignableListItemTypes(e, r) {
      return e;
    }
    parseMaybeDefault(e, r) {
      var s, i;
      if ((s = e) != null || (e = this.state.startLoc), r = (i = r) != null ? i : this.parseBindingAtom(), !this.eat(29)) return r;
      let a = this.startNodeAt(e);
      return a.left = r, a.right = this.parseMaybeAssignAllowIn(), this.finishNode(a, "AssignmentPattern");
    }
    isValidLVal(e, r, s) {
      return s_e({
        AssignmentPattern: "left",
        RestElement: "argument",
        ObjectProperty: "value",
        ParenthesizedExpression: "expression",
        ArrayPattern: "elements",
        ObjectPattern: "properties"
      }, e);
    }
    isOptionalMemberExpression(e) {
      return e.type === "OptionalMemberExpression";
    }
    checkLVal(e, {
      in: r,
      binding: s = 64,
      checkClashes: i = !1,
      strictModeChanged: a = !1,
      hasParenthesizedAncestor: o = !1
    }) {
      var l;
      let u = e.type;
      if (this.isObjectMethod(e)) return;
      let c = this.isOptionalMemberExpression(e);
      if (c || u === "MemberExpression") {
        c && (this.expectPlugin("optionalChainingAssign", e.loc.start), r.type !== "AssignmentExpression" && this.raise(B.InvalidLhsOptionalChaining,
        e, {
          ancestor: r
        })), s !== 64 && this.raise(B.InvalidPropertyBindingPattern, e);
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(e, s, a);
        let {
          name: T
        } = e;
        i && (i.has(T) ? this.raise(B.ParamDupe, e) : i.add(T));
        return;
      }
      let p = this.isValidLVal(u, !(o || (l = e.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", s);
      if (p === !0) return;
      if (p === !1) {
        let T = s === 64 ? B.InvalidLhs : B.InvalidLhsBinding;
        this.raise(T, e, {
          ancestor: r
        });
        return;
      }
      let [f, m] = Array.isArray(p) ? p : [p, u === "ParenthesizedExpression"], y = u === "ArrayPattern" || u === "ObjectPattern" ? {
        type: u
      } : r;
      for (let T of [].concat(e[f]))
        T && this.checkLVal(T, {
          in: y,
          binding: s,
          checkClashes: i,
          strictModeChanged: a,
          hasParenthesizedAncestor: m
        });
    }
    checkIdentifier(e, r, s = !1) {
      this.state.strict && (s ? yN(e.name, this.inModule) : mN(e.name)) && (r === 64 ? this.raise(B.StrictEvalArguments, e, {
        referenceName: e.name
      }) : this.raise(B.StrictEvalArgumentsBinding, e, {
        bindingName: e.name
      })), r & 8192 && e.name === "let" && this.raise(B.LetInLexicalBinding, e), r & 64 || this.declareNameFromIdentifier(e, r);
    }
    declareNameFromIdentifier(e, r) {
      this.scope.declareName(e.name, r, e.loc.start);
    }
    checkToRestConversion(e, r) {
      switch (e.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(B.InvalidRestAssignmentPattern, e);
      }
    }
    checkCommaAfterRest(e) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === e ? B.RestTrailingComma : B.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, i_e = /* @__PURE__ */ n((t, e) => hasOwnProperty.call(t, e) && t[e], "getOwn");
  function n_e(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  n(n_e, "nonNull");
  function sN(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  n(sN, "assert");
  var Te = qs`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: t
    }) => `Method '${t}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: t
    }) => `Property '${t}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or nu\
meric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: t
    }) => `'declare' is not allowed in ${t}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => "Accessibility modifier already seen.", "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: t
    }) => `Duplicate modifier: '${t}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: t
    }) => `'${t}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: t
    }) => `'${t[0]}' modifier cannot be used with '${t[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Index signatures cannot have an accessibility modifier ('${t}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: t
    }) => `'${t}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: t
    }) => `'${t[0]}' modifier must precede '${t[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: t
    }) => `Private elements cannot have an accessibility modifier ('${t}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: t
    }) => `Single type parameter ${t} should have a trailing comma. Example usage: <${t},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: t
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t}.`, "UnsupportedSignatureParameterKind")
  });
  function a_e(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n(a_e, "keywordTypeFromName");
  function iN(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  n(iN, "tsIsAccessModifier");
  function o_e(t) {
    return t === "in" || t === "out";
  }
  n(o_e, "tsIsVarianceAnnotations");
  var l_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Te.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: Te.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: Te.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return hb;
    }
    tsIsIdentifier() {
      return mt(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.
      hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(r, s) {
      if (!mt(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let i = this.state.value;
      if (r.indexOf(i) !== -1) {
        if (s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return i;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: s,
      stopOnStartOfClassStaticBlock: i,
      errorTemplate: a = Te.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ n((c, p, f, m) => {
        p === f && o[m] && this.raise(Te.InvalidModifiersOrder, c, {
          orderedModifiers: [f, m]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ n((c, p, f, m) => {
        (o[f] && p === m || o[m] && p === f) && this.raise(Te.IncompatibleModifiers, c, {
          modifiers: [f, m]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(s ?? []), i);
        if (!p) break;
        iN(p) ? o.accessibility ? this.raise(Te.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : o_e(p) ? (o[p] && this.raise(Te.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(Te.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), s != null && s.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, s) {
      let i = [];
      for (; !this.tsIsListTerminator(r); )
        i.push(s());
      return i;
    }
    tsParseDelimitedList(r, s, i) {
      return n_e(this.tsParseDelimitedListWorker(r, s, !0, i));
    }
    tsParseDelimitedListWorker(r, s, i, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = s();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        i && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, s, i, a, o) {
      a || (i ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, s, o);
      return i ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(Te.UnsupportedImportTypeArgument, this.state.startLoc), r.argument =
      super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r.options = null), this.eat(12) &&
      (this.expectImportAttributesPlugin(), this.match(11) || (r.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11),
      this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(
      r, "TSImportType");
    }
    tsParseEntityName(r = !0) {
      let s = this.parseIdentifier(r);
      for (; this.eat(16); ) {
        let i = this.startNodeAtNode(s);
        i.left = s, i.right = this.parseIdentifier(r), s = this.finishNode(i, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let s = this.startNodeAtNode(r);
      return s.parameterName = r, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let s = this.startNode();
      return r(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(
      29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let s = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let i = {
        value: -1
      };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, i), s.params.
      length === 0 && this.raise(Te.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, s) {
      let i = r === 19, a = "parameters", o = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(),
      i ? s[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (s[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let s of r) {
        let {
          type: i
        } = s;
        (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(Te.UnsupportedSignatureParameterKind, s, {
          type: i
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), mt(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), r.parameters = [s];
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, s) {
      this.eat(17) && (r.optional = !0);
      let i = r;
      if (this.match(10) || this.match(47)) {
        s && this.raise(Te.ReadonlyForMethodSignature, r);
        let a = i;
        a.kind && this.match(47) && this.raise(Te.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, a), this.
        tsParseTypeMemberSemicolon();
        let o = "parameters", l = "typeAnnotation";
        if (a.kind === "get")
          a[o].length > 0 && (this.raise(B.BadGetterArity, this.state.curPosition()), this.isThisParam(a[o][0]) && this.raise(Te.AccesorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (a.kind === "set") {
          if (a[o].length !== 1)
            this.raise(B.BadSetterArity, this.state.curPosition());
          else {
            let u = a[o][0];
            this.isThisParam(u) && this.raise(Te.AccesorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(Te.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            Te.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          a[l] && this.raise(Te.SetAccesorCannotHaveReturnType, a[l]);
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = i;
        s && (a.readonly = !0);
        let o = this.tsTryParseTypeAnnotation();
        return o && (a.typeAnnotation = o), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let i = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let s = this.tsTryParseIndexSignature(r);
      return s || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let r = this.startNode();
      return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
    }
    tsParseMappedType() {
      let r = this.startNode();
      return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(
      122) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.
      tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) &&
      (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let s = !1;
      return r.elementTypes.forEach((i) => {
        let {
          type: a
        } = i;
        s && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && i.optional) && this.raise(Te.OptionalTypeBeforeRequired,
        i), s || (s = a === "TSNamedTupleMember" && i.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let {
        startLoc: r
      } = this.state, s = this.eat(21), i, a, o, l, c = es(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        i = !0, o = !1, a = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (c === 63) {
        o = !0;
        let p = this.state.startLoc, f = this.state.value, m = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (i = !0, a = this.createIdentifier(this.startNodeAt(p), f), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (i = !1, l = m, this.expect(17));
      } else
        l = this.tsParseType(), o = this.eat(17), i = this.eat(14);
      if (i) {
        let p;
        a ? (p = this.startNodeAtNode(a), p.optional = o, p.label = a, p.elementType = l, this.eat(17) && (p.optional = !0, this.raise(Te.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (p = this.startNodeAtNode(l), p.optional = o, this.raise(Te.InvalidTupleMemberLabel, l), p.label = l,
        p.elementType = this.tsParseType()), l = this.finishNode(p, "TSNamedTupleMember");
      } else if (o) {
        let p = this.startNodeAtNode(l);
        p.typeAnnotation = l, l = this.finishNode(p, "TSOptionalType");
      }
      if (s) {
        let p = this.startNodeAt(r);
        p.typeAnnotation = l, l = this.finishNode(p, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, s) {
      let i = this.startNode();
      return r === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, i)), this.finishNode(i, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let r = this.startNode();
      return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), s = this.lookahead();
            return s.type !== 134 && s.type !== 135 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (mt(r) || r === 88 || r === 84) {
            let s = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : a_e(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let i = this.startNode();
              return this.next(), this.finishNode(i, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let r = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAtNode(r);
          s.elementType = r, this.expect(3), r = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAtNode(r);
          s.objectType = r, s.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(s, "TSIndexedAccessType");
        }
      return r;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), s = this.state.value;
      return this.next(), r.operator = s, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(Te.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(s, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return vDe(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, s, i) {
      let a = this.startNode(), o = this.eat(i), l = [];
      do
        l.push(s());
      while (this.eat(i));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (mt(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === s;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === s;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(r);
        let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = !0, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, i), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i,
          "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
        let l = this.tsParseTypeAnnotation(!1);
        return i.parameterName = o, i.typeAnnotation = l, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(
        s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !mt(this.state.type) && !this.match(78) ? !1 : (r && this.raise(B.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, s = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      sN(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let s = this.startNodeAtNode(r);
      return s.checkType = r, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Te.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
        a, "TSExpressionWithTypeArguments");
      });
      return i.length || this.raise(Te.EmptyHeritageClauseType, s, {
        token: r
      }), i;
    }
    tsParseInterfaceDeclaration(r, s = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), s.declare && (r.declare = !0), mt(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(Te.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let i = this.startNode();
      return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().
        type !== 16) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInNoContext(r) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return r();
      } finally {
        this.state.context = s;
      }
    }
    tsInType(r) {
      let s = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, s = {}) {
      return s.const && (r.const = !0), s.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, s = !1) {
      if (r.id = this.parseIdentifier(), s || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let i = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(i, !0), r.body = i;
      } else
        this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(133) ? r.id = super.parseStringLiteral(this.
      state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(),
      this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(r, s, i) {
      r.isExport = i || !1, r.id = s || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(Te.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let s = this.state.clone(), i = r();
      return this.state = s, i;
    }
    tsTryParseAndCatch(r) {
      let s = this.tryParse((i) => r() || i());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(r) {
      let s = this.state.clone(), i = r();
      if (i !== void 0 && i !== !1)
        return i;
      this.state = s;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type, i;
      return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
        switch (s) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, i || this.state.value,
            !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 129: {
            let a = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (a) return a;
          }
          default:
            if (mt(s))
              return this.tsParseDeclaration(r, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(r, s, i) {
      switch (s.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(r);
          return a && (a.declare = !0), a;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let a = r;
            return a.global = !0, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a,
            "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(r, s.name, !1, i);
      }
    }
    tsParseDeclaration(r, s, i, a) {
      switch (s) {
        case "abstract":
          if (this.tsCheckLineTerminator(i) && (this.match(80) || mt(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(i)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (mt(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(i) && mt(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case "type":
          if (this.tsCheckLineTerminator(i) && mt(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let i = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!i)
        return super.parseArrowExpression(i, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments",
      this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(Te.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      Pt.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return CDe(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(r, s) {
      let i = this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(Te.UnexpectedParameterModifier, i);
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, r);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let f = this.startNodeAt(i);
        return s.length && (f.decorators = s), o && (f.accessibility = o), u && (f.readonly = u), l && (f.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(Te.UnsupportedParameterPropertyKind, f), f.parameter = p, this.finishNode(f, "TSParamet\
erProperty");
      }
      return s.length && (c.decorators = s), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let s of r.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(Te.PatternIsOptional, s);
    }
    setArrowFunctionParameters(r, s, i) {
      super.setArrowFunctionParameters(r, s, i), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, s, i = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(Te.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, i) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, s, i));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((s) => {
        s?.type === "TSTypeCastExpression" && this.raise(Te.UnexpectedTypeAnnotation, s.typeAnnotation);
      });
    }
    toReferencedList(r, s) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, s, i, a) {
      let o = super.parseArrayLike(r, s, i, a);
      return o.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(o.elements), o;
    }
    parseSubscript(r, s, i, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(s);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(r)) {
            let m = this.tsTryParseGenericAsyncArrowFunction(s);
            if (m)
              return m;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (Uc(this.state.type)) {
            let m = super.parseTaggedTemplateExpression(r, s, a);
            return m.typeParameters = c, m;
          }
          if (!i && this.eat(10)) {
            let m = this.startNodeAt(s);
            return m.callee = r, m.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(m.arguments), m.typeParameters =
            c, a.optionalChainMember && (m.optional = o), this.finishCallExpression(m, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && G0(p) && !this.hasPrecedingLineBreak())
            return;
          let f = this.startNodeAt(s);
          return f.expression = r, f.typeParameters = c, this.finishNode(f, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          Te.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), u;
      }
      return super.parseSubscript(r, s, i, a);
    }
    parseNewCallee(r) {
      var s;
      super.parseNewCallee(r);
      let {
        callee: i
      } = r;
      i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (r.typeParameters = i.typeParameters, r.callee =
      i.expression);
    }
    parseExprOp(r, s, i) {
      let a;
      if (Bc(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(s);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(B.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, s, i);
      }
      return super.parseExprOp(r, s, i);
    }
    checkReservedWord(r, s, i, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, s, i, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Te.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let s = this.lookaheadCharCode();
        return r ? s === 123 || s === 42 : s !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, i, a) {
      super.applyImportPhase(r, s, i, a), s ? r.exportKind = i === "type" ? "type" : "value" : r.importKind = i === "type" || i === "typeof" ?
      i : "value";
    }
    parseImport(r) {
      if (this.match(133))
        return r.importKind = "value", super.parseImport(r);
      let s;
      if (mt(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let i = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, i);
        s = super.parseImportSpecifiersAndAfter(r, i);
      } else
        s = super.parseImport(r);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(Te.TypeImportCannotSpecifyDefaultAndNamed,
      s), s;
    }
    parseExport(r, s) {
      if (this.match(83)) {
        this.next();
        let i = r, a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(i, !1) : i.importKind = "value", this.
        tsParseImportEqualsDeclaration(i, a, !0);
      } else if (this.eat(29)) {
        let i = r;
        return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let i = r;
        return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, s);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, s, i = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, s, i || a);
      if (!a) return o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (s !== "const" || l.typeAnnotation ? this.raise(Te.InitializerNotAllowedInAmbientContext, u) : c_e(u, this.hasPlugin("estree")) ||
        this.raise(Te.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, s) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let i = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(i, {
          const: !0
        });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i) return i;
      }
      return super.parseStatementContent(r, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, s) {
      return s.some((i) => iN(i) ? r.accessibility === i : !!r[i]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, s, i) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: Te.InvalidModifierOnTypeParameterPositions
      }, s);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(Te.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, s)) : this.parseClassMemberWithIsStatic(r, s, i, !!s.static);
      }, "callParseClassMemberWithIsStatic");
      s.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, s, i, a) {
      let o = this.tsTryParseIndexSignature(s);
      if (o) {
        r.body.push(o), s.abstract && this.raise(Te.IndexSignatureHasAbstract, s), s.accessibility && this.raise(Te.IndexSignatureHasAccessibility,
        s, {
          modifier: s.accessibility
        }), s.declare && this.raise(Te.IndexSignatureHasDeclare, s), s.override && this.raise(Te.IndexSignatureHasOverride, s);
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(Te.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.
      raise(Te.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(r, s, i, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(Te.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(Te.ClassMethodHasDeclare, r);
    }
    parseExpressionStatement(r, s, i) {
      return (s.type === "Identifier" ? this.tsParseExpressionStatement(r, s, i) : void 0) || super.parseExpressionStatement(r, s, i);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, s, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(r, s, i);
      let a = this.tryParse(() => super.parseConditional(r, s));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), r);
    }
    parseParenItem(r, s) {
      let i = super.parseParenItem(r, s);
      if (this.eat(17) && (i.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let s = this.state.startLoc, i = this.eatContextual(125);
      if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(Te.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = mt(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || i) && (r.exportKind = "type"), i && (this.resetStartLocation(
      o, s), o.declare = !0), o) : null;
    }
    parseClassId(r, s, i, a) {
      if ((!s || i) && this.isContextual(113))
        return;
      super.parseClassId(r, s, i, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let s = this.tsTryParseTypeAnnotation();
      s && (r.typeAnnotation = s);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(Te.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: s
        } = r;
        this.raise(Te.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: s.type === "Identifier" && !r.computed ? s.name : `[${this.input.slice(s.start, s.end)}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(Te.PrivateElementHasAbstract, r), r.accessibility && this.raise(Te.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(Te.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, s, i, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(Te.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = s;
      c && (p === "get" || p === "set") && this.raise(Te.DeclareAccessor, s, {
        kind: p
      }), u && (s.typeParameters = u), super.pushClassMethod(r, s, i, a, o, l);
    }
    pushClassPrivateMethod(r, s, i, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (s.typeParameters = o), super.pushClassPrivateMethod(r, s, i, a);
    }
    declareClassPrivateMethodInScope(r, s) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(
      r, s));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, s, i, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, s, i, a, o, l, u);
    }
    parseFunctionParams(r, s) {
      let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      i && (r.typeParameters = i), super.parseFunctionParams(r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let i = this.tsTryParseTypeAnnotation();
      i && (r.id.typeAnnotation = i, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, s);
    }
    parseMaybeAssign(r, s) {
      var i, a, o, l, u;
      let c, p, f;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, s), c), !p.error) return p.node;
        let {
          context: T
        } = this.state, L = T[T.length - 1];
        (L === Pt.j_oTag || L === Pt.j_expr) && T.pop();
      }
      if (!((i = p) != null && i.error) && !this.match(47))
        return super.parseMaybeAssign(r, s);
      (!c || c === this.state) && (c = this.state.clone());
      let m, y = this.tryParse((T) => {
        var L, q;
        m = this.tsParseTypeParameters(this.tsParseConstModifier);
        let _ = super.parseMaybeAssign(r, s);
        return (_.type !== "ArrowFunctionExpression" || (L = _.extra) != null && L.parenthesized) && T(), ((q = m) == null ? void 0 : q.params.
        length) !== 0 && this.resetStartLocationFromNode(_, m), _.typeParameters = m, _;
      }, c);
      if (!y.error && !y.aborted)
        return m && this.reportReservedArrowTypeParam(m), y.node;
      if (!p && (sN(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, s), c), !f.error))
        return f.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (y.node)
        return this.state = y.failState, m && this.reportReservedArrowTypeParam(m), y.node;
      if ((o = f) != null && o.node)
        return this.state = f.failState, f.node;
      throw ((l = p) == null ? void 0 : l.error) || y.error || ((u = f) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var s;
      r.params.length === 1 && !r.params[0].constraint && !((s = r.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(Te.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse((i) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
        });
        if (s.aborted) return;
        s.thrown || (s.error && (this.state = s.failState), r.returnType = s.node);
      }
      return super.parseArrow(r);
    }
    parseAssignableListItemTypes(r, s) {
      if (!(s & 2)) return r;
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, s) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, s);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, s);
      }
    }
    toAssignable(r, s = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(Te.UnexpectedTypeCastInParameter, r) : this.raise(Te.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, s);
          break;
        case "AssignmentExpression":
          !s && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, s);
      }
    }
    toAssignableParenthesizedExpression(r, s) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, s);
          break;
        default:
          super.toAssignable(r, s);
      }
    }
    checkToRestConversion(r, s) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, s);
      }
    }
    isValidLVal(r, s, i) {
      return i_e({
        TSTypeCastExpression: !0,
        TSParameterProperty: "parameter",
        TSNonNullExpression: "expression",
        TSInstantiationExpression: "expression",
        TSAsExpression: (i !== 64 || !s) && ["expression", !0],
        TSSatisfiesExpression: (i !== 64 || !s) && ["expression", !0],
        TSTypeAssertion: (i !== 64 || !s) && ["expression", !0]
      }, r) || super.isValidLVal(r, s, i);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let i = super.parseMaybeDecoratorArguments(r);
          return i.typeParameters = s, i;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, s) {
      let i = super.parseMaybeDefault(r, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(Te.TypeAnnotationAfterAssign,
      i.typeAnnotation), i;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableList(r, s, i) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TSTypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, i);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (r.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let s = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let s = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = s;
      }
    }
    parseClass(r, s, i) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, s, i);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, s) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(r, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return r.abstract = !0, this.raise(Te.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(r, s, i, a, o, l, u) {
      let c = super.parseMethod(r, s, i, a, o, l, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let {
          key: f
        } = c;
        this.raise(Te.AbstractMethodHasImplementation, c, {
          methodName: f.type === "Identifier" && !c.computed ? f.name : `[${this.input.slice(f.start, f.end)}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, s, i, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, i), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, s, i, a));
    }
    parseImportSpecifier(r, s, i, a, o) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, i), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, s, i, a, i ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, s, i) {
      let a = s ? "imported" : "local", o = s ? "local" : "exported", l = r[a], u, c = !1, p = !0, f = l.loc.start;
      if (this.isContextual(93)) {
        let y = this.parseIdentifier();
        if (this.isContextual(93)) {
          let T = this.parseIdentifier();
          es(this.state.type) ? (c = !0, l = y, u = s ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = T, p = !1);
        } else es(this.state.type) ? (p = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = y);
      } else es(this.state.type) && (c = !0, s ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && i && this.raise(s ? Te.TypeModifierIsUsedInTypeImports : Te.TypeModifierIsUsedInTypeExports, f), r[a] = l, r[o] = u;
      let m = s ? "importKind" : "exportKind";
      r[m] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = s ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = Vs(r[a])), s && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
  }, "typescript");
  function u_e(t) {
    if (t.type !== "MemberExpression") return !1;
    let {
      computed: e,
      property: r
    } = t;
    return e && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : AN(t.object);
  }
  n(u_e, "isPossiblyLiteralEnum");
  function c_e(t, e) {
    var r;
    let {
      type: s
    } = t;
    if ((r = t.extra) != null && r.parenthesized)
      return !1;
    if (e) {
      if (s === "Literal") {
        let {
          value: i
        } = t;
        if (typeof i == "string" || typeof i == "boolean")
          return !0;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return !0;
    return !!(EN(t, e) || p_e(t, e) || s === "TemplateLiteral" && t.expressions.length === 0 || u_e(t));
  }
  n(c_e, "isValidAmbientConstInitializer");
  function EN(t, e) {
    return e ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLite\
ral";
  }
  n(EN, "isNumber");
  function p_e(t, e) {
    if (t.type === "UnaryExpression") {
      let {
        operator: r,
        argument: s
      } = t;
      if (r === "-" && EN(s, e))
        return !0;
    }
    return !1;
  }
  n(p_e, "isNegativeNumber");
  function AN(t) {
    return t.type === "Identifier" ? !0 : t.type !== "MemberExpression" || t.computed ? !1 : AN(t.object);
  }
  n(AN, "isUncomputedMemberExpressionChain");
  var nN = qs`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), f_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(144)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(
        s, r);
      }
    }
    finishPlaceholder(r, s) {
      let i = r;
      return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, s, i, a) {
      r !== void 0 && super.checkReservedWord(r, s, i, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, s, i) {
      return r === "Placeholder" || super.isValidLVal(r, s, i);
    }
    toAssignable(r, s) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, s);
    }
    chStartsBindingIdentifier(r, s) {
      return !!(super.chStartsBindingIdentifier(r, s) || this.lookahead().type === 144);
    }
    verifyBreakContinue(r, s) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, s);
    }
    parseExpressionStatement(r, s) {
      var i;
      if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized)
        return super.parseExpressionStatement(r, s);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(s, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = s.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, s, i) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, s, i);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, s, i) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(144) || this.match(5))
          r.id = l;
        else {
          if (i || !s)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(nN.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, s, i);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseExport(r, s);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = i, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(Si(144), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, s) {
      var i;
      return (i = r.specifiers) != null && i.length ? !0 : super.maybeParseExportDefaultSpecifier(r, s);
    }
    checkExport(r) {
      let {
        specifiers: s
      } = r;
      s != null && s.length && (r.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = s;
    }
    parseImport(r) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let i = this.startNodeAtNode(s);
      return i.local = s, r.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(nN.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), h_e = /* @__PURE__ */ n((t) => class extends t {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, s = this.startNode();
        if (this.next(), mt(this.state.type)) {
          let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic");
  function Yt(t, e) {
    let [r, s] = typeof e == "string" ? [e, {}] : e, i = Object.keys(s), a = i.length === 0;
    return t.some((o) => {
      if (typeof o == "string")
        return a && o === r;
      {
        let [l, u] = o;
        if (l !== r)
          return !1;
        for (let c of i)
          if (u[c] !== s[c])
            return !1;
        return !0;
      }
    });
  }
  n(Yt, "hasPlugin");
  function rn(t, e, r) {
    let s = t.find((i) => Array.isArray(i) ? i[0] === e : i === e);
    return s && Array.isArray(s) && s.length > 1 ? s[1][r] : null;
  }
  n(rn, "getPluginOption");
  var aN = ["minimal", "fsharp", "hack", "smart"], oN = ["^^", "@@", "^", "%", "#"];
  function d_e(t) {
    if (Yt(t, "decorators")) {
      if (Yt(t, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let e = rn(t, "decorators", "decoratorsBeforeExport");
      if (e != null && typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let r = rn(t, "decorators", "allowCallParenthesized");
      if (r != null && typeof r != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Yt(t, "flow") && Yt(t, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Yt(t, "placeholders") && Yt(t, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Yt(t, "pipelineOperator")) {
      let e = rn(t, "pipelineOperator", "proposal");
      if (!aN.includes(e)) {
        let i = aN.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
      }
      let r = ["recordAndTuple", {
        syntaxType: "hash"
      }], s = Yt(t, r);
      if (e === "hack") {
        if (Yt(t, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Yt(t, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let i = rn(t, "pipelineOperator", "topicToken");
        if (!oN.includes(i)) {
          let a = oN.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        if (i === "#" && s)
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(r)}\
\`.`);
      } else if (e === "smart" && s)
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(r)}\`.`);
    }
    if (Yt(t, "moduleAttributes")) {
      if (Yt(t, "importAssertions") || Yt(t, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (rn(t, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (Yt(t, "importAssertions") && Yt(t, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Yt(t, "recordAndTuple")) {
      let e = rn(t, "recordAndTuple", "syntaxType");
      if (e != null) {
        let r = ["hash", "bar"];
        if (!r.includes(e))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + r.map((s) => `'${s}'`).join(", "));
      }
    }
    if (Yt(t, "asyncDoExpressions") && !Yt(t, "doExpressions")) {
      let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
    if (Yt(t, "optionalChainingAssign") && rn(t, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
  }
  n(d_e, "validatePlugins");
  var vN = {
    estree: mDe,
    jsx: r_e,
    flow: e_e,
    typescript: l_e,
    v8intrinsic: h_e,
    placeholders: f_e
  }, m_e = Object.keys(vN), $0 = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createImportExpressions: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0
  };
  function y_e(t) {
    if (t == null)
      return Object.assign({}, $0);
    if (t.annexB != null && t.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let e = {};
    for (let s of Object.keys($0)) {
      var r;
      e[s] = (r = t[s]) != null ? r : $0[s];
    }
    return e;
  }
  n(y_e, "getOptions");
  var mb = class extends db {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(e, r, s, i) {
      if (e.type === "SpreadElement" || this.isObjectMethod(e) || e.computed || e.shorthand)
        return;
      let a = e.key;
      if ((a.type === "Identifier" ? a.name : a.value) === "__proto__") {
        if (r) {
          this.raise(B.RecordNoProto, a);
          return;
        }
        s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = a.loc.start) : this.raise(B.DuplicateProto, a)), s.used = !0;
      }
    }
    shouldExitDescending(e, r) {
      return e.type === "ArrowFunctionExpression" && e.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let e = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e.comments = this.comments, e.errors = this.state.errors,
      this.options.tokens && (e.tokens = this.tokens), e;
    }
    parseExpression(e, r) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(e) {
      let r = this.state.startLoc, s = this.parseMaybeAssign(e);
      if (this.match(12)) {
        let i = this.startNodeAt(r);
        for (i.expressions = [s]; this.eat(12); )
          i.expressions.push(this.parseMaybeAssign(e));
        return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
      }
      return s;
    }
    parseMaybeAssignDisallowIn(e, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, r));
    }
    parseMaybeAssignAllowIn(e, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, r));
    }
    setOptionalParametersError(e, r) {
      var s;
      e.optionalParametersLoc = (s = r?.loc) != null ? s : this.state.startLoc;
    }
    parseMaybeAssign(e, r) {
      let s = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let l = this.parseYield();
        return r && (l = r.call(this, l, s)), l;
      }
      let i;
      e ? i = !1 : (e = new ea(), i = !0);
      let {
        type: a
      } = this.state;
      (a === 10 || mt(a)) && (this.state.potentialArrowAt = this.state.start);
      let o = this.parseMaybeConditional(e);
      if (r && (o = r.call(this, o, s)), SDe(this.state.type)) {
        let l = this.startNodeAt(s), u = this.state.value;
        if (l.operator = u, this.match(29)) {
          this.toAssignable(o, !0), l.left = o;
          let c = s.index;
          e.doubleProtoLoc != null && e.doubleProtoLoc.index >= c && (e.doubleProtoLoc = null), e.shorthandAssignLoc != null && e.shorthandAssignLoc.
          index >= c && (e.shorthandAssignLoc = null), e.privateKeyLoc != null && e.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(
          e), e.privateKeyLoc = null);
        } else
          l.left = o;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(o, {
          in: this.finishNode(l, "AssignmentExpression")
        }), l;
      } else i && this.checkExpressionErrors(e, !0);
      return o;
    }
    parseMaybeConditional(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(e);
      return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, r, e);
    }
    parseConditional(e, r, s) {
      if (this.eat(17)) {
        let i = this.startNodeAt(r);
        return i.test = e, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(
        i, "ConditionalExpression");
      }
      return e;
    }
    parseMaybeUnaryOrPrivate(e) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e);
    }
    parseExprOps(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, r, -1);
    }
    parseExprOp(e, r, s) {
      if (this.isPrivateName(e)) {
        let a = this.getPrivateNameSV(e);
        (s >= Bc(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(B.PrivateInExpectedIn, e, {
          identifierName: a
        }), this.classScope.usePrivateName(a, e.loc.start);
      }
      let i = this.state.type;
      if (PDe(i) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Bc(i);
        if (a > s) {
          if (i === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return e;
            this.checkPipelineAtInfixOperator(e, r);
          }
          let o = this.startNodeAt(r);
          o.left = e, o.operator = this.state.value;
          let l = i === 41 || i === 42, u = i === 40;
          if (u && (a = Bc(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(B.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(i, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(B.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, s);
        }
      }
      return e;
    }
    parseExprOpRightExpr(e, r) {
      let s = this.state.startLoc;
      switch (e) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(B.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, r), s);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(e, r);
      }
    }
    parseExprOpBaseRightExpr(e, r) {
      let s = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, IDe(e) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var e;
      let {
        startLoc: r
      } = this.state, s = this.parseMaybeAssign();
      return uDe.has(s.type) && !((e = s.extra) != null && e.parenthesized) && this.raise(B.PipeUnparenthesizedBody, r, {
        type: s.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(B.PipeTopicUnused, r), s;
    }
    checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(B.UnexpectedTokenUnaryExponentiation, e.argument);
    }
    parseMaybeUnary(e, r) {
      let s = this.state.startLoc, i = this.isContextual(96);
      if (i && this.isAwaitAllowed()) {
        this.next();
        let u = this.parseAwait(s);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (ADe(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(B.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(B.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, e);
      if (i) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? G0(u) : G0(u) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(B.AwaitNotInAsyncContext, s), this.parseAwait(s);
      }
      return l;
    }
    parseUpdate(e, r, s) {
      if (r) {
        let o = e;
        return this.checkLVal(o.argument, {
          in: this.finishNode(o, "UpdateExpression")
        }), e;
      }
      let i = this.state.startLoc, a = this.parseExprSubscripts(s);
      if (this.checkExpressionErrors(s, !1)) return a;
      for (; EDe(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(i);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, {
          in: a = this.finishNode(o, "UpdateExpression")
        });
      }
      return a;
    }
    parseExprSubscripts(e) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(e);
      return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, r);
    }
    parseSubscripts(e, r, s) {
      let i = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(e),
        stop: !1
      };
      do
        e = this.parseSubscript(e, r, s, i), i.maybeAsyncArrow = !1;
      while (!i.stop);
      return e;
    }
    parseSubscript(e, r, s, i) {
      let {
        type: a
      } = this.state;
      if (!s && a === 15)
        return this.parseBind(e, r, s, i);
      if (Uc(a))
        return this.parseTaggedTemplateExpression(e, r, i);
      let o = !1;
      if (a === 18) {
        if (s && (this.raise(B.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return i.stop = !0, e;
        i.optionalChainMember = o = !0, this.next();
      }
      if (!s && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(e, r, i, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(e, r, i, l, o) : (i.stop = !0, e);
      }
    }
    parseMember(e, r, s, i, a) {
      let o = this.startNodeAt(r);
      return o.object = e, o.computed = i, i ? (o.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (e.type === "Super" &&
      this.raise(B.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), s.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(e, r, s, i) {
      let a = this.startNodeAt(r);
      return a.object = e, this.next(), a.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, s);
    }
    parseCoverCallAndAsyncArrowHead(e, r, s, i) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = e;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = s;
      u && (this.expressionScope.enter(JDe()), o = new ea()), c && (l.optional = i), i ? l.arguments = this.parseCallExpressionArguments(11) :
      l.arguments = this.parseCallExpressionArguments(11, e.type === "Import", e.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(e, r) {
      this.toReferencedListDeep(e.arguments, r);
    }
    parseTaggedTemplateExpression(e, r, s) {
      let i = this.startNodeAt(r);
      return i.tag = e, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(B.OptionalChainingNoTemplate, r), this.finishNode(
      i, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e) {
      return e.type === "Identifier" && e.name === "async" && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end -
      e.start === 5 && e.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(e, r) {
      if (e.callee.type === "Import")
        if (e.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), e.arguments.length === 0 ||
        e.arguments.length > 2)
          this.raise(B.ImportCallArity, e, {
            maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ?
            2 : 1
          });
        else
          for (let s of e.arguments)
            s.type === "SpreadElement" && this.raise(B.ImportCallSpreadArgument, s);
      return this.finishNode(e, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e, r, s, i, a) {
      let o = [], l = !0, u = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(
          B.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        o.push(this.parseExprListItem(!1, a, s));
      }
      return this.state.inFSharpPipelineDirectBody = u, o;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e, r) {
      var s;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(e, r.arguments, !0, (s = r.extra) == null ?
      void 0 : s.trailingCommaLoc), r.innerComments && zo(e, r.innerComments), r.callee.trailingComments && zo(e, r.callee.trailingComments),
      e;
    }
    parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
    }
    parseExprAtom(e) {
      let r, s = null, {
        type: i
      } = this.state;
      switch (i) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ?
          this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(B.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(
          r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, e);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, e);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          s = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(B.UnsupportedBind, a);
        }
        case 138:
          return this.raise(B.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          this.unexpected();
          break;
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          Us(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (mt(i)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (mt(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e, r) {
      let s = this.getPluginOption("pipelineOperator", "proposal");
      if (s)
        return this.state.type = e, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = Cr(this.state.endLoc, -1),
        this.parseTopicReference(s);
      this.unexpected();
    }
    parseTopicReference(e) {
      let r = this.startNode(), s = this.state.startLoc, i = this.state.type;
      return this.next(), this.finishTopicReference(r, s, e, i);
    }
    finishTopicReference(e, r, s, i) {
      if (this.testTopicReferenceConfiguration(s, r, i)) {
        let a = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? B.PrimaryTopicNotAllowed : B.PipeTopicUnbound, r),
        this.registerTopicReference(), this.finishNode(e, a);
      } else
        throw this.raise(B.PipeTopicUnconfiguredToken, r, {
          token: Si(i)
        });
    }
    testTopicReferenceConfiguration(e, r, s) {
      switch (e) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: Si(s)
          }]);
        case "smart":
          return s === 27;
        default:
          throw this.raise(B.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(jc(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(B.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(e, r, !0);
    }
    parseDo(e, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), e.async = r, this.next();
      let s = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), e.body = this.parseBlock(), this.prodParam.exit()) : e.body = this.parseBlock(),
      this.state.labels = s, this.finishNode(e, "DoExpression");
    }
    parseSuper() {
      let e = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(B.SuperNotAllowed,
      e) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(B.UnexpectedSuper, e), !this.match(10) && !this.match(
      0) && !this.match(16) && this.raise(B.UnsupportedSuper, e), this.finishNode(e, "Super");
    }
    parsePrivateName() {
      let e = this.startNode(), r = this.startNodeAt(Cr(this.state.startLoc, 1)), s = this.state.value;
      return this.next(), e.id = this.createIdentifier(r, s), this.finishNode(e, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(e, r, "sent");
      }
      return this.parseFunction(e);
    }
    parseMetaProperty(e, r, s) {
      e.meta = r;
      let i = this.state.containsEsc;
      return e.property = this.parseIdentifier(!0), (e.property.name !== s || i) && this.raise(B.UnsupportedMetaProperty, e.property, {
        target: r.name,
        onlyValidPropertyName: s
      }), this.finishNode(e, "MetaProperty");
    }
    parseImportMetaProperty(e) {
      let r = this.createIdentifier(this.startNodeAtNode(e), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(B.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let s = this.isContextual(105);
        if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(B.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
            phase: this.state.value
          });
        return this.next(), e.phase = s ? "source" : "defer", this.parseImportCall(e);
      }
      return this.parseMetaProperty(e, r, "meta");
    }
    parseLiteralAtNode(e, r, s) {
      return this.addExtra(s, "rawValue", e), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = e, this.next(), this.
      finishNode(s, r);
    }
    parseLiteral(e, r) {
      let s = this.startNode();
      return this.parseLiteralAtNode(e, r, s);
    }
    parseStringLiteral(e) {
      return this.parseLiteral(e, "StringLiteral");
    }
    parseNumericLiteral(e) {
      return this.parseLiteral(e, "NumericLiteral");
    }
    parseBigIntLiteral(e) {
      return this.parseLiteral(e, "BigIntLiteral");
    }
    parseDecimalLiteral(e) {
      return this.parseLiteral(e, "DecimalLiteral");
    }
    parseRegExpLiteral(e) {
      let r = this.parseLiteral(e.value, "RegExpLiteral");
      return r.pattern = e.pattern, r.flags = e.flags, r;
    }
    parseBooleanLiteral(e) {
      let r = this.startNode();
      return r.value = e, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e) {
      let r = this.state.startLoc, s;
      this.next(), this.expressionScope.enter(YDe());
      let i = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new ea(), c = !0, p, f;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          f = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let T = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), T)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
      }
      let m = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = a;
      let y = this.startNodeAt(r);
      return e && this.shouldParseArrow(l) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(y, l, !1), y) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), f && this.unexpected(f), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (s = this.startNodeAt(o), s.expressions = l, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s,
      m)) : s = l[0], this.wrapParenthesis(r, s));
    }
    wrapParenthesis(e, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", e.index), this.takeSurroundingComments(r, e.index, this.
        state.lastTokEndLoc.index), r;
      let s = this.startNodeAt(e);
      return s.expression = r, this.finishNode(s, "ParenthesizedExpression");
    }
    shouldParseArrow(e) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e) {
      if (this.eat(19))
        return e;
    }
    parseParenItem(e, r) {
      return e;
    }
    parseNewOrNewTarget() {
      let e = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(e), "new");
        this.next();
        let s = this.parseMetaProperty(e, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(B.UnexpectedNewTarget,
        s), s;
      }
      return this.parseNew(e);
    }
    parseNew(e) {
      if (this.parseNewCallee(e), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), e.arguments = r;
      } else
        e.arguments = [];
      return this.finishNode(e, "NewExpression");
    }
    parseNewCallee(e) {
      let r = this.match(83), s = this.parseNoCallExpr();
      e.callee = s, r && (s.type === "Import" || s.type === "ImportExpression") && this.raise(B.ImportCallNotNewExpression, s);
    }
    parseTemplateElement(e) {
      let {
        start: r,
        startLoc: s,
        end: i,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(Cr(s, 1));
      a === null && (e || this.raise(B.InvalidEscapeSequenceTemplate, Cr(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = i + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let f = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(f, Cr(this.state.lastTokEndLoc, c)), f;
    }
    parseTemplate(e) {
      let r = this.startNode(), s = this.parseTemplateElement(e), i = [s], a = [];
      for (; !s.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(e));
      return r.expressions = a, r.quasis = i, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = /* @__PURE__ */ Object.create(null), l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(e); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(e)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(i), this.checkProto(p, s, o, i)), s && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(B.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(e) {
      this.addExtra(e, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(e) {
      return !e.computed && e.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(B.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let s = this.startNode(), i = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (s.decorators = r, r = []), s.method = !1, e && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(s, e), !l && !u && this.maybeAsyncOrAccessorProp(s)) {
        let {
          key: c
        } = s, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        s)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), s.kind = p, this.match(55) && (l = !0, this.
        raise(B.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(s));
      }
      return this.parseObjPropValue(s, o, l, i, !1, a, e);
    }
    getGetterSetterExpectedParamCount(e) {
      return e.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(e) {
      return e.params;
    }
    checkGetterSetterParams(e) {
      var r;
      let s = this.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e);
      i.length !== s && this.raise(e.kind === "get" ? B.BadGetterArity : B.BadSetterArity, e), e.kind === "set" && ((r = i[i.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(B.BadSetterRestParameter, e);
    }
    parseObjectMethod(e, r, s, i, a) {
      if (a) {
        let o = this.parseMethod(e, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (s || r || this.match(10))
        return i && this.unexpected(), e.kind = "method", e.method = !0, this.parseMethod(e, r, s, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(e, r, s, i) {
      if (e.shorthand = !1, this.eat(14))
        return e.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(e, "ObjectProper\
ty");
      if (!e.computed && e.key.type === "Identifier") {
        if (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), s)
          e.value = this.parseMaybeDefault(r, Vs(e.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = a) : this.raise(B.InvalidCoverInitializedName, a), e.value = this.
          parseMaybeDefault(r, Vs(e.key));
        } else
          e.value = Vs(e.key);
        return e.shorthand = !0, this.finishNode(e, "ObjectProperty");
      }
    }
    parseObjPropValue(e, r, s, i, a, o, l) {
      let u = this.parseObjectMethod(e, s, i, a, o) || this.parseObjectProperty(e, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(e, r) {
      if (this.eat(0))
        e.computed = !0, e.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: s,
          value: i
        } = this.state, a;
        if (es(s))
          a = this.parseIdentifier(!0);
        else
          switch (s) {
            case 134:
              a = this.parseNumericLiteral(i);
              break;
            case 133:
              a = this.parseStringLiteral(i);
              break;
            case 135:
              a = this.parseBigIntLiteral(i);
              break;
            case 136:
              a = this.parseDecimalLiteral(i);
              break;
            case 138: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(B.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        e.key = a, s !== 138 && (e.computed = !1);
      }
    }
    initFunction(e, r) {
      e.id = null, e.generator = !1, e.async = r;
    }
    parseMethod(e, r, s, i, a, o, l = !1) {
      this.initFunction(e, s), e.generator = r, this.scope.enter(18 | (l ? 64 : 0) | (a ? 32 : 0)), this.prodParam.enter(jc(s, e.generator)),
      this.parseFunctionParams(e, i);
      let u = this.parseFunctionBodyAndFinish(e, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(e, r, s, i) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = this.startNode();
      return this.next(), o.elements = this.parseExprList(e, !s, i, o), this.state.inFSharpPipelineDirectBody = a, this.finishNode(o, s ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e, r, s, i) {
      this.scope.enter(6);
      let a = jc(s, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(e, s);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(e, r, i)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(e, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(e, r, s) {
      this.toAssignableList(r, s, !1), e.params = r;
    }
    parseFunctionBodyAndFinish(e, r, s = !1) {
      return this.parseFunctionBody(e, !1, s), this.finishNode(e, r);
    }
    parseFunctionBody(e, r, s = !1) {
      let i = r && !this.match(5);
      if (this.expressionScope.enter(gN()), i)
        e.body = this.parseMaybeAssign(), this.checkParams(e, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), e.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(e.params);
          l && u && this.raise(B.IllegalLanguageModeDirective, (e.kind === "method" || e.kind === "constructor") && e.key ? e.key.loc.end : e);
          let c = !a && this.state.strict;
          this.checkParams(e, !this.state.strict && !r && !s && !u, r, c), this.state.strict && e.id && this.checkIdentifier(e.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e) {
      return e.type === "Identifier";
    }
    isSimpleParamList(e) {
      for (let r = 0, s = e.length; r < s; r++)
        if (!this.isSimpleParameter(e[r])) return !1;
      return !0;
    }
    checkParams(e, r, s, i = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of e.params)
        this.checkLVal(l, {
          in: o,
          binding: 5,
          checkClashes: a,
          strictModeChanged: i
        });
    }
    parseExprList(e, r, s, i) {
      let a = [], o = !0;
      for (; !this.eat(e); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(e)) {
          i && this.addTrailingCommaExtraToNode(i), this.next();
          break;
        }
        a.push(this.parseExprListItem(r, s));
      }
      return a;
    }
    parseExprListItem(e, r, s) {
      let i;
      if (this.match(12))
        e || this.raise(B.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), i = null;
      else if (this.match(21)) {
        let a = this.state.startLoc;
        i = this.parseParenItem(this.parseSpread(r), a);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s || this.raise(B.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let a = this.startNode();
        this.next(), i = this.finishNode(a, "ArgumentPlaceholder");
      } else
        i = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return i;
    }
    parseIdentifier(e) {
      let r = this.startNode(), s = this.parseIdentifierName(e);
      return this.createIdentifier(r, s);
    }
    createIdentifier(e, r) {
      return e.name = r, e.loc.identifierName = r, this.finishNode(e, "Identifier");
    }
    parseIdentifierName(e) {
      let r, {
        startLoc: s,
        type: i
      } = this.state;
      es(i) ? r = this.state.value : this.unexpected();
      let a = bDe(i);
      return e ? a && this.replaceToken(132) : this.checkReservedWord(r, s, a, !1), this.next(), r;
    }
    checkReservedWord(e, r, s, i) {
      if (e.length > 10 || !FDe(e))
        return;
      if (s && LDe(e)) {
        this.raise(B.UnexpectedKeyword, r, {
          keyword: e
        });
        return;
      }
      if ((this.state.strict ? i ? yN : dN : hN)(e, this.inModule)) {
        this.raise(B.UnexpectedReservedWord, r, {
          reservedWord: e
        });
        return;
      } else if (e === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(B.YieldBindingIdentifier, r);
          return;
        }
      } else if (e === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(B.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(B.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (e === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(B.ArgumentsInClass, r);
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(e) {
      let r = this.startNodeAt(e);
      return this.expressionScope.recordParameterInitializerError(B.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(B.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst =
      !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExp\
ression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: e
      } = this.state;
      return e === 53 || e === 10 || e === 0 || Uc(e) || e === 102 && !this.state.containsEsc || e === 137 || e === 56 || this.hasPlugin("v8\
intrinsic") && e === 54;
    }
    parseYield() {
      let e = this.startNode();
      this.expressionScope.recordParameterInitializerError(B.YieldInParameter, e), this.next();
      let r = !1, s = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r) break;
          default:
            s = this.parseMaybeAssign();
        }
      return e.delegate = r, e.argument = s, this.finishNode(e, "YieldExpression");
    }
    parseImportCall(e) {
      return this.next(), e.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) &&
      (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = this.parseMaybeAssignAllowIn(),
      this.eat(12))), this.expect(11), this.finishNode(e, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && e.type === "SequenceExpression" && this.raise(B.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(e, r) {
      if (this.isSimpleReference(e)) {
        let s = this.startNodeAt(r);
        return s.callee = e, this.finishNode(s, "PipelineBareFunction");
      } else {
        let s = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), s.expression = e, this.finishNode(s, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e) {
      switch (e.type) {
        case "MemberExpression":
          return !e.computed && this.isSimpleReference(e.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19))
        throw this.raise(B.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(B.PipelineTopicUnused, e);
    }
    withTopicBindingContext(e) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return e();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(e) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return e();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return e();
    }
    withSoloAwaitPermittingContext(e) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return e();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    disallowInAnd(e) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return e();
        } finally {
          this.prodParam.exit();
        }
      }
      return e();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, e);
      return this.state.inFSharpPipelineDirectBody = s, i;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let e = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let s = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        e.body = this.parseProgram(r, 8, "module");
      } finally {
        s();
      }
      return this.finishNode(e, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e) {
    }
  }, H0 = {
    kind: 1
  }, T_e = {
    kind: 2
  }, b_e = /[\uD800-\uDFFF]/u, z0 = /in(?:stanceof)?/y;
  function x_e(t, e) {
    for (let r = 0; r < t.length; r++) {
      let s = t[r], {
        type: i
      } = s;
      if (typeof i == "number") {
        {
          if (i === 138) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = Cr(a.start, 1);
            t.splice(r, 1, new fs({
              type: js(27),
              value: "#",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }), new fs({
              type: js(132),
              value: l,
              start: c,
              end: u,
              startLoc: p,
              endLoc: a.end
            })), r++;
            continue;
          }
          if (Uc(i)) {
            let {
              loc: a,
              start: o,
              value: l,
              end: u
            } = s, c = o + 1, p = Cr(a.start, 1), f;
            e.charCodeAt(o) === 96 ? f = new fs({
              type: js(22),
              value: "`",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            }) : f = new fs({
              type: js(8),
              value: "}",
              start: o,
              end: c,
              startLoc: a.start,
              endLoc: p
            });
            let m, y, T, L;
            i === 24 ? (y = u - 1, T = Cr(a.end, -1), m = l === null ? null : l.slice(1, -1), L = new fs({
              type: js(22),
              value: "`",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })) : (y = u - 2, T = Cr(a.end, -2), m = l === null ? null : l.slice(1, -2), L = new fs({
              type: js(23),
              value: "${",
              start: y,
              end: u,
              startLoc: T,
              endLoc: a.end
            })), t.splice(r, 1, f, new fs({
              type: js(20),
              value: m,
              start: c,
              end: y,
              startLoc: p,
              endLoc: T
            }), L), r += 2;
            continue;
          }
        }
        s.type = js(i);
      }
    }
    return t;
  }
  n(x_e, "babel7CompatTokens");
  var yb = class extends mb {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(e, r) {
      return e.program = this.parseProgram(r), e.comments = this.comments, this.options.tokens && (e.tokens = x_e(this.tokens, this.input)),
      this.finishNode(e, "File");
    }
    parseProgram(e, r = 139, s = this.options.sourceType) {
      if (e.sourceType = s, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, r), this.inModule && !this.options.
      allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [a, o] of Array.from(this.scope.undefinedExports))
          this.raise(B.ModuleExportUndefined, o, {
            localName: a
          });
      let i;
      return r === 139 ? i = this.finishNode(e, "Program") : i = this.finishNodeAt(e, "Program", Cr(this.state.startLoc, -1)), i;
    }
    stmtToDirective(e) {
      let r = e;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let s = r.value, i = s.value, a = this.input.slice(s.start, s.end), o = s.value = a.slice(1, -1);
      return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", o), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral",
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let e = this.startNode();
      return e.value = this.state.value, this.next(), this.finishNode(e, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(e, r) {
      if (Us(e)) {
        if (z0.lastIndex = r, z0.test(this.input)) {
          let s = this.codePointAtPos(z0.lastIndex);
          if (!Zn(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return e === 92;
    }
    chStartsBindingPattern(e) {
      return e === 91 || e === 123;
    }
    hasFollowingBindingAtom() {
      let e = this.nextTokenStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, e);
    }
    hasInLineFollowingBindingIdentifier() {
      let e = this.nextTokenInLineStart(), r = this.codePointAtPos(e);
      return this.chStartsBindingIdentifier(r, e);
    }
    startsUsingForOf() {
      let {
        type: e,
        containsEsc: r
      } = this.lookahead();
      if (e === 102 && !r)
        return !1;
      if (mt(e) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, "using")) {
        e = this.nextTokenInLineStartSince(e + 5);
        let r = this.codePointAtPos(e);
        if (this.chStartsBindingIdentifier(r, e))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, e && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(e, r);
    }
    parseStatementContent(e, r) {
      let s = this.state.type, i = this.startNode(), a = !!(e & 2), o = !!(e & 4), l = e & 1;
      switch (s) {
        case 60:
          return this.parseBreakContinueStatement(i, !0);
        case 63:
          return this.parseBreakContinueStatement(i, !1);
        case 64:
          return this.parseDebuggerStatement(i);
        case 90:
          return this.parseDoWhileStatement(i);
        case 91:
          return this.parseForStatement(i);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? B.StrictFunction : this.options.annexB ? B.SloppyFunctionAnnexB : B.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(i, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, i), !0);
        case 69:
          return this.parseIfStatement(i);
        case 70:
          return this.parseReturnStatement(i);
        case 71:
          return this.parseSwitchStatement(i);
        case 72:
          return this.parseThrowStatement(i);
        case 73:
          return this.parseTryStatement(i);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? a || this.raise(B.UnexpectedLexicalDeclaration, i) : this.raise(B.AwaitUsingNotInAsyncContext, i),
            this.next(), this.parseVarStatement(i, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(B.UnexpectedUsingDeclaration,
          this.state.startLoc) : a || this.raise(B.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), f = this.codePointAtPos(p);
          if (f !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, p) && f !== 123))
            break;
        }
        case 75:
          a || this.raise(B.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(i, p);
        }
        case 92:
          return this.parseWhileStatement(i);
        case 76:
          return this.parseWithStatement(i);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(i);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !l && this.raise(B.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return s === 83 ? (p = this.parseImport(i), p.type === "ImportDeclaration" && (!p.importKind || p.importKind === "value") && (this.
          sawUnambiguousESM = !0)) : (p = this.parseExport(i, r), (p.type === "ExportNamedDeclaration" && (!p.exportKind || p.exportKind ===
          "value") || p.type === "ExportAllDeclaration" && (!p.exportKind || p.exportKind === "value") || p.type === "ExportDefaultDeclarati\
on") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(B.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return mt(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, u, c, e) : this.parseExpressionStatement(i, c,
      r);
    }
    assertModuleNodeAllowed(e) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(B.ImportOutsideModule, e);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(e, r, s) {
      return e && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolea\
n" && this.raise(B.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...e)) : r.decorators = e, this.resetStartLocationFromNode(
      r, e[0]), s && this.resetStartLocationFromNode(s, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(B.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(B.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let e = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, s;
        if (this.match(10)) {
          let i = this.state.startLoc;
          this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
          let a = this.state.startLoc;
          e.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && e.expression !==
          s && this.raise(B.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (s = this.parseIdentifier(!1); this.eat(16); ) {
            let i = this.startNodeAt(r);
            i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) :
            i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
          }
          e.expression = this.parseMaybeDecoratorArguments(s);
        }
      } else
        e.expression = this.parseExprSubscripts();
      return this.finishNode(e, "Decorator");
    }
    parseMaybeDecoratorArguments(e) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(e);
        return r.callee = e, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r,
        "CallExpression");
      }
      return e;
    }
    parseBreakContinueStatement(e, r) {
      return this.next(), this.isLineTerminator() ? e.label = null : (e.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      e, r), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e, r) {
      let s;
      for (s = 0; s < this.state.labels.length; ++s) {
        let i = this.state.labels[s];
        if ((e.label == null || i.name === e.label.name) && (i.kind != null && (r || i.kind === 1) || e.label && r))
          break;
      }
      if (s === this.state.labels.length) {
        let i = r ? "BreakStatement" : "ContinueStatement";
        this.raise(B.IllegalBreakContinue, e, {
          type: i
        });
      }
    }
    parseDebuggerStatement(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return this.expect(11), e;
    }
    parseDoWhileStatement(e) {
      return this.next(), this.state.labels.push(H0), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), e.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e, "DoWhileStatement");
    }
    parseForStatement(e) {
      this.next(), this.state.labels.push(H0);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(
      13))
        return r !== null && this.unexpected(r), this.parseFor(e, null);
      let s = this.isContextual(100);
      {
        let u = this.isContextual(96) && this.startsAwaitUsing(), c = u || this.isContextual(107) && this.startsUsingForOf(), p = s && this.
        hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let f = this.startNode(), m;
          u ? (m = "await using", this.isAwaitAllowed() || this.raise(B.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : m =
          this.state.value, this.next(), this.parseVar(f, !0, m);
          let y = this.finishNode(f, "VariableDeclaration"), T = this.match(58);
          return T && c && this.raise(B.ForInUsing, y), (T || this.isContextual(102)) && y.declarations.length === 1 ? this.parseForIn(e, y,
          r) : (r !== null && this.unexpected(r), this.parseFor(e, y));
        }
      }
      let i = this.isContextual(95), a = new ea(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (s && this.raise(B.ForOfLet, o), r === null && i && o.type === "Identifier" && this.raise(B.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          in: {
            type: u
          }
        }), this.parseForIn(e, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(e, o);
    }
    parseFunctionStatement(e, r, s) {
      return this.next(), this.parseFunction(e, 1 | (s ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e, "IfStatement");
    }
    parseReturnStatement(e) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(B.IllegalReturn, this.state.startLoc), this.
      next(), this.isLineTerminator() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "Ret\
urnStatement");
    }
    parseSwitchStatement(e) {
      this.next(), e.discriminant = this.parseHeaderExpression();
      let r = e.cases = [];
      this.expect(5), this.state.labels.push(T_e), this.scope.enter(0);
      let s;
      for (let i; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          s && this.finishNode(s, "SwitchCase"), r.push(s = this.startNode()), s.consequent = [], this.next(), a ? s.test = this.parseExpression() :
          (i && this.raise(B.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
        } else
          s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e, "SwitchState\
ment");
    }
    parseThrowStatement(e) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(B.NewlineAfterThrow, this.state.lastTokEndLoc), e.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(e, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && e.type === "Identifier" ? 8 : 0), this.checkLVal(e, {
        in: {
          type: "CatchClause"
        },
        binding: 9
      }), e;
    }
    parseTryStatement(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), e.handler = this.finishNode(
        r, "CatchClause");
      }
      return e.finalizer = this.eat(67) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(B.NoCatchOrFinally, e), this.finishNode(
      e, "TryStatement");
    }
    parseVarStatement(e, r, s = !1) {
      return this.next(), this.parseVar(e, !1, r, s), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }
    parseWhileStatement(e) {
      return this.next(), e.test = this.parseHeaderExpression(), this.state.labels.push(H0), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(e, "WhileStatement");
    }
    parseWithStatement(e) {
      return this.state.strict && this.raise(B.StrictWith, this.state.startLoc), this.next(), e.object = this.parseHeaderExpression(), e.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e, "WithStatement");
    }
    parseEmptyStatement(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }
    parseLabeledStatement(e, r, s, i) {
      for (let o of this.state.labels)
        o.name === r && this.raise(B.LabelRedeclaration, s, {
          labelName: r
        });
      let a = gDe(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === e.start)
          l.statementStart = this.state.start, l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.state.start
      }), e.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), e.label =
      s, this.finishNode(e, "LabeledStatement");
    }
    parseExpressionStatement(e, r, s) {
      return e.expression = r, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }
    parseBlock(e = !1, r = !0, s) {
      let i = this.startNode();
      return e && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(i, e, !1, 8, s), r && this.
      scope.exit(), this.finishNode(i, "BlockStatement");
    }
    isValidDirective(e) {
      return e.type === "ExpressionStatement" && e.expression.type === "StringLiteral" && !e.expression.extra.parenthesized;
    }
    parseBlockBody(e, r, s, i, a) {
      let o = e.body = [], l = e.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, s, i, a);
    }
    parseBlockOrModuleBlockBody(e, r, s, i, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(i); ) {
        let c = s ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        e.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(e, r) {
      return e.init = r, this.semicolon(!1), e.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), e.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(e, "ForStatement");
    }
    parseForIn(e, r, s) {
      let i = this.match(58);
      return this.next(), i ? s !== null && this.unexpected(s) : e.await = s !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!i || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(B.ForInOfLoopInitializer, r, {
        type: i ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(B.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), e.left = r, e.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e, r, s, i = !1) {
      let a = e.declarations = [];
      for (e.kind = s; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, s), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !i && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(B.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(B.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: s
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e;
    }
    parseVarId(e, r) {
      let s = this.parseBindingAtom();
      this.checkLVal(s, {
        in: {
          type: "VariableDeclarator"
        },
        binding: r === "var" ? 5 : 8201
      }), e.id = s;
    }
    parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
    }
    parseFunction(e, r = 0) {
      let s = r & 2, i = !!(r & 1), a = i && !(r & 4), o = !!(r & 8);
      this.initFunction(e, o), this.match(55) && (s && this.raise(B.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e.
      generator = !0), i && (e.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(jc(o, e.generator)), i || (e.id = this.parseFunctionId()),
      this.parseFunctionParams(e, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, i ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(e), this.state.maybeInArrowParameters = l, e;
    }
    parseFunctionId(e) {
      return e || mt(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e, r) {
      this.expect(10), this.expressionScope.enter(WDe()), e.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, e.id.loc.start);
    }
    parseClass(e, r, s) {
      this.next();
      let i = this.state.strict;
      return this.state.strict = !0, this.parseClassId(e, r, s), this.parseClassSuper(e), e.body = this.parseClassBody(!!e.superClass, i), this.
      finishNode(e, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(e) {
      return e.type === "Identifier" && e.name === "constructor" || e.type === "StringLiteral" && e.value === "constructor";
    }
    isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
    }
    parseClassBody(e, r) {
      this.classScope.enter();
      let s = {
        hadConstructor: !1,
        hadSuperClass: e
      }, i = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (i.length > 0)
              throw this.raise(B.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            i.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          i.length && (o.decorators = i, this.resetStartLocationFromNode(o, i[0]), i = []), this.parseClassMember(a, o, s), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(B.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), i.length)
        throw this.raise(B.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(e, r) {
      let s = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let i = r;
        return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(e, i, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let i = r;
        return i.computed = !1, i.key = s, i.static = !1, e.body.push(this.parseClassProperty(i)), !0;
      }
      return this.resetPreviousNodeTrailingComments(s), !1;
    }
    parseClassMember(e, r, s) {
      let i = this.isContextual(106);
      if (i) {
        if (this.parseClassMemberFromModifier(e, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(e, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(e, r, s, i);
    }
    parseClassMemberWithIsStatic(e, r, s, i) {
      let a = r, o = r, l = r, u = r, c = r, p = a, f = a;
      if (r.static = i, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let _ = this.match(138);
        if (this.parseClassElementName(p), _) {
          this.pushClassPrivateMethod(e, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(B.ConstructorIsGenerator, a.key), this.pushClassMethod(e, a, !0, !1, !1, !1);
        return;
      }
      let m = !this.state.containsEsc && mt(this.state.type), y = this.parseClassElementName(r), T = m ? y.name : null, L = this.isPrivateName(
      y), q = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
        if (p.kind = "method", L) {
          this.pushClassPrivateMethod(e, o, !1, !1);
          return;
        }
        let _ = this.isNonstaticConstructor(a), U = !1;
        _ && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(B.DuplicateConstructor, y), _ && this.
        hasPlugin("typescript") && r.override && this.raise(B.OverrideOnConstructor, y), s.hadConstructor = !0, U = s.hadSuperClass), this.pushClassMethod(
        e, a, !1, !1, _, U);
      } else if (this.isClassProperty())
        L ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l);
      else if (T === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(y);
        let _ = this.eat(55);
        f.optional && this.unexpected(q), p.kind = "method";
        let U = this.match(138);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(f), U ? this.pushClassPrivateMethod(e, o, _, !0) : (this.isNonstaticConstructor(
        a) && this.raise(B.ConstructorIsAsync, a.key), this.pushClassMethod(e, a, _, !0, !1, !1));
      } else if ((T === "get" || T === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(y), p.kind = T;
        let _ = this.match(138);
        this.parseClassElementName(a), _ ? this.pushClassPrivateMethod(e, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(B.ConstructorIsAccessor,
        a.key), this.pushClassMethod(e, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (T === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(y);
        let _ = this.match(138);
        this.parseClassElementName(l), this.pushClassAccessorProperty(e, c, _);
      } else this.isLineTerminator() ? L ? this.pushClassPrivateProperty(e, u) : this.pushClassProperty(e, l) : this.unexpected();
    }
    parseClassElementName(e) {
      let {
        type: r,
        value: s
      } = this.state;
      if ((r === 132 || r === 133) && e.static && s === "prototype" && this.raise(B.StaticPrototype, this.state.startLoc), r === 138) {
        s === "constructor" && this.raise(B.ConstructorClassPrivateField, this.state.startLoc);
        let i = this.parsePrivateName();
        return e.key = i, i;
      }
      return this.parsePropertyName(e), e.key;
    }
    parseClassStaticBlock(e, r) {
      var s;
      this.scope.enter(208);
      let i = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, e.body.push(this.
      finishNode(r, "StaticBlock")), (s = r.decorators) != null && s.length && this.raise(B.DecoratorStaticBlock, r);
    }
    pushClassProperty(e, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(B.ConstructorClassField, r.key), e.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(e, r) {
      let s = this.parseClassPrivateProperty(r);
      e.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassAccessorProperty(e, r, s) {
      !s && !r.computed && this.nameIsConstructor(r.key) && this.raise(B.ConstructorClassField, r.key);
      let i = this.parseClassAccessorProperty(r);
      e.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassMethod(e, r, s, i, a, o) {
      e.body.push(this.parseMethod(r, s, i, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(e, r, s, i) {
      let a = this.parseMethod(r, s, i, !1, !1, "ClassPrivateMethod", !0);
      e.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(e, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), r, e.key.loc.start);
    }
    parsePostMemberNameModifiers(e) {
    }
    parseClassPrivateProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassPrivateProperty");
    }
    parseClassProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassProperty");
    }
    parseClassAccessorProperty(e) {
      return this.parseInitializer(e), this.semicolon(), this.finishNode(e, "ClassAccessorProperty");
    }
    parseInitializer(e) {
      this.scope.enter(80), this.expressionScope.enter(gN()), this.prodParam.enter(0), e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e, r, s, i = 8331) {
      if (mt(this.state.type))
        e.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(e.id, i);
      else if (s || !r)
        e.id = null;
      else
        throw this.raise(B.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e, r) {
      let s = this.parseMaybeImportPhase(e, !0), i = this.maybeParseExportDefaultSpecifier(e, s), a = !i || this.eat(12), o = a && this.eatExportStar(
      e), l = o && this.maybeParseExportNamespaceSpecifier(e), u = a && (!l || this.eat(12)), c = i || o;
      if (o && !l) {
        if (i && this.unexpected(), r)
          throw this.raise(B.UnsupportedDecoratorExport, e);
        return this.parseExportFrom(e, !0), this.finishNode(e, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(e);
      i && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let f;
      if (c || p) {
        if (f = !1, r)
          throw this.raise(B.UnsupportedDecoratorExport, e);
        this.parseExportFrom(e, c);
      } else
        f = this.maybeParseExportDeclaration(e);
      if (c || p || f) {
        var m;
        let y = e;
        if (this.checkExport(y, !0, !1, !!y.source), ((m = y.declaration) == null ? void 0 : m.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, y.declaration, y);
        else if (r)
          throw this.raise(B.UnsupportedDecoratorExport, e);
        return this.finishNode(y, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let y = e, T = this.parseExportDefaultExpression();
        if (y.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, T, y);
        else if (r)
          throw this.raise(B.UnsupportedDecoratorExport, e);
        return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let s = r || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
        return i.exported = s, e.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
        var r, s;
        (s = (r = e).specifiers) != null || (r.specifiers = []);
        let i = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), i.exported = this.parseModuleExportName(), e.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
        let r = e;
        r.specifiers || (r.specifiers = []);
        let s = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(s)), r.source = null, r.declaration = null, this.hasPlugin("importAssertions") &&
        (r.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(e) {
      return this.shouldParseExportDeclaration() ? (e.specifiers = [], e.source = null, this.hasPlugin("importAssertions") && (e.assertions =
      []), e.declaration = this.parseExportDeclaration(e), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, "function");
    }
    parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(e, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(e, 13);
      if (this.match(80))
        return this.parseClass(e, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(B.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(B.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: e
      } = this.state;
      if (mt(e)) {
        if (e === 95 && !this.state.containsEsc || e === 100)
          return !1;
        if ((e === 130 || e === 129) && !this.state.containsEsc) {
          let {
            type: i
          } = this.lookahead();
          if (mt(i) && i !== 98 || i === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), s = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || mt(this.state.type) && s)
        return !0;
      if (this.match(65) && s) {
        let i = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return i === 34 || i === 39;
      }
      return !1;
    }
    parseExportFrom(e, r) {
      this.eatContextual(98) ? (e.source = this.parseImportSource(), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(
      e)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: e
      } = this.state;
      return e === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(B.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.
      raise(B.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(B.UsingDeclarationExport,
      this.state.startLoc), !0) : e === 74 || e === 75 || e === 68 || e === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e, r, s, i) {
      if (r) {
        var a;
        if (s) {
          if (this.checkDuplicateExports(e, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = e.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            B.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = e.specifiers) != null && a.length)
          for (let l of e.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !i && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(B.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (e.declaration) {
          let l = e.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(e, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(e) {
      if (e.type === "Identifier")
        this.checkDuplicateExports(e, e.name);
      else if (e.type === "ObjectPattern")
        for (let r of e.properties)
          this.checkDeclaration(r);
      else if (e.type === "ArrayPattern")
        for (let r of e.elements)
          r && this.checkDeclaration(r);
      else e.type === "ObjectProperty" ? this.checkDeclaration(e.value) : e.type === "RestElement" ? this.checkDeclaration(e.argument) : e.type ===
      "AssignmentPattern" && this.checkDeclaration(e.left);
    }
    checkDuplicateExports(e, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(B.DuplicateDefaultExport, e) : this.raise(B.DuplicateExport, e, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(e) {
      let r = [], s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else if (this.expect(12), this.eat(8)) break;
        let i = this.isContextual(130), a = this.match(133), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, e, i));
      }
      return r;
    }
    parseExportSpecifier(e, r, s, i) {
      return this.eatContextual(93) ? e.exported = this.parseModuleExportName() : r ? e.exported = $De(e.local) : e.exported || (e.exported =
      Vs(e.local)), this.finishNode(e, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let e = this.parseStringLiteral(this.state.value), r = e.value.match(b_e);
        return r && this.raise(B.ModuleExportNameHasLoneSurrogate, e, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), e;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(e) {
      return e.assertions != null ? e.assertions.some(({
        key: r,
        value: s
      }) => s.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(e) {
      let {
        specifiers: r
      } = e, s = r.length === 1 ? r[0].type : null;
      if (e.phase === "source")
        s !== "ImportDefaultSpecifier" && this.raise(B.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (e.phase === "defer")
        s !== "ImportNamespaceSpecifier" && this.raise(B.DeferImportRequiresNamespace, r[0].loc.start);
      else if (e.module) {
        var i;
        s !== "ImportDefaultSpecifier" && this.raise(B.ImportReflectionNotBinding, r[0].loc.start), ((i = e.assertions) == null ? void 0 : i.
        length) > 0 && this.raise(B.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && e.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = e;
        if (r != null) {
          let s = r.find((i) => {
            let a;
            if (i.type === "ExportSpecifier" ? a = i.local : i.type === "ImportSpecifier" && (a = i.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          s !== void 0 && this.raise(B.ImportJSONBindingNotDefault, s.loc.start);
        }
      }
    }
    isPotentialImportPhase(e) {
      return e ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(e, r, s, i) {
      r || (s === "module" ? (this.expectPlugin("importReflection", i), e.module = !0) : this.hasPlugin("importReflection") && (e.module = !1),
      s === "source" ? (this.expectPlugin("sourcePhaseImports", i), e.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", i), e.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e.phase = null));
    }
    parseMaybeImportPhase(e, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(e, r, null), null;
      let s = this.parseIdentifier(!0), {
        type: i
      } = this.state;
      return (es(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(
      e, r, s.name, s.loc.start), null) : (this.applyImportPhase(e, r, null), s);
    }
    isPrecedingIdImportPhase(e) {
      let {
        type: r
      } = this.state;
      return mt(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(e) {
      return this.match(133) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
    }
    parseImportSpecifiersAndAfter(e, r) {
      e.specifiers = [];
      let i = !this.maybeParseDefaultImportSpecifier(e, r) || this.eat(12), a = i && this.maybeParseStarImportSpecifier(e);
      return i && !a && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
    }
    parseImportSourceAndAttributes(e) {
      var r;
      return (r = e.specifiers) != null || (e.specifiers = []), e.source = this.parseImportSource(), this.maybeParseImportAttributes(e), this.
      checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e, r, s) {
      r.local = this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(r, s));
    }
    finishImportSpecifier(e, r, s = 8201) {
      return this.checkLVal(e.local, {
        in: {
          type: r
        },
        binding: s
      }), this.finishNode(e, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s = this.startNode(), i = this.state.value;
        if (r.has(i) && this.raise(B.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: i
        }), r.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        133))
          throw this.raise(B.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e;
    }
    parseModuleAttributes() {
      let e = [], r = /* @__PURE__ */ new Set();
      do {
        let s = this.startNode();
        if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(B.ModuleAttributeDifferentFromType, s.key), r.has(s.key.name) &&
        this.raise(B.ModuleAttributesWithDuplicateKeys, s.key, {
          key: s.key.name
        }), r.add(s.key.name), this.expect(14), !this.match(133))
          throw this.raise(B.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), e.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return e;
    }
    maybeParseImportAttributes(e) {
      let r, s = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.
        parseImportAttributes()), s = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(B.ImportAttributesUseAssert,
        this.state.startLoc), this.addExtra(e, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]),
        this.next(), r = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        r = [];
      else if (this.hasPlugin("moduleAttributes"))
        r = [];
      else return;
      !s && this.hasPlugin("importAssertions") ? e.assertions = r : e.attributes = r;
    }
    maybeParseDefaultImportSpecifier(e, r) {
      if (r) {
        let s = this.startNodeAtNode(r);
        return s.local = r, e.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
      } else if (es(this.state.type))
        return this.parseImportSpecifierLocal(e, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(e) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(B.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let s = this.startNode(), i = this.match(133), a = this.isContextual(130);
        s.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(s, i, e.importKind === "type" || e.importKind === "typeof", a, void 0);
        e.specifiers.push(o);
      }
    }
    parseImportSpecifier(e, r, s, i, a) {
      if (this.eatContextual(93))
        e.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = e;
        if (r)
          throw this.raise(B.ImportBindingIsString, e, {
            importName: o.value
          });
        this.checkReservedWord(o.name, e.loc.start, !0, !0), e.local || (e.local = Vs(o));
      }
      return this.finishImportSpecifier(e, "ImportSpecifier", a);
    }
    isThisParam(e) {
      return e.type === "Identifier" && e.name === "this";
    }
  }, Vc = class extends yb {
    static {
      n(this, "Parser");
    }
    constructor(e, r) {
      e = y_e(e), super(e, r), this.options = e, this.initializeScopes(), this.plugins = S_e(this.options.plugins), this.filename = e.sourceFilename;
    }
    getScopeHandler() {
      return Ho;
    }
    parse() {
      this.enterInitialScopes();
      let e = this.startNode(), r = this.startNode();
      return this.nextToken(), e.errors = null, this.parseTopLevel(e, r), e.errors = this.state.errors, e.comments.length = this.state.commentsLen,
      e;
    }
  };
  function S_e(t) {
    let e = /* @__PURE__ */ new Map();
    for (let r of t) {
      let [s, i] = Array.isArray(r) ? r : [r, {}];
      e.has(s) || e.set(s, i || {});
    }
    return e;
  }
  n(S_e, "pluginsMap");
  function g_e(t, e) {
    var r;
    if (((r = e) == null ? void 0 : r.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let s = Yo(e, t), i = s.parse();
        if (s.sawUnambiguousESM)
          return i;
        if (s.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", Yo(e, t).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (s) {
        try {
          return e.sourceType = "script", Yo(e, t).parse();
        } catch {
        }
        throw s;
      }
    } else
      return Yo(e, t).parse();
  }
  n(g_e, "parse");
  function P_e(t, e) {
    let r = Yo(e, t);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  n(P_e, "parseExpression");
  function E_e(t) {
    let e = {};
    for (let r of Object.keys(t))
      e[r] = js(t[r]);
    return e;
  }
  n(E_e, "generateExportedTokenTypes");
  var A_e = E_e(TDe);
  function Yo(t, e) {
    let r = Vc;
    return t != null && t.plugins && (d_e(t.plugins), r = v_e(t.plugins)), new r(t, e);
  }
  n(Yo, "getParser");
  var lN = {};
  function v_e(t) {
    let e = m_e.filter((i) => Yt(t, i)), r = e.join("/"), s = lN[r];
    if (!s) {
      s = Vc;
      for (let i of e)
        s = vN[i](s);
      lN[r] = s;
    }
    return s;
  }
  n(v_e, "getParserClass");
  Go.parse = g_e;
  Go.parseExpression = P_e;
  Go.tokTypes = A_e;
});

// src/csf-tools/CsfFile.ts
var Qo = tr(ol(), 1), Q = tr(Ce(), 1), Ib = tr(Da(), 1), wb = tr(Fi(), 1);
import { readFile as I_e, writeFile as w_e } from "node:fs/promises";
import * as kb from "recast";
import { toId as N_e, isExportStory as wN, storyNameFromExport as NN } from "@storybook/csf";

// src/csf-tools/babelParse.ts
var Kc = tr(CN(), 1);
import * as Wc from "recast";
function C_e(t, e) {
  let i = /^\s*\/\/\s*@flow/.test(t) ? ["flow"] : ["typescript"], a = {
    ...e,
    plugins: [...e.plugins ?? [], ...i]
  };
  return Kc.parse(t, a);
}
n(C_e, "parseWithFlowOrTypescript");
var IN = {
  sourceType: "module",
  // FIXME: we should get this from the project config somehow?
  plugins: ["jsx", "decorators-legacy", "classProperties"],
  tokens: !0
}, nn = /* @__PURE__ */ n((t) => Wc.parse(t, {
  parser: {
    parse(e) {
      return C_e(e, IN);
    }
  }
}), "babelParse"), HUe = /* @__PURE__ */ n((t) => Wc.print(t, {
  quote: "single",
  trailingComma: !0,
  tabWidth: 2,
  wrapColumn: 80,
  arrowParensAlways: !0
}).code, "babelPrint"), zUe = /* @__PURE__ */ n((t) => Kc.parseExpression(t, IN), "babelParseExpression");

// src/csf-tools/findVarInitialization.ts
var Ks = tr(Ce(), 1);
var Ws = /* @__PURE__ */ n((t, e) => {
  let r = null, s = null;
  return e.body.find((i) => (Ks.isVariableDeclaration(i) ? s = i.declarations : Ks.isExportNamedDeclaration(i) && Ks.isVariableDeclaration(i.
  declaration) && (s = i.declaration.declarations), s && s.find((a) => Ks.isVariableDeclarator(a) && Ks.isIdentifier(a.id) && a.id.name === t ?
  (r = a.init, !0) : !1))), r;
}, "findVarInitialization");

// src/csf-tools/CsfFile.ts
var O_e = wb.default.default || wb.default, k_e = Ib.default.default || Ib.default, ON = console;
function D_e(t) {
  if (Q.isArrayExpression(t))
    return t.elements.map((e) => {
      if (Q.isStringLiteral(e)) return e.value;
      throw new Error(`Expected string literal: ${e}`);
    });
  if (Q.isStringLiteral(t)) return new RegExp(t.value);
  if (Q.isRegExpLiteral(t)) return new RegExp(t.pattern, t.flags);
  throw new Error(`Unknown include/exclude: ${t}`);
}
n(D_e, "parseIncludeExclude");
function kN(t) {
  if (!Q.isArrayExpression(t))
    throw new Error("CSF: Expected tags array");
  return t.elements.map((e) => {
    if (Q.isStringLiteral(e)) return e.value;
    throw new Error("CSF: Expected tag to be string literal");
  });
}
n(kN, "parseTags");
var Nb = /* @__PURE__ */ n((t, e) => {
  let { line: r, column: s } = t.loc?.start || {};
  return `${e || ""} (line ${r}, col ${s})`.trim();
}, "formatLocation"), DN = /* @__PURE__ */ n((t, e, r) => {
  let s = t;
  if (Q.isCallExpression(t)) {
    let { callee: i, arguments: a } = t;
    if (Q.isProgram(e) && Q.isMemberExpression(i) && Q.isIdentifier(i.object) && Q.isIdentifier(i.property) && i.property.name === "bind" &&
    (a.length === 0 || a.length === 1 && Q.isObjectExpression(a[0]) && a[0].properties.length === 0)) {
      let o = i.object.name, l = Ws(o, e);
      l && (r._templates[o] = l, s = l);
    }
  }
  return Q.isArrowFunctionExpression(s) || Q.isFunctionDeclaration(s) ? s.params.length > 0 : !1;
}, "isArgsStory"), __e = /* @__PURE__ */ n((t) => {
  if (Q.isArrayExpression(t))
    return t.elements.map((e) => {
      if (Q.isStringLiteral(e))
        return e.value;
      throw new Error(`Expected string literal named export: ${e}`);
    });
  throw new Error(`Expected array of string literals: ${t}`);
}, "parseExportsOrder"), _N = /* @__PURE__ */ n((t, e) => e.reduce(
  (r, s) => {
    let i = t[s];
    return i && (r[s] = i), r;
  },
  {}
), "sortExports"), Yc = class extends Error {
  static {
    n(this, "NoMetaError");
  }
  constructor(e, r, s) {
    super(Qo.dedent`
      CSF: ${e} ${Nb(r, s)}

      More info: https://storybook.js.org/docs/react/writing-stories#default-export
    `), this.name = this.constructor.name;
  }
}, Ob = class {
  static {
    n(this, "CsfFile");
  }
  _ast;
  _fileName;
  _rawComponentPath;
  _makeTitle;
  _meta;
  _stories = {};
  _metaAnnotations = {};
  _storyExports = {};
  _metaStatement;
  _metaNode;
  _storyStatements = {};
  _storyAnnotations = {};
  _templates = {};
  _namedExportsOrder;
  imports;
  constructor(e, { fileName: r, makeTitle: s }) {
    this._ast = e, this._fileName = r, this.imports = [], this._makeTitle = s;
  }
  _parseTitle(e) {
    let r = Q.isIdentifier(e) ? Ws(e.name, this._ast.program) : e;
    if (Q.isStringLiteral(r))
      return r.value;
    if (Q.isTSSatisfiesExpression(r) && Q.isStringLiteral(r.expression))
      return r.expression.value;
    throw new Error(Qo.dedent`
      CSF: unexpected dynamic title ${Nb(r, this._fileName)}

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
    `);
  }
  _parseMeta(e, r) {
    let s = {};
    e.properties.forEach((i) => {
      if (Q.isIdentifier(i.key)) {
        if (this._metaAnnotations[i.key.name] = i.value, i.key.name === "title")
          s.title = this._parseTitle(i.value);
        else if (["includeStories", "excludeStories"].includes(i.key.name))
          s[i.key.name] = D_e(i.value);
        else if (i.key.name === "component") {
          let a = i.value;
          if (Q.isIdentifier(a)) {
            let l = a.name, u = r.body.find(
              (c) => Q.isImportDeclaration(c) && c.specifiers.find((p) => p.local.name === l)
            );
            if (u) {
              let { source: c } = u;
              Q.isStringLiteral(c) && (this._rawComponentPath = c.value);
            }
          }
          let { code: o } = kb.print(i.value, {});
          s.component = o;
        } else if (i.key.name === "tags") {
          let a = i.value;
          Q.isIdentifier(a) && (a = Ws(a.name, this._ast.program)), s.tags = kN(a);
        } else if (i.key.name === "id")
          if (Q.isStringLiteral(i.value))
            s.id = i.value.value;
          else
            throw new Error(`Unexpected component id: ${i.value}`);
      }
    }), this._meta = s;
  }
  getStoryExport(e) {
    let r = this._storyExports[e];
    if (r = Q.isVariableDeclarator(r) ? r.init : r, Q.isCallExpression(r)) {
      let { callee: s, arguments: i } = r;
      if (Q.isMemberExpression(s) && Q.isIdentifier(s.object) && Q.isIdentifier(s.property) && s.property.name === "bind" && (i.length === 0 ||
      i.length === 1 && Q.isObjectExpression(i[0]) && i[0].properties.length === 0)) {
        let { name: a } = s.object;
        r = this._templates[a];
      }
    }
    return r;
  }
  parse() {
    let e = this;
    if (O_e(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: s, parent: i }) {
          let a, o = Q.isIdentifier(s.declaration) && Q.isProgram(i), l;
          if (o) {
            let u = s.declaration.name, c = /* @__PURE__ */ n((p) => Q.isIdentifier(p.id) && p.id.name === u, "isVariableDeclarator");
            e._metaStatement = e._ast.program.body.find(
              (p) => Q.isVariableDeclaration(p) && p.declarations.find(c)
            ), l = (e?._metaStatement?.declarations || []).find(
              c
            )?.init;
          } else
            e._metaStatement = s, l = s.declaration;
          if (Q.isObjectExpression(l) ? a = l : (
            // export default { ... } as Meta<...>
            (Q.isTSAsExpression(l) || Q.isTSSatisfiesExpression(l)) && Q.isObjectExpression(l.expression) && (a = l.expression)
          ), !e._meta && a && Q.isProgram(i) && (e._metaNode = a, e._parseMeta(a, i)), e._metaStatement && !e._metaNode)
            throw new Yc(
              "default export must be an object",
              e._metaStatement,
              e._fileName
            );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: s, parent: i }) {
          let a;
          Q.isVariableDeclaration(s.declaration) ? a = s.declaration.declarations.filter((o) => Q.isVariableDeclarator(o)) : Q.isFunctionDeclaration(
          s.declaration) && (a = [s.declaration]), a ? a.forEach((o) => {
            if (Q.isIdentifier(o.id)) {
              let { name: l } = o.id;
              if (l === "__namedExportsOrder" && Q.isVariableDeclarator(o)) {
                e._namedExportsOrder = __e(o.init);
                return;
              }
              e._storyExports[l] = o, e._storyStatements[l] = s;
              let u = NN(l);
              e._storyAnnotations[l] ? ON.warn(
                `Unexpected annotations for "${l}" before story declaration`
              ) : e._storyAnnotations[l] = {};
              let c;
              Q.isVariableDeclarator(o) ? c = Q.isTSAsExpression(o.init) || Q.isTSSatisfiesExpression(o.init) ? o.init.expression : o.init :
              c = o;
              let p = {};
              Q.isObjectExpression(c) ? (p.__isArgsStory = !0, c.properties.forEach((f) => {
                if (Q.isIdentifier(f.key)) {
                  if (f.key.name === "render")
                    p.__isArgsStory = DN(
                      f.value,
                      i,
                      e
                    );
                  else if (f.key.name === "name" && Q.isStringLiteral(f.value))
                    u = f.value.value;
                  else if (f.key.name === "storyName" && Q.isStringLiteral(f.value))
                    ON.warn(
                      `Unexpected usage of "storyName" in "${l}". Please use "name" instead.`
                    );
                  else if (f.key.name === "parameters" && Q.isObjectExpression(f.value)) {
                    let m = f.value.properties.find(
                      (y) => Q.isObjectProperty(y) && Q.isIdentifier(y.key) && y.key.name === "__id"
                    );
                    m && (p.__id = m.value.value);
                  }
                  e._storyAnnotations[l][f.key.name] = f.value;
                }
              })) : p.__isArgsStory = DN(c, i, e), e._stories[l] = {
                id: "FIXME",
                name: u,
                parameters: p
              };
            }
          }) : s.specifiers.length > 0 && s.specifiers.forEach((o) => {
            if (Q.isExportSpecifier(o) && Q.isIdentifier(o.exported)) {
              let { name: l } = o.exported;
              if (l === "default") {
                let u, c = Q.isProgram(i) ? Ws(o.local.name, i) : o.local;
                Q.isObjectExpression(c) ? u = c : (
                  // export default { ... } as Meta<...>
                  Q.isTSAsExpression(c) && Q.isObjectExpression(c.expression) && (u = c.expression)
                ), !e._meta && u && Q.isProgram(i) && e._parseMeta(u, i);
              } else
                e._storyAnnotations[l] = {}, e._stories[l] = { id: "FIXME", name: l, parameters: {} };
            }
          });
        }
      },
      ExpressionStatement: {
        enter({ node: s, parent: i }) {
          let { expression: a } = s;
          if (Q.isProgram(i) && Q.isAssignmentExpression(a) && Q.isMemberExpression(a.left) && Q.isIdentifier(a.left.object) && Q.isIdentifier(
          a.left.property)) {
            let o = a.left.object.name, l = a.left.property.name, u = a.right;
            if (e._storyAnnotations[o] && (l === "story" && Q.isObjectExpression(u) ? u.properties.forEach((c) => {
              Q.isIdentifier(c.key) && (e._storyAnnotations[o][c.key.name] = c.value);
            }) : e._storyAnnotations[o][l] = u), l === "storyName" && Q.isStringLiteral(u)) {
              let c = u.value, p = e._stories[o];
              if (!p) return;
              p.name = c;
            }
          }
        }
      },
      CallExpression: {
        enter({ node: s }) {
          let { callee: i } = s;
          if (Q.isIdentifier(i) && i.name === "storiesOf")
            throw new Error(Qo.dedent`
              Unexpected \`storiesOf\` usage: ${Nb(s, e._fileName)}.

              SB8 does not support \`storiesOf\`. 
            `);
        }
      },
      ImportDeclaration: {
        enter({ node: s }) {
          let { source: i } = s;
          if (Q.isStringLiteral(i))
            e.imports.push(i.value);
          else
            throw new Error("CSF: unexpected import source");
        }
      }
    }), !e._meta)
      throw new Yc("missing default export", e._ast, e._fileName);
    let r = Object.entries(e._stories);
    if (e._meta.title = this._makeTitle(e._meta?.title), e._metaAnnotations.play && (e._meta.tags = [...e._meta.tags || [], "play-fn"]), e._stories =
    r.reduce(
      (s, [i, a]) => {
        if (!wN(i, e._meta))
          return s;
        let o = a.parameters?.__id ?? N_e(e._meta?.id || e._meta?.title, NN(i)), l = { ...a.parameters, __id: o }, { includeStories: u } = e.
        _meta || {};
        i === "__page" && (r.length === 1 || Array.isArray(u) && u.length === 1) && (l.docsOnly = !0), s[i] = { ...a, id: o, parameters: l };
        let { tags: c, play: p } = e._storyAnnotations[i];
        if (c) {
          let f = Q.isIdentifier(c) ? Ws(c.name, this._ast.program) : c;
          s[i].tags = kN(f);
        }
        return p && (s[i].tags = [...s[i].tags || [], "play-fn"]), s;
      },
      {}
    ), Object.keys(e._storyExports).forEach((s) => {
      wN(s, e._meta) || (delete e._storyExports[s], delete e._storyAnnotations[s]);
    }), e._namedExportsOrder) {
      let s = Object.keys(e._storyExports);
      e._storyExports = _N(e._storyExports, e._namedExportsOrder), e._stories = _N(e._stories, e._namedExportsOrder);
      let i = Object.keys(e._storyExports);
      if (s.length !== i.length)
        throw new Error(
          `Missing exports after sort: ${s.filter(
            (a) => !i.includes(a)
          )}`
        );
    }
    return e;
  }
  get meta() {
    return this._meta;
  }
  get stories() {
    return Object.values(this._stories);
  }
  get indexInputs() {
    if (!this._fileName)
      throw new Error(
        Qo.dedent`Cannot automatically create index inputs with CsfFile.indexInputs because the CsfFile instance was created without a the fileName option.
        Either add the fileName option when creating the CsfFile instance, or create the index inputs manually.`
      );
    return Object.entries(this._stories).map(([e, r]) => {
      let s = [...this._meta?.tags ?? [], ...r.tags ?? []];
      return {
        type: "story",
        importPath: this._fileName,
        rawComponentPath: this._rawComponentPath,
        exportName: e,
        name: r.name,
        title: this.meta?.title,
        metaId: this.meta?.id,
        tags: s,
        __id: r.id
      };
    });
  }
}, L_e = /* @__PURE__ */ n((t, e) => {
  let r = nn(t);
  return new Ob(r, e);
}, "loadCsf"), nqe = /* @__PURE__ */ n((t, e = { sourceMaps: !1 }, r) => {
  let s = k_e(t._ast, e, r);
  return e.sourceMaps ? s : s.code;
}, "formatCsf"), M_e = /* @__PURE__ */ n((t, e = {}) => kb.print(t._ast, e), "printCsf"), aqe = /* @__PURE__ */ n(async (t, e) => {
  let r = (await I_e(t, "utf-8")).toString();
  return L_e(r, { ...e, fileName: t });
}, "readCsf"), oqe = /* @__PURE__ */ n(async (t, e) => {
  if (!(e || t._fileName)) throw new Error("Please specify a fileName for writeCsf");
  await w_e(e, M_e(t).code);
}, "writeCsf");

// src/csf-tools/ConfigFile.ts
var BN = tr(ol(), 1), W = tr(Ce(), 1), Lb = tr(Da(), 1), Mb = tr(Fi(), 1);
import { readFile as B_e, writeFile as F_e } from "node:fs/promises";
import * as FN from "recast";
var LN = Mb.default.default || Mb.default, MN = Lb.default.default || Lb.default, Db = console, _b = /* @__PURE__ */ n(({
  expectedType: t,
  foundType: e,
  node: r
}) => {
  let s = "";
  if (r)
    try {
      s = JSON.stringify(r);
    } catch {
    }
  return BN.dedent`
      CSF Parsing error: Expected '${t}' but found '${e}' instead in '${r?.type}'.
      ${s}
    `;
}, "getCsfParsingErrorMessage"), Zo = /* @__PURE__ */ n((t) => W.isIdentifier(t.key) ? t.key.name : W.isStringLiteral(t.key) ? t.key.value :
null, "propKey"), jN = /* @__PURE__ */ n((t, e) => {
  if (t.length === 0)
    return e;
  if (W.isObjectExpression(e)) {
    let [r, ...s] = t, i = e.properties.find((a) => Zo(a) === r);
    if (i)
      return jN(s, i.value);
  }
}, "_getPath"), RN = /* @__PURE__ */ n((t, e) => {
  if (t.length === 0) {
    if (W.isObjectExpression(e))
      return e.properties;
    throw new Error("Expected object expression");
  }
  if (W.isObjectExpression(e)) {
    let [r, ...s] = t, i = e.properties.find((a) => Zo(a) === r);
    if (i)
      return s.length === 0 ? e.properties : RN(s, i.value);
  }
}, "_getPathProperties"), UN = /* @__PURE__ */ n((t, e) => {
  let r = null, s = null;
  return e.body.find((i) => (W.isVariableDeclaration(i) ? s = i.declarations : W.isExportNamedDeclaration(i) && W.isVariableDeclaration(i.declaration) &&
  (s = i.declaration.declarations), s && s.find((a) => W.isVariableDeclarator(a) && W.isIdentifier(a.id) && a.id.name === t ? (r = a, !0) : !1))),
  r;
}, "_findVarDeclarator"), ia = /* @__PURE__ */ n((t, e) => UN(t, e)?.init, "_findVarInitialization"), el = /* @__PURE__ */ n((t, e) => {
  if (t.length === 0) return e;
  let [r, ...s] = t, i = el(s, e);
  return W.objectExpression([W.objectProperty(W.identifier(r), i)]);
}, "_makeObjectExpression"), Bb = /* @__PURE__ */ n((t, e, r) => {
  let [s, ...i] = t, a = r.properties.find(
    (o) => Zo(o) === s
  );
  a ? W.isObjectExpression(a.value) && i.length > 0 ? Bb(i, e, a.value) : a.value = el(i, e) : r.properties.push(
    W.objectProperty(W.identifier(s), el(i, e))
  );
}, "_updateExportNode"), Fb = class {
  static {
    n(this, "ConfigFile");
  }
  _ast;
  _code;
  _exports = {};
  // FIXME: this is a hack. this is only used in the case where the user is
  // modifying a named export that's a scalar. The _exports map is not suitable
  // for that. But rather than refactor the whole thing, we just use this as a stopgap.
  _exportDecls = {};
  _exportsObject;
  _quotes;
  fileName;
  hasDefaultExport = !1;
  constructor(e, r, s) {
    this._ast = e, this._code = r, this.fileName = s;
  }
  parse() {
    let e = this;
    return LN(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node: r, parent: s }) {
          e.hasDefaultExport = !0;
          let i = W.isIdentifier(r.declaration) && W.isProgram(s) ? ia(r.declaration.name, s) : r.declaration;
          (W.isTSAsExpression(i) || W.isTSSatisfiesExpression(i)) && (i = i.expression), W.isObjectExpression(i) ? (e._exportsObject = i, i.
          properties.forEach((a) => {
            let o = Zo(a);
            if (o) {
              let l = a.value;
              W.isIdentifier(l) && (l = ia(l.name, s)), e._exports[o] = l;
            }
          })) : Db.warn(
            _b({
              expectedType: "ObjectExpression",
              foundType: i?.type,
              node: i || r.declaration
            })
          );
        }
      },
      ExportNamedDeclaration: {
        enter({ node: r, parent: s }) {
          W.isVariableDeclaration(r.declaration) ? r.declaration.declarations.forEach((i) => {
            if (W.isVariableDeclarator(i) && W.isIdentifier(i.id)) {
              let { name: a } = i.id, o = i.init;
              W.isIdentifier(o) && (o = ia(o.name, s)), e._exports[a] = o, e._exportDecls[a] = i;
            }
          }) : r.specifiers ? r.specifiers.forEach((i) => {
            if (W.isExportSpecifier(i) && W.isIdentifier(i.local) && W.isIdentifier(i.exported)) {
              let { name: a } = i.local, { name: o } = i.exported, l = UN(a, s);
              e._exports[o] = l.init, e._exportDecls[o] = l;
            }
          }) : Db.warn(
            _b({
              expectedType: "VariableDeclaration",
              foundType: r.declaration?.type,
              node: r.declaration
            })
          );
        }
      },
      ExpressionStatement: {
        enter({ node: r, parent: s }) {
          if (W.isAssignmentExpression(r.expression) && r.expression.operator === "=") {
            let { left: i, right: a } = r.expression;
            if (W.isMemberExpression(i) && W.isIdentifier(i.object) && i.object.name === "module" && W.isIdentifier(i.property) && i.property.
            name === "exports") {
              let o = a;
              W.isIdentifier(a) && (o = ia(a.name, s)), (W.isTSAsExpression(o) || W.isTSSatisfiesExpression(o)) && (o = o.expression), W.isObjectExpression(
              o) ? (e._exportsObject = o, o.properties.forEach((l) => {
                let u = Zo(l);
                if (u) {
                  let c = l.value;
                  W.isIdentifier(c) && (c = ia(
                    c.name,
                    s
                  )), e._exports[u] = c;
                }
              })) : Db.warn(
                _b({
                  expectedType: "ObjectExpression",
                  foundType: o?.type,
                  node: o
                })
              );
            }
          }
        }
      }
    }), e;
  }
  getFieldNode(e) {
    let [r, ...s] = e, i = this._exports[r];
    if (i)
      return jN(s, i);
  }
  getFieldProperties(e) {
    let [r, ...s] = e, i = this._exports[r];
    if (i)
      return RN(s, i);
  }
  getFieldValue(e) {
    let r = this.getFieldNode(e);
    if (r) {
      let { code: s } = MN(r, {});
      return (0, eval)(`(() => (${s}))()`);
    }
  }
  getSafeFieldValue(e) {
    try {
      return this.getFieldValue(e);
    } catch {
    }
  }
  setFieldNode(e, r) {
    let [s, ...i] = e, a = this._exports[s];
    if (this._exportsObject)
      Bb(e, r, this._exportsObject), this._exports[e[0]] = r;
    else if (a && W.isObjectExpression(a) && i.length > 0)
      Bb(i, r, a);
    else if (a && i.length === 0 && this._exportDecls[e[0]]) {
      let o = this._exportDecls[e[0]];
      o.init = el([], r);
    } else {
      if (this.hasDefaultExport)
        throw new Error(
          `Could not set the "${e.join(
            "."
          )}" field as the default export is not an object in this file.`
        );
      {
        let o = el(i, r), l = W.exportNamedDeclaration(
          W.variableDeclaration("const", [W.variableDeclarator(W.identifier(s), o)])
        );
        this._exports[s] = o, this._ast.program.body.push(l);
      }
    }
  }
  /**
   * Returns the name of a node in a given path, supporting the following formats:
   * 1. { framework: 'value' }
   * 2. { framework: { name: 'value', options: {} } }
   */
  /**
   * Returns the name of a node in a given path, supporting the following formats:
   * @example
   * // 1. { framework: 'framework-name' }
   * // 2. { framework: { name: 'framework-name', options: {} }
   * getNameFromPath(['framework']) // => 'framework-name'
   */
  getNameFromPath(e) {
    let r = this.getFieldNode(e);
    if (r)
      return this._getPresetValue(r, "name");
  }
  /**
   * Returns an array of names of a node in a given path, supporting the following formats:
   * @example
   * const config = {
   *   addons: [
   *     'first-addon',
   *     { name: 'second-addon', options: {} }
   *   ]
   * }
   * // => ['first-addon', 'second-addon']
   * getNamesFromPath(['addons'])
   *
   */
  getNamesFromPath(e) {
    let r = this.getFieldNode(e);
    if (!r)
      return;
    let s = [];
    return W.isArrayExpression(r) && r.elements.forEach((i) => {
      s.push(this._getPresetValue(i, "name"));
    }), s;
  }
  _getPnpWrappedValue(e) {
    if (W.isCallExpression(e)) {
      let r = e.arguments[0];
      if (W.isStringLiteral(r))
        return r.value;
    }
  }
  /**
   * Given a node and a fallback property, returns a **non-evaluated** string value of the node.
   * 1. { node: 'value' }
   * 2. { node: { fallbackProperty: 'value' } }
   */
  _getPresetValue(e, r) {
    let s;
    if (W.isStringLiteral(e) ? s = e.value : W.isObjectExpression(e) && e.properties.forEach((i) => {
      W.isObjectProperty(i) && W.isIdentifier(i.key) && i.key.name === r && (W.isStringLiteral(i.value) ? s = i.value.value : s = this._getPnpWrappedValue(
      i.value)), W.isObjectProperty(i) && W.isStringLiteral(i.key) && i.key.value === "name" && W.isStringLiteral(i.value) && (s = i.value.value);
    }), !s)
      throw new Error(
        `The given node must be a string literal or an object expression with a "${r}" property that is a string literal.`
      );
    return s;
  }
  removeField(e) {
    let r = /* @__PURE__ */ n((i, a) => {
      let o = i.findIndex(
        (l) => W.isIdentifier(l.key) && l.key.name === a || W.isStringLiteral(l.key) && l.key.value === a
      );
      o >= 0 && i.splice(o, 1);
    }, "removeProperty");
    if (e.length === 1) {
      let i = !1;
      if (this._ast.program.body.forEach((a) => {
        if (W.isExportNamedDeclaration(a) && W.isVariableDeclaration(a.declaration)) {
          let o = a.declaration.declarations[0];
          W.isIdentifier(o.id) && o.id.name === e[0] && (this._ast.program.body.splice(this._ast.program.body.indexOf(a), 1), i = !0);
        }
        if (W.isExportDefaultDeclaration(a)) {
          let o = a.declaration;
          if (W.isIdentifier(o) && (o = ia(o.name, this._ast.program)), (W.isTSAsExpression(o) || W.isTSSatisfiesExpression(o)) && (o = o.expression),
          W.isObjectExpression(o)) {
            let l = o.properties;
            r(l, e[0]), i = !0;
          }
        }
        if (W.isExpressionStatement(a) && W.isAssignmentExpression(a.expression) && W.isMemberExpression(a.expression.left) && W.isIdentifier(
        a.expression.left.object) && a.expression.left.object.name === "module" && W.isIdentifier(a.expression.left.property) && a.expression.
        left.property.name === "exports" && W.isObjectExpression(a.expression.right)) {
          let o = a.expression.right.properties;
          r(o, e[0]), i = !0;
        }
      }), i) return;
    }
    let s = this.getFieldProperties(e);
    if (s) {
      let i = e.at(-1);
      r(s, i);
    }
  }
  appendValueToArray(e, r) {
    let s = this.valueToNode(r);
    s && this.appendNodeToArray(e, s);
  }
  appendNodeToArray(e, r) {
    let s = this.getFieldNode(e);
    if (!s)
      this.setFieldNode(e, W.arrayExpression([r]));
    else if (W.isArrayExpression(s))
      s.elements.push(r);
    else
      throw new Error(`Expected array at '${e.join(".")}', got '${s.type}'`);
  }
  /**
   * Specialized helper to remove addons or other array entries
   * that can either be strings or objects with a name property.
   */
  removeEntryFromArray(e, r) {
    let s = this.getFieldNode(e);
    if (s)
      if (W.isArrayExpression(s)) {
        let i = s.elements.findIndex((a) => W.isStringLiteral(a) ? a.value === r : W.isObjectExpression(a) ? this._getPresetValue(a, "name") ===
        r : this._getPnpWrappedValue(a) === r);
        if (i >= 0)
          s.elements.splice(i, 1);
        else
          throw new Error(`Could not find '${r}' in array at '${e.join(".")}'`);
      } else
        throw new Error(`Expected array at '${e.join(".")}', got '${s.type}'`);
  }
  _inferQuotes() {
    if (!this._quotes) {
      let e = (this._ast.tokens || []).slice(0, 500).reduce(
        (r, s) => (s.type.label === "string" && (r[this._code[s.start]] += 1), r),
        { "'": 0, '"': 0 }
      );
      this._quotes = e["'"] > e['"'] ? "single" : "double";
    }
    return this._quotes;
  }
  valueToNode(e) {
    let r = this._inferQuotes(), s;
    if (r === "single") {
      let { code: i } = MN(W.valueToNode(e), { jsescOption: { quotes: r } }), a = nn(`const __x = ${i}`);
      LN(a, {
        VariableDeclaration: {
          enter({ node: o }) {
            o.declarations.length === 1 && W.isVariableDeclarator(o.declarations[0]) && W.isIdentifier(o.declarations[0].id) && o.declarations[0].
            id.name === "__x" && (s = o.declarations[0].init);
          }
        }
      });
    } else
      s = W.valueToNode(e);
    return s;
  }
  setFieldValue(e, r) {
    let s = this.valueToNode(r);
    if (!s)
      throw new Error(`Unexpected value ${JSON.stringify(r)}`);
    this.setFieldNode(e, s);
  }
  getBodyDeclarations() {
    return this._ast.program.body;
  }
  setBodyDeclaration(e) {
    this._ast.program.body.push(e);
  }
  /**
   * Import specifiers for a specific require import
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   * @example
   * // const { foo } = require('bar');
   * setRequireImport(['foo'], 'bar');
   *
   * // const foo = require('bar');
   * setRequireImport('foo', 'bar');
   *
   */
  setRequireImport(e, r) {
    let s = this._ast.program.body.find(
      (o) => W.isVariableDeclaration(o) && o.declarations.length === 1 && W.isVariableDeclarator(o.declarations[0]) && W.isCallExpression(o.
      declarations[0].init) && W.isIdentifier(o.declarations[0].init.callee) && o.declarations[0].init.callee.name === "require" && W.isStringLiteral(
      o.declarations[0].init.arguments[0]) && o.declarations[0].init.arguments[0].value === r
    ), i = /* @__PURE__ */ n((o) => W.isObjectPattern(s?.declarations[0].id) && s?.declarations[0].id.properties.find(
      (l) => W.isObjectProperty(l) && W.isIdentifier(l.key) && l.key.name === o
    ), "hasRequireSpecifier"), a = /* @__PURE__ */ n((o, l) => o.declarations.length === 1 && W.isVariableDeclarator(o.declarations[0]) && W.isIdentifier(
    o.declarations[0].id) && o.declarations[0].id.name === l, "hasDefaultRequireSpecifier");
    if (typeof e == "string") {
      let o = /* @__PURE__ */ n(() => {
        this._ast.program.body.unshift(
          W.variableDeclaration("const", [
            W.variableDeclarator(
              W.identifier(e),
              W.callExpression(W.identifier("require"), [W.stringLiteral(r)])
            )
          ])
        );
      }, "addDefaultRequireSpecifier");
      s && a(s, e) || o();
    } else s ? e.forEach((o) => {
      i(o) || s.declarations[0].id.properties.push(
        W.objectProperty(W.identifier(o), W.identifier(o), void 0, !0)
      );
    }) : this._ast.program.body.unshift(
      W.variableDeclaration("const", [
        W.variableDeclarator(
          W.objectPattern(
            e.map(
              (o) => W.objectProperty(W.identifier(o), W.identifier(o), void 0, !0)
            )
          ),
          W.callExpression(W.identifier("require"), [W.stringLiteral(r)])
        )
      ])
    );
  }
  /**
   * Set import specifiers for a given import statement.
   * @description Does not support setting type imports (yet)
   * @param importSpecifiers - The import specifiers to set. If a string is passed in, a default import will be set. Otherwise, an array of named imports will be set
   * @param fromImport - The module to import from
   * @example
   * // import { foo } from 'bar';
   * setImport(['foo'], 'bar');
   *
   * // import foo from 'bar';
   * setImport('foo', 'bar');
   *
   */
  setImport(e, r) {
    let s = /* @__PURE__ */ n((l) => W.importSpecifier(W.identifier(l), W.identifier(l)), "getNewImportSpecifier"), i = /* @__PURE__ */ n((l, u) => l.
    specifiers.find(
      (c) => W.isImportSpecifier(c) && W.isIdentifier(c.imported) && c.imported.name === u
    ), "hasImportSpecifier"), a = /* @__PURE__ */ n((l, u) => l.specifiers.find((c) => W.isImportDefaultSpecifier(c)), "hasDefaultImportSpec\
ifier"), o = this._ast.program.body.find(
      (l) => W.isImportDeclaration(l) && l.source.value === r
    );
    typeof e == "string" ? o ? a(o, e) || o.specifiers.push(
      W.importDefaultSpecifier(W.identifier(e))
    ) : this._ast.program.body.unshift(
      W.importDeclaration(
        [W.importDefaultSpecifier(W.identifier(e))],
        W.stringLiteral(r)
      )
    ) : o ? e.forEach((l) => {
      i(o, l) || o.specifiers.push(s(l));
    }) : this._ast.program.body.unshift(
      W.importDeclaration(
        e.map(
          (l) => W.importSpecifier(W.identifier(l), W.identifier(l))
        ),
        W.stringLiteral(r)
      )
    );
  }
}, j_e = /* @__PURE__ */ n((t, e) => {
  let r = nn(t);
  return new Fb(r, t, e);
}, "loadConfig"), R_e = /* @__PURE__ */ n((t) => U_e(t).code, "formatConfig"), U_e = /* @__PURE__ */ n((t, e = {}) => FN.print(t._ast, e), "\
printConfig"), fqe = /* @__PURE__ */ n(async (t) => {
  let e = (await B_e(t, "utf-8")).toString();
  return j_e(e, t).parse();
}, "readConfig"), hqe = /* @__PURE__ */ n(async (t, e) => {
  let r = e || t.fileName;
  if (!r) throw new Error("Please specify a fileName for writeConfig");
  await F_e(r, R_e(t));
}, "writeConfig");

// src/csf-tools/getStorySortParameter.ts
var ot = tr(Ce(), 1), jb = tr(Fi(), 1), Rb = tr(Da(), 1), VN = tr(ol(), 1);
var q_e = jb.default.default || jb.default, qN = Rb.default.default || Rb.default, V_e = console, Ub = /* @__PURE__ */ n((t, e) => {
  let r;
  return t.properties.forEach((s) => {
    ot.isIdentifier(s.key) && s.key.name === e && (r = s.value);
  }), r;
}, "getValue"), qb = /* @__PURE__ */ n((t) => {
  let e = tl(t);
  if (ot.isArrayExpression(e))
    return e.elements.map((r) => qb(r));
  if (ot.isObjectExpression(e))
    return e.properties.reduce((r, s) => (ot.isIdentifier(s.key) && (r[s.key.name] = qb(s.value)), r), {});
  if (ot.isLiteral(e))
    return e.value;
  if (ot.isIdentifier(e))
    return na(e.name, !0);
  throw new Error(`Unknown node type ${e.type}`);
}, "parseValue"), na = /* @__PURE__ */ n((t, e) => {
  let r = VN.dedent`
    Unexpected '${t}'. Parameter 'options.storySort' should be defined inline e.g.:

    export default {
      parameters: {
        options: {
          storySort: <array | object | function>
        },
      },
    };
  `;
  if (e)
    throw new Error(r);
  V_e.info(r);
}, "unsupported"), tl = /* @__PURE__ */ n((t) => ot.isTSAsExpression(t) || ot.isTSSatisfiesExpression(t) ? t.expression : t, "stripTSModifie\
rs"), KN = /* @__PURE__ */ n((t) => {
  let e = tl(t);
  if (ot.isObjectExpression(e)) {
    let r = Ub(e, "options");
    if (r) {
      if (ot.isObjectExpression(r))
        return Ub(r, "storySort");
      na("options", !0);
    }
  }
}, "parseParameters"), K_e = /* @__PURE__ */ n((t, e) => {
  let r = tl(t);
  if (ot.isObjectExpression(r)) {
    let s = Ub(r, "parameters");
    if (ot.isIdentifier(s) && (s = Ws(s.name, e)), s)
      return KN(s);
  } else
    na("default", !0);
}, "parseDefault"), bqe = /* @__PURE__ */ n((t) => {
  if (!t.includes("storySort")) return;
  let e, r = nn(t);
  if (q_e(r, {
    ExportNamedDeclaration: {
      enter({ node: s }) {
        ot.isVariableDeclaration(s.declaration) ? s.declaration.declarations.forEach((i) => {
          if (ot.isVariableDeclarator(i) && ot.isIdentifier(i.id)) {
            let { name: a } = i.id;
            if (a === "parameters" && i.init) {
              let o = tl(i.init);
              e = KN(o);
            }
          }
        }) : s.specifiers.forEach((i) => {
          ot.isIdentifier(i.exported) && i.exported.name === "parameters" && na("parameters", !1);
        });
      }
    },
    ExportDefaultDeclaration: {
      enter({ node: s }) {
        let i = s.declaration;
        ot.isIdentifier(i) && (i = Ws(i.name, r.program)), i = tl(i), ot.isObjectExpression(i) ? e = K_e(i, r.program) : na("default", !1);
      }
    }
  }), !!e) {
    if (ot.isArrowFunctionExpression(e)) {
      let { code: s } = qN(e, {});
      return (0, eval)(s);
    }
    if (ot.isFunctionExpression(e)) {
      let { code: s } = qN(e, {}), i = e.id?.name, a = `(a, b) => {
      ${s};
      return ${i}(a, b)
    }`;
      return (0, eval)(a);
    }
    return ot.isLiteral(e) || ot.isArrayExpression(e) || ot.isObjectExpression(e) ? qb(e) : na("storySort", !0);
  }
}, "getStorySortParameter");

// src/csf-tools/enrichCsf.ts
var Ie = tr(Ce(), 1), Vb = tr(Da(), 1);
var W_e = Vb.default.default || Vb.default, Y_e = /* @__PURE__ */ n((t, e, r, s) => {
  let i = e.getStoryExport(r), a = !s?.disableSource && X_e(i), o = !s?.disableDescription && YN(e._storyStatements[r]), l = [], u = Ie.memberExpression(
  Ie.identifier(r), Ie.identifier("parameters"));
  l.push(Ie.spreadElement(u));
  let c = Ie.optionalMemberExpression(
    u,
    Ie.identifier("docs"),
    !1,
    !0
  ), p = [];
  if (a) {
    let f = Ie.optionalMemberExpression(
      c,
      Ie.identifier("source"),
      !1,
      !0
    );
    p.push(
      Ie.objectProperty(
        Ie.identifier("source"),
        Ie.objectExpression([
          Ie.objectProperty(Ie.identifier("originalSource"), Ie.stringLiteral(a)),
          Ie.spreadElement(f)
        ])
      )
    );
  }
  if (o) {
    let f = Ie.optionalMemberExpression(
      c,
      Ie.identifier("description"),
      !1,
      !0
    );
    p.push(
      Ie.objectProperty(
        Ie.identifier("description"),
        Ie.objectExpression([
          Ie.objectProperty(Ie.identifier("story"), Ie.stringLiteral(o)),
          Ie.spreadElement(f)
        ])
      )
    );
  }
  if (p.length > 0) {
    l.push(
      Ie.objectProperty(
        Ie.identifier("docs"),
        Ie.objectExpression([Ie.spreadElement(c), ...p])
      )
    );
    let f = Ie.expressionStatement(
      Ie.assignmentExpression("=", u, Ie.objectExpression(l))
    );
    t._ast.program.body.push(f);
  }
}, "enrichCsfStory"), WN = /* @__PURE__ */ n((t, e, r) => {
  if (!e.length) {
    t.properties.find(
      (u) => Ie.isObjectProperty(u) && Ie.isIdentifier(u.key) && u.key.name === "component"
    ) || t.properties.unshift(r);
    return;
  }
  let [s, ...i] = e, a = t.properties.find(
    (l) => Ie.isObjectProperty(l) && Ie.isIdentifier(l.key) && l.key.name === s && Ie.isObjectExpression(l.value)
  ), o;
  a ? o = a.value : (o = Ie.objectExpression([]), t.properties.push(Ie.objectProperty(Ie.identifier(s), o))), WN(o, i, r);
}, "addComponentDescription"), J_e = /* @__PURE__ */ n((t, e, r) => {
  let s = !r?.disableDescription && YN(e._metaStatement);
  if (s) {
    let i = t._metaNode;
    i && Ie.isObjectExpression(i) && WN(
      i,
      ["parameters", "docs", "description"],
      Ie.objectProperty(Ie.identifier("component"), Ie.stringLiteral(s))
    );
  }
}, "enrichCsfMeta"), gqe = /* @__PURE__ */ n((t, e, r) => {
  J_e(t, e, r), Object.keys(t._storyExports).forEach((s) => {
    Y_e(t, e, s, r);
  });
}, "enrichCsf"), X_e = /* @__PURE__ */ n((t) => {
  let e = Ie.isVariableDeclarator(t) ? t.init : t, { code: r } = W_e(e, {});
  return r;
}, "extractSource"), YN = /* @__PURE__ */ n((t) => t?.leadingComments ? t.leadingComments.map((r) => r.type === "CommentLine" || !r.value.startsWith(
"*") ? null : r.value.split(`
`).map((s) => s.replace(/^(\s+)?(\*+)?(\s)?/, "")).join(`
`).trim()).filter(Boolean).join(`
`) : "", "extractDescription");
export {
  Fb as ConfigFile,
  Ob as CsfFile,
  Yc as NoMetaError,
  nn as babelParse,
  zUe as babelParseExpression,
  HUe as babelPrint,
  gqe as enrichCsf,
  J_e as enrichCsfMeta,
  Y_e as enrichCsfStory,
  YN as extractDescription,
  X_e as extractSource,
  R_e as formatConfig,
  nqe as formatCsf,
  bqe as getStorySortParameter,
  j_e as loadConfig,
  L_e as loadCsf,
  IN as parserOptions,
  U_e as printConfig,
  M_e as printCsf,
  fqe as readConfig,
  aqe as readCsf,
  hqe as writeConfig,
  oqe as writeCsf
};
